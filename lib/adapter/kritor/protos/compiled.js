/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
import $protobuf from "protobufjs/minimal.js";

// Common aliases
const $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
const $root = $protobuf.roots || ($protobuf.roots = {})

export const kritor = $root.kritor = (() => {

    /**
     * Namespace kritor.
     * @exports kritor
     * @namespace
     */
    const kritor = {};

    kritor.authentication = (function() {

        /**
         * Namespace authentication.
         * @memberof kritor
         * @namespace
         */
        const authentication = {};

        authentication.AuthenticationService = (function() {

            /**
             * Constructs a new AuthenticationService service.
             * @memberof kritor.authentication
             * @classdesc Represents an AuthenticationService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function AuthenticationService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (AuthenticationService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = AuthenticationService;

            /**
             * Creates new AuthenticationService service using the specified rpc implementation.
             * @function create
             * @memberof kritor.authentication.AuthenticationService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {AuthenticationService} RPC service. Useful where requests and/or responses are streamed.
             */
            AuthenticationService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link kritor.authentication.AuthenticationService#authenticate}.
             * @memberof kritor.authentication.AuthenticationService
             * @typedef AuthenticateCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.authentication.AuthenticateResponse} [response] AuthenticateResponse
             */

            /**
             * Calls Authenticate.
             * @function authenticate
             * @memberof kritor.authentication.AuthenticationService
             * @instance
             * @param {kritor.authentication.IAuthenticateRequest} request AuthenticateRequest message or plain object
             * @param {kritor.authentication.AuthenticationService.AuthenticateCallback} callback Node-style callback called with the error, if any, and AuthenticateResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(AuthenticationService.prototype.authenticate = function authenticate(request, callback) {
                return this.rpcCall(authenticate, $root.kritor.authentication.AuthenticateRequest, $root.kritor.authentication.AuthenticateResponse, request, callback);
            }, "name", { value: "Authenticate" });

            /**
             * Calls Authenticate.
             * @function authenticate
             * @memberof kritor.authentication.AuthenticationService
             * @instance
             * @param {kritor.authentication.IAuthenticateRequest} request AuthenticateRequest message or plain object
             * @returns {Promise<kritor.authentication.AuthenticateResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.authentication.AuthenticationService#getAuthenticationState}.
             * @memberof kritor.authentication.AuthenticationService
             * @typedef GetAuthenticationStateCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.authentication.GetAuthenticationStateResponse} [response] GetAuthenticationStateResponse
             */

            /**
             * Calls GetAuthenticationState.
             * @function getAuthenticationState
             * @memberof kritor.authentication.AuthenticationService
             * @instance
             * @param {kritor.authentication.IGetAuthenticationStateRequest} request GetAuthenticationStateRequest message or plain object
             * @param {kritor.authentication.AuthenticationService.GetAuthenticationStateCallback} callback Node-style callback called with the error, if any, and GetAuthenticationStateResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(AuthenticationService.prototype.getAuthenticationState = function getAuthenticationState(request, callback) {
                return this.rpcCall(getAuthenticationState, $root.kritor.authentication.GetAuthenticationStateRequest, $root.kritor.authentication.GetAuthenticationStateResponse, request, callback);
            }, "name", { value: "GetAuthenticationState" });

            /**
             * Calls GetAuthenticationState.
             * @function getAuthenticationState
             * @memberof kritor.authentication.AuthenticationService
             * @instance
             * @param {kritor.authentication.IGetAuthenticationStateRequest} request GetAuthenticationStateRequest message or plain object
             * @returns {Promise<kritor.authentication.GetAuthenticationStateResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.authentication.AuthenticationService#getTicket}.
             * @memberof kritor.authentication.AuthenticationService
             * @typedef GetTicketCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.authentication.GetTicketResponse} [response] GetTicketResponse
             */

            /**
             * Calls GetTicket.
             * @function getTicket
             * @memberof kritor.authentication.AuthenticationService
             * @instance
             * @param {kritor.authentication.IGetTicketRequest} request GetTicketRequest message or plain object
             * @param {kritor.authentication.AuthenticationService.GetTicketCallback} callback Node-style callback called with the error, if any, and GetTicketResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(AuthenticationService.prototype.getTicket = function getTicket(request, callback) {
                return this.rpcCall(getTicket, $root.kritor.authentication.GetTicketRequest, $root.kritor.authentication.GetTicketResponse, request, callback);
            }, "name", { value: "GetTicket" });

            /**
             * Calls GetTicket.
             * @function getTicket
             * @memberof kritor.authentication.AuthenticationService
             * @instance
             * @param {kritor.authentication.IGetTicketRequest} request GetTicketRequest message or plain object
             * @returns {Promise<kritor.authentication.GetTicketResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.authentication.AuthenticationService#addTicket}.
             * @memberof kritor.authentication.AuthenticationService
             * @typedef AddTicketCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.authentication.AddTicketResponse} [response] AddTicketResponse
             */

            /**
             * Calls AddTicket.
             * @function addTicket
             * @memberof kritor.authentication.AuthenticationService
             * @instance
             * @param {kritor.authentication.IAddTicketRequest} request AddTicketRequest message or plain object
             * @param {kritor.authentication.AuthenticationService.AddTicketCallback} callback Node-style callback called with the error, if any, and AddTicketResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(AuthenticationService.prototype.addTicket = function addTicket(request, callback) {
                return this.rpcCall(addTicket, $root.kritor.authentication.AddTicketRequest, $root.kritor.authentication.AddTicketResponse, request, callback);
            }, "name", { value: "AddTicket" });

            /**
             * Calls AddTicket.
             * @function addTicket
             * @memberof kritor.authentication.AuthenticationService
             * @instance
             * @param {kritor.authentication.IAddTicketRequest} request AddTicketRequest message or plain object
             * @returns {Promise<kritor.authentication.AddTicketResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.authentication.AuthenticationService#deleteTicket}.
             * @memberof kritor.authentication.AuthenticationService
             * @typedef DeleteTicketCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.authentication.DeleteTicketResponse} [response] DeleteTicketResponse
             */

            /**
             * Calls DeleteTicket.
             * @function deleteTicket
             * @memberof kritor.authentication.AuthenticationService
             * @instance
             * @param {kritor.authentication.IDeleteTicketRequest} request DeleteTicketRequest message or plain object
             * @param {kritor.authentication.AuthenticationService.DeleteTicketCallback} callback Node-style callback called with the error, if any, and DeleteTicketResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(AuthenticationService.prototype.deleteTicket = function deleteTicket(request, callback) {
                return this.rpcCall(deleteTicket, $root.kritor.authentication.DeleteTicketRequest, $root.kritor.authentication.DeleteTicketResponse, request, callback);
            }, "name", { value: "DeleteTicket" });

            /**
             * Calls DeleteTicket.
             * @function deleteTicket
             * @memberof kritor.authentication.AuthenticationService
             * @instance
             * @param {kritor.authentication.IDeleteTicketRequest} request DeleteTicketRequest message or plain object
             * @returns {Promise<kritor.authentication.DeleteTicketResponse>} Promise
             * @variation 2
             */

            return AuthenticationService;
        })();

        authentication.AuthenticateRequest = (function() {

            /**
             * Properties of an AuthenticateRequest.
             * @memberof kritor.authentication
             * @interface IAuthenticateRequest
             * @property {string|null} [account] AuthenticateRequest account
             * @property {string|null} [ticket] AuthenticateRequest ticket
             */

            /**
             * Constructs a new AuthenticateRequest.
             * @memberof kritor.authentication
             * @classdesc Represents an AuthenticateRequest.
             * @implements IAuthenticateRequest
             * @constructor
             * @param {kritor.authentication.IAuthenticateRequest=} [properties] Properties to set
             */
            function AuthenticateRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AuthenticateRequest account.
             * @member {string} account
             * @memberof kritor.authentication.AuthenticateRequest
             * @instance
             */
            AuthenticateRequest.prototype.account = "";

            /**
             * AuthenticateRequest ticket.
             * @member {string} ticket
             * @memberof kritor.authentication.AuthenticateRequest
             * @instance
             */
            AuthenticateRequest.prototype.ticket = "";

            /**
             * Creates a new AuthenticateRequest instance using the specified properties.
             * @function create
             * @memberof kritor.authentication.AuthenticateRequest
             * @static
             * @param {kritor.authentication.IAuthenticateRequest=} [properties] Properties to set
             * @returns {kritor.authentication.AuthenticateRequest} AuthenticateRequest instance
             */
            AuthenticateRequest.create = function create(properties) {
                return new AuthenticateRequest(properties);
            };

            /**
             * Encodes the specified AuthenticateRequest message. Does not implicitly {@link kritor.authentication.AuthenticateRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.authentication.AuthenticateRequest
             * @static
             * @param {kritor.authentication.IAuthenticateRequest} message AuthenticateRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AuthenticateRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.account != null && Object.hasOwnProperty.call(message, "account"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.account);
                if (message.ticket != null && Object.hasOwnProperty.call(message, "ticket"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.ticket);
                return writer;
            };

            /**
             * Encodes the specified AuthenticateRequest message, length delimited. Does not implicitly {@link kritor.authentication.AuthenticateRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.authentication.AuthenticateRequest
             * @static
             * @param {kritor.authentication.IAuthenticateRequest} message AuthenticateRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AuthenticateRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AuthenticateRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.authentication.AuthenticateRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.authentication.AuthenticateRequest} AuthenticateRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AuthenticateRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.authentication.AuthenticateRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.account = reader.string();
                            break;
                        }
                    case 2: {
                            message.ticket = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AuthenticateRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.authentication.AuthenticateRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.authentication.AuthenticateRequest} AuthenticateRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AuthenticateRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AuthenticateRequest message.
             * @function verify
             * @memberof kritor.authentication.AuthenticateRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AuthenticateRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.account != null && message.hasOwnProperty("account"))
                    if (!$util.isString(message.account))
                        return "account: string expected";
                if (message.ticket != null && message.hasOwnProperty("ticket"))
                    if (!$util.isString(message.ticket))
                        return "ticket: string expected";
                return null;
            };

            /**
             * Creates an AuthenticateRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.authentication.AuthenticateRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.authentication.AuthenticateRequest} AuthenticateRequest
             */
            AuthenticateRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.authentication.AuthenticateRequest)
                    return object;
                let message = new $root.kritor.authentication.AuthenticateRequest();
                if (object.account != null)
                    message.account = String(object.account);
                if (object.ticket != null)
                    message.ticket = String(object.ticket);
                return message;
            };

            /**
             * Creates a plain object from an AuthenticateRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.authentication.AuthenticateRequest
             * @static
             * @param {kritor.authentication.AuthenticateRequest} message AuthenticateRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AuthenticateRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.account = "";
                    object.ticket = "";
                }
                if (message.account != null && message.hasOwnProperty("account"))
                    object.account = message.account;
                if (message.ticket != null && message.hasOwnProperty("ticket"))
                    object.ticket = message.ticket;
                return object;
            };

            /**
             * Converts this AuthenticateRequest to JSON.
             * @function toJSON
             * @memberof kritor.authentication.AuthenticateRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AuthenticateRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for AuthenticateRequest
             * @function getTypeUrl
             * @memberof kritor.authentication.AuthenticateRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            AuthenticateRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.authentication.AuthenticateRequest";
            };

            return AuthenticateRequest;
        })();

        authentication.AuthenticateResponse = (function() {

            /**
             * Properties of an AuthenticateResponse.
             * @memberof kritor.authentication
             * @interface IAuthenticateResponse
             * @property {kritor.authentication.AuthenticateResponse.AuthenticateResponseCode|null} [code] AuthenticateResponse code
             * @property {string|null} [msg] AuthenticateResponse msg
             */

            /**
             * Constructs a new AuthenticateResponse.
             * @memberof kritor.authentication
             * @classdesc Represents an AuthenticateResponse.
             * @implements IAuthenticateResponse
             * @constructor
             * @param {kritor.authentication.IAuthenticateResponse=} [properties] Properties to set
             */
            function AuthenticateResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AuthenticateResponse code.
             * @member {kritor.authentication.AuthenticateResponse.AuthenticateResponseCode} code
             * @memberof kritor.authentication.AuthenticateResponse
             * @instance
             */
            AuthenticateResponse.prototype.code = 0;

            /**
             * AuthenticateResponse msg.
             * @member {string} msg
             * @memberof kritor.authentication.AuthenticateResponse
             * @instance
             */
            AuthenticateResponse.prototype.msg = "";

            /**
             * Creates a new AuthenticateResponse instance using the specified properties.
             * @function create
             * @memberof kritor.authentication.AuthenticateResponse
             * @static
             * @param {kritor.authentication.IAuthenticateResponse=} [properties] Properties to set
             * @returns {kritor.authentication.AuthenticateResponse} AuthenticateResponse instance
             */
            AuthenticateResponse.create = function create(properties) {
                return new AuthenticateResponse(properties);
            };

            /**
             * Encodes the specified AuthenticateResponse message. Does not implicitly {@link kritor.authentication.AuthenticateResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.authentication.AuthenticateResponse
             * @static
             * @param {kritor.authentication.IAuthenticateResponse} message AuthenticateResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AuthenticateResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.msg);
                return writer;
            };

            /**
             * Encodes the specified AuthenticateResponse message, length delimited. Does not implicitly {@link kritor.authentication.AuthenticateResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.authentication.AuthenticateResponse
             * @static
             * @param {kritor.authentication.IAuthenticateResponse} message AuthenticateResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AuthenticateResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AuthenticateResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.authentication.AuthenticateResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.authentication.AuthenticateResponse} AuthenticateResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AuthenticateResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.authentication.AuthenticateResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.code = reader.int32();
                            break;
                        }
                    case 2: {
                            message.msg = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AuthenticateResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.authentication.AuthenticateResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.authentication.AuthenticateResponse} AuthenticateResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AuthenticateResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AuthenticateResponse message.
             * @function verify
             * @memberof kritor.authentication.AuthenticateResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AuthenticateResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.code != null && message.hasOwnProperty("code"))
                    switch (message.code) {
                    default:
                        return "code: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.msg != null && message.hasOwnProperty("msg"))
                    if (!$util.isString(message.msg))
                        return "msg: string expected";
                return null;
            };

            /**
             * Creates an AuthenticateResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.authentication.AuthenticateResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.authentication.AuthenticateResponse} AuthenticateResponse
             */
            AuthenticateResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.authentication.AuthenticateResponse)
                    return object;
                let message = new $root.kritor.authentication.AuthenticateResponse();
                switch (object.code) {
                default:
                    if (typeof object.code === "number") {
                        message.code = object.code;
                        break;
                    }
                    break;
                case "OK":
                case 0:
                    message.code = 0;
                    break;
                case "NO_ACCOUNT":
                case 1:
                    message.code = 1;
                    break;
                case "NO_TICKET":
                case 2:
                    message.code = 2;
                    break;
                case "LOGIC_ERROR":
                case 3:
                    message.code = 3;
                    break;
                }
                if (object.msg != null)
                    message.msg = String(object.msg);
                return message;
            };

            /**
             * Creates a plain object from an AuthenticateResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.authentication.AuthenticateResponse
             * @static
             * @param {kritor.authentication.AuthenticateResponse} message AuthenticateResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AuthenticateResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.code = options.enums === String ? "OK" : 0;
                    object.msg = "";
                }
                if (message.code != null && message.hasOwnProperty("code"))
                    object.code = options.enums === String ? $root.kritor.authentication.AuthenticateResponse.AuthenticateResponseCode[message.code] === undefined ? message.code : $root.kritor.authentication.AuthenticateResponse.AuthenticateResponseCode[message.code] : message.code;
                if (message.msg != null && message.hasOwnProperty("msg"))
                    object.msg = message.msg;
                return object;
            };

            /**
             * Converts this AuthenticateResponse to JSON.
             * @function toJSON
             * @memberof kritor.authentication.AuthenticateResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AuthenticateResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for AuthenticateResponse
             * @function getTypeUrl
             * @memberof kritor.authentication.AuthenticateResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            AuthenticateResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.authentication.AuthenticateResponse";
            };

            /**
             * AuthenticateResponseCode enum.
             * @name kritor.authentication.AuthenticateResponse.AuthenticateResponseCode
             * @enum {number}
             * @property {number} OK=0 OK value
             * @property {number} NO_ACCOUNT=1 NO_ACCOUNT value
             * @property {number} NO_TICKET=2 NO_TICKET value
             * @property {number} LOGIC_ERROR=3 LOGIC_ERROR value
             */
            AuthenticateResponse.AuthenticateResponseCode = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "OK"] = 0;
                values[valuesById[1] = "NO_ACCOUNT"] = 1;
                values[valuesById[2] = "NO_TICKET"] = 2;
                values[valuesById[3] = "LOGIC_ERROR"] = 3;
                return values;
            })();

            return AuthenticateResponse;
        })();

        authentication.GetAuthenticationStateRequest = (function() {

            /**
             * Properties of a GetAuthenticationStateRequest.
             * @memberof kritor.authentication
             * @interface IGetAuthenticationStateRequest
             * @property {string|null} [account] GetAuthenticationStateRequest account
             */

            /**
             * Constructs a new GetAuthenticationStateRequest.
             * @memberof kritor.authentication
             * @classdesc Represents a GetAuthenticationStateRequest.
             * @implements IGetAuthenticationStateRequest
             * @constructor
             * @param {kritor.authentication.IGetAuthenticationStateRequest=} [properties] Properties to set
             */
            function GetAuthenticationStateRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetAuthenticationStateRequest account.
             * @member {string} account
             * @memberof kritor.authentication.GetAuthenticationStateRequest
             * @instance
             */
            GetAuthenticationStateRequest.prototype.account = "";

            /**
             * Creates a new GetAuthenticationStateRequest instance using the specified properties.
             * @function create
             * @memberof kritor.authentication.GetAuthenticationStateRequest
             * @static
             * @param {kritor.authentication.IGetAuthenticationStateRequest=} [properties] Properties to set
             * @returns {kritor.authentication.GetAuthenticationStateRequest} GetAuthenticationStateRequest instance
             */
            GetAuthenticationStateRequest.create = function create(properties) {
                return new GetAuthenticationStateRequest(properties);
            };

            /**
             * Encodes the specified GetAuthenticationStateRequest message. Does not implicitly {@link kritor.authentication.GetAuthenticationStateRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.authentication.GetAuthenticationStateRequest
             * @static
             * @param {kritor.authentication.IGetAuthenticationStateRequest} message GetAuthenticationStateRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetAuthenticationStateRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.account != null && Object.hasOwnProperty.call(message, "account"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.account);
                return writer;
            };

            /**
             * Encodes the specified GetAuthenticationStateRequest message, length delimited. Does not implicitly {@link kritor.authentication.GetAuthenticationStateRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.authentication.GetAuthenticationStateRequest
             * @static
             * @param {kritor.authentication.IGetAuthenticationStateRequest} message GetAuthenticationStateRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetAuthenticationStateRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetAuthenticationStateRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.authentication.GetAuthenticationStateRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.authentication.GetAuthenticationStateRequest} GetAuthenticationStateRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetAuthenticationStateRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.authentication.GetAuthenticationStateRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.account = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetAuthenticationStateRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.authentication.GetAuthenticationStateRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.authentication.GetAuthenticationStateRequest} GetAuthenticationStateRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetAuthenticationStateRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetAuthenticationStateRequest message.
             * @function verify
             * @memberof kritor.authentication.GetAuthenticationStateRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetAuthenticationStateRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.account != null && message.hasOwnProperty("account"))
                    if (!$util.isString(message.account))
                        return "account: string expected";
                return null;
            };

            /**
             * Creates a GetAuthenticationStateRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.authentication.GetAuthenticationStateRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.authentication.GetAuthenticationStateRequest} GetAuthenticationStateRequest
             */
            GetAuthenticationStateRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.authentication.GetAuthenticationStateRequest)
                    return object;
                let message = new $root.kritor.authentication.GetAuthenticationStateRequest();
                if (object.account != null)
                    message.account = String(object.account);
                return message;
            };

            /**
             * Creates a plain object from a GetAuthenticationStateRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.authentication.GetAuthenticationStateRequest
             * @static
             * @param {kritor.authentication.GetAuthenticationStateRequest} message GetAuthenticationStateRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetAuthenticationStateRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.account = "";
                if (message.account != null && message.hasOwnProperty("account"))
                    object.account = message.account;
                return object;
            };

            /**
             * Converts this GetAuthenticationStateRequest to JSON.
             * @function toJSON
             * @memberof kritor.authentication.GetAuthenticationStateRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetAuthenticationStateRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetAuthenticationStateRequest
             * @function getTypeUrl
             * @memberof kritor.authentication.GetAuthenticationStateRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetAuthenticationStateRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.authentication.GetAuthenticationStateRequest";
            };

            return GetAuthenticationStateRequest;
        })();

        authentication.GetAuthenticationStateResponse = (function() {

            /**
             * Properties of a GetAuthenticationStateResponse.
             * @memberof kritor.authentication
             * @interface IGetAuthenticationStateResponse
             * @property {boolean|null} [isRequired] GetAuthenticationStateResponse isRequired
             */

            /**
             * Constructs a new GetAuthenticationStateResponse.
             * @memberof kritor.authentication
             * @classdesc Represents a GetAuthenticationStateResponse.
             * @implements IGetAuthenticationStateResponse
             * @constructor
             * @param {kritor.authentication.IGetAuthenticationStateResponse=} [properties] Properties to set
             */
            function GetAuthenticationStateResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetAuthenticationStateResponse isRequired.
             * @member {boolean} isRequired
             * @memberof kritor.authentication.GetAuthenticationStateResponse
             * @instance
             */
            GetAuthenticationStateResponse.prototype.isRequired = false;

            /**
             * Creates a new GetAuthenticationStateResponse instance using the specified properties.
             * @function create
             * @memberof kritor.authentication.GetAuthenticationStateResponse
             * @static
             * @param {kritor.authentication.IGetAuthenticationStateResponse=} [properties] Properties to set
             * @returns {kritor.authentication.GetAuthenticationStateResponse} GetAuthenticationStateResponse instance
             */
            GetAuthenticationStateResponse.create = function create(properties) {
                return new GetAuthenticationStateResponse(properties);
            };

            /**
             * Encodes the specified GetAuthenticationStateResponse message. Does not implicitly {@link kritor.authentication.GetAuthenticationStateResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.authentication.GetAuthenticationStateResponse
             * @static
             * @param {kritor.authentication.IGetAuthenticationStateResponse} message GetAuthenticationStateResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetAuthenticationStateResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.isRequired != null && Object.hasOwnProperty.call(message, "isRequired"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.isRequired);
                return writer;
            };

            /**
             * Encodes the specified GetAuthenticationStateResponse message, length delimited. Does not implicitly {@link kritor.authentication.GetAuthenticationStateResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.authentication.GetAuthenticationStateResponse
             * @static
             * @param {kritor.authentication.IGetAuthenticationStateResponse} message GetAuthenticationStateResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetAuthenticationStateResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetAuthenticationStateResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.authentication.GetAuthenticationStateResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.authentication.GetAuthenticationStateResponse} GetAuthenticationStateResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetAuthenticationStateResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.authentication.GetAuthenticationStateResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.isRequired = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetAuthenticationStateResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.authentication.GetAuthenticationStateResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.authentication.GetAuthenticationStateResponse} GetAuthenticationStateResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetAuthenticationStateResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetAuthenticationStateResponse message.
             * @function verify
             * @memberof kritor.authentication.GetAuthenticationStateResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetAuthenticationStateResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.isRequired != null && message.hasOwnProperty("isRequired"))
                    if (typeof message.isRequired !== "boolean")
                        return "isRequired: boolean expected";
                return null;
            };

            /**
             * Creates a GetAuthenticationStateResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.authentication.GetAuthenticationStateResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.authentication.GetAuthenticationStateResponse} GetAuthenticationStateResponse
             */
            GetAuthenticationStateResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.authentication.GetAuthenticationStateResponse)
                    return object;
                let message = new $root.kritor.authentication.GetAuthenticationStateResponse();
                if (object.isRequired != null)
                    message.isRequired = Boolean(object.isRequired);
                return message;
            };

            /**
             * Creates a plain object from a GetAuthenticationStateResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.authentication.GetAuthenticationStateResponse
             * @static
             * @param {kritor.authentication.GetAuthenticationStateResponse} message GetAuthenticationStateResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetAuthenticationStateResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.isRequired = false;
                if (message.isRequired != null && message.hasOwnProperty("isRequired"))
                    object.isRequired = message.isRequired;
                return object;
            };

            /**
             * Converts this GetAuthenticationStateResponse to JSON.
             * @function toJSON
             * @memberof kritor.authentication.GetAuthenticationStateResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetAuthenticationStateResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetAuthenticationStateResponse
             * @function getTypeUrl
             * @memberof kritor.authentication.GetAuthenticationStateResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetAuthenticationStateResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.authentication.GetAuthenticationStateResponse";
            };

            return GetAuthenticationStateResponse;
        })();

        /**
         * TicketOperationResponseCode enum.
         * @name kritor.authentication.TicketOperationResponseCode
         * @enum {number}
         * @property {number} OK=0 OK value
         * @property {number} ERROR=1 ERROR value
         */
        authentication.TicketOperationResponseCode = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "OK"] = 0;
            values[valuesById[1] = "ERROR"] = 1;
            return values;
        })();

        authentication.GetTicketRequest = (function() {

            /**
             * Properties of a GetTicketRequest.
             * @memberof kritor.authentication
             * @interface IGetTicketRequest
             * @property {string|null} [account] GetTicketRequest account
             * @property {string|null} [superTicket] GetTicketRequest superTicket
             */

            /**
             * Constructs a new GetTicketRequest.
             * @memberof kritor.authentication
             * @classdesc Represents a GetTicketRequest.
             * @implements IGetTicketRequest
             * @constructor
             * @param {kritor.authentication.IGetTicketRequest=} [properties] Properties to set
             */
            function GetTicketRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetTicketRequest account.
             * @member {string} account
             * @memberof kritor.authentication.GetTicketRequest
             * @instance
             */
            GetTicketRequest.prototype.account = "";

            /**
             * GetTicketRequest superTicket.
             * @member {string} superTicket
             * @memberof kritor.authentication.GetTicketRequest
             * @instance
             */
            GetTicketRequest.prototype.superTicket = "";

            /**
             * Creates a new GetTicketRequest instance using the specified properties.
             * @function create
             * @memberof kritor.authentication.GetTicketRequest
             * @static
             * @param {kritor.authentication.IGetTicketRequest=} [properties] Properties to set
             * @returns {kritor.authentication.GetTicketRequest} GetTicketRequest instance
             */
            GetTicketRequest.create = function create(properties) {
                return new GetTicketRequest(properties);
            };

            /**
             * Encodes the specified GetTicketRequest message. Does not implicitly {@link kritor.authentication.GetTicketRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.authentication.GetTicketRequest
             * @static
             * @param {kritor.authentication.IGetTicketRequest} message GetTicketRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetTicketRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.account != null && Object.hasOwnProperty.call(message, "account"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.account);
                if (message.superTicket != null && Object.hasOwnProperty.call(message, "superTicket"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.superTicket);
                return writer;
            };

            /**
             * Encodes the specified GetTicketRequest message, length delimited. Does not implicitly {@link kritor.authentication.GetTicketRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.authentication.GetTicketRequest
             * @static
             * @param {kritor.authentication.IGetTicketRequest} message GetTicketRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetTicketRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetTicketRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.authentication.GetTicketRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.authentication.GetTicketRequest} GetTicketRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetTicketRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.authentication.GetTicketRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.account = reader.string();
                            break;
                        }
                    case 2: {
                            message.superTicket = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetTicketRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.authentication.GetTicketRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.authentication.GetTicketRequest} GetTicketRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetTicketRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetTicketRequest message.
             * @function verify
             * @memberof kritor.authentication.GetTicketRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetTicketRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.account != null && message.hasOwnProperty("account"))
                    if (!$util.isString(message.account))
                        return "account: string expected";
                if (message.superTicket != null && message.hasOwnProperty("superTicket"))
                    if (!$util.isString(message.superTicket))
                        return "superTicket: string expected";
                return null;
            };

            /**
             * Creates a GetTicketRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.authentication.GetTicketRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.authentication.GetTicketRequest} GetTicketRequest
             */
            GetTicketRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.authentication.GetTicketRequest)
                    return object;
                let message = new $root.kritor.authentication.GetTicketRequest();
                if (object.account != null)
                    message.account = String(object.account);
                if (object.superTicket != null)
                    message.superTicket = String(object.superTicket);
                return message;
            };

            /**
             * Creates a plain object from a GetTicketRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.authentication.GetTicketRequest
             * @static
             * @param {kritor.authentication.GetTicketRequest} message GetTicketRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetTicketRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.account = "";
                    object.superTicket = "";
                }
                if (message.account != null && message.hasOwnProperty("account"))
                    object.account = message.account;
                if (message.superTicket != null && message.hasOwnProperty("superTicket"))
                    object.superTicket = message.superTicket;
                return object;
            };

            /**
             * Converts this GetTicketRequest to JSON.
             * @function toJSON
             * @memberof kritor.authentication.GetTicketRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetTicketRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetTicketRequest
             * @function getTypeUrl
             * @memberof kritor.authentication.GetTicketRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetTicketRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.authentication.GetTicketRequest";
            };

            return GetTicketRequest;
        })();

        authentication.GetTicketResponse = (function() {

            /**
             * Properties of a GetTicketResponse.
             * @memberof kritor.authentication
             * @interface IGetTicketResponse
             * @property {kritor.authentication.TicketOperationResponseCode|null} [code] GetTicketResponse code
             * @property {string|null} [msg] GetTicketResponse msg
             * @property {Array.<string>|null} [tickets] GetTicketResponse tickets
             */

            /**
             * Constructs a new GetTicketResponse.
             * @memberof kritor.authentication
             * @classdesc Represents a GetTicketResponse.
             * @implements IGetTicketResponse
             * @constructor
             * @param {kritor.authentication.IGetTicketResponse=} [properties] Properties to set
             */
            function GetTicketResponse(properties) {
                this.tickets = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetTicketResponse code.
             * @member {kritor.authentication.TicketOperationResponseCode} code
             * @memberof kritor.authentication.GetTicketResponse
             * @instance
             */
            GetTicketResponse.prototype.code = 0;

            /**
             * GetTicketResponse msg.
             * @member {string} msg
             * @memberof kritor.authentication.GetTicketResponse
             * @instance
             */
            GetTicketResponse.prototype.msg = "";

            /**
             * GetTicketResponse tickets.
             * @member {Array.<string>} tickets
             * @memberof kritor.authentication.GetTicketResponse
             * @instance
             */
            GetTicketResponse.prototype.tickets = $util.emptyArray;

            /**
             * Creates a new GetTicketResponse instance using the specified properties.
             * @function create
             * @memberof kritor.authentication.GetTicketResponse
             * @static
             * @param {kritor.authentication.IGetTicketResponse=} [properties] Properties to set
             * @returns {kritor.authentication.GetTicketResponse} GetTicketResponse instance
             */
            GetTicketResponse.create = function create(properties) {
                return new GetTicketResponse(properties);
            };

            /**
             * Encodes the specified GetTicketResponse message. Does not implicitly {@link kritor.authentication.GetTicketResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.authentication.GetTicketResponse
             * @static
             * @param {kritor.authentication.IGetTicketResponse} message GetTicketResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetTicketResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.msg);
                if (message.tickets != null && message.tickets.length)
                    for (let i = 0; i < message.tickets.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.tickets[i]);
                return writer;
            };

            /**
             * Encodes the specified GetTicketResponse message, length delimited. Does not implicitly {@link kritor.authentication.GetTicketResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.authentication.GetTicketResponse
             * @static
             * @param {kritor.authentication.IGetTicketResponse} message GetTicketResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetTicketResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetTicketResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.authentication.GetTicketResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.authentication.GetTicketResponse} GetTicketResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetTicketResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.authentication.GetTicketResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.code = reader.int32();
                            break;
                        }
                    case 2: {
                            message.msg = reader.string();
                            break;
                        }
                    case 3: {
                            if (!(message.tickets && message.tickets.length))
                                message.tickets = [];
                            message.tickets.push(reader.string());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetTicketResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.authentication.GetTicketResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.authentication.GetTicketResponse} GetTicketResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetTicketResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetTicketResponse message.
             * @function verify
             * @memberof kritor.authentication.GetTicketResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetTicketResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.code != null && message.hasOwnProperty("code"))
                    switch (message.code) {
                    default:
                        return "code: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                if (message.msg != null && message.hasOwnProperty("msg"))
                    if (!$util.isString(message.msg))
                        return "msg: string expected";
                if (message.tickets != null && message.hasOwnProperty("tickets")) {
                    if (!Array.isArray(message.tickets))
                        return "tickets: array expected";
                    for (let i = 0; i < message.tickets.length; ++i)
                        if (!$util.isString(message.tickets[i]))
                            return "tickets: string[] expected";
                }
                return null;
            };

            /**
             * Creates a GetTicketResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.authentication.GetTicketResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.authentication.GetTicketResponse} GetTicketResponse
             */
            GetTicketResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.authentication.GetTicketResponse)
                    return object;
                let message = new $root.kritor.authentication.GetTicketResponse();
                switch (object.code) {
                default:
                    if (typeof object.code === "number") {
                        message.code = object.code;
                        break;
                    }
                    break;
                case "OK":
                case 0:
                    message.code = 0;
                    break;
                case "ERROR":
                case 1:
                    message.code = 1;
                    break;
                }
                if (object.msg != null)
                    message.msg = String(object.msg);
                if (object.tickets) {
                    if (!Array.isArray(object.tickets))
                        throw TypeError(".kritor.authentication.GetTicketResponse.tickets: array expected");
                    message.tickets = [];
                    for (let i = 0; i < object.tickets.length; ++i)
                        message.tickets[i] = String(object.tickets[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a GetTicketResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.authentication.GetTicketResponse
             * @static
             * @param {kritor.authentication.GetTicketResponse} message GetTicketResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetTicketResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.tickets = [];
                if (options.defaults) {
                    object.code = options.enums === String ? "OK" : 0;
                    object.msg = "";
                }
                if (message.code != null && message.hasOwnProperty("code"))
                    object.code = options.enums === String ? $root.kritor.authentication.TicketOperationResponseCode[message.code] === undefined ? message.code : $root.kritor.authentication.TicketOperationResponseCode[message.code] : message.code;
                if (message.msg != null && message.hasOwnProperty("msg"))
                    object.msg = message.msg;
                if (message.tickets && message.tickets.length) {
                    object.tickets = [];
                    for (let j = 0; j < message.tickets.length; ++j)
                        object.tickets[j] = message.tickets[j];
                }
                return object;
            };

            /**
             * Converts this GetTicketResponse to JSON.
             * @function toJSON
             * @memberof kritor.authentication.GetTicketResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetTicketResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetTicketResponse
             * @function getTypeUrl
             * @memberof kritor.authentication.GetTicketResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetTicketResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.authentication.GetTicketResponse";
            };

            return GetTicketResponse;
        })();

        authentication.AddTicketRequest = (function() {

            /**
             * Properties of an AddTicketRequest.
             * @memberof kritor.authentication
             * @interface IAddTicketRequest
             * @property {string|null} [account] AddTicketRequest account
             * @property {string|null} [superTicket] AddTicketRequest superTicket
             * @property {string|null} [ticket] AddTicketRequest ticket
             */

            /**
             * Constructs a new AddTicketRequest.
             * @memberof kritor.authentication
             * @classdesc Represents an AddTicketRequest.
             * @implements IAddTicketRequest
             * @constructor
             * @param {kritor.authentication.IAddTicketRequest=} [properties] Properties to set
             */
            function AddTicketRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AddTicketRequest account.
             * @member {string} account
             * @memberof kritor.authentication.AddTicketRequest
             * @instance
             */
            AddTicketRequest.prototype.account = "";

            /**
             * AddTicketRequest superTicket.
             * @member {string} superTicket
             * @memberof kritor.authentication.AddTicketRequest
             * @instance
             */
            AddTicketRequest.prototype.superTicket = "";

            /**
             * AddTicketRequest ticket.
             * @member {string} ticket
             * @memberof kritor.authentication.AddTicketRequest
             * @instance
             */
            AddTicketRequest.prototype.ticket = "";

            /**
             * Creates a new AddTicketRequest instance using the specified properties.
             * @function create
             * @memberof kritor.authentication.AddTicketRequest
             * @static
             * @param {kritor.authentication.IAddTicketRequest=} [properties] Properties to set
             * @returns {kritor.authentication.AddTicketRequest} AddTicketRequest instance
             */
            AddTicketRequest.create = function create(properties) {
                return new AddTicketRequest(properties);
            };

            /**
             * Encodes the specified AddTicketRequest message. Does not implicitly {@link kritor.authentication.AddTicketRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.authentication.AddTicketRequest
             * @static
             * @param {kritor.authentication.IAddTicketRequest} message AddTicketRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AddTicketRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.account != null && Object.hasOwnProperty.call(message, "account"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.account);
                if (message.superTicket != null && Object.hasOwnProperty.call(message, "superTicket"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.superTicket);
                if (message.ticket != null && Object.hasOwnProperty.call(message, "ticket"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.ticket);
                return writer;
            };

            /**
             * Encodes the specified AddTicketRequest message, length delimited. Does not implicitly {@link kritor.authentication.AddTicketRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.authentication.AddTicketRequest
             * @static
             * @param {kritor.authentication.IAddTicketRequest} message AddTicketRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AddTicketRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AddTicketRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.authentication.AddTicketRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.authentication.AddTicketRequest} AddTicketRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AddTicketRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.authentication.AddTicketRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.account = reader.string();
                            break;
                        }
                    case 2: {
                            message.superTicket = reader.string();
                            break;
                        }
                    case 3: {
                            message.ticket = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AddTicketRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.authentication.AddTicketRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.authentication.AddTicketRequest} AddTicketRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AddTicketRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AddTicketRequest message.
             * @function verify
             * @memberof kritor.authentication.AddTicketRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AddTicketRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.account != null && message.hasOwnProperty("account"))
                    if (!$util.isString(message.account))
                        return "account: string expected";
                if (message.superTicket != null && message.hasOwnProperty("superTicket"))
                    if (!$util.isString(message.superTicket))
                        return "superTicket: string expected";
                if (message.ticket != null && message.hasOwnProperty("ticket"))
                    if (!$util.isString(message.ticket))
                        return "ticket: string expected";
                return null;
            };

            /**
             * Creates an AddTicketRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.authentication.AddTicketRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.authentication.AddTicketRequest} AddTicketRequest
             */
            AddTicketRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.authentication.AddTicketRequest)
                    return object;
                let message = new $root.kritor.authentication.AddTicketRequest();
                if (object.account != null)
                    message.account = String(object.account);
                if (object.superTicket != null)
                    message.superTicket = String(object.superTicket);
                if (object.ticket != null)
                    message.ticket = String(object.ticket);
                return message;
            };

            /**
             * Creates a plain object from an AddTicketRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.authentication.AddTicketRequest
             * @static
             * @param {kritor.authentication.AddTicketRequest} message AddTicketRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AddTicketRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.account = "";
                    object.superTicket = "";
                    object.ticket = "";
                }
                if (message.account != null && message.hasOwnProperty("account"))
                    object.account = message.account;
                if (message.superTicket != null && message.hasOwnProperty("superTicket"))
                    object.superTicket = message.superTicket;
                if (message.ticket != null && message.hasOwnProperty("ticket"))
                    object.ticket = message.ticket;
                return object;
            };

            /**
             * Converts this AddTicketRequest to JSON.
             * @function toJSON
             * @memberof kritor.authentication.AddTicketRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AddTicketRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for AddTicketRequest
             * @function getTypeUrl
             * @memberof kritor.authentication.AddTicketRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            AddTicketRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.authentication.AddTicketRequest";
            };

            return AddTicketRequest;
        })();

        authentication.AddTicketResponse = (function() {

            /**
             * Properties of an AddTicketResponse.
             * @memberof kritor.authentication
             * @interface IAddTicketResponse
             * @property {kritor.authentication.TicketOperationResponseCode|null} [code] AddTicketResponse code
             * @property {string|null} [msg] AddTicketResponse msg
             */

            /**
             * Constructs a new AddTicketResponse.
             * @memberof kritor.authentication
             * @classdesc Represents an AddTicketResponse.
             * @implements IAddTicketResponse
             * @constructor
             * @param {kritor.authentication.IAddTicketResponse=} [properties] Properties to set
             */
            function AddTicketResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AddTicketResponse code.
             * @member {kritor.authentication.TicketOperationResponseCode} code
             * @memberof kritor.authentication.AddTicketResponse
             * @instance
             */
            AddTicketResponse.prototype.code = 0;

            /**
             * AddTicketResponse msg.
             * @member {string} msg
             * @memberof kritor.authentication.AddTicketResponse
             * @instance
             */
            AddTicketResponse.prototype.msg = "";

            /**
             * Creates a new AddTicketResponse instance using the specified properties.
             * @function create
             * @memberof kritor.authentication.AddTicketResponse
             * @static
             * @param {kritor.authentication.IAddTicketResponse=} [properties] Properties to set
             * @returns {kritor.authentication.AddTicketResponse} AddTicketResponse instance
             */
            AddTicketResponse.create = function create(properties) {
                return new AddTicketResponse(properties);
            };

            /**
             * Encodes the specified AddTicketResponse message. Does not implicitly {@link kritor.authentication.AddTicketResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.authentication.AddTicketResponse
             * @static
             * @param {kritor.authentication.IAddTicketResponse} message AddTicketResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AddTicketResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.msg);
                return writer;
            };

            /**
             * Encodes the specified AddTicketResponse message, length delimited. Does not implicitly {@link kritor.authentication.AddTicketResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.authentication.AddTicketResponse
             * @static
             * @param {kritor.authentication.IAddTicketResponse} message AddTicketResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AddTicketResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AddTicketResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.authentication.AddTicketResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.authentication.AddTicketResponse} AddTicketResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AddTicketResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.authentication.AddTicketResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.code = reader.int32();
                            break;
                        }
                    case 2: {
                            message.msg = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AddTicketResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.authentication.AddTicketResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.authentication.AddTicketResponse} AddTicketResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AddTicketResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AddTicketResponse message.
             * @function verify
             * @memberof kritor.authentication.AddTicketResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AddTicketResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.code != null && message.hasOwnProperty("code"))
                    switch (message.code) {
                    default:
                        return "code: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                if (message.msg != null && message.hasOwnProperty("msg"))
                    if (!$util.isString(message.msg))
                        return "msg: string expected";
                return null;
            };

            /**
             * Creates an AddTicketResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.authentication.AddTicketResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.authentication.AddTicketResponse} AddTicketResponse
             */
            AddTicketResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.authentication.AddTicketResponse)
                    return object;
                let message = new $root.kritor.authentication.AddTicketResponse();
                switch (object.code) {
                default:
                    if (typeof object.code === "number") {
                        message.code = object.code;
                        break;
                    }
                    break;
                case "OK":
                case 0:
                    message.code = 0;
                    break;
                case "ERROR":
                case 1:
                    message.code = 1;
                    break;
                }
                if (object.msg != null)
                    message.msg = String(object.msg);
                return message;
            };

            /**
             * Creates a plain object from an AddTicketResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.authentication.AddTicketResponse
             * @static
             * @param {kritor.authentication.AddTicketResponse} message AddTicketResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AddTicketResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.code = options.enums === String ? "OK" : 0;
                    object.msg = "";
                }
                if (message.code != null && message.hasOwnProperty("code"))
                    object.code = options.enums === String ? $root.kritor.authentication.TicketOperationResponseCode[message.code] === undefined ? message.code : $root.kritor.authentication.TicketOperationResponseCode[message.code] : message.code;
                if (message.msg != null && message.hasOwnProperty("msg"))
                    object.msg = message.msg;
                return object;
            };

            /**
             * Converts this AddTicketResponse to JSON.
             * @function toJSON
             * @memberof kritor.authentication.AddTicketResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AddTicketResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for AddTicketResponse
             * @function getTypeUrl
             * @memberof kritor.authentication.AddTicketResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            AddTicketResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.authentication.AddTicketResponse";
            };

            return AddTicketResponse;
        })();

        authentication.DeleteTicketRequest = (function() {

            /**
             * Properties of a DeleteTicketRequest.
             * @memberof kritor.authentication
             * @interface IDeleteTicketRequest
             * @property {string|null} [account] DeleteTicketRequest account
             * @property {string|null} [superTicket] DeleteTicketRequest superTicket
             * @property {string|null} [ticket] DeleteTicketRequest ticket
             */

            /**
             * Constructs a new DeleteTicketRequest.
             * @memberof kritor.authentication
             * @classdesc Represents a DeleteTicketRequest.
             * @implements IDeleteTicketRequest
             * @constructor
             * @param {kritor.authentication.IDeleteTicketRequest=} [properties] Properties to set
             */
            function DeleteTicketRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DeleteTicketRequest account.
             * @member {string} account
             * @memberof kritor.authentication.DeleteTicketRequest
             * @instance
             */
            DeleteTicketRequest.prototype.account = "";

            /**
             * DeleteTicketRequest superTicket.
             * @member {string} superTicket
             * @memberof kritor.authentication.DeleteTicketRequest
             * @instance
             */
            DeleteTicketRequest.prototype.superTicket = "";

            /**
             * DeleteTicketRequest ticket.
             * @member {string} ticket
             * @memberof kritor.authentication.DeleteTicketRequest
             * @instance
             */
            DeleteTicketRequest.prototype.ticket = "";

            /**
             * Creates a new DeleteTicketRequest instance using the specified properties.
             * @function create
             * @memberof kritor.authentication.DeleteTicketRequest
             * @static
             * @param {kritor.authentication.IDeleteTicketRequest=} [properties] Properties to set
             * @returns {kritor.authentication.DeleteTicketRequest} DeleteTicketRequest instance
             */
            DeleteTicketRequest.create = function create(properties) {
                return new DeleteTicketRequest(properties);
            };

            /**
             * Encodes the specified DeleteTicketRequest message. Does not implicitly {@link kritor.authentication.DeleteTicketRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.authentication.DeleteTicketRequest
             * @static
             * @param {kritor.authentication.IDeleteTicketRequest} message DeleteTicketRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteTicketRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.account != null && Object.hasOwnProperty.call(message, "account"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.account);
                if (message.superTicket != null && Object.hasOwnProperty.call(message, "superTicket"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.superTicket);
                if (message.ticket != null && Object.hasOwnProperty.call(message, "ticket"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.ticket);
                return writer;
            };

            /**
             * Encodes the specified DeleteTicketRequest message, length delimited. Does not implicitly {@link kritor.authentication.DeleteTicketRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.authentication.DeleteTicketRequest
             * @static
             * @param {kritor.authentication.IDeleteTicketRequest} message DeleteTicketRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteTicketRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeleteTicketRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.authentication.DeleteTicketRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.authentication.DeleteTicketRequest} DeleteTicketRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteTicketRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.authentication.DeleteTicketRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.account = reader.string();
                            break;
                        }
                    case 2: {
                            message.superTicket = reader.string();
                            break;
                        }
                    case 3: {
                            message.ticket = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DeleteTicketRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.authentication.DeleteTicketRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.authentication.DeleteTicketRequest} DeleteTicketRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteTicketRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeleteTicketRequest message.
             * @function verify
             * @memberof kritor.authentication.DeleteTicketRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeleteTicketRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.account != null && message.hasOwnProperty("account"))
                    if (!$util.isString(message.account))
                        return "account: string expected";
                if (message.superTicket != null && message.hasOwnProperty("superTicket"))
                    if (!$util.isString(message.superTicket))
                        return "superTicket: string expected";
                if (message.ticket != null && message.hasOwnProperty("ticket"))
                    if (!$util.isString(message.ticket))
                        return "ticket: string expected";
                return null;
            };

            /**
             * Creates a DeleteTicketRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.authentication.DeleteTicketRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.authentication.DeleteTicketRequest} DeleteTicketRequest
             */
            DeleteTicketRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.authentication.DeleteTicketRequest)
                    return object;
                let message = new $root.kritor.authentication.DeleteTicketRequest();
                if (object.account != null)
                    message.account = String(object.account);
                if (object.superTicket != null)
                    message.superTicket = String(object.superTicket);
                if (object.ticket != null)
                    message.ticket = String(object.ticket);
                return message;
            };

            /**
             * Creates a plain object from a DeleteTicketRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.authentication.DeleteTicketRequest
             * @static
             * @param {kritor.authentication.DeleteTicketRequest} message DeleteTicketRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeleteTicketRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.account = "";
                    object.superTicket = "";
                    object.ticket = "";
                }
                if (message.account != null && message.hasOwnProperty("account"))
                    object.account = message.account;
                if (message.superTicket != null && message.hasOwnProperty("superTicket"))
                    object.superTicket = message.superTicket;
                if (message.ticket != null && message.hasOwnProperty("ticket"))
                    object.ticket = message.ticket;
                return object;
            };

            /**
             * Converts this DeleteTicketRequest to JSON.
             * @function toJSON
             * @memberof kritor.authentication.DeleteTicketRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeleteTicketRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DeleteTicketRequest
             * @function getTypeUrl
             * @memberof kritor.authentication.DeleteTicketRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DeleteTicketRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.authentication.DeleteTicketRequest";
            };

            return DeleteTicketRequest;
        })();

        authentication.DeleteTicketResponse = (function() {

            /**
             * Properties of a DeleteTicketResponse.
             * @memberof kritor.authentication
             * @interface IDeleteTicketResponse
             * @property {kritor.authentication.TicketOperationResponseCode|null} [code] DeleteTicketResponse code
             * @property {string|null} [msg] DeleteTicketResponse msg
             */

            /**
             * Constructs a new DeleteTicketResponse.
             * @memberof kritor.authentication
             * @classdesc Represents a DeleteTicketResponse.
             * @implements IDeleteTicketResponse
             * @constructor
             * @param {kritor.authentication.IDeleteTicketResponse=} [properties] Properties to set
             */
            function DeleteTicketResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DeleteTicketResponse code.
             * @member {kritor.authentication.TicketOperationResponseCode} code
             * @memberof kritor.authentication.DeleteTicketResponse
             * @instance
             */
            DeleteTicketResponse.prototype.code = 0;

            /**
             * DeleteTicketResponse msg.
             * @member {string} msg
             * @memberof kritor.authentication.DeleteTicketResponse
             * @instance
             */
            DeleteTicketResponse.prototype.msg = "";

            /**
             * Creates a new DeleteTicketResponse instance using the specified properties.
             * @function create
             * @memberof kritor.authentication.DeleteTicketResponse
             * @static
             * @param {kritor.authentication.IDeleteTicketResponse=} [properties] Properties to set
             * @returns {kritor.authentication.DeleteTicketResponse} DeleteTicketResponse instance
             */
            DeleteTicketResponse.create = function create(properties) {
                return new DeleteTicketResponse(properties);
            };

            /**
             * Encodes the specified DeleteTicketResponse message. Does not implicitly {@link kritor.authentication.DeleteTicketResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.authentication.DeleteTicketResponse
             * @static
             * @param {kritor.authentication.IDeleteTicketResponse} message DeleteTicketResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteTicketResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.msg);
                return writer;
            };

            /**
             * Encodes the specified DeleteTicketResponse message, length delimited. Does not implicitly {@link kritor.authentication.DeleteTicketResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.authentication.DeleteTicketResponse
             * @static
             * @param {kritor.authentication.IDeleteTicketResponse} message DeleteTicketResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteTicketResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeleteTicketResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.authentication.DeleteTicketResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.authentication.DeleteTicketResponse} DeleteTicketResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteTicketResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.authentication.DeleteTicketResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.code = reader.int32();
                            break;
                        }
                    case 2: {
                            message.msg = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DeleteTicketResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.authentication.DeleteTicketResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.authentication.DeleteTicketResponse} DeleteTicketResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteTicketResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeleteTicketResponse message.
             * @function verify
             * @memberof kritor.authentication.DeleteTicketResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeleteTicketResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.code != null && message.hasOwnProperty("code"))
                    switch (message.code) {
                    default:
                        return "code: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                if (message.msg != null && message.hasOwnProperty("msg"))
                    if (!$util.isString(message.msg))
                        return "msg: string expected";
                return null;
            };

            /**
             * Creates a DeleteTicketResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.authentication.DeleteTicketResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.authentication.DeleteTicketResponse} DeleteTicketResponse
             */
            DeleteTicketResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.authentication.DeleteTicketResponse)
                    return object;
                let message = new $root.kritor.authentication.DeleteTicketResponse();
                switch (object.code) {
                default:
                    if (typeof object.code === "number") {
                        message.code = object.code;
                        break;
                    }
                    break;
                case "OK":
                case 0:
                    message.code = 0;
                    break;
                case "ERROR":
                case 1:
                    message.code = 1;
                    break;
                }
                if (object.msg != null)
                    message.msg = String(object.msg);
                return message;
            };

            /**
             * Creates a plain object from a DeleteTicketResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.authentication.DeleteTicketResponse
             * @static
             * @param {kritor.authentication.DeleteTicketResponse} message DeleteTicketResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeleteTicketResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.code = options.enums === String ? "OK" : 0;
                    object.msg = "";
                }
                if (message.code != null && message.hasOwnProperty("code"))
                    object.code = options.enums === String ? $root.kritor.authentication.TicketOperationResponseCode[message.code] === undefined ? message.code : $root.kritor.authentication.TicketOperationResponseCode[message.code] : message.code;
                if (message.msg != null && message.hasOwnProperty("msg"))
                    object.msg = message.msg;
                return object;
            };

            /**
             * Converts this DeleteTicketResponse to JSON.
             * @function toJSON
             * @memberof kritor.authentication.DeleteTicketResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeleteTicketResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DeleteTicketResponse
             * @function getTypeUrl
             * @memberof kritor.authentication.DeleteTicketResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DeleteTicketResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.authentication.DeleteTicketResponse";
            };

            return DeleteTicketResponse;
        })();

        return authentication;
    })();

    kritor.common = (function() {

        /**
         * Namespace common.
         * @memberof kritor
         * @namespace
         */
        const common = {};

        /**
         * Scene enum.
         * @name kritor.common.Scene
         * @enum {number}
         * @property {number} GROUP=0 GROUP value
         * @property {number} FRIEND=1 FRIEND value
         * @property {number} GUILD=2 GUILD value
         * @property {number} STRANGER_FROM_GROUP=10 STRANGER_FROM_GROUP value
         * @property {number} NEARBY=5 NEARBY value
         * @property {number} STRANGER=9 STRANGER value
         */
        common.Scene = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "GROUP"] = 0;
            values[valuesById[1] = "FRIEND"] = 1;
            values[valuesById[2] = "GUILD"] = 2;
            values[valuesById[10] = "STRANGER_FROM_GROUP"] = 10;
            values[valuesById[5] = "NEARBY"] = 5;
            values[valuesById[9] = "STRANGER"] = 9;
            return values;
        })();

        common.Contact = (function() {

            /**
             * Properties of a Contact.
             * @memberof kritor.common
             * @interface IContact
             * @property {kritor.common.Scene|null} [scene] Contact scene
             * @property {string|null} [peer] Contact peer
             * @property {string|null} [subPeer] Contact subPeer
             */

            /**
             * Constructs a new Contact.
             * @memberof kritor.common
             * @classdesc Represents a Contact.
             * @implements IContact
             * @constructor
             * @param {kritor.common.IContact=} [properties] Properties to set
             */
            function Contact(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Contact scene.
             * @member {kritor.common.Scene} scene
             * @memberof kritor.common.Contact
             * @instance
             */
            Contact.prototype.scene = 0;

            /**
             * Contact peer.
             * @member {string} peer
             * @memberof kritor.common.Contact
             * @instance
             */
            Contact.prototype.peer = "";

            /**
             * Contact subPeer.
             * @member {string|null|undefined} subPeer
             * @memberof kritor.common.Contact
             * @instance
             */
            Contact.prototype.subPeer = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * Contact _subPeer.
             * @member {"subPeer"|undefined} _subPeer
             * @memberof kritor.common.Contact
             * @instance
             */
            Object.defineProperty(Contact.prototype, "_subPeer", {
                get: $util.oneOfGetter($oneOfFields = ["subPeer"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new Contact instance using the specified properties.
             * @function create
             * @memberof kritor.common.Contact
             * @static
             * @param {kritor.common.IContact=} [properties] Properties to set
             * @returns {kritor.common.Contact} Contact instance
             */
            Contact.create = function create(properties) {
                return new Contact(properties);
            };

            /**
             * Encodes the specified Contact message. Does not implicitly {@link kritor.common.Contact.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.Contact
             * @static
             * @param {kritor.common.IContact} message Contact message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Contact.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.scene != null && Object.hasOwnProperty.call(message, "scene"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.scene);
                if (message.peer != null && Object.hasOwnProperty.call(message, "peer"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.peer);
                if (message.subPeer != null && Object.hasOwnProperty.call(message, "subPeer"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.subPeer);
                return writer;
            };

            /**
             * Encodes the specified Contact message, length delimited. Does not implicitly {@link kritor.common.Contact.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.Contact
             * @static
             * @param {kritor.common.IContact} message Contact message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Contact.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Contact message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.Contact
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.Contact} Contact
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Contact.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.Contact();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.scene = reader.int32();
                            break;
                        }
                    case 2: {
                            message.peer = reader.string();
                            break;
                        }
                    case 3: {
                            message.subPeer = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Contact message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.Contact
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.Contact} Contact
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Contact.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Contact message.
             * @function verify
             * @memberof kritor.common.Contact
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Contact.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.scene != null && message.hasOwnProperty("scene"))
                    switch (message.scene) {
                    default:
                        return "scene: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 10:
                    case 5:
                    case 9:
                        break;
                    }
                if (message.peer != null && message.hasOwnProperty("peer"))
                    if (!$util.isString(message.peer))
                        return "peer: string expected";
                if (message.subPeer != null && message.hasOwnProperty("subPeer")) {
                    properties._subPeer = 1;
                    if (!$util.isString(message.subPeer))
                        return "subPeer: string expected";
                }
                return null;
            };

            /**
             * Creates a Contact message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.Contact
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.Contact} Contact
             */
            Contact.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.Contact)
                    return object;
                let message = new $root.kritor.common.Contact();
                switch (object.scene) {
                default:
                    if (typeof object.scene === "number") {
                        message.scene = object.scene;
                        break;
                    }
                    break;
                case "GROUP":
                case 0:
                    message.scene = 0;
                    break;
                case "FRIEND":
                case 1:
                    message.scene = 1;
                    break;
                case "GUILD":
                case 2:
                    message.scene = 2;
                    break;
                case "STRANGER_FROM_GROUP":
                case 10:
                    message.scene = 10;
                    break;
                case "NEARBY":
                case 5:
                    message.scene = 5;
                    break;
                case "STRANGER":
                case 9:
                    message.scene = 9;
                    break;
                }
                if (object.peer != null)
                    message.peer = String(object.peer);
                if (object.subPeer != null)
                    message.subPeer = String(object.subPeer);
                return message;
            };

            /**
             * Creates a plain object from a Contact message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.Contact
             * @static
             * @param {kritor.common.Contact} message Contact
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Contact.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.scene = options.enums === String ? "GROUP" : 0;
                    object.peer = "";
                }
                if (message.scene != null && message.hasOwnProperty("scene"))
                    object.scene = options.enums === String ? $root.kritor.common.Scene[message.scene] === undefined ? message.scene : $root.kritor.common.Scene[message.scene] : message.scene;
                if (message.peer != null && message.hasOwnProperty("peer"))
                    object.peer = message.peer;
                if (message.subPeer != null && message.hasOwnProperty("subPeer")) {
                    object.subPeer = message.subPeer;
                    if (options.oneofs)
                        object._subPeer = "subPeer";
                }
                return object;
            };

            /**
             * Converts this Contact to JSON.
             * @function toJSON
             * @memberof kritor.common.Contact
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Contact.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Contact
             * @function getTypeUrl
             * @memberof kritor.common.Contact
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Contact.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.Contact";
            };

            return Contact;
        })();

        common.Sender = (function() {

            /**
             * Properties of a Sender.
             * @memberof kritor.common
             * @interface ISender
             * @property {string|null} [uid] Sender uid
             * @property {number|Long|null} [uin] Sender uin
             * @property {string|null} [nick] Sender nick
             */

            /**
             * Constructs a new Sender.
             * @memberof kritor.common
             * @classdesc Represents a Sender.
             * @implements ISender
             * @constructor
             * @param {kritor.common.ISender=} [properties] Properties to set
             */
            function Sender(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Sender uid.
             * @member {string} uid
             * @memberof kritor.common.Sender
             * @instance
             */
            Sender.prototype.uid = "";

            /**
             * Sender uin.
             * @member {number|Long|null|undefined} uin
             * @memberof kritor.common.Sender
             * @instance
             */
            Sender.prototype.uin = null;

            /**
             * Sender nick.
             * @member {string|null|undefined} nick
             * @memberof kritor.common.Sender
             * @instance
             */
            Sender.prototype.nick = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * Sender _uin.
             * @member {"uin"|undefined} _uin
             * @memberof kritor.common.Sender
             * @instance
             */
            Object.defineProperty(Sender.prototype, "_uin", {
                get: $util.oneOfGetter($oneOfFields = ["uin"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Sender _nick.
             * @member {"nick"|undefined} _nick
             * @memberof kritor.common.Sender
             * @instance
             */
            Object.defineProperty(Sender.prototype, "_nick", {
                get: $util.oneOfGetter($oneOfFields = ["nick"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new Sender instance using the specified properties.
             * @function create
             * @memberof kritor.common.Sender
             * @static
             * @param {kritor.common.ISender=} [properties] Properties to set
             * @returns {kritor.common.Sender} Sender instance
             */
            Sender.create = function create(properties) {
                return new Sender(properties);
            };

            /**
             * Encodes the specified Sender message. Does not implicitly {@link kritor.common.Sender.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.Sender
             * @static
             * @param {kritor.common.ISender} message Sender message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Sender.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.uid);
                if (message.uin != null && Object.hasOwnProperty.call(message, "uin"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.uin);
                if (message.nick != null && Object.hasOwnProperty.call(message, "nick"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.nick);
                return writer;
            };

            /**
             * Encodes the specified Sender message, length delimited. Does not implicitly {@link kritor.common.Sender.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.Sender
             * @static
             * @param {kritor.common.ISender} message Sender message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Sender.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Sender message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.Sender
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.Sender} Sender
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Sender.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.Sender();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.uid = reader.string();
                            break;
                        }
                    case 2: {
                            message.uin = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.nick = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Sender message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.Sender
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.Sender} Sender
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Sender.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Sender message.
             * @function verify
             * @memberof kritor.common.Sender
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Sender.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.uid != null && message.hasOwnProperty("uid"))
                    if (!$util.isString(message.uid))
                        return "uid: string expected";
                if (message.uin != null && message.hasOwnProperty("uin")) {
                    properties._uin = 1;
                    if (!$util.isInteger(message.uin) && !(message.uin && $util.isInteger(message.uin.low) && $util.isInteger(message.uin.high)))
                        return "uin: integer|Long expected";
                }
                if (message.nick != null && message.hasOwnProperty("nick")) {
                    properties._nick = 1;
                    if (!$util.isString(message.nick))
                        return "nick: string expected";
                }
                return null;
            };

            /**
             * Creates a Sender message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.Sender
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.Sender} Sender
             */
            Sender.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.Sender)
                    return object;
                let message = new $root.kritor.common.Sender();
                if (object.uid != null)
                    message.uid = String(object.uid);
                if (object.uin != null)
                    if ($util.Long)
                        (message.uin = $util.Long.fromValue(object.uin)).unsigned = true;
                    else if (typeof object.uin === "string")
                        message.uin = parseInt(object.uin, 10);
                    else if (typeof object.uin === "number")
                        message.uin = object.uin;
                    else if (typeof object.uin === "object")
                        message.uin = new $util.LongBits(object.uin.low >>> 0, object.uin.high >>> 0).toNumber(true);
                if (object.nick != null)
                    message.nick = String(object.nick);
                return message;
            };

            /**
             * Creates a plain object from a Sender message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.Sender
             * @static
             * @param {kritor.common.Sender} message Sender
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Sender.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.uid = "";
                if (message.uid != null && message.hasOwnProperty("uid"))
                    object.uid = message.uid;
                if (message.uin != null && message.hasOwnProperty("uin")) {
                    if (typeof message.uin === "number")
                        object.uin = options.longs === String ? String(message.uin) : message.uin;
                    else
                        object.uin = options.longs === String ? $util.Long.prototype.toString.call(message.uin) : options.longs === Number ? new $util.LongBits(message.uin.low >>> 0, message.uin.high >>> 0).toNumber(true) : message.uin;
                    if (options.oneofs)
                        object._uin = "uin";
                }
                if (message.nick != null && message.hasOwnProperty("nick")) {
                    object.nick = message.nick;
                    if (options.oneofs)
                        object._nick = "nick";
                }
                return object;
            };

            /**
             * Converts this Sender to JSON.
             * @function toJSON
             * @memberof kritor.common.Sender
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Sender.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Sender
             * @function getTypeUrl
             * @memberof kritor.common.Sender
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Sender.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.Sender";
            };

            return Sender;
        })();

        common.PushMessageBody = (function() {

            /**
             * Properties of a PushMessageBody.
             * @memberof kritor.common
             * @interface IPushMessageBody
             * @property {number|null} [time] PushMessageBody time
             * @property {string|null} [messageId] PushMessageBody messageId
             * @property {number|Long|null} [messageSeq] PushMessageBody messageSeq
             * @property {kritor.common.IContact|null} [contact] PushMessageBody contact
             * @property {kritor.common.ISender|null} [sender] PushMessageBody sender
             * @property {Array.<kritor.common.IElement>|null} [elements] PushMessageBody elements
             */

            /**
             * Constructs a new PushMessageBody.
             * @memberof kritor.common
             * @classdesc Represents a PushMessageBody.
             * @implements IPushMessageBody
             * @constructor
             * @param {kritor.common.IPushMessageBody=} [properties] Properties to set
             */
            function PushMessageBody(properties) {
                this.elements = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PushMessageBody time.
             * @member {number} time
             * @memberof kritor.common.PushMessageBody
             * @instance
             */
            PushMessageBody.prototype.time = 0;

            /**
             * PushMessageBody messageId.
             * @member {string} messageId
             * @memberof kritor.common.PushMessageBody
             * @instance
             */
            PushMessageBody.prototype.messageId = "";

            /**
             * PushMessageBody messageSeq.
             * @member {number|Long} messageSeq
             * @memberof kritor.common.PushMessageBody
             * @instance
             */
            PushMessageBody.prototype.messageSeq = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * PushMessageBody contact.
             * @member {kritor.common.IContact|null|undefined} contact
             * @memberof kritor.common.PushMessageBody
             * @instance
             */
            PushMessageBody.prototype.contact = null;

            /**
             * PushMessageBody sender.
             * @member {kritor.common.ISender|null|undefined} sender
             * @memberof kritor.common.PushMessageBody
             * @instance
             */
            PushMessageBody.prototype.sender = null;

            /**
             * PushMessageBody elements.
             * @member {Array.<kritor.common.IElement>} elements
             * @memberof kritor.common.PushMessageBody
             * @instance
             */
            PushMessageBody.prototype.elements = $util.emptyArray;

            /**
             * Creates a new PushMessageBody instance using the specified properties.
             * @function create
             * @memberof kritor.common.PushMessageBody
             * @static
             * @param {kritor.common.IPushMessageBody=} [properties] Properties to set
             * @returns {kritor.common.PushMessageBody} PushMessageBody instance
             */
            PushMessageBody.create = function create(properties) {
                return new PushMessageBody(properties);
            };

            /**
             * Encodes the specified PushMessageBody message. Does not implicitly {@link kritor.common.PushMessageBody.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.PushMessageBody
             * @static
             * @param {kritor.common.IPushMessageBody} message PushMessageBody message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PushMessageBody.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.time);
                if (message.messageId != null && Object.hasOwnProperty.call(message, "messageId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.messageId);
                if (message.messageSeq != null && Object.hasOwnProperty.call(message, "messageSeq"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.messageSeq);
                if (message.contact != null && Object.hasOwnProperty.call(message, "contact"))
                    $root.kritor.common.Contact.encode(message.contact, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.sender != null && Object.hasOwnProperty.call(message, "sender"))
                    $root.kritor.common.Sender.encode(message.sender, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.elements != null && message.elements.length)
                    for (let i = 0; i < message.elements.length; ++i)
                        $root.kritor.common.Element.encode(message.elements[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified PushMessageBody message, length delimited. Does not implicitly {@link kritor.common.PushMessageBody.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.PushMessageBody
             * @static
             * @param {kritor.common.IPushMessageBody} message PushMessageBody message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PushMessageBody.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PushMessageBody message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.PushMessageBody
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.PushMessageBody} PushMessageBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PushMessageBody.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.PushMessageBody();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.time = reader.uint32();
                            break;
                        }
                    case 2: {
                            message.messageId = reader.string();
                            break;
                        }
                    case 3: {
                            message.messageSeq = reader.uint64();
                            break;
                        }
                    case 4: {
                            message.contact = $root.kritor.common.Contact.decode(reader, reader.uint32());
                            break;
                        }
                    case 5: {
                            message.sender = $root.kritor.common.Sender.decode(reader, reader.uint32());
                            break;
                        }
                    case 6: {
                            if (!(message.elements && message.elements.length))
                                message.elements = [];
                            message.elements.push($root.kritor.common.Element.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PushMessageBody message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.PushMessageBody
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.PushMessageBody} PushMessageBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PushMessageBody.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PushMessageBody message.
             * @function verify
             * @memberof kritor.common.PushMessageBody
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PushMessageBody.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.time != null && message.hasOwnProperty("time"))
                    if (!$util.isInteger(message.time))
                        return "time: integer expected";
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    if (!$util.isString(message.messageId))
                        return "messageId: string expected";
                if (message.messageSeq != null && message.hasOwnProperty("messageSeq"))
                    if (!$util.isInteger(message.messageSeq) && !(message.messageSeq && $util.isInteger(message.messageSeq.low) && $util.isInteger(message.messageSeq.high)))
                        return "messageSeq: integer|Long expected";
                if (message.contact != null && message.hasOwnProperty("contact")) {
                    let error = $root.kritor.common.Contact.verify(message.contact);
                    if (error)
                        return "contact." + error;
                }
                if (message.sender != null && message.hasOwnProperty("sender")) {
                    let error = $root.kritor.common.Sender.verify(message.sender);
                    if (error)
                        return "sender." + error;
                }
                if (message.elements != null && message.hasOwnProperty("elements")) {
                    if (!Array.isArray(message.elements))
                        return "elements: array expected";
                    for (let i = 0; i < message.elements.length; ++i) {
                        let error = $root.kritor.common.Element.verify(message.elements[i]);
                        if (error)
                            return "elements." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a PushMessageBody message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.PushMessageBody
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.PushMessageBody} PushMessageBody
             */
            PushMessageBody.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.PushMessageBody)
                    return object;
                let message = new $root.kritor.common.PushMessageBody();
                if (object.time != null)
                    message.time = object.time >>> 0;
                if (object.messageId != null)
                    message.messageId = String(object.messageId);
                if (object.messageSeq != null)
                    if ($util.Long)
                        (message.messageSeq = $util.Long.fromValue(object.messageSeq)).unsigned = true;
                    else if (typeof object.messageSeq === "string")
                        message.messageSeq = parseInt(object.messageSeq, 10);
                    else if (typeof object.messageSeq === "number")
                        message.messageSeq = object.messageSeq;
                    else if (typeof object.messageSeq === "object")
                        message.messageSeq = new $util.LongBits(object.messageSeq.low >>> 0, object.messageSeq.high >>> 0).toNumber(true);
                if (object.contact != null) {
                    if (typeof object.contact !== "object")
                        throw TypeError(".kritor.common.PushMessageBody.contact: object expected");
                    message.contact = $root.kritor.common.Contact.fromObject(object.contact);
                }
                if (object.sender != null) {
                    if (typeof object.sender !== "object")
                        throw TypeError(".kritor.common.PushMessageBody.sender: object expected");
                    message.sender = $root.kritor.common.Sender.fromObject(object.sender);
                }
                if (object.elements) {
                    if (!Array.isArray(object.elements))
                        throw TypeError(".kritor.common.PushMessageBody.elements: array expected");
                    message.elements = [];
                    for (let i = 0; i < object.elements.length; ++i) {
                        if (typeof object.elements[i] !== "object")
                            throw TypeError(".kritor.common.PushMessageBody.elements: object expected");
                        message.elements[i] = $root.kritor.common.Element.fromObject(object.elements[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a PushMessageBody message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.PushMessageBody
             * @static
             * @param {kritor.common.PushMessageBody} message PushMessageBody
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PushMessageBody.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.elements = [];
                if (options.defaults) {
                    object.time = 0;
                    object.messageId = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.messageSeq = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.messageSeq = options.longs === String ? "0" : 0;
                    object.contact = null;
                    object.sender = null;
                }
                if (message.time != null && message.hasOwnProperty("time"))
                    object.time = message.time;
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    object.messageId = message.messageId;
                if (message.messageSeq != null && message.hasOwnProperty("messageSeq"))
                    if (typeof message.messageSeq === "number")
                        object.messageSeq = options.longs === String ? String(message.messageSeq) : message.messageSeq;
                    else
                        object.messageSeq = options.longs === String ? $util.Long.prototype.toString.call(message.messageSeq) : options.longs === Number ? new $util.LongBits(message.messageSeq.low >>> 0, message.messageSeq.high >>> 0).toNumber(true) : message.messageSeq;
                if (message.contact != null && message.hasOwnProperty("contact"))
                    object.contact = $root.kritor.common.Contact.toObject(message.contact, options);
                if (message.sender != null && message.hasOwnProperty("sender"))
                    object.sender = $root.kritor.common.Sender.toObject(message.sender, options);
                if (message.elements && message.elements.length) {
                    object.elements = [];
                    for (let j = 0; j < message.elements.length; ++j)
                        object.elements[j] = $root.kritor.common.Element.toObject(message.elements[j], options);
                }
                return object;
            };

            /**
             * Converts this PushMessageBody to JSON.
             * @function toJSON
             * @memberof kritor.common.PushMessageBody
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PushMessageBody.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for PushMessageBody
             * @function getTypeUrl
             * @memberof kritor.common.PushMessageBody
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            PushMessageBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.PushMessageBody";
            };

            return PushMessageBody;
        })();

        common.ForwardMessageBody = (function() {

            /**
             * Properties of a ForwardMessageBody.
             * @memberof kritor.common
             * @interface IForwardMessageBody
             * @property {string|null} [messageId] ForwardMessageBody messageId
             * @property {kritor.common.IPushMessageBody|null} [message] ForwardMessageBody message
             */

            /**
             * Constructs a new ForwardMessageBody.
             * @memberof kritor.common
             * @classdesc Represents a ForwardMessageBody.
             * @implements IForwardMessageBody
             * @constructor
             * @param {kritor.common.IForwardMessageBody=} [properties] Properties to set
             */
            function ForwardMessageBody(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ForwardMessageBody messageId.
             * @member {string|null|undefined} messageId
             * @memberof kritor.common.ForwardMessageBody
             * @instance
             */
            ForwardMessageBody.prototype.messageId = null;

            /**
             * ForwardMessageBody message.
             * @member {kritor.common.IPushMessageBody|null|undefined} message
             * @memberof kritor.common.ForwardMessageBody
             * @instance
             */
            ForwardMessageBody.prototype.message = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * ForwardMessageBody forwardMessage.
             * @member {"messageId"|"message"|undefined} forwardMessage
             * @memberof kritor.common.ForwardMessageBody
             * @instance
             */
            Object.defineProperty(ForwardMessageBody.prototype, "forwardMessage", {
                get: $util.oneOfGetter($oneOfFields = ["messageId", "message"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new ForwardMessageBody instance using the specified properties.
             * @function create
             * @memberof kritor.common.ForwardMessageBody
             * @static
             * @param {kritor.common.IForwardMessageBody=} [properties] Properties to set
             * @returns {kritor.common.ForwardMessageBody} ForwardMessageBody instance
             */
            ForwardMessageBody.create = function create(properties) {
                return new ForwardMessageBody(properties);
            };

            /**
             * Encodes the specified ForwardMessageBody message. Does not implicitly {@link kritor.common.ForwardMessageBody.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.ForwardMessageBody
             * @static
             * @param {kritor.common.IForwardMessageBody} message ForwardMessageBody message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ForwardMessageBody.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.messageId != null && Object.hasOwnProperty.call(message, "messageId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.messageId);
                if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                    $root.kritor.common.PushMessageBody.encode(message.message, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ForwardMessageBody message, length delimited. Does not implicitly {@link kritor.common.ForwardMessageBody.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.ForwardMessageBody
             * @static
             * @param {kritor.common.IForwardMessageBody} message ForwardMessageBody message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ForwardMessageBody.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ForwardMessageBody message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.ForwardMessageBody
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.ForwardMessageBody} ForwardMessageBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ForwardMessageBody.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.ForwardMessageBody();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.messageId = reader.string();
                            break;
                        }
                    case 2: {
                            message.message = $root.kritor.common.PushMessageBody.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ForwardMessageBody message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.ForwardMessageBody
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.ForwardMessageBody} ForwardMessageBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ForwardMessageBody.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ForwardMessageBody message.
             * @function verify
             * @memberof kritor.common.ForwardMessageBody
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ForwardMessageBody.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.messageId != null && message.hasOwnProperty("messageId")) {
                    properties.forwardMessage = 1;
                    if (!$util.isString(message.messageId))
                        return "messageId: string expected";
                }
                if (message.message != null && message.hasOwnProperty("message")) {
                    if (properties.forwardMessage === 1)
                        return "forwardMessage: multiple values";
                    properties.forwardMessage = 1;
                    {
                        let error = $root.kritor.common.PushMessageBody.verify(message.message);
                        if (error)
                            return "message." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a ForwardMessageBody message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.ForwardMessageBody
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.ForwardMessageBody} ForwardMessageBody
             */
            ForwardMessageBody.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.ForwardMessageBody)
                    return object;
                let message = new $root.kritor.common.ForwardMessageBody();
                if (object.messageId != null)
                    message.messageId = String(object.messageId);
                if (object.message != null) {
                    if (typeof object.message !== "object")
                        throw TypeError(".kritor.common.ForwardMessageBody.message: object expected");
                    message.message = $root.kritor.common.PushMessageBody.fromObject(object.message);
                }
                return message;
            };

            /**
             * Creates a plain object from a ForwardMessageBody message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.ForwardMessageBody
             * @static
             * @param {kritor.common.ForwardMessageBody} message ForwardMessageBody
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ForwardMessageBody.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (message.messageId != null && message.hasOwnProperty("messageId")) {
                    object.messageId = message.messageId;
                    if (options.oneofs)
                        object.forwardMessage = "messageId";
                }
                if (message.message != null && message.hasOwnProperty("message")) {
                    object.message = $root.kritor.common.PushMessageBody.toObject(message.message, options);
                    if (options.oneofs)
                        object.forwardMessage = "message";
                }
                return object;
            };

            /**
             * Converts this ForwardMessageBody to JSON.
             * @function toJSON
             * @memberof kritor.common.ForwardMessageBody
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ForwardMessageBody.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ForwardMessageBody
             * @function getTypeUrl
             * @memberof kritor.common.ForwardMessageBody
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ForwardMessageBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.ForwardMessageBody";
            };

            return ForwardMessageBody;
        })();

        common.EssenceMessageBody = (function() {

            /**
             * Properties of an EssenceMessageBody.
             * @memberof kritor.common
             * @interface IEssenceMessageBody
             * @property {number|null} [groupId] EssenceMessageBody groupId
             * @property {string|null} [senderUid] EssenceMessageBody senderUid
             * @property {number|Long|null} [senderUin] EssenceMessageBody senderUin
             * @property {string|null} [senderNick] EssenceMessageBody senderNick
             * @property {number|Long|null} [operatorUid] EssenceMessageBody operatorUid
             * @property {number|Long|null} [operatorUin] EssenceMessageBody operatorUin
             * @property {string|null} [operatorNick] EssenceMessageBody operatorNick
             * @property {number|null} [operationTime] EssenceMessageBody operationTime
             * @property {number|null} [messageTime] EssenceMessageBody messageTime
             * @property {string|null} [messageId] EssenceMessageBody messageId
             * @property {number|Long|null} [messageSeq] EssenceMessageBody messageSeq
             * @property {string|null} [jsonElements] EssenceMessageBody jsonElements
             */

            /**
             * Constructs a new EssenceMessageBody.
             * @memberof kritor.common
             * @classdesc Represents an EssenceMessageBody.
             * @implements IEssenceMessageBody
             * @constructor
             * @param {kritor.common.IEssenceMessageBody=} [properties] Properties to set
             */
            function EssenceMessageBody(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EssenceMessageBody groupId.
             * @member {number} groupId
             * @memberof kritor.common.EssenceMessageBody
             * @instance
             */
            EssenceMessageBody.prototype.groupId = 0;

            /**
             * EssenceMessageBody senderUid.
             * @member {string} senderUid
             * @memberof kritor.common.EssenceMessageBody
             * @instance
             */
            EssenceMessageBody.prototype.senderUid = "";

            /**
             * EssenceMessageBody senderUin.
             * @member {number|Long} senderUin
             * @memberof kritor.common.EssenceMessageBody
             * @instance
             */
            EssenceMessageBody.prototype.senderUin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * EssenceMessageBody senderNick.
             * @member {string} senderNick
             * @memberof kritor.common.EssenceMessageBody
             * @instance
             */
            EssenceMessageBody.prototype.senderNick = "";

            /**
             * EssenceMessageBody operatorUid.
             * @member {number|Long} operatorUid
             * @memberof kritor.common.EssenceMessageBody
             * @instance
             */
            EssenceMessageBody.prototype.operatorUid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * EssenceMessageBody operatorUin.
             * @member {number|Long} operatorUin
             * @memberof kritor.common.EssenceMessageBody
             * @instance
             */
            EssenceMessageBody.prototype.operatorUin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * EssenceMessageBody operatorNick.
             * @member {string} operatorNick
             * @memberof kritor.common.EssenceMessageBody
             * @instance
             */
            EssenceMessageBody.prototype.operatorNick = "";

            /**
             * EssenceMessageBody operationTime.
             * @member {number} operationTime
             * @memberof kritor.common.EssenceMessageBody
             * @instance
             */
            EssenceMessageBody.prototype.operationTime = 0;

            /**
             * EssenceMessageBody messageTime.
             * @member {number} messageTime
             * @memberof kritor.common.EssenceMessageBody
             * @instance
             */
            EssenceMessageBody.prototype.messageTime = 0;

            /**
             * EssenceMessageBody messageId.
             * @member {string} messageId
             * @memberof kritor.common.EssenceMessageBody
             * @instance
             */
            EssenceMessageBody.prototype.messageId = "";

            /**
             * EssenceMessageBody messageSeq.
             * @member {number|Long} messageSeq
             * @memberof kritor.common.EssenceMessageBody
             * @instance
             */
            EssenceMessageBody.prototype.messageSeq = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * EssenceMessageBody jsonElements.
             * @member {string} jsonElements
             * @memberof kritor.common.EssenceMessageBody
             * @instance
             */
            EssenceMessageBody.prototype.jsonElements = "";

            /**
             * Creates a new EssenceMessageBody instance using the specified properties.
             * @function create
             * @memberof kritor.common.EssenceMessageBody
             * @static
             * @param {kritor.common.IEssenceMessageBody=} [properties] Properties to set
             * @returns {kritor.common.EssenceMessageBody} EssenceMessageBody instance
             */
            EssenceMessageBody.create = function create(properties) {
                return new EssenceMessageBody(properties);
            };

            /**
             * Encodes the specified EssenceMessageBody message. Does not implicitly {@link kritor.common.EssenceMessageBody.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.EssenceMessageBody
             * @static
             * @param {kritor.common.IEssenceMessageBody} message EssenceMessageBody message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EssenceMessageBody.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.groupId);
                if (message.senderUid != null && Object.hasOwnProperty.call(message, "senderUid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.senderUid);
                if (message.senderUin != null && Object.hasOwnProperty.call(message, "senderUin"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.senderUin);
                if (message.senderNick != null && Object.hasOwnProperty.call(message, "senderNick"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.senderNick);
                if (message.operatorUid != null && Object.hasOwnProperty.call(message, "operatorUid"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.operatorUid);
                if (message.operatorUin != null && Object.hasOwnProperty.call(message, "operatorUin"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.operatorUin);
                if (message.operatorNick != null && Object.hasOwnProperty.call(message, "operatorNick"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.operatorNick);
                if (message.operationTime != null && Object.hasOwnProperty.call(message, "operationTime"))
                    writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.operationTime);
                if (message.messageTime != null && Object.hasOwnProperty.call(message, "messageTime"))
                    writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.messageTime);
                if (message.messageId != null && Object.hasOwnProperty.call(message, "messageId"))
                    writer.uint32(/* id 10, wireType 2 =*/82).string(message.messageId);
                if (message.messageSeq != null && Object.hasOwnProperty.call(message, "messageSeq"))
                    writer.uint32(/* id 11, wireType 0 =*/88).uint64(message.messageSeq);
                if (message.jsonElements != null && Object.hasOwnProperty.call(message, "jsonElements"))
                    writer.uint32(/* id 12, wireType 2 =*/98).string(message.jsonElements);
                return writer;
            };

            /**
             * Encodes the specified EssenceMessageBody message, length delimited. Does not implicitly {@link kritor.common.EssenceMessageBody.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.EssenceMessageBody
             * @static
             * @param {kritor.common.IEssenceMessageBody} message EssenceMessageBody message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EssenceMessageBody.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EssenceMessageBody message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.EssenceMessageBody
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.EssenceMessageBody} EssenceMessageBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EssenceMessageBody.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.EssenceMessageBody();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint32();
                            break;
                        }
                    case 2: {
                            message.senderUid = reader.string();
                            break;
                        }
                    case 3: {
                            message.senderUin = reader.uint64();
                            break;
                        }
                    case 4: {
                            message.senderNick = reader.string();
                            break;
                        }
                    case 5: {
                            message.operatorUid = reader.uint64();
                            break;
                        }
                    case 6: {
                            message.operatorUin = reader.uint64();
                            break;
                        }
                    case 7: {
                            message.operatorNick = reader.string();
                            break;
                        }
                    case 8: {
                            message.operationTime = reader.uint32();
                            break;
                        }
                    case 9: {
                            message.messageTime = reader.uint32();
                            break;
                        }
                    case 10: {
                            message.messageId = reader.string();
                            break;
                        }
                    case 11: {
                            message.messageSeq = reader.uint64();
                            break;
                        }
                    case 12: {
                            message.jsonElements = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EssenceMessageBody message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.EssenceMessageBody
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.EssenceMessageBody} EssenceMessageBody
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EssenceMessageBody.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EssenceMessageBody message.
             * @function verify
             * @memberof kritor.common.EssenceMessageBody
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EssenceMessageBody.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId))
                        return "groupId: integer expected";
                if (message.senderUid != null && message.hasOwnProperty("senderUid"))
                    if (!$util.isString(message.senderUid))
                        return "senderUid: string expected";
                if (message.senderUin != null && message.hasOwnProperty("senderUin"))
                    if (!$util.isInteger(message.senderUin) && !(message.senderUin && $util.isInteger(message.senderUin.low) && $util.isInteger(message.senderUin.high)))
                        return "senderUin: integer|Long expected";
                if (message.senderNick != null && message.hasOwnProperty("senderNick"))
                    if (!$util.isString(message.senderNick))
                        return "senderNick: string expected";
                if (message.operatorUid != null && message.hasOwnProperty("operatorUid"))
                    if (!$util.isInteger(message.operatorUid) && !(message.operatorUid && $util.isInteger(message.operatorUid.low) && $util.isInteger(message.operatorUid.high)))
                        return "operatorUid: integer|Long expected";
                if (message.operatorUin != null && message.hasOwnProperty("operatorUin"))
                    if (!$util.isInteger(message.operatorUin) && !(message.operatorUin && $util.isInteger(message.operatorUin.low) && $util.isInteger(message.operatorUin.high)))
                        return "operatorUin: integer|Long expected";
                if (message.operatorNick != null && message.hasOwnProperty("operatorNick"))
                    if (!$util.isString(message.operatorNick))
                        return "operatorNick: string expected";
                if (message.operationTime != null && message.hasOwnProperty("operationTime"))
                    if (!$util.isInteger(message.operationTime))
                        return "operationTime: integer expected";
                if (message.messageTime != null && message.hasOwnProperty("messageTime"))
                    if (!$util.isInteger(message.messageTime))
                        return "messageTime: integer expected";
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    if (!$util.isString(message.messageId))
                        return "messageId: string expected";
                if (message.messageSeq != null && message.hasOwnProperty("messageSeq"))
                    if (!$util.isInteger(message.messageSeq) && !(message.messageSeq && $util.isInteger(message.messageSeq.low) && $util.isInteger(message.messageSeq.high)))
                        return "messageSeq: integer|Long expected";
                if (message.jsonElements != null && message.hasOwnProperty("jsonElements"))
                    if (!$util.isString(message.jsonElements))
                        return "jsonElements: string expected";
                return null;
            };

            /**
             * Creates an EssenceMessageBody message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.EssenceMessageBody
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.EssenceMessageBody} EssenceMessageBody
             */
            EssenceMessageBody.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.EssenceMessageBody)
                    return object;
                let message = new $root.kritor.common.EssenceMessageBody();
                if (object.groupId != null)
                    message.groupId = object.groupId >>> 0;
                if (object.senderUid != null)
                    message.senderUid = String(object.senderUid);
                if (object.senderUin != null)
                    if ($util.Long)
                        (message.senderUin = $util.Long.fromValue(object.senderUin)).unsigned = true;
                    else if (typeof object.senderUin === "string")
                        message.senderUin = parseInt(object.senderUin, 10);
                    else if (typeof object.senderUin === "number")
                        message.senderUin = object.senderUin;
                    else if (typeof object.senderUin === "object")
                        message.senderUin = new $util.LongBits(object.senderUin.low >>> 0, object.senderUin.high >>> 0).toNumber(true);
                if (object.senderNick != null)
                    message.senderNick = String(object.senderNick);
                if (object.operatorUid != null)
                    if ($util.Long)
                        (message.operatorUid = $util.Long.fromValue(object.operatorUid)).unsigned = true;
                    else if (typeof object.operatorUid === "string")
                        message.operatorUid = parseInt(object.operatorUid, 10);
                    else if (typeof object.operatorUid === "number")
                        message.operatorUid = object.operatorUid;
                    else if (typeof object.operatorUid === "object")
                        message.operatorUid = new $util.LongBits(object.operatorUid.low >>> 0, object.operatorUid.high >>> 0).toNumber(true);
                if (object.operatorUin != null)
                    if ($util.Long)
                        (message.operatorUin = $util.Long.fromValue(object.operatorUin)).unsigned = true;
                    else if (typeof object.operatorUin === "string")
                        message.operatorUin = parseInt(object.operatorUin, 10);
                    else if (typeof object.operatorUin === "number")
                        message.operatorUin = object.operatorUin;
                    else if (typeof object.operatorUin === "object")
                        message.operatorUin = new $util.LongBits(object.operatorUin.low >>> 0, object.operatorUin.high >>> 0).toNumber(true);
                if (object.operatorNick != null)
                    message.operatorNick = String(object.operatorNick);
                if (object.operationTime != null)
                    message.operationTime = object.operationTime >>> 0;
                if (object.messageTime != null)
                    message.messageTime = object.messageTime >>> 0;
                if (object.messageId != null)
                    message.messageId = String(object.messageId);
                if (object.messageSeq != null)
                    if ($util.Long)
                        (message.messageSeq = $util.Long.fromValue(object.messageSeq)).unsigned = true;
                    else if (typeof object.messageSeq === "string")
                        message.messageSeq = parseInt(object.messageSeq, 10);
                    else if (typeof object.messageSeq === "number")
                        message.messageSeq = object.messageSeq;
                    else if (typeof object.messageSeq === "object")
                        message.messageSeq = new $util.LongBits(object.messageSeq.low >>> 0, object.messageSeq.high >>> 0).toNumber(true);
                if (object.jsonElements != null)
                    message.jsonElements = String(object.jsonElements);
                return message;
            };

            /**
             * Creates a plain object from an EssenceMessageBody message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.EssenceMessageBody
             * @static
             * @param {kritor.common.EssenceMessageBody} message EssenceMessageBody
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EssenceMessageBody.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.groupId = 0;
                    object.senderUid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.senderUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.senderUin = options.longs === String ? "0" : 0;
                    object.senderNick = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.operatorUid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.operatorUid = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.operatorUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.operatorUin = options.longs === String ? "0" : 0;
                    object.operatorNick = "";
                    object.operationTime = 0;
                    object.messageTime = 0;
                    object.messageId = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.messageSeq = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.messageSeq = options.longs === String ? "0" : 0;
                    object.jsonElements = "";
                }
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    object.groupId = message.groupId;
                if (message.senderUid != null && message.hasOwnProperty("senderUid"))
                    object.senderUid = message.senderUid;
                if (message.senderUin != null && message.hasOwnProperty("senderUin"))
                    if (typeof message.senderUin === "number")
                        object.senderUin = options.longs === String ? String(message.senderUin) : message.senderUin;
                    else
                        object.senderUin = options.longs === String ? $util.Long.prototype.toString.call(message.senderUin) : options.longs === Number ? new $util.LongBits(message.senderUin.low >>> 0, message.senderUin.high >>> 0).toNumber(true) : message.senderUin;
                if (message.senderNick != null && message.hasOwnProperty("senderNick"))
                    object.senderNick = message.senderNick;
                if (message.operatorUid != null && message.hasOwnProperty("operatorUid"))
                    if (typeof message.operatorUid === "number")
                        object.operatorUid = options.longs === String ? String(message.operatorUid) : message.operatorUid;
                    else
                        object.operatorUid = options.longs === String ? $util.Long.prototype.toString.call(message.operatorUid) : options.longs === Number ? new $util.LongBits(message.operatorUid.low >>> 0, message.operatorUid.high >>> 0).toNumber(true) : message.operatorUid;
                if (message.operatorUin != null && message.hasOwnProperty("operatorUin"))
                    if (typeof message.operatorUin === "number")
                        object.operatorUin = options.longs === String ? String(message.operatorUin) : message.operatorUin;
                    else
                        object.operatorUin = options.longs === String ? $util.Long.prototype.toString.call(message.operatorUin) : options.longs === Number ? new $util.LongBits(message.operatorUin.low >>> 0, message.operatorUin.high >>> 0).toNumber(true) : message.operatorUin;
                if (message.operatorNick != null && message.hasOwnProperty("operatorNick"))
                    object.operatorNick = message.operatorNick;
                if (message.operationTime != null && message.hasOwnProperty("operationTime"))
                    object.operationTime = message.operationTime;
                if (message.messageTime != null && message.hasOwnProperty("messageTime"))
                    object.messageTime = message.messageTime;
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    object.messageId = message.messageId;
                if (message.messageSeq != null && message.hasOwnProperty("messageSeq"))
                    if (typeof message.messageSeq === "number")
                        object.messageSeq = options.longs === String ? String(message.messageSeq) : message.messageSeq;
                    else
                        object.messageSeq = options.longs === String ? $util.Long.prototype.toString.call(message.messageSeq) : options.longs === Number ? new $util.LongBits(message.messageSeq.low >>> 0, message.messageSeq.high >>> 0).toNumber(true) : message.messageSeq;
                if (message.jsonElements != null && message.hasOwnProperty("jsonElements"))
                    object.jsonElements = message.jsonElements;
                return object;
            };

            /**
             * Converts this EssenceMessageBody to JSON.
             * @function toJSON
             * @memberof kritor.common.EssenceMessageBody
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EssenceMessageBody.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for EssenceMessageBody
             * @function getTypeUrl
             * @memberof kritor.common.EssenceMessageBody
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            EssenceMessageBody.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.EssenceMessageBody";
            };

            return EssenceMessageBody;
        })();

        common.Element = (function() {

            /**
             * Properties of an Element.
             * @memberof kritor.common
             * @interface IElement
             * @property {kritor.common.Element.ElementType|null} [type] Element type
             * @property {kritor.common.ITextElement|null} [text] Element text
             * @property {kritor.common.IAtElement|null} [at] Element at
             * @property {kritor.common.IFaceElement|null} [face] Element face
             * @property {kritor.common.IBubbleFaceElement|null} [bubbleFace] Element bubbleFace
             * @property {kritor.common.IReplyElement|null} [reply] Element reply
             * @property {kritor.common.IImageElement|null} [image] Element image
             * @property {kritor.common.IVoiceElement|null} [voice] Element voice
             * @property {kritor.common.IVideoElement|null} [video] Element video
             * @property {kritor.common.IBasketballElement|null} [basketball] Element basketball
             * @property {kritor.common.IDiceElement|null} [dice] Element dice
             * @property {kritor.common.IRpsElement|null} [rps] Element rps
             * @property {kritor.common.IPokeElement|null} [poke] Element poke
             * @property {kritor.common.IMusicElement|null} [music] Element music
             * @property {kritor.common.IWeatherElement|null} [weather] Element weather
             * @property {kritor.common.ILocationElement|null} [location] Element location
             * @property {kritor.common.IShareElement|null} [share] Element share
             * @property {kritor.common.IGiftElement|null} [gift] Element gift
             * @property {kritor.common.IMarketFaceElement|null} [marketFace] Element marketFace
             * @property {kritor.common.IForwardElement|null} [forward] Element forward
             * @property {kritor.common.IContactElement|null} [contact] Element contact
             * @property {kritor.common.IJsonElement|null} [json] Element json
             * @property {kritor.common.IXmlElement|null} [xml] Element xml
             * @property {kritor.common.IFileElement|null} [file] Element file
             * @property {kritor.common.IMarkdownElement|null} [markdown] Element markdown
             * @property {kritor.common.IKeyboardElement|null} [keyboard] Element keyboard
             */

            /**
             * Constructs a new Element.
             * @memberof kritor.common
             * @classdesc Represents an Element.
             * @implements IElement
             * @constructor
             * @param {kritor.common.IElement=} [properties] Properties to set
             */
            function Element(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Element type.
             * @member {kritor.common.Element.ElementType} type
             * @memberof kritor.common.Element
             * @instance
             */
            Element.prototype.type = 0;

            /**
             * Element text.
             * @member {kritor.common.ITextElement|null|undefined} text
             * @memberof kritor.common.Element
             * @instance
             */
            Element.prototype.text = null;

            /**
             * Element at.
             * @member {kritor.common.IAtElement|null|undefined} at
             * @memberof kritor.common.Element
             * @instance
             */
            Element.prototype.at = null;

            /**
             * Element face.
             * @member {kritor.common.IFaceElement|null|undefined} face
             * @memberof kritor.common.Element
             * @instance
             */
            Element.prototype.face = null;

            /**
             * Element bubbleFace.
             * @member {kritor.common.IBubbleFaceElement|null|undefined} bubbleFace
             * @memberof kritor.common.Element
             * @instance
             */
            Element.prototype.bubbleFace = null;

            /**
             * Element reply.
             * @member {kritor.common.IReplyElement|null|undefined} reply
             * @memberof kritor.common.Element
             * @instance
             */
            Element.prototype.reply = null;

            /**
             * Element image.
             * @member {kritor.common.IImageElement|null|undefined} image
             * @memberof kritor.common.Element
             * @instance
             */
            Element.prototype.image = null;

            /**
             * Element voice.
             * @member {kritor.common.IVoiceElement|null|undefined} voice
             * @memberof kritor.common.Element
             * @instance
             */
            Element.prototype.voice = null;

            /**
             * Element video.
             * @member {kritor.common.IVideoElement|null|undefined} video
             * @memberof kritor.common.Element
             * @instance
             */
            Element.prototype.video = null;

            /**
             * Element basketball.
             * @member {kritor.common.IBasketballElement|null|undefined} basketball
             * @memberof kritor.common.Element
             * @instance
             */
            Element.prototype.basketball = null;

            /**
             * Element dice.
             * @member {kritor.common.IDiceElement|null|undefined} dice
             * @memberof kritor.common.Element
             * @instance
             */
            Element.prototype.dice = null;

            /**
             * Element rps.
             * @member {kritor.common.IRpsElement|null|undefined} rps
             * @memberof kritor.common.Element
             * @instance
             */
            Element.prototype.rps = null;

            /**
             * Element poke.
             * @member {kritor.common.IPokeElement|null|undefined} poke
             * @memberof kritor.common.Element
             * @instance
             */
            Element.prototype.poke = null;

            /**
             * Element music.
             * @member {kritor.common.IMusicElement|null|undefined} music
             * @memberof kritor.common.Element
             * @instance
             */
            Element.prototype.music = null;

            /**
             * Element weather.
             * @member {kritor.common.IWeatherElement|null|undefined} weather
             * @memberof kritor.common.Element
             * @instance
             */
            Element.prototype.weather = null;

            /**
             * Element location.
             * @member {kritor.common.ILocationElement|null|undefined} location
             * @memberof kritor.common.Element
             * @instance
             */
            Element.prototype.location = null;

            /**
             * Element share.
             * @member {kritor.common.IShareElement|null|undefined} share
             * @memberof kritor.common.Element
             * @instance
             */
            Element.prototype.share = null;

            /**
             * Element gift.
             * @member {kritor.common.IGiftElement|null|undefined} gift
             * @memberof kritor.common.Element
             * @instance
             */
            Element.prototype.gift = null;

            /**
             * Element marketFace.
             * @member {kritor.common.IMarketFaceElement|null|undefined} marketFace
             * @memberof kritor.common.Element
             * @instance
             */
            Element.prototype.marketFace = null;

            /**
             * Element forward.
             * @member {kritor.common.IForwardElement|null|undefined} forward
             * @memberof kritor.common.Element
             * @instance
             */
            Element.prototype.forward = null;

            /**
             * Element contact.
             * @member {kritor.common.IContactElement|null|undefined} contact
             * @memberof kritor.common.Element
             * @instance
             */
            Element.prototype.contact = null;

            /**
             * Element json.
             * @member {kritor.common.IJsonElement|null|undefined} json
             * @memberof kritor.common.Element
             * @instance
             */
            Element.prototype.json = null;

            /**
             * Element xml.
             * @member {kritor.common.IXmlElement|null|undefined} xml
             * @memberof kritor.common.Element
             * @instance
             */
            Element.prototype.xml = null;

            /**
             * Element file.
             * @member {kritor.common.IFileElement|null|undefined} file
             * @memberof kritor.common.Element
             * @instance
             */
            Element.prototype.file = null;

            /**
             * Element markdown.
             * @member {kritor.common.IMarkdownElement|null|undefined} markdown
             * @memberof kritor.common.Element
             * @instance
             */
            Element.prototype.markdown = null;

            /**
             * Element keyboard.
             * @member {kritor.common.IKeyboardElement|null|undefined} keyboard
             * @memberof kritor.common.Element
             * @instance
             */
            Element.prototype.keyboard = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * Element data.
             * @member {"text"|"at"|"face"|"bubbleFace"|"reply"|"image"|"voice"|"video"|"basketball"|"dice"|"rps"|"poke"|"music"|"weather"|"location"|"share"|"gift"|"marketFace"|"forward"|"contact"|"json"|"xml"|"file"|"markdown"|"keyboard"|undefined} data
             * @memberof kritor.common.Element
             * @instance
             */
            Object.defineProperty(Element.prototype, "data", {
                get: $util.oneOfGetter($oneOfFields = ["text", "at", "face", "bubbleFace", "reply", "image", "voice", "video", "basketball", "dice", "rps", "poke", "music", "weather", "location", "share", "gift", "marketFace", "forward", "contact", "json", "xml", "file", "markdown", "keyboard"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new Element instance using the specified properties.
             * @function create
             * @memberof kritor.common.Element
             * @static
             * @param {kritor.common.IElement=} [properties] Properties to set
             * @returns {kritor.common.Element} Element instance
             */
            Element.create = function create(properties) {
                return new Element(properties);
            };

            /**
             * Encodes the specified Element message. Does not implicitly {@link kritor.common.Element.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.Element
             * @static
             * @param {kritor.common.IElement} message Element message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Element.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                    $root.kritor.common.TextElement.encode(message.text, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.at != null && Object.hasOwnProperty.call(message, "at"))
                    $root.kritor.common.AtElement.encode(message.at, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.face != null && Object.hasOwnProperty.call(message, "face"))
                    $root.kritor.common.FaceElement.encode(message.face, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.bubbleFace != null && Object.hasOwnProperty.call(message, "bubbleFace"))
                    $root.kritor.common.BubbleFaceElement.encode(message.bubbleFace, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.reply != null && Object.hasOwnProperty.call(message, "reply"))
                    $root.kritor.common.ReplyElement.encode(message.reply, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.image != null && Object.hasOwnProperty.call(message, "image"))
                    $root.kritor.common.ImageElement.encode(message.image, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.voice != null && Object.hasOwnProperty.call(message, "voice"))
                    $root.kritor.common.VoiceElement.encode(message.voice, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.video != null && Object.hasOwnProperty.call(message, "video"))
                    $root.kritor.common.VideoElement.encode(message.video, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.basketball != null && Object.hasOwnProperty.call(message, "basketball"))
                    $root.kritor.common.BasketballElement.encode(message.basketball, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                if (message.dice != null && Object.hasOwnProperty.call(message, "dice"))
                    $root.kritor.common.DiceElement.encode(message.dice, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                if (message.rps != null && Object.hasOwnProperty.call(message, "rps"))
                    $root.kritor.common.RpsElement.encode(message.rps, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                if (message.poke != null && Object.hasOwnProperty.call(message, "poke"))
                    $root.kritor.common.PokeElement.encode(message.poke, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
                if (message.music != null && Object.hasOwnProperty.call(message, "music"))
                    $root.kritor.common.MusicElement.encode(message.music, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
                if (message.weather != null && Object.hasOwnProperty.call(message, "weather"))
                    $root.kritor.common.WeatherElement.encode(message.weather, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
                if (message.location != null && Object.hasOwnProperty.call(message, "location"))
                    $root.kritor.common.LocationElement.encode(message.location, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
                if (message.share != null && Object.hasOwnProperty.call(message, "share"))
                    $root.kritor.common.ShareElement.encode(message.share, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
                if (message.gift != null && Object.hasOwnProperty.call(message, "gift"))
                    $root.kritor.common.GiftElement.encode(message.gift, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
                if (message.marketFace != null && Object.hasOwnProperty.call(message, "marketFace"))
                    $root.kritor.common.MarketFaceElement.encode(message.marketFace, writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
                if (message.forward != null && Object.hasOwnProperty.call(message, "forward"))
                    $root.kritor.common.ForwardElement.encode(message.forward, writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
                if (message.contact != null && Object.hasOwnProperty.call(message, "contact"))
                    $root.kritor.common.ContactElement.encode(message.contact, writer.uint32(/* id 21, wireType 2 =*/170).fork()).ldelim();
                if (message.json != null && Object.hasOwnProperty.call(message, "json"))
                    $root.kritor.common.JsonElement.encode(message.json, writer.uint32(/* id 22, wireType 2 =*/178).fork()).ldelim();
                if (message.xml != null && Object.hasOwnProperty.call(message, "xml"))
                    $root.kritor.common.XmlElement.encode(message.xml, writer.uint32(/* id 23, wireType 2 =*/186).fork()).ldelim();
                if (message.file != null && Object.hasOwnProperty.call(message, "file"))
                    $root.kritor.common.FileElement.encode(message.file, writer.uint32(/* id 24, wireType 2 =*/194).fork()).ldelim();
                if (message.markdown != null && Object.hasOwnProperty.call(message, "markdown"))
                    $root.kritor.common.MarkdownElement.encode(message.markdown, writer.uint32(/* id 25, wireType 2 =*/202).fork()).ldelim();
                if (message.keyboard != null && Object.hasOwnProperty.call(message, "keyboard"))
                    $root.kritor.common.KeyboardElement.encode(message.keyboard, writer.uint32(/* id 26, wireType 2 =*/210).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Element message, length delimited. Does not implicitly {@link kritor.common.Element.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.Element
             * @static
             * @param {kritor.common.IElement} message Element message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Element.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Element message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.Element
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.Element} Element
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Element.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.Element();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.type = reader.int32();
                            break;
                        }
                    case 2: {
                            message.text = $root.kritor.common.TextElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 3: {
                            message.at = $root.kritor.common.AtElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 4: {
                            message.face = $root.kritor.common.FaceElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 5: {
                            message.bubbleFace = $root.kritor.common.BubbleFaceElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 6: {
                            message.reply = $root.kritor.common.ReplyElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 7: {
                            message.image = $root.kritor.common.ImageElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 8: {
                            message.voice = $root.kritor.common.VoiceElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 9: {
                            message.video = $root.kritor.common.VideoElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 10: {
                            message.basketball = $root.kritor.common.BasketballElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 11: {
                            message.dice = $root.kritor.common.DiceElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 12: {
                            message.rps = $root.kritor.common.RpsElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 13: {
                            message.poke = $root.kritor.common.PokeElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 14: {
                            message.music = $root.kritor.common.MusicElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 15: {
                            message.weather = $root.kritor.common.WeatherElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 16: {
                            message.location = $root.kritor.common.LocationElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 17: {
                            message.share = $root.kritor.common.ShareElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 18: {
                            message.gift = $root.kritor.common.GiftElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 19: {
                            message.marketFace = $root.kritor.common.MarketFaceElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 20: {
                            message.forward = $root.kritor.common.ForwardElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 21: {
                            message.contact = $root.kritor.common.ContactElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 22: {
                            message.json = $root.kritor.common.JsonElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 23: {
                            message.xml = $root.kritor.common.XmlElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 24: {
                            message.file = $root.kritor.common.FileElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 25: {
                            message.markdown = $root.kritor.common.MarkdownElement.decode(reader, reader.uint32());
                            break;
                        }
                    case 26: {
                            message.keyboard = $root.kritor.common.KeyboardElement.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Element message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.Element
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.Element} Element
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Element.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Element message.
             * @function verify
             * @memberof kritor.common.Element
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Element.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                    case 16:
                    case 17:
                    case 18:
                    case 19:
                    case 20:
                    case 21:
                    case 22:
                    case 23:
                    case 24:
                        break;
                    }
                if (message.text != null && message.hasOwnProperty("text")) {
                    properties.data = 1;
                    {
                        let error = $root.kritor.common.TextElement.verify(message.text);
                        if (error)
                            return "text." + error;
                    }
                }
                if (message.at != null && message.hasOwnProperty("at")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.common.AtElement.verify(message.at);
                        if (error)
                            return "at." + error;
                    }
                }
                if (message.face != null && message.hasOwnProperty("face")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.common.FaceElement.verify(message.face);
                        if (error)
                            return "face." + error;
                    }
                }
                if (message.bubbleFace != null && message.hasOwnProperty("bubbleFace")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.common.BubbleFaceElement.verify(message.bubbleFace);
                        if (error)
                            return "bubbleFace." + error;
                    }
                }
                if (message.reply != null && message.hasOwnProperty("reply")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.common.ReplyElement.verify(message.reply);
                        if (error)
                            return "reply." + error;
                    }
                }
                if (message.image != null && message.hasOwnProperty("image")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.common.ImageElement.verify(message.image);
                        if (error)
                            return "image." + error;
                    }
                }
                if (message.voice != null && message.hasOwnProperty("voice")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.common.VoiceElement.verify(message.voice);
                        if (error)
                            return "voice." + error;
                    }
                }
                if (message.video != null && message.hasOwnProperty("video")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.common.VideoElement.verify(message.video);
                        if (error)
                            return "video." + error;
                    }
                }
                if (message.basketball != null && message.hasOwnProperty("basketball")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.common.BasketballElement.verify(message.basketball);
                        if (error)
                            return "basketball." + error;
                    }
                }
                if (message.dice != null && message.hasOwnProperty("dice")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.common.DiceElement.verify(message.dice);
                        if (error)
                            return "dice." + error;
                    }
                }
                if (message.rps != null && message.hasOwnProperty("rps")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.common.RpsElement.verify(message.rps);
                        if (error)
                            return "rps." + error;
                    }
                }
                if (message.poke != null && message.hasOwnProperty("poke")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.common.PokeElement.verify(message.poke);
                        if (error)
                            return "poke." + error;
                    }
                }
                if (message.music != null && message.hasOwnProperty("music")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.common.MusicElement.verify(message.music);
                        if (error)
                            return "music." + error;
                    }
                }
                if (message.weather != null && message.hasOwnProperty("weather")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.common.WeatherElement.verify(message.weather);
                        if (error)
                            return "weather." + error;
                    }
                }
                if (message.location != null && message.hasOwnProperty("location")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.common.LocationElement.verify(message.location);
                        if (error)
                            return "location." + error;
                    }
                }
                if (message.share != null && message.hasOwnProperty("share")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.common.ShareElement.verify(message.share);
                        if (error)
                            return "share." + error;
                    }
                }
                if (message.gift != null && message.hasOwnProperty("gift")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.common.GiftElement.verify(message.gift);
                        if (error)
                            return "gift." + error;
                    }
                }
                if (message.marketFace != null && message.hasOwnProperty("marketFace")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.common.MarketFaceElement.verify(message.marketFace);
                        if (error)
                            return "marketFace." + error;
                    }
                }
                if (message.forward != null && message.hasOwnProperty("forward")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.common.ForwardElement.verify(message.forward);
                        if (error)
                            return "forward." + error;
                    }
                }
                if (message.contact != null && message.hasOwnProperty("contact")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.common.ContactElement.verify(message.contact);
                        if (error)
                            return "contact." + error;
                    }
                }
                if (message.json != null && message.hasOwnProperty("json")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.common.JsonElement.verify(message.json);
                        if (error)
                            return "json." + error;
                    }
                }
                if (message.xml != null && message.hasOwnProperty("xml")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.common.XmlElement.verify(message.xml);
                        if (error)
                            return "xml." + error;
                    }
                }
                if (message.file != null && message.hasOwnProperty("file")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.common.FileElement.verify(message.file);
                        if (error)
                            return "file." + error;
                    }
                }
                if (message.markdown != null && message.hasOwnProperty("markdown")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.common.MarkdownElement.verify(message.markdown);
                        if (error)
                            return "markdown." + error;
                    }
                }
                if (message.keyboard != null && message.hasOwnProperty("keyboard")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.common.KeyboardElement.verify(message.keyboard);
                        if (error)
                            return "keyboard." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an Element message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.Element
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.Element} Element
             */
            Element.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.Element)
                    return object;
                let message = new $root.kritor.common.Element();
                switch (object.type) {
                default:
                    if (typeof object.type === "number") {
                        message.type = object.type;
                        break;
                    }
                    break;
                case "TEXT":
                case 0:
                    message.type = 0;
                    break;
                case "AT":
                case 1:
                    message.type = 1;
                    break;
                case "FACE":
                case 2:
                    message.type = 2;
                    break;
                case "BUBBLE_FACE":
                case 3:
                    message.type = 3;
                    break;
                case "REPLY":
                case 4:
                    message.type = 4;
                    break;
                case "IMAGE":
                case 5:
                    message.type = 5;
                    break;
                case "VOICE":
                case 6:
                    message.type = 6;
                    break;
                case "VIDEO":
                case 7:
                    message.type = 7;
                    break;
                case "BASKETBALL":
                case 8:
                    message.type = 8;
                    break;
                case "DICE":
                case 9:
                    message.type = 9;
                    break;
                case "RPS":
                case 10:
                    message.type = 10;
                    break;
                case "POKE":
                case 11:
                    message.type = 11;
                    break;
                case "MUSIC":
                case 12:
                    message.type = 12;
                    break;
                case "WEATHER":
                case 13:
                    message.type = 13;
                    break;
                case "LOCATION":
                case 14:
                    message.type = 14;
                    break;
                case "SHARE":
                case 15:
                    message.type = 15;
                    break;
                case "GIFT":
                case 16:
                    message.type = 16;
                    break;
                case "MARKET_FACE":
                case 17:
                    message.type = 17;
                    break;
                case "FORWARD":
                case 18:
                    message.type = 18;
                    break;
                case "CONTACT":
                case 19:
                    message.type = 19;
                    break;
                case "JSON":
                case 20:
                    message.type = 20;
                    break;
                case "XML":
                case 21:
                    message.type = 21;
                    break;
                case "FILE":
                case 22:
                    message.type = 22;
                    break;
                case "MARKDOWN":
                case 23:
                    message.type = 23;
                    break;
                case "KEYBOARD":
                case 24:
                    message.type = 24;
                    break;
                }
                if (object.text != null) {
                    if (typeof object.text !== "object")
                        throw TypeError(".kritor.common.Element.text: object expected");
                    message.text = $root.kritor.common.TextElement.fromObject(object.text);
                }
                if (object.at != null) {
                    if (typeof object.at !== "object")
                        throw TypeError(".kritor.common.Element.at: object expected");
                    message.at = $root.kritor.common.AtElement.fromObject(object.at);
                }
                if (object.face != null) {
                    if (typeof object.face !== "object")
                        throw TypeError(".kritor.common.Element.face: object expected");
                    message.face = $root.kritor.common.FaceElement.fromObject(object.face);
                }
                if (object.bubbleFace != null) {
                    if (typeof object.bubbleFace !== "object")
                        throw TypeError(".kritor.common.Element.bubbleFace: object expected");
                    message.bubbleFace = $root.kritor.common.BubbleFaceElement.fromObject(object.bubbleFace);
                }
                if (object.reply != null) {
                    if (typeof object.reply !== "object")
                        throw TypeError(".kritor.common.Element.reply: object expected");
                    message.reply = $root.kritor.common.ReplyElement.fromObject(object.reply);
                }
                if (object.image != null) {
                    if (typeof object.image !== "object")
                        throw TypeError(".kritor.common.Element.image: object expected");
                    message.image = $root.kritor.common.ImageElement.fromObject(object.image);
                }
                if (object.voice != null) {
                    if (typeof object.voice !== "object")
                        throw TypeError(".kritor.common.Element.voice: object expected");
                    message.voice = $root.kritor.common.VoiceElement.fromObject(object.voice);
                }
                if (object.video != null) {
                    if (typeof object.video !== "object")
                        throw TypeError(".kritor.common.Element.video: object expected");
                    message.video = $root.kritor.common.VideoElement.fromObject(object.video);
                }
                if (object.basketball != null) {
                    if (typeof object.basketball !== "object")
                        throw TypeError(".kritor.common.Element.basketball: object expected");
                    message.basketball = $root.kritor.common.BasketballElement.fromObject(object.basketball);
                }
                if (object.dice != null) {
                    if (typeof object.dice !== "object")
                        throw TypeError(".kritor.common.Element.dice: object expected");
                    message.dice = $root.kritor.common.DiceElement.fromObject(object.dice);
                }
                if (object.rps != null) {
                    if (typeof object.rps !== "object")
                        throw TypeError(".kritor.common.Element.rps: object expected");
                    message.rps = $root.kritor.common.RpsElement.fromObject(object.rps);
                }
                if (object.poke != null) {
                    if (typeof object.poke !== "object")
                        throw TypeError(".kritor.common.Element.poke: object expected");
                    message.poke = $root.kritor.common.PokeElement.fromObject(object.poke);
                }
                if (object.music != null) {
                    if (typeof object.music !== "object")
                        throw TypeError(".kritor.common.Element.music: object expected");
                    message.music = $root.kritor.common.MusicElement.fromObject(object.music);
                }
                if (object.weather != null) {
                    if (typeof object.weather !== "object")
                        throw TypeError(".kritor.common.Element.weather: object expected");
                    message.weather = $root.kritor.common.WeatherElement.fromObject(object.weather);
                }
                if (object.location != null) {
                    if (typeof object.location !== "object")
                        throw TypeError(".kritor.common.Element.location: object expected");
                    message.location = $root.kritor.common.LocationElement.fromObject(object.location);
                }
                if (object.share != null) {
                    if (typeof object.share !== "object")
                        throw TypeError(".kritor.common.Element.share: object expected");
                    message.share = $root.kritor.common.ShareElement.fromObject(object.share);
                }
                if (object.gift != null) {
                    if (typeof object.gift !== "object")
                        throw TypeError(".kritor.common.Element.gift: object expected");
                    message.gift = $root.kritor.common.GiftElement.fromObject(object.gift);
                }
                if (object.marketFace != null) {
                    if (typeof object.marketFace !== "object")
                        throw TypeError(".kritor.common.Element.marketFace: object expected");
                    message.marketFace = $root.kritor.common.MarketFaceElement.fromObject(object.marketFace);
                }
                if (object.forward != null) {
                    if (typeof object.forward !== "object")
                        throw TypeError(".kritor.common.Element.forward: object expected");
                    message.forward = $root.kritor.common.ForwardElement.fromObject(object.forward);
                }
                if (object.contact != null) {
                    if (typeof object.contact !== "object")
                        throw TypeError(".kritor.common.Element.contact: object expected");
                    message.contact = $root.kritor.common.ContactElement.fromObject(object.contact);
                }
                if (object.json != null) {
                    if (typeof object.json !== "object")
                        throw TypeError(".kritor.common.Element.json: object expected");
                    message.json = $root.kritor.common.JsonElement.fromObject(object.json);
                }
                if (object.xml != null) {
                    if (typeof object.xml !== "object")
                        throw TypeError(".kritor.common.Element.xml: object expected");
                    message.xml = $root.kritor.common.XmlElement.fromObject(object.xml);
                }
                if (object.file != null) {
                    if (typeof object.file !== "object")
                        throw TypeError(".kritor.common.Element.file: object expected");
                    message.file = $root.kritor.common.FileElement.fromObject(object.file);
                }
                if (object.markdown != null) {
                    if (typeof object.markdown !== "object")
                        throw TypeError(".kritor.common.Element.markdown: object expected");
                    message.markdown = $root.kritor.common.MarkdownElement.fromObject(object.markdown);
                }
                if (object.keyboard != null) {
                    if (typeof object.keyboard !== "object")
                        throw TypeError(".kritor.common.Element.keyboard: object expected");
                    message.keyboard = $root.kritor.common.KeyboardElement.fromObject(object.keyboard);
                }
                return message;
            };

            /**
             * Creates a plain object from an Element message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.Element
             * @static
             * @param {kritor.common.Element} message Element
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Element.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.type = options.enums === String ? "TEXT" : 0;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.kritor.common.Element.ElementType[message.type] === undefined ? message.type : $root.kritor.common.Element.ElementType[message.type] : message.type;
                if (message.text != null && message.hasOwnProperty("text")) {
                    object.text = $root.kritor.common.TextElement.toObject(message.text, options);
                    if (options.oneofs)
                        object.data = "text";
                }
                if (message.at != null && message.hasOwnProperty("at")) {
                    object.at = $root.kritor.common.AtElement.toObject(message.at, options);
                    if (options.oneofs)
                        object.data = "at";
                }
                if (message.face != null && message.hasOwnProperty("face")) {
                    object.face = $root.kritor.common.FaceElement.toObject(message.face, options);
                    if (options.oneofs)
                        object.data = "face";
                }
                if (message.bubbleFace != null && message.hasOwnProperty("bubbleFace")) {
                    object.bubbleFace = $root.kritor.common.BubbleFaceElement.toObject(message.bubbleFace, options);
                    if (options.oneofs)
                        object.data = "bubbleFace";
                }
                if (message.reply != null && message.hasOwnProperty("reply")) {
                    object.reply = $root.kritor.common.ReplyElement.toObject(message.reply, options);
                    if (options.oneofs)
                        object.data = "reply";
                }
                if (message.image != null && message.hasOwnProperty("image")) {
                    object.image = $root.kritor.common.ImageElement.toObject(message.image, options);
                    if (options.oneofs)
                        object.data = "image";
                }
                if (message.voice != null && message.hasOwnProperty("voice")) {
                    object.voice = $root.kritor.common.VoiceElement.toObject(message.voice, options);
                    if (options.oneofs)
                        object.data = "voice";
                }
                if (message.video != null && message.hasOwnProperty("video")) {
                    object.video = $root.kritor.common.VideoElement.toObject(message.video, options);
                    if (options.oneofs)
                        object.data = "video";
                }
                if (message.basketball != null && message.hasOwnProperty("basketball")) {
                    object.basketball = $root.kritor.common.BasketballElement.toObject(message.basketball, options);
                    if (options.oneofs)
                        object.data = "basketball";
                }
                if (message.dice != null && message.hasOwnProperty("dice")) {
                    object.dice = $root.kritor.common.DiceElement.toObject(message.dice, options);
                    if (options.oneofs)
                        object.data = "dice";
                }
                if (message.rps != null && message.hasOwnProperty("rps")) {
                    object.rps = $root.kritor.common.RpsElement.toObject(message.rps, options);
                    if (options.oneofs)
                        object.data = "rps";
                }
                if (message.poke != null && message.hasOwnProperty("poke")) {
                    object.poke = $root.kritor.common.PokeElement.toObject(message.poke, options);
                    if (options.oneofs)
                        object.data = "poke";
                }
                if (message.music != null && message.hasOwnProperty("music")) {
                    object.music = $root.kritor.common.MusicElement.toObject(message.music, options);
                    if (options.oneofs)
                        object.data = "music";
                }
                if (message.weather != null && message.hasOwnProperty("weather")) {
                    object.weather = $root.kritor.common.WeatherElement.toObject(message.weather, options);
                    if (options.oneofs)
                        object.data = "weather";
                }
                if (message.location != null && message.hasOwnProperty("location")) {
                    object.location = $root.kritor.common.LocationElement.toObject(message.location, options);
                    if (options.oneofs)
                        object.data = "location";
                }
                if (message.share != null && message.hasOwnProperty("share")) {
                    object.share = $root.kritor.common.ShareElement.toObject(message.share, options);
                    if (options.oneofs)
                        object.data = "share";
                }
                if (message.gift != null && message.hasOwnProperty("gift")) {
                    object.gift = $root.kritor.common.GiftElement.toObject(message.gift, options);
                    if (options.oneofs)
                        object.data = "gift";
                }
                if (message.marketFace != null && message.hasOwnProperty("marketFace")) {
                    object.marketFace = $root.kritor.common.MarketFaceElement.toObject(message.marketFace, options);
                    if (options.oneofs)
                        object.data = "marketFace";
                }
                if (message.forward != null && message.hasOwnProperty("forward")) {
                    object.forward = $root.kritor.common.ForwardElement.toObject(message.forward, options);
                    if (options.oneofs)
                        object.data = "forward";
                }
                if (message.contact != null && message.hasOwnProperty("contact")) {
                    object.contact = $root.kritor.common.ContactElement.toObject(message.contact, options);
                    if (options.oneofs)
                        object.data = "contact";
                }
                if (message.json != null && message.hasOwnProperty("json")) {
                    object.json = $root.kritor.common.JsonElement.toObject(message.json, options);
                    if (options.oneofs)
                        object.data = "json";
                }
                if (message.xml != null && message.hasOwnProperty("xml")) {
                    object.xml = $root.kritor.common.XmlElement.toObject(message.xml, options);
                    if (options.oneofs)
                        object.data = "xml";
                }
                if (message.file != null && message.hasOwnProperty("file")) {
                    object.file = $root.kritor.common.FileElement.toObject(message.file, options);
                    if (options.oneofs)
                        object.data = "file";
                }
                if (message.markdown != null && message.hasOwnProperty("markdown")) {
                    object.markdown = $root.kritor.common.MarkdownElement.toObject(message.markdown, options);
                    if (options.oneofs)
                        object.data = "markdown";
                }
                if (message.keyboard != null && message.hasOwnProperty("keyboard")) {
                    object.keyboard = $root.kritor.common.KeyboardElement.toObject(message.keyboard, options);
                    if (options.oneofs)
                        object.data = "keyboard";
                }
                return object;
            };

            /**
             * Converts this Element to JSON.
             * @function toJSON
             * @memberof kritor.common.Element
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Element.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Element
             * @function getTypeUrl
             * @memberof kritor.common.Element
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Element.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.Element";
            };

            /**
             * ElementType enum.
             * @name kritor.common.Element.ElementType
             * @enum {number}
             * @property {number} TEXT=0 TEXT value
             * @property {number} AT=1 AT value
             * @property {number} FACE=2 FACE value
             * @property {number} BUBBLE_FACE=3 BUBBLE_FACE value
             * @property {number} REPLY=4 REPLY value
             * @property {number} IMAGE=5 IMAGE value
             * @property {number} VOICE=6 VOICE value
             * @property {number} VIDEO=7 VIDEO value
             * @property {number} BASKETBALL=8 BASKETBALL value
             * @property {number} DICE=9 DICE value
             * @property {number} RPS=10 RPS value
             * @property {number} POKE=11 POKE value
             * @property {number} MUSIC=12 MUSIC value
             * @property {number} WEATHER=13 WEATHER value
             * @property {number} LOCATION=14 LOCATION value
             * @property {number} SHARE=15 SHARE value
             * @property {number} GIFT=16 GIFT value
             * @property {number} MARKET_FACE=17 MARKET_FACE value
             * @property {number} FORWARD=18 FORWARD value
             * @property {number} CONTACT=19 CONTACT value
             * @property {number} JSON=20 JSON value
             * @property {number} XML=21 XML value
             * @property {number} FILE=22 FILE value
             * @property {number} MARKDOWN=23 MARKDOWN value
             * @property {number} KEYBOARD=24 KEYBOARD value
             */
            Element.ElementType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "TEXT"] = 0;
                values[valuesById[1] = "AT"] = 1;
                values[valuesById[2] = "FACE"] = 2;
                values[valuesById[3] = "BUBBLE_FACE"] = 3;
                values[valuesById[4] = "REPLY"] = 4;
                values[valuesById[5] = "IMAGE"] = 5;
                values[valuesById[6] = "VOICE"] = 6;
                values[valuesById[7] = "VIDEO"] = 7;
                values[valuesById[8] = "BASKETBALL"] = 8;
                values[valuesById[9] = "DICE"] = 9;
                values[valuesById[10] = "RPS"] = 10;
                values[valuesById[11] = "POKE"] = 11;
                values[valuesById[12] = "MUSIC"] = 12;
                values[valuesById[13] = "WEATHER"] = 13;
                values[valuesById[14] = "LOCATION"] = 14;
                values[valuesById[15] = "SHARE"] = 15;
                values[valuesById[16] = "GIFT"] = 16;
                values[valuesById[17] = "MARKET_FACE"] = 17;
                values[valuesById[18] = "FORWARD"] = 18;
                values[valuesById[19] = "CONTACT"] = 19;
                values[valuesById[20] = "JSON"] = 20;
                values[valuesById[21] = "XML"] = 21;
                values[valuesById[22] = "FILE"] = 22;
                values[valuesById[23] = "MARKDOWN"] = 23;
                values[valuesById[24] = "KEYBOARD"] = 24;
                return values;
            })();

            return Element;
        })();

        common.TextElement = (function() {

            /**
             * Properties of a TextElement.
             * @memberof kritor.common
             * @interface ITextElement
             * @property {string|null} [text] TextElement text
             */

            /**
             * Constructs a new TextElement.
             * @memberof kritor.common
             * @classdesc Represents a TextElement.
             * @implements ITextElement
             * @constructor
             * @param {kritor.common.ITextElement=} [properties] Properties to set
             */
            function TextElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TextElement text.
             * @member {string} text
             * @memberof kritor.common.TextElement
             * @instance
             */
            TextElement.prototype.text = "";

            /**
             * Creates a new TextElement instance using the specified properties.
             * @function create
             * @memberof kritor.common.TextElement
             * @static
             * @param {kritor.common.ITextElement=} [properties] Properties to set
             * @returns {kritor.common.TextElement} TextElement instance
             */
            TextElement.create = function create(properties) {
                return new TextElement(properties);
            };

            /**
             * Encodes the specified TextElement message. Does not implicitly {@link kritor.common.TextElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.TextElement
             * @static
             * @param {kritor.common.ITextElement} message TextElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TextElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.text);
                return writer;
            };

            /**
             * Encodes the specified TextElement message, length delimited. Does not implicitly {@link kritor.common.TextElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.TextElement
             * @static
             * @param {kritor.common.ITextElement} message TextElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TextElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TextElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.TextElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.TextElement} TextElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TextElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.TextElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.text = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TextElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.TextElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.TextElement} TextElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TextElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TextElement message.
             * @function verify
             * @memberof kritor.common.TextElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TextElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.text != null && message.hasOwnProperty("text"))
                    if (!$util.isString(message.text))
                        return "text: string expected";
                return null;
            };

            /**
             * Creates a TextElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.TextElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.TextElement} TextElement
             */
            TextElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.TextElement)
                    return object;
                let message = new $root.kritor.common.TextElement();
                if (object.text != null)
                    message.text = String(object.text);
                return message;
            };

            /**
             * Creates a plain object from a TextElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.TextElement
             * @static
             * @param {kritor.common.TextElement} message TextElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TextElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.text = "";
                if (message.text != null && message.hasOwnProperty("text"))
                    object.text = message.text;
                return object;
            };

            /**
             * Converts this TextElement to JSON.
             * @function toJSON
             * @memberof kritor.common.TextElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TextElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for TextElement
             * @function getTypeUrl
             * @memberof kritor.common.TextElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            TextElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.TextElement";
            };

            return TextElement;
        })();

        common.AtElement = (function() {

            /**
             * Properties of an AtElement.
             * @memberof kritor.common
             * @interface IAtElement
             * @property {string|null} [uid] AtElement uid
             * @property {number|Long|null} [uin] AtElement uin
             */

            /**
             * Constructs a new AtElement.
             * @memberof kritor.common
             * @classdesc Represents an AtElement.
             * @implements IAtElement
             * @constructor
             * @param {kritor.common.IAtElement=} [properties] Properties to set
             */
            function AtElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * AtElement uid.
             * @member {string} uid
             * @memberof kritor.common.AtElement
             * @instance
             */
            AtElement.prototype.uid = "";

            /**
             * AtElement uin.
             * @member {number|Long|null|undefined} uin
             * @memberof kritor.common.AtElement
             * @instance
             */
            AtElement.prototype.uin = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * AtElement _uin.
             * @member {"uin"|undefined} _uin
             * @memberof kritor.common.AtElement
             * @instance
             */
            Object.defineProperty(AtElement.prototype, "_uin", {
                get: $util.oneOfGetter($oneOfFields = ["uin"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new AtElement instance using the specified properties.
             * @function create
             * @memberof kritor.common.AtElement
             * @static
             * @param {kritor.common.IAtElement=} [properties] Properties to set
             * @returns {kritor.common.AtElement} AtElement instance
             */
            AtElement.create = function create(properties) {
                return new AtElement(properties);
            };

            /**
             * Encodes the specified AtElement message. Does not implicitly {@link kritor.common.AtElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.AtElement
             * @static
             * @param {kritor.common.IAtElement} message AtElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AtElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.uid);
                if (message.uin != null && Object.hasOwnProperty.call(message, "uin"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.uin);
                return writer;
            };

            /**
             * Encodes the specified AtElement message, length delimited. Does not implicitly {@link kritor.common.AtElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.AtElement
             * @static
             * @param {kritor.common.IAtElement} message AtElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            AtElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an AtElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.AtElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.AtElement} AtElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AtElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.AtElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.uid = reader.string();
                            break;
                        }
                    case 2: {
                            message.uin = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an AtElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.AtElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.AtElement} AtElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            AtElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an AtElement message.
             * @function verify
             * @memberof kritor.common.AtElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            AtElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.uid != null && message.hasOwnProperty("uid"))
                    if (!$util.isString(message.uid))
                        return "uid: string expected";
                if (message.uin != null && message.hasOwnProperty("uin")) {
                    properties._uin = 1;
                    if (!$util.isInteger(message.uin) && !(message.uin && $util.isInteger(message.uin.low) && $util.isInteger(message.uin.high)))
                        return "uin: integer|Long expected";
                }
                return null;
            };

            /**
             * Creates an AtElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.AtElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.AtElement} AtElement
             */
            AtElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.AtElement)
                    return object;
                let message = new $root.kritor.common.AtElement();
                if (object.uid != null)
                    message.uid = String(object.uid);
                if (object.uin != null)
                    if ($util.Long)
                        (message.uin = $util.Long.fromValue(object.uin)).unsigned = true;
                    else if (typeof object.uin === "string")
                        message.uin = parseInt(object.uin, 10);
                    else if (typeof object.uin === "number")
                        message.uin = object.uin;
                    else if (typeof object.uin === "object")
                        message.uin = new $util.LongBits(object.uin.low >>> 0, object.uin.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from an AtElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.AtElement
             * @static
             * @param {kritor.common.AtElement} message AtElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            AtElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.uid = "";
                if (message.uid != null && message.hasOwnProperty("uid"))
                    object.uid = message.uid;
                if (message.uin != null && message.hasOwnProperty("uin")) {
                    if (typeof message.uin === "number")
                        object.uin = options.longs === String ? String(message.uin) : message.uin;
                    else
                        object.uin = options.longs === String ? $util.Long.prototype.toString.call(message.uin) : options.longs === Number ? new $util.LongBits(message.uin.low >>> 0, message.uin.high >>> 0).toNumber(true) : message.uin;
                    if (options.oneofs)
                        object._uin = "uin";
                }
                return object;
            };

            /**
             * Converts this AtElement to JSON.
             * @function toJSON
             * @memberof kritor.common.AtElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            AtElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for AtElement
             * @function getTypeUrl
             * @memberof kritor.common.AtElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            AtElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.AtElement";
            };

            return AtElement;
        })();

        common.FaceElement = (function() {

            /**
             * Properties of a FaceElement.
             * @memberof kritor.common
             * @interface IFaceElement
             * @property {number|null} [id] FaceElement id
             * @property {boolean|null} [isBig] FaceElement isBig
             * @property {number|null} [result] FaceElement result
             */

            /**
             * Constructs a new FaceElement.
             * @memberof kritor.common
             * @classdesc Represents a FaceElement.
             * @implements IFaceElement
             * @constructor
             * @param {kritor.common.IFaceElement=} [properties] Properties to set
             */
            function FaceElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FaceElement id.
             * @member {number} id
             * @memberof kritor.common.FaceElement
             * @instance
             */
            FaceElement.prototype.id = 0;

            /**
             * FaceElement isBig.
             * @member {boolean|null|undefined} isBig
             * @memberof kritor.common.FaceElement
             * @instance
             */
            FaceElement.prototype.isBig = null;

            /**
             * FaceElement result.
             * @member {number|null|undefined} result
             * @memberof kritor.common.FaceElement
             * @instance
             */
            FaceElement.prototype.result = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * FaceElement _isBig.
             * @member {"isBig"|undefined} _isBig
             * @memberof kritor.common.FaceElement
             * @instance
             */
            Object.defineProperty(FaceElement.prototype, "_isBig", {
                get: $util.oneOfGetter($oneOfFields = ["isBig"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * FaceElement _result.
             * @member {"result"|undefined} _result
             * @memberof kritor.common.FaceElement
             * @instance
             */
            Object.defineProperty(FaceElement.prototype, "_result", {
                get: $util.oneOfGetter($oneOfFields = ["result"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new FaceElement instance using the specified properties.
             * @function create
             * @memberof kritor.common.FaceElement
             * @static
             * @param {kritor.common.IFaceElement=} [properties] Properties to set
             * @returns {kritor.common.FaceElement} FaceElement instance
             */
            FaceElement.create = function create(properties) {
                return new FaceElement(properties);
            };

            /**
             * Encodes the specified FaceElement message. Does not implicitly {@link kritor.common.FaceElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.FaceElement
             * @static
             * @param {kritor.common.IFaceElement} message FaceElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FaceElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
                if (message.isBig != null && Object.hasOwnProperty.call(message, "isBig"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isBig);
                if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.result);
                return writer;
            };

            /**
             * Encodes the specified FaceElement message, length delimited. Does not implicitly {@link kritor.common.FaceElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.FaceElement
             * @static
             * @param {kritor.common.IFaceElement} message FaceElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FaceElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FaceElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.FaceElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.FaceElement} FaceElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FaceElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.FaceElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.id = reader.uint32();
                            break;
                        }
                    case 2: {
                            message.isBig = reader.bool();
                            break;
                        }
                    case 3: {
                            message.result = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FaceElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.FaceElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.FaceElement} FaceElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FaceElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FaceElement message.
             * @function verify
             * @memberof kritor.common.FaceElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FaceElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isInteger(message.id))
                        return "id: integer expected";
                if (message.isBig != null && message.hasOwnProperty("isBig")) {
                    properties._isBig = 1;
                    if (typeof message.isBig !== "boolean")
                        return "isBig: boolean expected";
                }
                if (message.result != null && message.hasOwnProperty("result")) {
                    properties._result = 1;
                    if (!$util.isInteger(message.result))
                        return "result: integer expected";
                }
                return null;
            };

            /**
             * Creates a FaceElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.FaceElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.FaceElement} FaceElement
             */
            FaceElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.FaceElement)
                    return object;
                let message = new $root.kritor.common.FaceElement();
                if (object.id != null)
                    message.id = object.id >>> 0;
                if (object.isBig != null)
                    message.isBig = Boolean(object.isBig);
                if (object.result != null)
                    message.result = object.result >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a FaceElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.FaceElement
             * @static
             * @param {kritor.common.FaceElement} message FaceElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FaceElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.id = 0;
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.isBig != null && message.hasOwnProperty("isBig")) {
                    object.isBig = message.isBig;
                    if (options.oneofs)
                        object._isBig = "isBig";
                }
                if (message.result != null && message.hasOwnProperty("result")) {
                    object.result = message.result;
                    if (options.oneofs)
                        object._result = "result";
                }
                return object;
            };

            /**
             * Converts this FaceElement to JSON.
             * @function toJSON
             * @memberof kritor.common.FaceElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FaceElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for FaceElement
             * @function getTypeUrl
             * @memberof kritor.common.FaceElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            FaceElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.FaceElement";
            };

            return FaceElement;
        })();

        common.BubbleFaceElement = (function() {

            /**
             * Properties of a BubbleFaceElement.
             * @memberof kritor.common
             * @interface IBubbleFaceElement
             * @property {number|null} [id] BubbleFaceElement id
             * @property {number|null} [count] BubbleFaceElement count
             */

            /**
             * Constructs a new BubbleFaceElement.
             * @memberof kritor.common
             * @classdesc Represents a BubbleFaceElement.
             * @implements IBubbleFaceElement
             * @constructor
             * @param {kritor.common.IBubbleFaceElement=} [properties] Properties to set
             */
            function BubbleFaceElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BubbleFaceElement id.
             * @member {number} id
             * @memberof kritor.common.BubbleFaceElement
             * @instance
             */
            BubbleFaceElement.prototype.id = 0;

            /**
             * BubbleFaceElement count.
             * @member {number} count
             * @memberof kritor.common.BubbleFaceElement
             * @instance
             */
            BubbleFaceElement.prototype.count = 0;

            /**
             * Creates a new BubbleFaceElement instance using the specified properties.
             * @function create
             * @memberof kritor.common.BubbleFaceElement
             * @static
             * @param {kritor.common.IBubbleFaceElement=} [properties] Properties to set
             * @returns {kritor.common.BubbleFaceElement} BubbleFaceElement instance
             */
            BubbleFaceElement.create = function create(properties) {
                return new BubbleFaceElement(properties);
            };

            /**
             * Encodes the specified BubbleFaceElement message. Does not implicitly {@link kritor.common.BubbleFaceElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.BubbleFaceElement
             * @static
             * @param {kritor.common.IBubbleFaceElement} message BubbleFaceElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BubbleFaceElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
                if (message.count != null && Object.hasOwnProperty.call(message, "count"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.count);
                return writer;
            };

            /**
             * Encodes the specified BubbleFaceElement message, length delimited. Does not implicitly {@link kritor.common.BubbleFaceElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.BubbleFaceElement
             * @static
             * @param {kritor.common.IBubbleFaceElement} message BubbleFaceElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BubbleFaceElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BubbleFaceElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.BubbleFaceElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.BubbleFaceElement} BubbleFaceElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BubbleFaceElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.BubbleFaceElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.id = reader.uint32();
                            break;
                        }
                    case 2: {
                            message.count = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BubbleFaceElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.BubbleFaceElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.BubbleFaceElement} BubbleFaceElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BubbleFaceElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BubbleFaceElement message.
             * @function verify
             * @memberof kritor.common.BubbleFaceElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BubbleFaceElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isInteger(message.id))
                        return "id: integer expected";
                if (message.count != null && message.hasOwnProperty("count"))
                    if (!$util.isInteger(message.count))
                        return "count: integer expected";
                return null;
            };

            /**
             * Creates a BubbleFaceElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.BubbleFaceElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.BubbleFaceElement} BubbleFaceElement
             */
            BubbleFaceElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.BubbleFaceElement)
                    return object;
                let message = new $root.kritor.common.BubbleFaceElement();
                if (object.id != null)
                    message.id = object.id >>> 0;
                if (object.count != null)
                    message.count = object.count >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a BubbleFaceElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.BubbleFaceElement
             * @static
             * @param {kritor.common.BubbleFaceElement} message BubbleFaceElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BubbleFaceElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.id = 0;
                    object.count = 0;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.count != null && message.hasOwnProperty("count"))
                    object.count = message.count;
                return object;
            };

            /**
             * Converts this BubbleFaceElement to JSON.
             * @function toJSON
             * @memberof kritor.common.BubbleFaceElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BubbleFaceElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for BubbleFaceElement
             * @function getTypeUrl
             * @memberof kritor.common.BubbleFaceElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            BubbleFaceElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.BubbleFaceElement";
            };

            return BubbleFaceElement;
        })();

        common.ReplyElement = (function() {

            /**
             * Properties of a ReplyElement.
             * @memberof kritor.common
             * @interface IReplyElement
             * @property {string|null} [messageId] ReplyElement messageId
             */

            /**
             * Constructs a new ReplyElement.
             * @memberof kritor.common
             * @classdesc Represents a ReplyElement.
             * @implements IReplyElement
             * @constructor
             * @param {kritor.common.IReplyElement=} [properties] Properties to set
             */
            function ReplyElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReplyElement messageId.
             * @member {string} messageId
             * @memberof kritor.common.ReplyElement
             * @instance
             */
            ReplyElement.prototype.messageId = "";

            /**
             * Creates a new ReplyElement instance using the specified properties.
             * @function create
             * @memberof kritor.common.ReplyElement
             * @static
             * @param {kritor.common.IReplyElement=} [properties] Properties to set
             * @returns {kritor.common.ReplyElement} ReplyElement instance
             */
            ReplyElement.create = function create(properties) {
                return new ReplyElement(properties);
            };

            /**
             * Encodes the specified ReplyElement message. Does not implicitly {@link kritor.common.ReplyElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.ReplyElement
             * @static
             * @param {kritor.common.IReplyElement} message ReplyElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReplyElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.messageId != null && Object.hasOwnProperty.call(message, "messageId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.messageId);
                return writer;
            };

            /**
             * Encodes the specified ReplyElement message, length delimited. Does not implicitly {@link kritor.common.ReplyElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.ReplyElement
             * @static
             * @param {kritor.common.IReplyElement} message ReplyElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReplyElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReplyElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.ReplyElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.ReplyElement} ReplyElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReplyElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.ReplyElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.messageId = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReplyElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.ReplyElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.ReplyElement} ReplyElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReplyElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReplyElement message.
             * @function verify
             * @memberof kritor.common.ReplyElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReplyElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    if (!$util.isString(message.messageId))
                        return "messageId: string expected";
                return null;
            };

            /**
             * Creates a ReplyElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.ReplyElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.ReplyElement} ReplyElement
             */
            ReplyElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.ReplyElement)
                    return object;
                let message = new $root.kritor.common.ReplyElement();
                if (object.messageId != null)
                    message.messageId = String(object.messageId);
                return message;
            };

            /**
             * Creates a plain object from a ReplyElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.ReplyElement
             * @static
             * @param {kritor.common.ReplyElement} message ReplyElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReplyElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.messageId = "";
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    object.messageId = message.messageId;
                return object;
            };

            /**
             * Converts this ReplyElement to JSON.
             * @function toJSON
             * @memberof kritor.common.ReplyElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReplyElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ReplyElement
             * @function getTypeUrl
             * @memberof kritor.common.ReplyElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ReplyElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.ReplyElement";
            };

            return ReplyElement;
        })();

        common.ImageElement = (function() {

            /**
             * Properties of an ImageElement.
             * @memberof kritor.common
             * @interface IImageElement
             * @property {Uint8Array|null} [file] ImageElement file
             * @property {string|null} [fileName] ImageElement fileName
             * @property {string|null} [filePath] ImageElement filePath
             * @property {string|null} [fileUrl] ImageElement fileUrl
             * @property {string|null} [fileMd5] ImageElement fileMd5
             * @property {number|null} [subType] ImageElement subType
             * @property {kritor.common.ImageElement.ImageType|null} [type] ImageElement type
             */

            /**
             * Constructs a new ImageElement.
             * @memberof kritor.common
             * @classdesc Represents an ImageElement.
             * @implements IImageElement
             * @constructor
             * @param {kritor.common.IImageElement=} [properties] Properties to set
             */
            function ImageElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ImageElement file.
             * @member {Uint8Array|null|undefined} file
             * @memberof kritor.common.ImageElement
             * @instance
             */
            ImageElement.prototype.file = null;

            /**
             * ImageElement fileName.
             * @member {string|null|undefined} fileName
             * @memberof kritor.common.ImageElement
             * @instance
             */
            ImageElement.prototype.fileName = null;

            /**
             * ImageElement filePath.
             * @member {string|null|undefined} filePath
             * @memberof kritor.common.ImageElement
             * @instance
             */
            ImageElement.prototype.filePath = null;

            /**
             * ImageElement fileUrl.
             * @member {string|null|undefined} fileUrl
             * @memberof kritor.common.ImageElement
             * @instance
             */
            ImageElement.prototype.fileUrl = null;

            /**
             * ImageElement fileMd5.
             * @member {string|null|undefined} fileMd5
             * @memberof kritor.common.ImageElement
             * @instance
             */
            ImageElement.prototype.fileMd5 = null;

            /**
             * ImageElement subType.
             * @member {number|null|undefined} subType
             * @memberof kritor.common.ImageElement
             * @instance
             */
            ImageElement.prototype.subType = null;

            /**
             * ImageElement type.
             * @member {kritor.common.ImageElement.ImageType|null|undefined} type
             * @memberof kritor.common.ImageElement
             * @instance
             */
            ImageElement.prototype.type = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * ImageElement data.
             * @member {"file"|"fileName"|"filePath"|"fileUrl"|undefined} data
             * @memberof kritor.common.ImageElement
             * @instance
             */
            Object.defineProperty(ImageElement.prototype, "data", {
                get: $util.oneOfGetter($oneOfFields = ["file", "fileName", "filePath", "fileUrl"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * ImageElement _fileMd5.
             * @member {"fileMd5"|undefined} _fileMd5
             * @memberof kritor.common.ImageElement
             * @instance
             */
            Object.defineProperty(ImageElement.prototype, "_fileMd5", {
                get: $util.oneOfGetter($oneOfFields = ["fileMd5"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * ImageElement _subType.
             * @member {"subType"|undefined} _subType
             * @memberof kritor.common.ImageElement
             * @instance
             */
            Object.defineProperty(ImageElement.prototype, "_subType", {
                get: $util.oneOfGetter($oneOfFields = ["subType"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * ImageElement _type.
             * @member {"type"|undefined} _type
             * @memberof kritor.common.ImageElement
             * @instance
             */
            Object.defineProperty(ImageElement.prototype, "_type", {
                get: $util.oneOfGetter($oneOfFields = ["type"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new ImageElement instance using the specified properties.
             * @function create
             * @memberof kritor.common.ImageElement
             * @static
             * @param {kritor.common.IImageElement=} [properties] Properties to set
             * @returns {kritor.common.ImageElement} ImageElement instance
             */
            ImageElement.create = function create(properties) {
                return new ImageElement(properties);
            };

            /**
             * Encodes the specified ImageElement message. Does not implicitly {@link kritor.common.ImageElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.ImageElement
             * @static
             * @param {kritor.common.IImageElement} message ImageElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ImageElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.file != null && Object.hasOwnProperty.call(message, "file"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.file);
                if (message.fileName != null && Object.hasOwnProperty.call(message, "fileName"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.fileName);
                if (message.filePath != null && Object.hasOwnProperty.call(message, "filePath"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.filePath);
                if (message.fileUrl != null && Object.hasOwnProperty.call(message, "fileUrl"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.fileUrl);
                if (message.fileMd5 != null && Object.hasOwnProperty.call(message, "fileMd5"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.fileMd5);
                if (message.subType != null && Object.hasOwnProperty.call(message, "subType"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.subType);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 10, wireType 0 =*/80).int32(message.type);
                return writer;
            };

            /**
             * Encodes the specified ImageElement message, length delimited. Does not implicitly {@link kritor.common.ImageElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.ImageElement
             * @static
             * @param {kritor.common.IImageElement} message ImageElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ImageElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ImageElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.ImageElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.ImageElement} ImageElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ImageElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.ImageElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.file = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.fileName = reader.string();
                            break;
                        }
                    case 3: {
                            message.filePath = reader.string();
                            break;
                        }
                    case 4: {
                            message.fileUrl = reader.string();
                            break;
                        }
                    case 5: {
                            message.fileMd5 = reader.string();
                            break;
                        }
                    case 6: {
                            message.subType = reader.uint32();
                            break;
                        }
                    case 10: {
                            message.type = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ImageElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.ImageElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.ImageElement} ImageElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ImageElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ImageElement message.
             * @function verify
             * @memberof kritor.common.ImageElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ImageElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.file != null && message.hasOwnProperty("file")) {
                    properties.data = 1;
                    if (!(message.file && typeof message.file.length === "number" || $util.isString(message.file)))
                        return "file: buffer expected";
                }
                if (message.fileName != null && message.hasOwnProperty("fileName")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    if (!$util.isString(message.fileName))
                        return "fileName: string expected";
                }
                if (message.filePath != null && message.hasOwnProperty("filePath")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    if (!$util.isString(message.filePath))
                        return "filePath: string expected";
                }
                if (message.fileUrl != null && message.hasOwnProperty("fileUrl")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    if (!$util.isString(message.fileUrl))
                        return "fileUrl: string expected";
                }
                if (message.fileMd5 != null && message.hasOwnProperty("fileMd5")) {
                    properties._fileMd5 = 1;
                    if (!$util.isString(message.fileMd5))
                        return "fileMd5: string expected";
                }
                if (message.subType != null && message.hasOwnProperty("subType")) {
                    properties._subType = 1;
                    if (!$util.isInteger(message.subType))
                        return "subType: integer expected";
                }
                if (message.type != null && message.hasOwnProperty("type")) {
                    properties._type = 1;
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                }
                return null;
            };

            /**
             * Creates an ImageElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.ImageElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.ImageElement} ImageElement
             */
            ImageElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.ImageElement)
                    return object;
                let message = new $root.kritor.common.ImageElement();
                if (object.file != null)
                    if (typeof object.file === "string")
                        $util.base64.decode(object.file, message.file = $util.newBuffer($util.base64.length(object.file)), 0);
                    else if (object.file.length >= 0)
                        message.file = object.file;
                if (object.fileName != null)
                    message.fileName = String(object.fileName);
                if (object.filePath != null)
                    message.filePath = String(object.filePath);
                if (object.fileUrl != null)
                    message.fileUrl = String(object.fileUrl);
                if (object.fileMd5 != null)
                    message.fileMd5 = String(object.fileMd5);
                if (object.subType != null)
                    message.subType = object.subType >>> 0;
                switch (object.type) {
                default:
                    if (typeof object.type === "number") {
                        message.type = object.type;
                        break;
                    }
                    break;
                case "COMMON":
                case 0:
                    message.type = 0;
                    break;
                case "ORIGIN":
                case 1:
                    message.type = 1;
                    break;
                case "FLASH":
                case 2:
                    message.type = 2;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from an ImageElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.ImageElement
             * @static
             * @param {kritor.common.ImageElement} message ImageElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ImageElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (message.file != null && message.hasOwnProperty("file")) {
                    object.file = options.bytes === String ? $util.base64.encode(message.file, 0, message.file.length) : options.bytes === Array ? Array.prototype.slice.call(message.file) : message.file;
                    if (options.oneofs)
                        object.data = "file";
                }
                if (message.fileName != null && message.hasOwnProperty("fileName")) {
                    object.fileName = message.fileName;
                    if (options.oneofs)
                        object.data = "fileName";
                }
                if (message.filePath != null && message.hasOwnProperty("filePath")) {
                    object.filePath = message.filePath;
                    if (options.oneofs)
                        object.data = "filePath";
                }
                if (message.fileUrl != null && message.hasOwnProperty("fileUrl")) {
                    object.fileUrl = message.fileUrl;
                    if (options.oneofs)
                        object.data = "fileUrl";
                }
                if (message.fileMd5 != null && message.hasOwnProperty("fileMd5")) {
                    object.fileMd5 = message.fileMd5;
                    if (options.oneofs)
                        object._fileMd5 = "fileMd5";
                }
                if (message.subType != null && message.hasOwnProperty("subType")) {
                    object.subType = message.subType;
                    if (options.oneofs)
                        object._subType = "subType";
                }
                if (message.type != null && message.hasOwnProperty("type")) {
                    object.type = options.enums === String ? $root.kritor.common.ImageElement.ImageType[message.type] === undefined ? message.type : $root.kritor.common.ImageElement.ImageType[message.type] : message.type;
                    if (options.oneofs)
                        object._type = "type";
                }
                return object;
            };

            /**
             * Converts this ImageElement to JSON.
             * @function toJSON
             * @memberof kritor.common.ImageElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ImageElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ImageElement
             * @function getTypeUrl
             * @memberof kritor.common.ImageElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ImageElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.ImageElement";
            };

            /**
             * ImageType enum.
             * @name kritor.common.ImageElement.ImageType
             * @enum {number}
             * @property {number} COMMON=0 COMMON value
             * @property {number} ORIGIN=1 ORIGIN value
             * @property {number} FLASH=2 FLASH value
             */
            ImageElement.ImageType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "COMMON"] = 0;
                values[valuesById[1] = "ORIGIN"] = 1;
                values[valuesById[2] = "FLASH"] = 2;
                return values;
            })();

            return ImageElement;
        })();

        common.VoiceElement = (function() {

            /**
             * Properties of a VoiceElement.
             * @memberof kritor.common
             * @interface IVoiceElement
             * @property {Uint8Array|null} [file] VoiceElement file
             * @property {string|null} [fileName] VoiceElement fileName
             * @property {string|null} [filePath] VoiceElement filePath
             * @property {string|null} [fileUrl] VoiceElement fileUrl
             * @property {string|null} [fileMd5] VoiceElement fileMd5
             * @property {boolean|null} [magic] VoiceElement magic
             */

            /**
             * Constructs a new VoiceElement.
             * @memberof kritor.common
             * @classdesc Represents a VoiceElement.
             * @implements IVoiceElement
             * @constructor
             * @param {kritor.common.IVoiceElement=} [properties] Properties to set
             */
            function VoiceElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * VoiceElement file.
             * @member {Uint8Array|null|undefined} file
             * @memberof kritor.common.VoiceElement
             * @instance
             */
            VoiceElement.prototype.file = null;

            /**
             * VoiceElement fileName.
             * @member {string|null|undefined} fileName
             * @memberof kritor.common.VoiceElement
             * @instance
             */
            VoiceElement.prototype.fileName = null;

            /**
             * VoiceElement filePath.
             * @member {string|null|undefined} filePath
             * @memberof kritor.common.VoiceElement
             * @instance
             */
            VoiceElement.prototype.filePath = null;

            /**
             * VoiceElement fileUrl.
             * @member {string|null|undefined} fileUrl
             * @memberof kritor.common.VoiceElement
             * @instance
             */
            VoiceElement.prototype.fileUrl = null;

            /**
             * VoiceElement fileMd5.
             * @member {string|null|undefined} fileMd5
             * @memberof kritor.common.VoiceElement
             * @instance
             */
            VoiceElement.prototype.fileMd5 = null;

            /**
             * VoiceElement magic.
             * @member {boolean|null|undefined} magic
             * @memberof kritor.common.VoiceElement
             * @instance
             */
            VoiceElement.prototype.magic = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * VoiceElement data.
             * @member {"file"|"fileName"|"filePath"|"fileUrl"|undefined} data
             * @memberof kritor.common.VoiceElement
             * @instance
             */
            Object.defineProperty(VoiceElement.prototype, "data", {
                get: $util.oneOfGetter($oneOfFields = ["file", "fileName", "filePath", "fileUrl"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * VoiceElement _fileMd5.
             * @member {"fileMd5"|undefined} _fileMd5
             * @memberof kritor.common.VoiceElement
             * @instance
             */
            Object.defineProperty(VoiceElement.prototype, "_fileMd5", {
                get: $util.oneOfGetter($oneOfFields = ["fileMd5"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * VoiceElement _magic.
             * @member {"magic"|undefined} _magic
             * @memberof kritor.common.VoiceElement
             * @instance
             */
            Object.defineProperty(VoiceElement.prototype, "_magic", {
                get: $util.oneOfGetter($oneOfFields = ["magic"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new VoiceElement instance using the specified properties.
             * @function create
             * @memberof kritor.common.VoiceElement
             * @static
             * @param {kritor.common.IVoiceElement=} [properties] Properties to set
             * @returns {kritor.common.VoiceElement} VoiceElement instance
             */
            VoiceElement.create = function create(properties) {
                return new VoiceElement(properties);
            };

            /**
             * Encodes the specified VoiceElement message. Does not implicitly {@link kritor.common.VoiceElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.VoiceElement
             * @static
             * @param {kritor.common.IVoiceElement} message VoiceElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VoiceElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.file != null && Object.hasOwnProperty.call(message, "file"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.file);
                if (message.fileName != null && Object.hasOwnProperty.call(message, "fileName"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.fileName);
                if (message.filePath != null && Object.hasOwnProperty.call(message, "filePath"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.filePath);
                if (message.fileUrl != null && Object.hasOwnProperty.call(message, "fileUrl"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.fileUrl);
                if (message.fileMd5 != null && Object.hasOwnProperty.call(message, "fileMd5"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.fileMd5);
                if (message.magic != null && Object.hasOwnProperty.call(message, "magic"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.magic);
                return writer;
            };

            /**
             * Encodes the specified VoiceElement message, length delimited. Does not implicitly {@link kritor.common.VoiceElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.VoiceElement
             * @static
             * @param {kritor.common.IVoiceElement} message VoiceElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VoiceElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a VoiceElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.VoiceElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.VoiceElement} VoiceElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VoiceElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.VoiceElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.file = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.fileName = reader.string();
                            break;
                        }
                    case 3: {
                            message.filePath = reader.string();
                            break;
                        }
                    case 4: {
                            message.fileUrl = reader.string();
                            break;
                        }
                    case 5: {
                            message.fileMd5 = reader.string();
                            break;
                        }
                    case 6: {
                            message.magic = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a VoiceElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.VoiceElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.VoiceElement} VoiceElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VoiceElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a VoiceElement message.
             * @function verify
             * @memberof kritor.common.VoiceElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            VoiceElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.file != null && message.hasOwnProperty("file")) {
                    properties.data = 1;
                    if (!(message.file && typeof message.file.length === "number" || $util.isString(message.file)))
                        return "file: buffer expected";
                }
                if (message.fileName != null && message.hasOwnProperty("fileName")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    if (!$util.isString(message.fileName))
                        return "fileName: string expected";
                }
                if (message.filePath != null && message.hasOwnProperty("filePath")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    if (!$util.isString(message.filePath))
                        return "filePath: string expected";
                }
                if (message.fileUrl != null && message.hasOwnProperty("fileUrl")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    if (!$util.isString(message.fileUrl))
                        return "fileUrl: string expected";
                }
                if (message.fileMd5 != null && message.hasOwnProperty("fileMd5")) {
                    properties._fileMd5 = 1;
                    if (!$util.isString(message.fileMd5))
                        return "fileMd5: string expected";
                }
                if (message.magic != null && message.hasOwnProperty("magic")) {
                    properties._magic = 1;
                    if (typeof message.magic !== "boolean")
                        return "magic: boolean expected";
                }
                return null;
            };

            /**
             * Creates a VoiceElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.VoiceElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.VoiceElement} VoiceElement
             */
            VoiceElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.VoiceElement)
                    return object;
                let message = new $root.kritor.common.VoiceElement();
                if (object.file != null)
                    if (typeof object.file === "string")
                        $util.base64.decode(object.file, message.file = $util.newBuffer($util.base64.length(object.file)), 0);
                    else if (object.file.length >= 0)
                        message.file = object.file;
                if (object.fileName != null)
                    message.fileName = String(object.fileName);
                if (object.filePath != null)
                    message.filePath = String(object.filePath);
                if (object.fileUrl != null)
                    message.fileUrl = String(object.fileUrl);
                if (object.fileMd5 != null)
                    message.fileMd5 = String(object.fileMd5);
                if (object.magic != null)
                    message.magic = Boolean(object.magic);
                return message;
            };

            /**
             * Creates a plain object from a VoiceElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.VoiceElement
             * @static
             * @param {kritor.common.VoiceElement} message VoiceElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            VoiceElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (message.file != null && message.hasOwnProperty("file")) {
                    object.file = options.bytes === String ? $util.base64.encode(message.file, 0, message.file.length) : options.bytes === Array ? Array.prototype.slice.call(message.file) : message.file;
                    if (options.oneofs)
                        object.data = "file";
                }
                if (message.fileName != null && message.hasOwnProperty("fileName")) {
                    object.fileName = message.fileName;
                    if (options.oneofs)
                        object.data = "fileName";
                }
                if (message.filePath != null && message.hasOwnProperty("filePath")) {
                    object.filePath = message.filePath;
                    if (options.oneofs)
                        object.data = "filePath";
                }
                if (message.fileUrl != null && message.hasOwnProperty("fileUrl")) {
                    object.fileUrl = message.fileUrl;
                    if (options.oneofs)
                        object.data = "fileUrl";
                }
                if (message.fileMd5 != null && message.hasOwnProperty("fileMd5")) {
                    object.fileMd5 = message.fileMd5;
                    if (options.oneofs)
                        object._fileMd5 = "fileMd5";
                }
                if (message.magic != null && message.hasOwnProperty("magic")) {
                    object.magic = message.magic;
                    if (options.oneofs)
                        object._magic = "magic";
                }
                return object;
            };

            /**
             * Converts this VoiceElement to JSON.
             * @function toJSON
             * @memberof kritor.common.VoiceElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            VoiceElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for VoiceElement
             * @function getTypeUrl
             * @memberof kritor.common.VoiceElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            VoiceElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.VoiceElement";
            };

            return VoiceElement;
        })();

        common.VideoElement = (function() {

            /**
             * Properties of a VideoElement.
             * @memberof kritor.common
             * @interface IVideoElement
             * @property {Uint8Array|null} [file] VideoElement file
             * @property {string|null} [fileName] VideoElement fileName
             * @property {string|null} [filePath] VideoElement filePath
             * @property {string|null} [fileUrl] VideoElement fileUrl
             * @property {string|null} [fileMd5] VideoElement fileMd5
             */

            /**
             * Constructs a new VideoElement.
             * @memberof kritor.common
             * @classdesc Represents a VideoElement.
             * @implements IVideoElement
             * @constructor
             * @param {kritor.common.IVideoElement=} [properties] Properties to set
             */
            function VideoElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * VideoElement file.
             * @member {Uint8Array|null|undefined} file
             * @memberof kritor.common.VideoElement
             * @instance
             */
            VideoElement.prototype.file = null;

            /**
             * VideoElement fileName.
             * @member {string|null|undefined} fileName
             * @memberof kritor.common.VideoElement
             * @instance
             */
            VideoElement.prototype.fileName = null;

            /**
             * VideoElement filePath.
             * @member {string|null|undefined} filePath
             * @memberof kritor.common.VideoElement
             * @instance
             */
            VideoElement.prototype.filePath = null;

            /**
             * VideoElement fileUrl.
             * @member {string|null|undefined} fileUrl
             * @memberof kritor.common.VideoElement
             * @instance
             */
            VideoElement.prototype.fileUrl = null;

            /**
             * VideoElement fileMd5.
             * @member {string|null|undefined} fileMd5
             * @memberof kritor.common.VideoElement
             * @instance
             */
            VideoElement.prototype.fileMd5 = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * VideoElement data.
             * @member {"file"|"fileName"|"filePath"|"fileUrl"|undefined} data
             * @memberof kritor.common.VideoElement
             * @instance
             */
            Object.defineProperty(VideoElement.prototype, "data", {
                get: $util.oneOfGetter($oneOfFields = ["file", "fileName", "filePath", "fileUrl"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * VideoElement _fileMd5.
             * @member {"fileMd5"|undefined} _fileMd5
             * @memberof kritor.common.VideoElement
             * @instance
             */
            Object.defineProperty(VideoElement.prototype, "_fileMd5", {
                get: $util.oneOfGetter($oneOfFields = ["fileMd5"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new VideoElement instance using the specified properties.
             * @function create
             * @memberof kritor.common.VideoElement
             * @static
             * @param {kritor.common.IVideoElement=} [properties] Properties to set
             * @returns {kritor.common.VideoElement} VideoElement instance
             */
            VideoElement.create = function create(properties) {
                return new VideoElement(properties);
            };

            /**
             * Encodes the specified VideoElement message. Does not implicitly {@link kritor.common.VideoElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.VideoElement
             * @static
             * @param {kritor.common.IVideoElement} message VideoElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VideoElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.file != null && Object.hasOwnProperty.call(message, "file"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.file);
                if (message.fileName != null && Object.hasOwnProperty.call(message, "fileName"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.fileName);
                if (message.filePath != null && Object.hasOwnProperty.call(message, "filePath"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.filePath);
                if (message.fileUrl != null && Object.hasOwnProperty.call(message, "fileUrl"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.fileUrl);
                if (message.fileMd5 != null && Object.hasOwnProperty.call(message, "fileMd5"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.fileMd5);
                return writer;
            };

            /**
             * Encodes the specified VideoElement message, length delimited. Does not implicitly {@link kritor.common.VideoElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.VideoElement
             * @static
             * @param {kritor.common.IVideoElement} message VideoElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VideoElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a VideoElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.VideoElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.VideoElement} VideoElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VideoElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.VideoElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.file = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.fileName = reader.string();
                            break;
                        }
                    case 3: {
                            message.filePath = reader.string();
                            break;
                        }
                    case 4: {
                            message.fileUrl = reader.string();
                            break;
                        }
                    case 5: {
                            message.fileMd5 = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a VideoElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.VideoElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.VideoElement} VideoElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VideoElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a VideoElement message.
             * @function verify
             * @memberof kritor.common.VideoElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            VideoElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.file != null && message.hasOwnProperty("file")) {
                    properties.data = 1;
                    if (!(message.file && typeof message.file.length === "number" || $util.isString(message.file)))
                        return "file: buffer expected";
                }
                if (message.fileName != null && message.hasOwnProperty("fileName")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    if (!$util.isString(message.fileName))
                        return "fileName: string expected";
                }
                if (message.filePath != null && message.hasOwnProperty("filePath")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    if (!$util.isString(message.filePath))
                        return "filePath: string expected";
                }
                if (message.fileUrl != null && message.hasOwnProperty("fileUrl")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    if (!$util.isString(message.fileUrl))
                        return "fileUrl: string expected";
                }
                if (message.fileMd5 != null && message.hasOwnProperty("fileMd5")) {
                    properties._fileMd5 = 1;
                    if (!$util.isString(message.fileMd5))
                        return "fileMd5: string expected";
                }
                return null;
            };

            /**
             * Creates a VideoElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.VideoElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.VideoElement} VideoElement
             */
            VideoElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.VideoElement)
                    return object;
                let message = new $root.kritor.common.VideoElement();
                if (object.file != null)
                    if (typeof object.file === "string")
                        $util.base64.decode(object.file, message.file = $util.newBuffer($util.base64.length(object.file)), 0);
                    else if (object.file.length >= 0)
                        message.file = object.file;
                if (object.fileName != null)
                    message.fileName = String(object.fileName);
                if (object.filePath != null)
                    message.filePath = String(object.filePath);
                if (object.fileUrl != null)
                    message.fileUrl = String(object.fileUrl);
                if (object.fileMd5 != null)
                    message.fileMd5 = String(object.fileMd5);
                return message;
            };

            /**
             * Creates a plain object from a VideoElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.VideoElement
             * @static
             * @param {kritor.common.VideoElement} message VideoElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            VideoElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (message.file != null && message.hasOwnProperty("file")) {
                    object.file = options.bytes === String ? $util.base64.encode(message.file, 0, message.file.length) : options.bytes === Array ? Array.prototype.slice.call(message.file) : message.file;
                    if (options.oneofs)
                        object.data = "file";
                }
                if (message.fileName != null && message.hasOwnProperty("fileName")) {
                    object.fileName = message.fileName;
                    if (options.oneofs)
                        object.data = "fileName";
                }
                if (message.filePath != null && message.hasOwnProperty("filePath")) {
                    object.filePath = message.filePath;
                    if (options.oneofs)
                        object.data = "filePath";
                }
                if (message.fileUrl != null && message.hasOwnProperty("fileUrl")) {
                    object.fileUrl = message.fileUrl;
                    if (options.oneofs)
                        object.data = "fileUrl";
                }
                if (message.fileMd5 != null && message.hasOwnProperty("fileMd5")) {
                    object.fileMd5 = message.fileMd5;
                    if (options.oneofs)
                        object._fileMd5 = "fileMd5";
                }
                return object;
            };

            /**
             * Converts this VideoElement to JSON.
             * @function toJSON
             * @memberof kritor.common.VideoElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            VideoElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for VideoElement
             * @function getTypeUrl
             * @memberof kritor.common.VideoElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            VideoElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.VideoElement";
            };

            return VideoElement;
        })();

        common.BasketballElement = (function() {

            /**
             * Properties of a BasketballElement.
             * @memberof kritor.common
             * @interface IBasketballElement
             * @property {number|null} [id] BasketballElement id
             */

            /**
             * Constructs a new BasketballElement.
             * @memberof kritor.common
             * @classdesc Represents a BasketballElement.
             * @implements IBasketballElement
             * @constructor
             * @param {kritor.common.IBasketballElement=} [properties] Properties to set
             */
            function BasketballElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BasketballElement id.
             * @member {number} id
             * @memberof kritor.common.BasketballElement
             * @instance
             */
            BasketballElement.prototype.id = 0;

            /**
             * Creates a new BasketballElement instance using the specified properties.
             * @function create
             * @memberof kritor.common.BasketballElement
             * @static
             * @param {kritor.common.IBasketballElement=} [properties] Properties to set
             * @returns {kritor.common.BasketballElement} BasketballElement instance
             */
            BasketballElement.create = function create(properties) {
                return new BasketballElement(properties);
            };

            /**
             * Encodes the specified BasketballElement message. Does not implicitly {@link kritor.common.BasketballElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.BasketballElement
             * @static
             * @param {kritor.common.IBasketballElement} message BasketballElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BasketballElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
                return writer;
            };

            /**
             * Encodes the specified BasketballElement message, length delimited. Does not implicitly {@link kritor.common.BasketballElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.BasketballElement
             * @static
             * @param {kritor.common.IBasketballElement} message BasketballElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BasketballElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BasketballElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.BasketballElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.BasketballElement} BasketballElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BasketballElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.BasketballElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.id = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BasketballElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.BasketballElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.BasketballElement} BasketballElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BasketballElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BasketballElement message.
             * @function verify
             * @memberof kritor.common.BasketballElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BasketballElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isInteger(message.id))
                        return "id: integer expected";
                return null;
            };

            /**
             * Creates a BasketballElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.BasketballElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.BasketballElement} BasketballElement
             */
            BasketballElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.BasketballElement)
                    return object;
                let message = new $root.kritor.common.BasketballElement();
                if (object.id != null)
                    message.id = object.id >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a BasketballElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.BasketballElement
             * @static
             * @param {kritor.common.BasketballElement} message BasketballElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BasketballElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.id = 0;
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                return object;
            };

            /**
             * Converts this BasketballElement to JSON.
             * @function toJSON
             * @memberof kritor.common.BasketballElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BasketballElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for BasketballElement
             * @function getTypeUrl
             * @memberof kritor.common.BasketballElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            BasketballElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.BasketballElement";
            };

            return BasketballElement;
        })();

        common.DiceElement = (function() {

            /**
             * Properties of a DiceElement.
             * @memberof kritor.common
             * @interface IDiceElement
             * @property {number|null} [id] DiceElement id
             */

            /**
             * Constructs a new DiceElement.
             * @memberof kritor.common
             * @classdesc Represents a DiceElement.
             * @implements IDiceElement
             * @constructor
             * @param {kritor.common.IDiceElement=} [properties] Properties to set
             */
            function DiceElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DiceElement id.
             * @member {number} id
             * @memberof kritor.common.DiceElement
             * @instance
             */
            DiceElement.prototype.id = 0;

            /**
             * Creates a new DiceElement instance using the specified properties.
             * @function create
             * @memberof kritor.common.DiceElement
             * @static
             * @param {kritor.common.IDiceElement=} [properties] Properties to set
             * @returns {kritor.common.DiceElement} DiceElement instance
             */
            DiceElement.create = function create(properties) {
                return new DiceElement(properties);
            };

            /**
             * Encodes the specified DiceElement message. Does not implicitly {@link kritor.common.DiceElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.DiceElement
             * @static
             * @param {kritor.common.IDiceElement} message DiceElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DiceElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
                return writer;
            };

            /**
             * Encodes the specified DiceElement message, length delimited. Does not implicitly {@link kritor.common.DiceElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.DiceElement
             * @static
             * @param {kritor.common.IDiceElement} message DiceElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DiceElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DiceElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.DiceElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.DiceElement} DiceElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DiceElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.DiceElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.id = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DiceElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.DiceElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.DiceElement} DiceElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DiceElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DiceElement message.
             * @function verify
             * @memberof kritor.common.DiceElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DiceElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isInteger(message.id))
                        return "id: integer expected";
                return null;
            };

            /**
             * Creates a DiceElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.DiceElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.DiceElement} DiceElement
             */
            DiceElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.DiceElement)
                    return object;
                let message = new $root.kritor.common.DiceElement();
                if (object.id != null)
                    message.id = object.id >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a DiceElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.DiceElement
             * @static
             * @param {kritor.common.DiceElement} message DiceElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DiceElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.id = 0;
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                return object;
            };

            /**
             * Converts this DiceElement to JSON.
             * @function toJSON
             * @memberof kritor.common.DiceElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DiceElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DiceElement
             * @function getTypeUrl
             * @memberof kritor.common.DiceElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DiceElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.DiceElement";
            };

            return DiceElement;
        })();

        common.RpsElement = (function() {

            /**
             * Properties of a RpsElement.
             * @memberof kritor.common
             * @interface IRpsElement
             * @property {number|null} [id] RpsElement id
             */

            /**
             * Constructs a new RpsElement.
             * @memberof kritor.common
             * @classdesc Represents a RpsElement.
             * @implements IRpsElement
             * @constructor
             * @param {kritor.common.IRpsElement=} [properties] Properties to set
             */
            function RpsElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RpsElement id.
             * @member {number} id
             * @memberof kritor.common.RpsElement
             * @instance
             */
            RpsElement.prototype.id = 0;

            /**
             * Creates a new RpsElement instance using the specified properties.
             * @function create
             * @memberof kritor.common.RpsElement
             * @static
             * @param {kritor.common.IRpsElement=} [properties] Properties to set
             * @returns {kritor.common.RpsElement} RpsElement instance
             */
            RpsElement.create = function create(properties) {
                return new RpsElement(properties);
            };

            /**
             * Encodes the specified RpsElement message. Does not implicitly {@link kritor.common.RpsElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.RpsElement
             * @static
             * @param {kritor.common.IRpsElement} message RpsElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RpsElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
                return writer;
            };

            /**
             * Encodes the specified RpsElement message, length delimited. Does not implicitly {@link kritor.common.RpsElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.RpsElement
             * @static
             * @param {kritor.common.IRpsElement} message RpsElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RpsElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RpsElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.RpsElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.RpsElement} RpsElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RpsElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.RpsElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.id = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RpsElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.RpsElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.RpsElement} RpsElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RpsElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RpsElement message.
             * @function verify
             * @memberof kritor.common.RpsElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RpsElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isInteger(message.id))
                        return "id: integer expected";
                return null;
            };

            /**
             * Creates a RpsElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.RpsElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.RpsElement} RpsElement
             */
            RpsElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.RpsElement)
                    return object;
                let message = new $root.kritor.common.RpsElement();
                if (object.id != null)
                    message.id = object.id >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a RpsElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.RpsElement
             * @static
             * @param {kritor.common.RpsElement} message RpsElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RpsElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.id = 0;
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                return object;
            };

            /**
             * Converts this RpsElement to JSON.
             * @function toJSON
             * @memberof kritor.common.RpsElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RpsElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for RpsElement
             * @function getTypeUrl
             * @memberof kritor.common.RpsElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            RpsElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.RpsElement";
            };

            return RpsElement;
        })();

        common.PokeElement = (function() {

            /**
             * Properties of a PokeElement.
             * @memberof kritor.common
             * @interface IPokeElement
             * @property {number|null} [id] PokeElement id
             * @property {number|null} [type] PokeElement type
             * @property {number|null} [strength] PokeElement strength
             */

            /**
             * Constructs a new PokeElement.
             * @memberof kritor.common
             * @classdesc Represents a PokeElement.
             * @implements IPokeElement
             * @constructor
             * @param {kritor.common.IPokeElement=} [properties] Properties to set
             */
            function PokeElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PokeElement id.
             * @member {number} id
             * @memberof kritor.common.PokeElement
             * @instance
             */
            PokeElement.prototype.id = 0;

            /**
             * PokeElement type.
             * @member {number} type
             * @memberof kritor.common.PokeElement
             * @instance
             */
            PokeElement.prototype.type = 0;

            /**
             * PokeElement strength.
             * @member {number} strength
             * @memberof kritor.common.PokeElement
             * @instance
             */
            PokeElement.prototype.strength = 0;

            /**
             * Creates a new PokeElement instance using the specified properties.
             * @function create
             * @memberof kritor.common.PokeElement
             * @static
             * @param {kritor.common.IPokeElement=} [properties] Properties to set
             * @returns {kritor.common.PokeElement} PokeElement instance
             */
            PokeElement.create = function create(properties) {
                return new PokeElement(properties);
            };

            /**
             * Encodes the specified PokeElement message. Does not implicitly {@link kritor.common.PokeElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.PokeElement
             * @static
             * @param {kritor.common.IPokeElement} message PokeElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PokeElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.type);
                if (message.strength != null && Object.hasOwnProperty.call(message, "strength"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.strength);
                return writer;
            };

            /**
             * Encodes the specified PokeElement message, length delimited. Does not implicitly {@link kritor.common.PokeElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.PokeElement
             * @static
             * @param {kritor.common.IPokeElement} message PokeElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PokeElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PokeElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.PokeElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.PokeElement} PokeElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PokeElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.PokeElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.id = reader.uint32();
                            break;
                        }
                    case 2: {
                            message.type = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.strength = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PokeElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.PokeElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.PokeElement} PokeElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PokeElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PokeElement message.
             * @function verify
             * @memberof kritor.common.PokeElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PokeElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isInteger(message.id))
                        return "id: integer expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    if (!$util.isInteger(message.type))
                        return "type: integer expected";
                if (message.strength != null && message.hasOwnProperty("strength"))
                    if (!$util.isInteger(message.strength))
                        return "strength: integer expected";
                return null;
            };

            /**
             * Creates a PokeElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.PokeElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.PokeElement} PokeElement
             */
            PokeElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.PokeElement)
                    return object;
                let message = new $root.kritor.common.PokeElement();
                if (object.id != null)
                    message.id = object.id >>> 0;
                if (object.type != null)
                    message.type = object.type >>> 0;
                if (object.strength != null)
                    message.strength = object.strength >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a PokeElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.PokeElement
             * @static
             * @param {kritor.common.PokeElement} message PokeElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PokeElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.id = 0;
                    object.type = 0;
                    object.strength = 0;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = message.type;
                if (message.strength != null && message.hasOwnProperty("strength"))
                    object.strength = message.strength;
                return object;
            };

            /**
             * Converts this PokeElement to JSON.
             * @function toJSON
             * @memberof kritor.common.PokeElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PokeElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for PokeElement
             * @function getTypeUrl
             * @memberof kritor.common.PokeElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            PokeElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.PokeElement";
            };

            return PokeElement;
        })();

        common.CustomMusicData = (function() {

            /**
             * Properties of a CustomMusicData.
             * @memberof kritor.common
             * @interface ICustomMusicData
             * @property {string|null} [url] CustomMusicData url
             * @property {string|null} [audio] CustomMusicData audio
             * @property {string|null} [title] CustomMusicData title
             * @property {string|null} [author] CustomMusicData author
             * @property {string|null} [pic] CustomMusicData pic
             */

            /**
             * Constructs a new CustomMusicData.
             * @memberof kritor.common
             * @classdesc Represents a CustomMusicData.
             * @implements ICustomMusicData
             * @constructor
             * @param {kritor.common.ICustomMusicData=} [properties] Properties to set
             */
            function CustomMusicData(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CustomMusicData url.
             * @member {string} url
             * @memberof kritor.common.CustomMusicData
             * @instance
             */
            CustomMusicData.prototype.url = "";

            /**
             * CustomMusicData audio.
             * @member {string} audio
             * @memberof kritor.common.CustomMusicData
             * @instance
             */
            CustomMusicData.prototype.audio = "";

            /**
             * CustomMusicData title.
             * @member {string} title
             * @memberof kritor.common.CustomMusicData
             * @instance
             */
            CustomMusicData.prototype.title = "";

            /**
             * CustomMusicData author.
             * @member {string} author
             * @memberof kritor.common.CustomMusicData
             * @instance
             */
            CustomMusicData.prototype.author = "";

            /**
             * CustomMusicData pic.
             * @member {string} pic
             * @memberof kritor.common.CustomMusicData
             * @instance
             */
            CustomMusicData.prototype.pic = "";

            /**
             * Creates a new CustomMusicData instance using the specified properties.
             * @function create
             * @memberof kritor.common.CustomMusicData
             * @static
             * @param {kritor.common.ICustomMusicData=} [properties] Properties to set
             * @returns {kritor.common.CustomMusicData} CustomMusicData instance
             */
            CustomMusicData.create = function create(properties) {
                return new CustomMusicData(properties);
            };

            /**
             * Encodes the specified CustomMusicData message. Does not implicitly {@link kritor.common.CustomMusicData.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.CustomMusicData
             * @static
             * @param {kritor.common.ICustomMusicData} message CustomMusicData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CustomMusicData.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.url);
                if (message.audio != null && Object.hasOwnProperty.call(message, "audio"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.audio);
                if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.title);
                if (message.author != null && Object.hasOwnProperty.call(message, "author"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.author);
                if (message.pic != null && Object.hasOwnProperty.call(message, "pic"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.pic);
                return writer;
            };

            /**
             * Encodes the specified CustomMusicData message, length delimited. Does not implicitly {@link kritor.common.CustomMusicData.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.CustomMusicData
             * @static
             * @param {kritor.common.ICustomMusicData} message CustomMusicData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CustomMusicData.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CustomMusicData message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.CustomMusicData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.CustomMusicData} CustomMusicData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CustomMusicData.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.CustomMusicData();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.url = reader.string();
                            break;
                        }
                    case 2: {
                            message.audio = reader.string();
                            break;
                        }
                    case 3: {
                            message.title = reader.string();
                            break;
                        }
                    case 4: {
                            message.author = reader.string();
                            break;
                        }
                    case 5: {
                            message.pic = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CustomMusicData message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.CustomMusicData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.CustomMusicData} CustomMusicData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CustomMusicData.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CustomMusicData message.
             * @function verify
             * @memberof kritor.common.CustomMusicData
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CustomMusicData.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.url != null && message.hasOwnProperty("url"))
                    if (!$util.isString(message.url))
                        return "url: string expected";
                if (message.audio != null && message.hasOwnProperty("audio"))
                    if (!$util.isString(message.audio))
                        return "audio: string expected";
                if (message.title != null && message.hasOwnProperty("title"))
                    if (!$util.isString(message.title))
                        return "title: string expected";
                if (message.author != null && message.hasOwnProperty("author"))
                    if (!$util.isString(message.author))
                        return "author: string expected";
                if (message.pic != null && message.hasOwnProperty("pic"))
                    if (!$util.isString(message.pic))
                        return "pic: string expected";
                return null;
            };

            /**
             * Creates a CustomMusicData message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.CustomMusicData
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.CustomMusicData} CustomMusicData
             */
            CustomMusicData.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.CustomMusicData)
                    return object;
                let message = new $root.kritor.common.CustomMusicData();
                if (object.url != null)
                    message.url = String(object.url);
                if (object.audio != null)
                    message.audio = String(object.audio);
                if (object.title != null)
                    message.title = String(object.title);
                if (object.author != null)
                    message.author = String(object.author);
                if (object.pic != null)
                    message.pic = String(object.pic);
                return message;
            };

            /**
             * Creates a plain object from a CustomMusicData message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.CustomMusicData
             * @static
             * @param {kritor.common.CustomMusicData} message CustomMusicData
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CustomMusicData.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.url = "";
                    object.audio = "";
                    object.title = "";
                    object.author = "";
                    object.pic = "";
                }
                if (message.url != null && message.hasOwnProperty("url"))
                    object.url = message.url;
                if (message.audio != null && message.hasOwnProperty("audio"))
                    object.audio = message.audio;
                if (message.title != null && message.hasOwnProperty("title"))
                    object.title = message.title;
                if (message.author != null && message.hasOwnProperty("author"))
                    object.author = message.author;
                if (message.pic != null && message.hasOwnProperty("pic"))
                    object.pic = message.pic;
                return object;
            };

            /**
             * Converts this CustomMusicData to JSON.
             * @function toJSON
             * @memberof kritor.common.CustomMusicData
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CustomMusicData.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for CustomMusicData
             * @function getTypeUrl
             * @memberof kritor.common.CustomMusicData
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            CustomMusicData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.CustomMusicData";
            };

            return CustomMusicData;
        })();

        common.MusicElement = (function() {

            /**
             * Properties of a MusicElement.
             * @memberof kritor.common
             * @interface IMusicElement
             * @property {kritor.common.MusicElement.MusicPlatform|null} [platform] MusicElement platform
             * @property {string|null} [id] MusicElement id
             * @property {kritor.common.ICustomMusicData|null} [custom] MusicElement custom
             */

            /**
             * Constructs a new MusicElement.
             * @memberof kritor.common
             * @classdesc Represents a MusicElement.
             * @implements IMusicElement
             * @constructor
             * @param {kritor.common.IMusicElement=} [properties] Properties to set
             */
            function MusicElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MusicElement platform.
             * @member {kritor.common.MusicElement.MusicPlatform} platform
             * @memberof kritor.common.MusicElement
             * @instance
             */
            MusicElement.prototype.platform = 0;

            /**
             * MusicElement id.
             * @member {string|null|undefined} id
             * @memberof kritor.common.MusicElement
             * @instance
             */
            MusicElement.prototype.id = null;

            /**
             * MusicElement custom.
             * @member {kritor.common.ICustomMusicData|null|undefined} custom
             * @memberof kritor.common.MusicElement
             * @instance
             */
            MusicElement.prototype.custom = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * MusicElement data.
             * @member {"id"|"custom"|undefined} data
             * @memberof kritor.common.MusicElement
             * @instance
             */
            Object.defineProperty(MusicElement.prototype, "data", {
                get: $util.oneOfGetter($oneOfFields = ["id", "custom"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new MusicElement instance using the specified properties.
             * @function create
             * @memberof kritor.common.MusicElement
             * @static
             * @param {kritor.common.IMusicElement=} [properties] Properties to set
             * @returns {kritor.common.MusicElement} MusicElement instance
             */
            MusicElement.create = function create(properties) {
                return new MusicElement(properties);
            };

            /**
             * Encodes the specified MusicElement message. Does not implicitly {@link kritor.common.MusicElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.MusicElement
             * @static
             * @param {kritor.common.IMusicElement} message MusicElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MusicElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.platform != null && Object.hasOwnProperty.call(message, "platform"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.platform);
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.id);
                if (message.custom != null && Object.hasOwnProperty.call(message, "custom"))
                    $root.kritor.common.CustomMusicData.encode(message.custom, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified MusicElement message, length delimited. Does not implicitly {@link kritor.common.MusicElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.MusicElement
             * @static
             * @param {kritor.common.IMusicElement} message MusicElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MusicElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MusicElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.MusicElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.MusicElement} MusicElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MusicElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.MusicElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.platform = reader.int32();
                            break;
                        }
                    case 2: {
                            message.id = reader.string();
                            break;
                        }
                    case 3: {
                            message.custom = $root.kritor.common.CustomMusicData.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MusicElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.MusicElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.MusicElement} MusicElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MusicElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MusicElement message.
             * @function verify
             * @memberof kritor.common.MusicElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MusicElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.platform != null && message.hasOwnProperty("platform"))
                    switch (message.platform) {
                    default:
                        return "platform: enum value expected";
                    case 0:
                    case 1:
                    case 10:
                        break;
                    }
                if (message.id != null && message.hasOwnProperty("id")) {
                    properties.data = 1;
                    if (!$util.isString(message.id))
                        return "id: string expected";
                }
                if (message.custom != null && message.hasOwnProperty("custom")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    {
                        let error = $root.kritor.common.CustomMusicData.verify(message.custom);
                        if (error)
                            return "custom." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a MusicElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.MusicElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.MusicElement} MusicElement
             */
            MusicElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.MusicElement)
                    return object;
                let message = new $root.kritor.common.MusicElement();
                switch (object.platform) {
                default:
                    if (typeof object.platform === "number") {
                        message.platform = object.platform;
                        break;
                    }
                    break;
                case "QQ":
                case 0:
                    message.platform = 0;
                    break;
                case "NetEase":
                case 1:
                    message.platform = 1;
                    break;
                case "Custom":
                case 10:
                    message.platform = 10;
                    break;
                }
                if (object.id != null)
                    message.id = String(object.id);
                if (object.custom != null) {
                    if (typeof object.custom !== "object")
                        throw TypeError(".kritor.common.MusicElement.custom: object expected");
                    message.custom = $root.kritor.common.CustomMusicData.fromObject(object.custom);
                }
                return message;
            };

            /**
             * Creates a plain object from a MusicElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.MusicElement
             * @static
             * @param {kritor.common.MusicElement} message MusicElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MusicElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.platform = options.enums === String ? "QQ" : 0;
                if (message.platform != null && message.hasOwnProperty("platform"))
                    object.platform = options.enums === String ? $root.kritor.common.MusicElement.MusicPlatform[message.platform] === undefined ? message.platform : $root.kritor.common.MusicElement.MusicPlatform[message.platform] : message.platform;
                if (message.id != null && message.hasOwnProperty("id")) {
                    object.id = message.id;
                    if (options.oneofs)
                        object.data = "id";
                }
                if (message.custom != null && message.hasOwnProperty("custom")) {
                    object.custom = $root.kritor.common.CustomMusicData.toObject(message.custom, options);
                    if (options.oneofs)
                        object.data = "custom";
                }
                return object;
            };

            /**
             * Converts this MusicElement to JSON.
             * @function toJSON
             * @memberof kritor.common.MusicElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MusicElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MusicElement
             * @function getTypeUrl
             * @memberof kritor.common.MusicElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MusicElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.MusicElement";
            };

            /**
             * MusicPlatform enum.
             * @name kritor.common.MusicElement.MusicPlatform
             * @enum {number}
             * @property {number} QQ=0 QQ value
             * @property {number} NetEase=1 NetEase value
             * @property {number} Custom=10 Custom value
             */
            MusicElement.MusicPlatform = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "QQ"] = 0;
                values[valuesById[1] = "NetEase"] = 1;
                values[valuesById[10] = "Custom"] = 10;
                return values;
            })();

            return MusicElement;
        })();

        common.WeatherElement = (function() {

            /**
             * Properties of a WeatherElement.
             * @memberof kritor.common
             * @interface IWeatherElement
             * @property {string|null} [city] WeatherElement city
             * @property {string|null} [code] WeatherElement code
             */

            /**
             * Constructs a new WeatherElement.
             * @memberof kritor.common
             * @classdesc Represents a WeatherElement.
             * @implements IWeatherElement
             * @constructor
             * @param {kritor.common.IWeatherElement=} [properties] Properties to set
             */
            function WeatherElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WeatherElement city.
             * @member {string} city
             * @memberof kritor.common.WeatherElement
             * @instance
             */
            WeatherElement.prototype.city = "";

            /**
             * WeatherElement code.
             * @member {string} code
             * @memberof kritor.common.WeatherElement
             * @instance
             */
            WeatherElement.prototype.code = "";

            /**
             * Creates a new WeatherElement instance using the specified properties.
             * @function create
             * @memberof kritor.common.WeatherElement
             * @static
             * @param {kritor.common.IWeatherElement=} [properties] Properties to set
             * @returns {kritor.common.WeatherElement} WeatherElement instance
             */
            WeatherElement.create = function create(properties) {
                return new WeatherElement(properties);
            };

            /**
             * Encodes the specified WeatherElement message. Does not implicitly {@link kritor.common.WeatherElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.WeatherElement
             * @static
             * @param {kritor.common.IWeatherElement} message WeatherElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WeatherElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.city != null && Object.hasOwnProperty.call(message, "city"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.city);
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.code);
                return writer;
            };

            /**
             * Encodes the specified WeatherElement message, length delimited. Does not implicitly {@link kritor.common.WeatherElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.WeatherElement
             * @static
             * @param {kritor.common.IWeatherElement} message WeatherElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WeatherElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WeatherElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.WeatherElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.WeatherElement} WeatherElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WeatherElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.WeatherElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.city = reader.string();
                            break;
                        }
                    case 2: {
                            message.code = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WeatherElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.WeatherElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.WeatherElement} WeatherElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WeatherElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WeatherElement message.
             * @function verify
             * @memberof kritor.common.WeatherElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WeatherElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.city != null && message.hasOwnProperty("city"))
                    if (!$util.isString(message.city))
                        return "city: string expected";
                if (message.code != null && message.hasOwnProperty("code"))
                    if (!$util.isString(message.code))
                        return "code: string expected";
                return null;
            };

            /**
             * Creates a WeatherElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.WeatherElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.WeatherElement} WeatherElement
             */
            WeatherElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.WeatherElement)
                    return object;
                let message = new $root.kritor.common.WeatherElement();
                if (object.city != null)
                    message.city = String(object.city);
                if (object.code != null)
                    message.code = String(object.code);
                return message;
            };

            /**
             * Creates a plain object from a WeatherElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.WeatherElement
             * @static
             * @param {kritor.common.WeatherElement} message WeatherElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WeatherElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.city = "";
                    object.code = "";
                }
                if (message.city != null && message.hasOwnProperty("city"))
                    object.city = message.city;
                if (message.code != null && message.hasOwnProperty("code"))
                    object.code = message.code;
                return object;
            };

            /**
             * Converts this WeatherElement to JSON.
             * @function toJSON
             * @memberof kritor.common.WeatherElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WeatherElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for WeatherElement
             * @function getTypeUrl
             * @memberof kritor.common.WeatherElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            WeatherElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.WeatherElement";
            };

            return WeatherElement;
        })();

        common.LocationElement = (function() {

            /**
             * Properties of a LocationElement.
             * @memberof kritor.common
             * @interface ILocationElement
             * @property {number|null} [lat] LocationElement lat
             * @property {number|null} [lon] LocationElement lon
             * @property {string|null} [title] LocationElement title
             * @property {string|null} [address] LocationElement address
             */

            /**
             * Constructs a new LocationElement.
             * @memberof kritor.common
             * @classdesc Represents a LocationElement.
             * @implements ILocationElement
             * @constructor
             * @param {kritor.common.ILocationElement=} [properties] Properties to set
             */
            function LocationElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LocationElement lat.
             * @member {number} lat
             * @memberof kritor.common.LocationElement
             * @instance
             */
            LocationElement.prototype.lat = 0;

            /**
             * LocationElement lon.
             * @member {number} lon
             * @memberof kritor.common.LocationElement
             * @instance
             */
            LocationElement.prototype.lon = 0;

            /**
             * LocationElement title.
             * @member {string} title
             * @memberof kritor.common.LocationElement
             * @instance
             */
            LocationElement.prototype.title = "";

            /**
             * LocationElement address.
             * @member {string} address
             * @memberof kritor.common.LocationElement
             * @instance
             */
            LocationElement.prototype.address = "";

            /**
             * Creates a new LocationElement instance using the specified properties.
             * @function create
             * @memberof kritor.common.LocationElement
             * @static
             * @param {kritor.common.ILocationElement=} [properties] Properties to set
             * @returns {kritor.common.LocationElement} LocationElement instance
             */
            LocationElement.create = function create(properties) {
                return new LocationElement(properties);
            };

            /**
             * Encodes the specified LocationElement message. Does not implicitly {@link kritor.common.LocationElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.LocationElement
             * @static
             * @param {kritor.common.ILocationElement} message LocationElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LocationElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.lat != null && Object.hasOwnProperty.call(message, "lat"))
                    writer.uint32(/* id 1, wireType 5 =*/13).float(message.lat);
                if (message.lon != null && Object.hasOwnProperty.call(message, "lon"))
                    writer.uint32(/* id 2, wireType 5 =*/21).float(message.lon);
                if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.title);
                if (message.address != null && Object.hasOwnProperty.call(message, "address"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.address);
                return writer;
            };

            /**
             * Encodes the specified LocationElement message, length delimited. Does not implicitly {@link kritor.common.LocationElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.LocationElement
             * @static
             * @param {kritor.common.ILocationElement} message LocationElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LocationElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LocationElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.LocationElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.LocationElement} LocationElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LocationElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.LocationElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.lat = reader.float();
                            break;
                        }
                    case 2: {
                            message.lon = reader.float();
                            break;
                        }
                    case 3: {
                            message.title = reader.string();
                            break;
                        }
                    case 4: {
                            message.address = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a LocationElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.LocationElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.LocationElement} LocationElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LocationElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LocationElement message.
             * @function verify
             * @memberof kritor.common.LocationElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LocationElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.lat != null && message.hasOwnProperty("lat"))
                    if (typeof message.lat !== "number")
                        return "lat: number expected";
                if (message.lon != null && message.hasOwnProperty("lon"))
                    if (typeof message.lon !== "number")
                        return "lon: number expected";
                if (message.title != null && message.hasOwnProperty("title"))
                    if (!$util.isString(message.title))
                        return "title: string expected";
                if (message.address != null && message.hasOwnProperty("address"))
                    if (!$util.isString(message.address))
                        return "address: string expected";
                return null;
            };

            /**
             * Creates a LocationElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.LocationElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.LocationElement} LocationElement
             */
            LocationElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.LocationElement)
                    return object;
                let message = new $root.kritor.common.LocationElement();
                if (object.lat != null)
                    message.lat = Number(object.lat);
                if (object.lon != null)
                    message.lon = Number(object.lon);
                if (object.title != null)
                    message.title = String(object.title);
                if (object.address != null)
                    message.address = String(object.address);
                return message;
            };

            /**
             * Creates a plain object from a LocationElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.LocationElement
             * @static
             * @param {kritor.common.LocationElement} message LocationElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LocationElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.lat = 0;
                    object.lon = 0;
                    object.title = "";
                    object.address = "";
                }
                if (message.lat != null && message.hasOwnProperty("lat"))
                    object.lat = options.json && !isFinite(message.lat) ? String(message.lat) : message.lat;
                if (message.lon != null && message.hasOwnProperty("lon"))
                    object.lon = options.json && !isFinite(message.lon) ? String(message.lon) : message.lon;
                if (message.title != null && message.hasOwnProperty("title"))
                    object.title = message.title;
                if (message.address != null && message.hasOwnProperty("address"))
                    object.address = message.address;
                return object;
            };

            /**
             * Converts this LocationElement to JSON.
             * @function toJSON
             * @memberof kritor.common.LocationElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LocationElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for LocationElement
             * @function getTypeUrl
             * @memberof kritor.common.LocationElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            LocationElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.LocationElement";
            };

            return LocationElement;
        })();

        common.ShareElement = (function() {

            /**
             * Properties of a ShareElement.
             * @memberof kritor.common
             * @interface IShareElement
             * @property {string|null} [url] ShareElement url
             * @property {string|null} [title] ShareElement title
             * @property {string|null} [content] ShareElement content
             * @property {string|null} [image] ShareElement image
             */

            /**
             * Constructs a new ShareElement.
             * @memberof kritor.common
             * @classdesc Represents a ShareElement.
             * @implements IShareElement
             * @constructor
             * @param {kritor.common.IShareElement=} [properties] Properties to set
             */
            function ShareElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ShareElement url.
             * @member {string} url
             * @memberof kritor.common.ShareElement
             * @instance
             */
            ShareElement.prototype.url = "";

            /**
             * ShareElement title.
             * @member {string} title
             * @memberof kritor.common.ShareElement
             * @instance
             */
            ShareElement.prototype.title = "";

            /**
             * ShareElement content.
             * @member {string} content
             * @memberof kritor.common.ShareElement
             * @instance
             */
            ShareElement.prototype.content = "";

            /**
             * ShareElement image.
             * @member {string} image
             * @memberof kritor.common.ShareElement
             * @instance
             */
            ShareElement.prototype.image = "";

            /**
             * Creates a new ShareElement instance using the specified properties.
             * @function create
             * @memberof kritor.common.ShareElement
             * @static
             * @param {kritor.common.IShareElement=} [properties] Properties to set
             * @returns {kritor.common.ShareElement} ShareElement instance
             */
            ShareElement.create = function create(properties) {
                return new ShareElement(properties);
            };

            /**
             * Encodes the specified ShareElement message. Does not implicitly {@link kritor.common.ShareElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.ShareElement
             * @static
             * @param {kritor.common.IShareElement} message ShareElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ShareElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.url);
                if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.title);
                if (message.content != null && Object.hasOwnProperty.call(message, "content"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.content);
                if (message.image != null && Object.hasOwnProperty.call(message, "image"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.image);
                return writer;
            };

            /**
             * Encodes the specified ShareElement message, length delimited. Does not implicitly {@link kritor.common.ShareElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.ShareElement
             * @static
             * @param {kritor.common.IShareElement} message ShareElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ShareElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ShareElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.ShareElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.ShareElement} ShareElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ShareElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.ShareElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.url = reader.string();
                            break;
                        }
                    case 2: {
                            message.title = reader.string();
                            break;
                        }
                    case 3: {
                            message.content = reader.string();
                            break;
                        }
                    case 4: {
                            message.image = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ShareElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.ShareElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.ShareElement} ShareElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ShareElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ShareElement message.
             * @function verify
             * @memberof kritor.common.ShareElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ShareElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.url != null && message.hasOwnProperty("url"))
                    if (!$util.isString(message.url))
                        return "url: string expected";
                if (message.title != null && message.hasOwnProperty("title"))
                    if (!$util.isString(message.title))
                        return "title: string expected";
                if (message.content != null && message.hasOwnProperty("content"))
                    if (!$util.isString(message.content))
                        return "content: string expected";
                if (message.image != null && message.hasOwnProperty("image"))
                    if (!$util.isString(message.image))
                        return "image: string expected";
                return null;
            };

            /**
             * Creates a ShareElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.ShareElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.ShareElement} ShareElement
             */
            ShareElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.ShareElement)
                    return object;
                let message = new $root.kritor.common.ShareElement();
                if (object.url != null)
                    message.url = String(object.url);
                if (object.title != null)
                    message.title = String(object.title);
                if (object.content != null)
                    message.content = String(object.content);
                if (object.image != null)
                    message.image = String(object.image);
                return message;
            };

            /**
             * Creates a plain object from a ShareElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.ShareElement
             * @static
             * @param {kritor.common.ShareElement} message ShareElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ShareElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.url = "";
                    object.title = "";
                    object.content = "";
                    object.image = "";
                }
                if (message.url != null && message.hasOwnProperty("url"))
                    object.url = message.url;
                if (message.title != null && message.hasOwnProperty("title"))
                    object.title = message.title;
                if (message.content != null && message.hasOwnProperty("content"))
                    object.content = message.content;
                if (message.image != null && message.hasOwnProperty("image"))
                    object.image = message.image;
                return object;
            };

            /**
             * Converts this ShareElement to JSON.
             * @function toJSON
             * @memberof kritor.common.ShareElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ShareElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ShareElement
             * @function getTypeUrl
             * @memberof kritor.common.ShareElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ShareElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.ShareElement";
            };

            return ShareElement;
        })();

        common.GiftElement = (function() {

            /**
             * Properties of a GiftElement.
             * @memberof kritor.common
             * @interface IGiftElement
             * @property {number|Long|null} [qq] GiftElement qq
             * @property {number|null} [id] GiftElement id
             */

            /**
             * Constructs a new GiftElement.
             * @memberof kritor.common
             * @classdesc Represents a GiftElement.
             * @implements IGiftElement
             * @constructor
             * @param {kritor.common.IGiftElement=} [properties] Properties to set
             */
            function GiftElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GiftElement qq.
             * @member {number|Long} qq
             * @memberof kritor.common.GiftElement
             * @instance
             */
            GiftElement.prototype.qq = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GiftElement id.
             * @member {number} id
             * @memberof kritor.common.GiftElement
             * @instance
             */
            GiftElement.prototype.id = 0;

            /**
             * Creates a new GiftElement instance using the specified properties.
             * @function create
             * @memberof kritor.common.GiftElement
             * @static
             * @param {kritor.common.IGiftElement=} [properties] Properties to set
             * @returns {kritor.common.GiftElement} GiftElement instance
             */
            GiftElement.create = function create(properties) {
                return new GiftElement(properties);
            };

            /**
             * Encodes the specified GiftElement message. Does not implicitly {@link kritor.common.GiftElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.GiftElement
             * @static
             * @param {kritor.common.IGiftElement} message GiftElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GiftElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.qq != null && Object.hasOwnProperty.call(message, "qq"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.qq);
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.id);
                return writer;
            };

            /**
             * Encodes the specified GiftElement message, length delimited. Does not implicitly {@link kritor.common.GiftElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.GiftElement
             * @static
             * @param {kritor.common.IGiftElement} message GiftElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GiftElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GiftElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.GiftElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.GiftElement} GiftElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GiftElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.GiftElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.qq = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.id = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GiftElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.GiftElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.GiftElement} GiftElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GiftElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GiftElement message.
             * @function verify
             * @memberof kritor.common.GiftElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GiftElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.qq != null && message.hasOwnProperty("qq"))
                    if (!$util.isInteger(message.qq) && !(message.qq && $util.isInteger(message.qq.low) && $util.isInteger(message.qq.high)))
                        return "qq: integer|Long expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isInteger(message.id))
                        return "id: integer expected";
                return null;
            };

            /**
             * Creates a GiftElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.GiftElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.GiftElement} GiftElement
             */
            GiftElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.GiftElement)
                    return object;
                let message = new $root.kritor.common.GiftElement();
                if (object.qq != null)
                    if ($util.Long)
                        (message.qq = $util.Long.fromValue(object.qq)).unsigned = true;
                    else if (typeof object.qq === "string")
                        message.qq = parseInt(object.qq, 10);
                    else if (typeof object.qq === "number")
                        message.qq = object.qq;
                    else if (typeof object.qq === "object")
                        message.qq = new $util.LongBits(object.qq.low >>> 0, object.qq.high >>> 0).toNumber(true);
                if (object.id != null)
                    message.id = object.id >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a GiftElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.GiftElement
             * @static
             * @param {kritor.common.GiftElement} message GiftElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GiftElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.qq = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.qq = options.longs === String ? "0" : 0;
                    object.id = 0;
                }
                if (message.qq != null && message.hasOwnProperty("qq"))
                    if (typeof message.qq === "number")
                        object.qq = options.longs === String ? String(message.qq) : message.qq;
                    else
                        object.qq = options.longs === String ? $util.Long.prototype.toString.call(message.qq) : options.longs === Number ? new $util.LongBits(message.qq.low >>> 0, message.qq.high >>> 0).toNumber(true) : message.qq;
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                return object;
            };

            /**
             * Converts this GiftElement to JSON.
             * @function toJSON
             * @memberof kritor.common.GiftElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GiftElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GiftElement
             * @function getTypeUrl
             * @memberof kritor.common.GiftElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GiftElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.GiftElement";
            };

            return GiftElement;
        })();

        common.MarketFaceElement = (function() {

            /**
             * Properties of a MarketFaceElement.
             * @memberof kritor.common
             * @interface IMarketFaceElement
             * @property {string|null} [id] MarketFaceElement id
             */

            /**
             * Constructs a new MarketFaceElement.
             * @memberof kritor.common
             * @classdesc Represents a MarketFaceElement.
             * @implements IMarketFaceElement
             * @constructor
             * @param {kritor.common.IMarketFaceElement=} [properties] Properties to set
             */
            function MarketFaceElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MarketFaceElement id.
             * @member {string} id
             * @memberof kritor.common.MarketFaceElement
             * @instance
             */
            MarketFaceElement.prototype.id = "";

            /**
             * Creates a new MarketFaceElement instance using the specified properties.
             * @function create
             * @memberof kritor.common.MarketFaceElement
             * @static
             * @param {kritor.common.IMarketFaceElement=} [properties] Properties to set
             * @returns {kritor.common.MarketFaceElement} MarketFaceElement instance
             */
            MarketFaceElement.create = function create(properties) {
                return new MarketFaceElement(properties);
            };

            /**
             * Encodes the specified MarketFaceElement message. Does not implicitly {@link kritor.common.MarketFaceElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.MarketFaceElement
             * @static
             * @param {kritor.common.IMarketFaceElement} message MarketFaceElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MarketFaceElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                return writer;
            };

            /**
             * Encodes the specified MarketFaceElement message, length delimited. Does not implicitly {@link kritor.common.MarketFaceElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.MarketFaceElement
             * @static
             * @param {kritor.common.IMarketFaceElement} message MarketFaceElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MarketFaceElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MarketFaceElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.MarketFaceElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.MarketFaceElement} MarketFaceElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MarketFaceElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.MarketFaceElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.id = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MarketFaceElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.MarketFaceElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.MarketFaceElement} MarketFaceElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MarketFaceElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MarketFaceElement message.
             * @function verify
             * @memberof kritor.common.MarketFaceElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MarketFaceElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                return null;
            };

            /**
             * Creates a MarketFaceElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.MarketFaceElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.MarketFaceElement} MarketFaceElement
             */
            MarketFaceElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.MarketFaceElement)
                    return object;
                let message = new $root.kritor.common.MarketFaceElement();
                if (object.id != null)
                    message.id = String(object.id);
                return message;
            };

            /**
             * Creates a plain object from a MarketFaceElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.MarketFaceElement
             * @static
             * @param {kritor.common.MarketFaceElement} message MarketFaceElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MarketFaceElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.id = "";
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                return object;
            };

            /**
             * Converts this MarketFaceElement to JSON.
             * @function toJSON
             * @memberof kritor.common.MarketFaceElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MarketFaceElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MarketFaceElement
             * @function getTypeUrl
             * @memberof kritor.common.MarketFaceElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MarketFaceElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.MarketFaceElement";
            };

            return MarketFaceElement;
        })();

        common.ForwardElement = (function() {

            /**
             * Properties of a ForwardElement.
             * @memberof kritor.common
             * @interface IForwardElement
             * @property {string|null} [resId] ForwardElement resId
             * @property {string|null} [uniseq] ForwardElement uniseq
             * @property {string|null} [summary] ForwardElement summary
             * @property {string|null} [description] ForwardElement description
             */

            /**
             * Constructs a new ForwardElement.
             * @memberof kritor.common
             * @classdesc Represents a ForwardElement.
             * @implements IForwardElement
             * @constructor
             * @param {kritor.common.IForwardElement=} [properties] Properties to set
             */
            function ForwardElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ForwardElement resId.
             * @member {string} resId
             * @memberof kritor.common.ForwardElement
             * @instance
             */
            ForwardElement.prototype.resId = "";

            /**
             * ForwardElement uniseq.
             * @member {string} uniseq
             * @memberof kritor.common.ForwardElement
             * @instance
             */
            ForwardElement.prototype.uniseq = "";

            /**
             * ForwardElement summary.
             * @member {string} summary
             * @memberof kritor.common.ForwardElement
             * @instance
             */
            ForwardElement.prototype.summary = "";

            /**
             * ForwardElement description.
             * @member {string} description
             * @memberof kritor.common.ForwardElement
             * @instance
             */
            ForwardElement.prototype.description = "";

            /**
             * Creates a new ForwardElement instance using the specified properties.
             * @function create
             * @memberof kritor.common.ForwardElement
             * @static
             * @param {kritor.common.IForwardElement=} [properties] Properties to set
             * @returns {kritor.common.ForwardElement} ForwardElement instance
             */
            ForwardElement.create = function create(properties) {
                return new ForwardElement(properties);
            };

            /**
             * Encodes the specified ForwardElement message. Does not implicitly {@link kritor.common.ForwardElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.ForwardElement
             * @static
             * @param {kritor.common.IForwardElement} message ForwardElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ForwardElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.resId != null && Object.hasOwnProperty.call(message, "resId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.resId);
                if (message.uniseq != null && Object.hasOwnProperty.call(message, "uniseq"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.uniseq);
                if (message.summary != null && Object.hasOwnProperty.call(message, "summary"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.summary);
                if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.description);
                return writer;
            };

            /**
             * Encodes the specified ForwardElement message, length delimited. Does not implicitly {@link kritor.common.ForwardElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.ForwardElement
             * @static
             * @param {kritor.common.IForwardElement} message ForwardElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ForwardElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ForwardElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.ForwardElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.ForwardElement} ForwardElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ForwardElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.ForwardElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.resId = reader.string();
                            break;
                        }
                    case 2: {
                            message.uniseq = reader.string();
                            break;
                        }
                    case 3: {
                            message.summary = reader.string();
                            break;
                        }
                    case 4: {
                            message.description = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ForwardElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.ForwardElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.ForwardElement} ForwardElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ForwardElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ForwardElement message.
             * @function verify
             * @memberof kritor.common.ForwardElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ForwardElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.resId != null && message.hasOwnProperty("resId"))
                    if (!$util.isString(message.resId))
                        return "resId: string expected";
                if (message.uniseq != null && message.hasOwnProperty("uniseq"))
                    if (!$util.isString(message.uniseq))
                        return "uniseq: string expected";
                if (message.summary != null && message.hasOwnProperty("summary"))
                    if (!$util.isString(message.summary))
                        return "summary: string expected";
                if (message.description != null && message.hasOwnProperty("description"))
                    if (!$util.isString(message.description))
                        return "description: string expected";
                return null;
            };

            /**
             * Creates a ForwardElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.ForwardElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.ForwardElement} ForwardElement
             */
            ForwardElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.ForwardElement)
                    return object;
                let message = new $root.kritor.common.ForwardElement();
                if (object.resId != null)
                    message.resId = String(object.resId);
                if (object.uniseq != null)
                    message.uniseq = String(object.uniseq);
                if (object.summary != null)
                    message.summary = String(object.summary);
                if (object.description != null)
                    message.description = String(object.description);
                return message;
            };

            /**
             * Creates a plain object from a ForwardElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.ForwardElement
             * @static
             * @param {kritor.common.ForwardElement} message ForwardElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ForwardElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.resId = "";
                    object.uniseq = "";
                    object.summary = "";
                    object.description = "";
                }
                if (message.resId != null && message.hasOwnProperty("resId"))
                    object.resId = message.resId;
                if (message.uniseq != null && message.hasOwnProperty("uniseq"))
                    object.uniseq = message.uniseq;
                if (message.summary != null && message.hasOwnProperty("summary"))
                    object.summary = message.summary;
                if (message.description != null && message.hasOwnProperty("description"))
                    object.description = message.description;
                return object;
            };

            /**
             * Converts this ForwardElement to JSON.
             * @function toJSON
             * @memberof kritor.common.ForwardElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ForwardElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ForwardElement
             * @function getTypeUrl
             * @memberof kritor.common.ForwardElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ForwardElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.ForwardElement";
            };

            return ForwardElement;
        })();

        common.ContactElement = (function() {

            /**
             * Properties of a ContactElement.
             * @memberof kritor.common
             * @interface IContactElement
             * @property {kritor.common.Scene|null} [scene] ContactElement scene
             * @property {string|null} [peer] ContactElement peer
             */

            /**
             * Constructs a new ContactElement.
             * @memberof kritor.common
             * @classdesc Represents a ContactElement.
             * @implements IContactElement
             * @constructor
             * @param {kritor.common.IContactElement=} [properties] Properties to set
             */
            function ContactElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ContactElement scene.
             * @member {kritor.common.Scene} scene
             * @memberof kritor.common.ContactElement
             * @instance
             */
            ContactElement.prototype.scene = 0;

            /**
             * ContactElement peer.
             * @member {string} peer
             * @memberof kritor.common.ContactElement
             * @instance
             */
            ContactElement.prototype.peer = "";

            /**
             * Creates a new ContactElement instance using the specified properties.
             * @function create
             * @memberof kritor.common.ContactElement
             * @static
             * @param {kritor.common.IContactElement=} [properties] Properties to set
             * @returns {kritor.common.ContactElement} ContactElement instance
             */
            ContactElement.create = function create(properties) {
                return new ContactElement(properties);
            };

            /**
             * Encodes the specified ContactElement message. Does not implicitly {@link kritor.common.ContactElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.ContactElement
             * @static
             * @param {kritor.common.IContactElement} message ContactElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ContactElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.scene != null && Object.hasOwnProperty.call(message, "scene"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.scene);
                if (message.peer != null && Object.hasOwnProperty.call(message, "peer"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.peer);
                return writer;
            };

            /**
             * Encodes the specified ContactElement message, length delimited. Does not implicitly {@link kritor.common.ContactElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.ContactElement
             * @static
             * @param {kritor.common.IContactElement} message ContactElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ContactElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ContactElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.ContactElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.ContactElement} ContactElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ContactElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.ContactElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.scene = reader.int32();
                            break;
                        }
                    case 2: {
                            message.peer = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ContactElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.ContactElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.ContactElement} ContactElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ContactElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ContactElement message.
             * @function verify
             * @memberof kritor.common.ContactElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ContactElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.scene != null && message.hasOwnProperty("scene"))
                    switch (message.scene) {
                    default:
                        return "scene: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 10:
                    case 5:
                    case 9:
                        break;
                    }
                if (message.peer != null && message.hasOwnProperty("peer"))
                    if (!$util.isString(message.peer))
                        return "peer: string expected";
                return null;
            };

            /**
             * Creates a ContactElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.ContactElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.ContactElement} ContactElement
             */
            ContactElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.ContactElement)
                    return object;
                let message = new $root.kritor.common.ContactElement();
                switch (object.scene) {
                default:
                    if (typeof object.scene === "number") {
                        message.scene = object.scene;
                        break;
                    }
                    break;
                case "GROUP":
                case 0:
                    message.scene = 0;
                    break;
                case "FRIEND":
                case 1:
                    message.scene = 1;
                    break;
                case "GUILD":
                case 2:
                    message.scene = 2;
                    break;
                case "STRANGER_FROM_GROUP":
                case 10:
                    message.scene = 10;
                    break;
                case "NEARBY":
                case 5:
                    message.scene = 5;
                    break;
                case "STRANGER":
                case 9:
                    message.scene = 9;
                    break;
                }
                if (object.peer != null)
                    message.peer = String(object.peer);
                return message;
            };

            /**
             * Creates a plain object from a ContactElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.ContactElement
             * @static
             * @param {kritor.common.ContactElement} message ContactElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ContactElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.scene = options.enums === String ? "GROUP" : 0;
                    object.peer = "";
                }
                if (message.scene != null && message.hasOwnProperty("scene"))
                    object.scene = options.enums === String ? $root.kritor.common.Scene[message.scene] === undefined ? message.scene : $root.kritor.common.Scene[message.scene] : message.scene;
                if (message.peer != null && message.hasOwnProperty("peer"))
                    object.peer = message.peer;
                return object;
            };

            /**
             * Converts this ContactElement to JSON.
             * @function toJSON
             * @memberof kritor.common.ContactElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ContactElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ContactElement
             * @function getTypeUrl
             * @memberof kritor.common.ContactElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ContactElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.ContactElement";
            };

            return ContactElement;
        })();

        common.JsonElement = (function() {

            /**
             * Properties of a JsonElement.
             * @memberof kritor.common
             * @interface IJsonElement
             * @property {string|null} [json] JsonElement json
             */

            /**
             * Constructs a new JsonElement.
             * @memberof kritor.common
             * @classdesc Represents a JsonElement.
             * @implements IJsonElement
             * @constructor
             * @param {kritor.common.IJsonElement=} [properties] Properties to set
             */
            function JsonElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * JsonElement json.
             * @member {string} json
             * @memberof kritor.common.JsonElement
             * @instance
             */
            JsonElement.prototype.json = "";

            /**
             * Creates a new JsonElement instance using the specified properties.
             * @function create
             * @memberof kritor.common.JsonElement
             * @static
             * @param {kritor.common.IJsonElement=} [properties] Properties to set
             * @returns {kritor.common.JsonElement} JsonElement instance
             */
            JsonElement.create = function create(properties) {
                return new JsonElement(properties);
            };

            /**
             * Encodes the specified JsonElement message. Does not implicitly {@link kritor.common.JsonElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.JsonElement
             * @static
             * @param {kritor.common.IJsonElement} message JsonElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            JsonElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.json != null && Object.hasOwnProperty.call(message, "json"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.json);
                return writer;
            };

            /**
             * Encodes the specified JsonElement message, length delimited. Does not implicitly {@link kritor.common.JsonElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.JsonElement
             * @static
             * @param {kritor.common.IJsonElement} message JsonElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            JsonElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a JsonElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.JsonElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.JsonElement} JsonElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            JsonElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.JsonElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.json = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a JsonElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.JsonElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.JsonElement} JsonElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            JsonElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a JsonElement message.
             * @function verify
             * @memberof kritor.common.JsonElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            JsonElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.json != null && message.hasOwnProperty("json"))
                    if (!$util.isString(message.json))
                        return "json: string expected";
                return null;
            };

            /**
             * Creates a JsonElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.JsonElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.JsonElement} JsonElement
             */
            JsonElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.JsonElement)
                    return object;
                let message = new $root.kritor.common.JsonElement();
                if (object.json != null)
                    message.json = String(object.json);
                return message;
            };

            /**
             * Creates a plain object from a JsonElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.JsonElement
             * @static
             * @param {kritor.common.JsonElement} message JsonElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            JsonElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.json = "";
                if (message.json != null && message.hasOwnProperty("json"))
                    object.json = message.json;
                return object;
            };

            /**
             * Converts this JsonElement to JSON.
             * @function toJSON
             * @memberof kritor.common.JsonElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            JsonElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for JsonElement
             * @function getTypeUrl
             * @memberof kritor.common.JsonElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            JsonElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.JsonElement";
            };

            return JsonElement;
        })();

        common.XmlElement = (function() {

            /**
             * Properties of a XmlElement.
             * @memberof kritor.common
             * @interface IXmlElement
             * @property {string|null} [xml] XmlElement xml
             */

            /**
             * Constructs a new XmlElement.
             * @memberof kritor.common
             * @classdesc Represents a XmlElement.
             * @implements IXmlElement
             * @constructor
             * @param {kritor.common.IXmlElement=} [properties] Properties to set
             */
            function XmlElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * XmlElement xml.
             * @member {string} xml
             * @memberof kritor.common.XmlElement
             * @instance
             */
            XmlElement.prototype.xml = "";

            /**
             * Creates a new XmlElement instance using the specified properties.
             * @function create
             * @memberof kritor.common.XmlElement
             * @static
             * @param {kritor.common.IXmlElement=} [properties] Properties to set
             * @returns {kritor.common.XmlElement} XmlElement instance
             */
            XmlElement.create = function create(properties) {
                return new XmlElement(properties);
            };

            /**
             * Encodes the specified XmlElement message. Does not implicitly {@link kritor.common.XmlElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.XmlElement
             * @static
             * @param {kritor.common.IXmlElement} message XmlElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            XmlElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.xml != null && Object.hasOwnProperty.call(message, "xml"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.xml);
                return writer;
            };

            /**
             * Encodes the specified XmlElement message, length delimited. Does not implicitly {@link kritor.common.XmlElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.XmlElement
             * @static
             * @param {kritor.common.IXmlElement} message XmlElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            XmlElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a XmlElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.XmlElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.XmlElement} XmlElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            XmlElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.XmlElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.xml = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a XmlElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.XmlElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.XmlElement} XmlElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            XmlElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a XmlElement message.
             * @function verify
             * @memberof kritor.common.XmlElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            XmlElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.xml != null && message.hasOwnProperty("xml"))
                    if (!$util.isString(message.xml))
                        return "xml: string expected";
                return null;
            };

            /**
             * Creates a XmlElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.XmlElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.XmlElement} XmlElement
             */
            XmlElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.XmlElement)
                    return object;
                let message = new $root.kritor.common.XmlElement();
                if (object.xml != null)
                    message.xml = String(object.xml);
                return message;
            };

            /**
             * Creates a plain object from a XmlElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.XmlElement
             * @static
             * @param {kritor.common.XmlElement} message XmlElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            XmlElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.xml = "";
                if (message.xml != null && message.hasOwnProperty("xml"))
                    object.xml = message.xml;
                return object;
            };

            /**
             * Converts this XmlElement to JSON.
             * @function toJSON
             * @memberof kritor.common.XmlElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            XmlElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for XmlElement
             * @function getTypeUrl
             * @memberof kritor.common.XmlElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            XmlElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.XmlElement";
            };

            return XmlElement;
        })();

        common.FileElement = (function() {

            /**
             * Properties of a FileElement.
             * @memberof kritor.common
             * @interface IFileElement
             * @property {string|null} [name] FileElement name
             * @property {number|Long|null} [size] FileElement size
             * @property {number|Long|null} [expireTime] FileElement expireTime
             * @property {string|null} [id] FileElement id
             * @property {string|null} [url] FileElement url
             * @property {number|null} [biz] FileElement biz
             * @property {string|null} [subId] FileElement subId
             */

            /**
             * Constructs a new FileElement.
             * @memberof kritor.common
             * @classdesc Represents a FileElement.
             * @implements IFileElement
             * @constructor
             * @param {kritor.common.IFileElement=} [properties] Properties to set
             */
            function FileElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FileElement name.
             * @member {string|null|undefined} name
             * @memberof kritor.common.FileElement
             * @instance
             */
            FileElement.prototype.name = null;

            /**
             * FileElement size.
             * @member {number|Long|null|undefined} size
             * @memberof kritor.common.FileElement
             * @instance
             */
            FileElement.prototype.size = null;

            /**
             * FileElement expireTime.
             * @member {number|Long|null|undefined} expireTime
             * @memberof kritor.common.FileElement
             * @instance
             */
            FileElement.prototype.expireTime = null;

            /**
             * FileElement id.
             * @member {string|null|undefined} id
             * @memberof kritor.common.FileElement
             * @instance
             */
            FileElement.prototype.id = null;

            /**
             * FileElement url.
             * @member {string|null|undefined} url
             * @memberof kritor.common.FileElement
             * @instance
             */
            FileElement.prototype.url = null;

            /**
             * FileElement biz.
             * @member {number|null|undefined} biz
             * @memberof kritor.common.FileElement
             * @instance
             */
            FileElement.prototype.biz = null;

            /**
             * FileElement subId.
             * @member {string|null|undefined} subId
             * @memberof kritor.common.FileElement
             * @instance
             */
            FileElement.prototype.subId = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * FileElement _name.
             * @member {"name"|undefined} _name
             * @memberof kritor.common.FileElement
             * @instance
             */
            Object.defineProperty(FileElement.prototype, "_name", {
                get: $util.oneOfGetter($oneOfFields = ["name"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * FileElement _size.
             * @member {"size"|undefined} _size
             * @memberof kritor.common.FileElement
             * @instance
             */
            Object.defineProperty(FileElement.prototype, "_size", {
                get: $util.oneOfGetter($oneOfFields = ["size"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * FileElement _expireTime.
             * @member {"expireTime"|undefined} _expireTime
             * @memberof kritor.common.FileElement
             * @instance
             */
            Object.defineProperty(FileElement.prototype, "_expireTime", {
                get: $util.oneOfGetter($oneOfFields = ["expireTime"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * FileElement _id.
             * @member {"id"|undefined} _id
             * @memberof kritor.common.FileElement
             * @instance
             */
            Object.defineProperty(FileElement.prototype, "_id", {
                get: $util.oneOfGetter($oneOfFields = ["id"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * FileElement _url.
             * @member {"url"|undefined} _url
             * @memberof kritor.common.FileElement
             * @instance
             */
            Object.defineProperty(FileElement.prototype, "_url", {
                get: $util.oneOfGetter($oneOfFields = ["url"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * FileElement _biz.
             * @member {"biz"|undefined} _biz
             * @memberof kritor.common.FileElement
             * @instance
             */
            Object.defineProperty(FileElement.prototype, "_biz", {
                get: $util.oneOfGetter($oneOfFields = ["biz"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * FileElement _subId.
             * @member {"subId"|undefined} _subId
             * @memberof kritor.common.FileElement
             * @instance
             */
            Object.defineProperty(FileElement.prototype, "_subId", {
                get: $util.oneOfGetter($oneOfFields = ["subId"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new FileElement instance using the specified properties.
             * @function create
             * @memberof kritor.common.FileElement
             * @static
             * @param {kritor.common.IFileElement=} [properties] Properties to set
             * @returns {kritor.common.FileElement} FileElement instance
             */
            FileElement.create = function create(properties) {
                return new FileElement(properties);
            };

            /**
             * Encodes the specified FileElement message. Does not implicitly {@link kritor.common.FileElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.FileElement
             * @static
             * @param {kritor.common.IFileElement} message FileElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.size != null && Object.hasOwnProperty.call(message, "size"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.size);
                if (message.expireTime != null && Object.hasOwnProperty.call(message, "expireTime"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.expireTime);
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.id);
                if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.url);
                if (message.biz != null && Object.hasOwnProperty.call(message, "biz"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.biz);
                if (message.subId != null && Object.hasOwnProperty.call(message, "subId"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.subId);
                return writer;
            };

            /**
             * Encodes the specified FileElement message, length delimited. Does not implicitly {@link kritor.common.FileElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.FileElement
             * @static
             * @param {kritor.common.IFileElement} message FileElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FileElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.FileElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.FileElement} FileElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.FileElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.name = reader.string();
                            break;
                        }
                    case 2: {
                            message.size = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.expireTime = reader.uint64();
                            break;
                        }
                    case 4: {
                            message.id = reader.string();
                            break;
                        }
                    case 5: {
                            message.url = reader.string();
                            break;
                        }
                    case 6: {
                            message.biz = reader.int32();
                            break;
                        }
                    case 7: {
                            message.subId = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FileElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.FileElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.FileElement} FileElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FileElement message.
             * @function verify
             * @memberof kritor.common.FileElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FileElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.name != null && message.hasOwnProperty("name")) {
                    properties._name = 1;
                    if (!$util.isString(message.name))
                        return "name: string expected";
                }
                if (message.size != null && message.hasOwnProperty("size")) {
                    properties._size = 1;
                    if (!$util.isInteger(message.size) && !(message.size && $util.isInteger(message.size.low) && $util.isInteger(message.size.high)))
                        return "size: integer|Long expected";
                }
                if (message.expireTime != null && message.hasOwnProperty("expireTime")) {
                    properties._expireTime = 1;
                    if (!$util.isInteger(message.expireTime) && !(message.expireTime && $util.isInteger(message.expireTime.low) && $util.isInteger(message.expireTime.high)))
                        return "expireTime: integer|Long expected";
                }
                if (message.id != null && message.hasOwnProperty("id")) {
                    properties._id = 1;
                    if (!$util.isString(message.id))
                        return "id: string expected";
                }
                if (message.url != null && message.hasOwnProperty("url")) {
                    properties._url = 1;
                    if (!$util.isString(message.url))
                        return "url: string expected";
                }
                if (message.biz != null && message.hasOwnProperty("biz")) {
                    properties._biz = 1;
                    if (!$util.isInteger(message.biz))
                        return "biz: integer expected";
                }
                if (message.subId != null && message.hasOwnProperty("subId")) {
                    properties._subId = 1;
                    if (!$util.isString(message.subId))
                        return "subId: string expected";
                }
                return null;
            };

            /**
             * Creates a FileElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.FileElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.FileElement} FileElement
             */
            FileElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.FileElement)
                    return object;
                let message = new $root.kritor.common.FileElement();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.size != null)
                    if ($util.Long)
                        (message.size = $util.Long.fromValue(object.size)).unsigned = true;
                    else if (typeof object.size === "string")
                        message.size = parseInt(object.size, 10);
                    else if (typeof object.size === "number")
                        message.size = object.size;
                    else if (typeof object.size === "object")
                        message.size = new $util.LongBits(object.size.low >>> 0, object.size.high >>> 0).toNumber(true);
                if (object.expireTime != null)
                    if ($util.Long)
                        (message.expireTime = $util.Long.fromValue(object.expireTime)).unsigned = true;
                    else if (typeof object.expireTime === "string")
                        message.expireTime = parseInt(object.expireTime, 10);
                    else if (typeof object.expireTime === "number")
                        message.expireTime = object.expireTime;
                    else if (typeof object.expireTime === "object")
                        message.expireTime = new $util.LongBits(object.expireTime.low >>> 0, object.expireTime.high >>> 0).toNumber(true);
                if (object.id != null)
                    message.id = String(object.id);
                if (object.url != null)
                    message.url = String(object.url);
                if (object.biz != null)
                    message.biz = object.biz | 0;
                if (object.subId != null)
                    message.subId = String(object.subId);
                return message;
            };

            /**
             * Creates a plain object from a FileElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.FileElement
             * @static
             * @param {kritor.common.FileElement} message FileElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FileElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (message.name != null && message.hasOwnProperty("name")) {
                    object.name = message.name;
                    if (options.oneofs)
                        object._name = "name";
                }
                if (message.size != null && message.hasOwnProperty("size")) {
                    if (typeof message.size === "number")
                        object.size = options.longs === String ? String(message.size) : message.size;
                    else
                        object.size = options.longs === String ? $util.Long.prototype.toString.call(message.size) : options.longs === Number ? new $util.LongBits(message.size.low >>> 0, message.size.high >>> 0).toNumber(true) : message.size;
                    if (options.oneofs)
                        object._size = "size";
                }
                if (message.expireTime != null && message.hasOwnProperty("expireTime")) {
                    if (typeof message.expireTime === "number")
                        object.expireTime = options.longs === String ? String(message.expireTime) : message.expireTime;
                    else
                        object.expireTime = options.longs === String ? $util.Long.prototype.toString.call(message.expireTime) : options.longs === Number ? new $util.LongBits(message.expireTime.low >>> 0, message.expireTime.high >>> 0).toNumber(true) : message.expireTime;
                    if (options.oneofs)
                        object._expireTime = "expireTime";
                }
                if (message.id != null && message.hasOwnProperty("id")) {
                    object.id = message.id;
                    if (options.oneofs)
                        object._id = "id";
                }
                if (message.url != null && message.hasOwnProperty("url")) {
                    object.url = message.url;
                    if (options.oneofs)
                        object._url = "url";
                }
                if (message.biz != null && message.hasOwnProperty("biz")) {
                    object.biz = message.biz;
                    if (options.oneofs)
                        object._biz = "biz";
                }
                if (message.subId != null && message.hasOwnProperty("subId")) {
                    object.subId = message.subId;
                    if (options.oneofs)
                        object._subId = "subId";
                }
                return object;
            };

            /**
             * Converts this FileElement to JSON.
             * @function toJSON
             * @memberof kritor.common.FileElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FileElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for FileElement
             * @function getTypeUrl
             * @memberof kritor.common.FileElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            FileElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.FileElement";
            };

            return FileElement;
        })();

        common.MarkdownElement = (function() {

            /**
             * Properties of a MarkdownElement.
             * @memberof kritor.common
             * @interface IMarkdownElement
             * @property {string|null} [markdown] MarkdownElement markdown
             */

            /**
             * Constructs a new MarkdownElement.
             * @memberof kritor.common
             * @classdesc Represents a MarkdownElement.
             * @implements IMarkdownElement
             * @constructor
             * @param {kritor.common.IMarkdownElement=} [properties] Properties to set
             */
            function MarkdownElement(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MarkdownElement markdown.
             * @member {string} markdown
             * @memberof kritor.common.MarkdownElement
             * @instance
             */
            MarkdownElement.prototype.markdown = "";

            /**
             * Creates a new MarkdownElement instance using the specified properties.
             * @function create
             * @memberof kritor.common.MarkdownElement
             * @static
             * @param {kritor.common.IMarkdownElement=} [properties] Properties to set
             * @returns {kritor.common.MarkdownElement} MarkdownElement instance
             */
            MarkdownElement.create = function create(properties) {
                return new MarkdownElement(properties);
            };

            /**
             * Encodes the specified MarkdownElement message. Does not implicitly {@link kritor.common.MarkdownElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.MarkdownElement
             * @static
             * @param {kritor.common.IMarkdownElement} message MarkdownElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MarkdownElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.markdown != null && Object.hasOwnProperty.call(message, "markdown"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.markdown);
                return writer;
            };

            /**
             * Encodes the specified MarkdownElement message, length delimited. Does not implicitly {@link kritor.common.MarkdownElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.MarkdownElement
             * @static
             * @param {kritor.common.IMarkdownElement} message MarkdownElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MarkdownElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MarkdownElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.MarkdownElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.MarkdownElement} MarkdownElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MarkdownElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.MarkdownElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.markdown = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MarkdownElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.MarkdownElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.MarkdownElement} MarkdownElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MarkdownElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MarkdownElement message.
             * @function verify
             * @memberof kritor.common.MarkdownElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MarkdownElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.markdown != null && message.hasOwnProperty("markdown"))
                    if (!$util.isString(message.markdown))
                        return "markdown: string expected";
                return null;
            };

            /**
             * Creates a MarkdownElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.MarkdownElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.MarkdownElement} MarkdownElement
             */
            MarkdownElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.MarkdownElement)
                    return object;
                let message = new $root.kritor.common.MarkdownElement();
                if (object.markdown != null)
                    message.markdown = String(object.markdown);
                return message;
            };

            /**
             * Creates a plain object from a MarkdownElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.MarkdownElement
             * @static
             * @param {kritor.common.MarkdownElement} message MarkdownElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MarkdownElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.markdown = "";
                if (message.markdown != null && message.hasOwnProperty("markdown"))
                    object.markdown = message.markdown;
                return object;
            };

            /**
             * Converts this MarkdownElement to JSON.
             * @function toJSON
             * @memberof kritor.common.MarkdownElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MarkdownElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MarkdownElement
             * @function getTypeUrl
             * @memberof kritor.common.MarkdownElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MarkdownElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.MarkdownElement";
            };

            return MarkdownElement;
        })();

        common.ButtonActionPermission = (function() {

            /**
             * Properties of a ButtonActionPermission.
             * @memberof kritor.common
             * @interface IButtonActionPermission
             * @property {number|null} [type] ButtonActionPermission type
             * @property {Array.<string>|null} [roleIds] ButtonActionPermission roleIds
             * @property {Array.<string>|null} [userIds] ButtonActionPermission userIds
             */

            /**
             * Constructs a new ButtonActionPermission.
             * @memberof kritor.common
             * @classdesc Represents a ButtonActionPermission.
             * @implements IButtonActionPermission
             * @constructor
             * @param {kritor.common.IButtonActionPermission=} [properties] Properties to set
             */
            function ButtonActionPermission(properties) {
                this.roleIds = [];
                this.userIds = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ButtonActionPermission type.
             * @member {number} type
             * @memberof kritor.common.ButtonActionPermission
             * @instance
             */
            ButtonActionPermission.prototype.type = 0;

            /**
             * ButtonActionPermission roleIds.
             * @member {Array.<string>} roleIds
             * @memberof kritor.common.ButtonActionPermission
             * @instance
             */
            ButtonActionPermission.prototype.roleIds = $util.emptyArray;

            /**
             * ButtonActionPermission userIds.
             * @member {Array.<string>} userIds
             * @memberof kritor.common.ButtonActionPermission
             * @instance
             */
            ButtonActionPermission.prototype.userIds = $util.emptyArray;

            /**
             * Creates a new ButtonActionPermission instance using the specified properties.
             * @function create
             * @memberof kritor.common.ButtonActionPermission
             * @static
             * @param {kritor.common.IButtonActionPermission=} [properties] Properties to set
             * @returns {kritor.common.ButtonActionPermission} ButtonActionPermission instance
             */
            ButtonActionPermission.create = function create(properties) {
                return new ButtonActionPermission(properties);
            };

            /**
             * Encodes the specified ButtonActionPermission message. Does not implicitly {@link kritor.common.ButtonActionPermission.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.ButtonActionPermission
             * @static
             * @param {kritor.common.IButtonActionPermission} message ButtonActionPermission message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ButtonActionPermission.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.roleIds != null && message.roleIds.length)
                    for (let i = 0; i < message.roleIds.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.roleIds[i]);
                if (message.userIds != null && message.userIds.length)
                    for (let i = 0; i < message.userIds.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.userIds[i]);
                return writer;
            };

            /**
             * Encodes the specified ButtonActionPermission message, length delimited. Does not implicitly {@link kritor.common.ButtonActionPermission.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.ButtonActionPermission
             * @static
             * @param {kritor.common.IButtonActionPermission} message ButtonActionPermission message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ButtonActionPermission.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ButtonActionPermission message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.ButtonActionPermission
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.ButtonActionPermission} ButtonActionPermission
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ButtonActionPermission.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.ButtonActionPermission();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.type = reader.int32();
                            break;
                        }
                    case 2: {
                            if (!(message.roleIds && message.roleIds.length))
                                message.roleIds = [];
                            message.roleIds.push(reader.string());
                            break;
                        }
                    case 3: {
                            if (!(message.userIds && message.userIds.length))
                                message.userIds = [];
                            message.userIds.push(reader.string());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ButtonActionPermission message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.ButtonActionPermission
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.ButtonActionPermission} ButtonActionPermission
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ButtonActionPermission.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ButtonActionPermission message.
             * @function verify
             * @memberof kritor.common.ButtonActionPermission
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ButtonActionPermission.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    if (!$util.isInteger(message.type))
                        return "type: integer expected";
                if (message.roleIds != null && message.hasOwnProperty("roleIds")) {
                    if (!Array.isArray(message.roleIds))
                        return "roleIds: array expected";
                    for (let i = 0; i < message.roleIds.length; ++i)
                        if (!$util.isString(message.roleIds[i]))
                            return "roleIds: string[] expected";
                }
                if (message.userIds != null && message.hasOwnProperty("userIds")) {
                    if (!Array.isArray(message.userIds))
                        return "userIds: array expected";
                    for (let i = 0; i < message.userIds.length; ++i)
                        if (!$util.isString(message.userIds[i]))
                            return "userIds: string[] expected";
                }
                return null;
            };

            /**
             * Creates a ButtonActionPermission message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.ButtonActionPermission
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.ButtonActionPermission} ButtonActionPermission
             */
            ButtonActionPermission.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.ButtonActionPermission)
                    return object;
                let message = new $root.kritor.common.ButtonActionPermission();
                if (object.type != null)
                    message.type = object.type | 0;
                if (object.roleIds) {
                    if (!Array.isArray(object.roleIds))
                        throw TypeError(".kritor.common.ButtonActionPermission.roleIds: array expected");
                    message.roleIds = [];
                    for (let i = 0; i < object.roleIds.length; ++i)
                        message.roleIds[i] = String(object.roleIds[i]);
                }
                if (object.userIds) {
                    if (!Array.isArray(object.userIds))
                        throw TypeError(".kritor.common.ButtonActionPermission.userIds: array expected");
                    message.userIds = [];
                    for (let i = 0; i < object.userIds.length; ++i)
                        message.userIds[i] = String(object.userIds[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a ButtonActionPermission message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.ButtonActionPermission
             * @static
             * @param {kritor.common.ButtonActionPermission} message ButtonActionPermission
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ButtonActionPermission.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.roleIds = [];
                    object.userIds = [];
                }
                if (options.defaults)
                    object.type = 0;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = message.type;
                if (message.roleIds && message.roleIds.length) {
                    object.roleIds = [];
                    for (let j = 0; j < message.roleIds.length; ++j)
                        object.roleIds[j] = message.roleIds[j];
                }
                if (message.userIds && message.userIds.length) {
                    object.userIds = [];
                    for (let j = 0; j < message.userIds.length; ++j)
                        object.userIds[j] = message.userIds[j];
                }
                return object;
            };

            /**
             * Converts this ButtonActionPermission to JSON.
             * @function toJSON
             * @memberof kritor.common.ButtonActionPermission
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ButtonActionPermission.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ButtonActionPermission
             * @function getTypeUrl
             * @memberof kritor.common.ButtonActionPermission
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ButtonActionPermission.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.ButtonActionPermission";
            };

            return ButtonActionPermission;
        })();

        common.ButtonAction = (function() {

            /**
             * Properties of a ButtonAction.
             * @memberof kritor.common
             * @interface IButtonAction
             * @property {number|null} [type] ButtonAction type
             * @property {kritor.common.IButtonActionPermission|null} [permission] ButtonAction permission
             * @property {string|null} [unsupportedTips] ButtonAction unsupportedTips
             * @property {string|null} [data] ButtonAction data
             * @property {boolean|null} [reply] ButtonAction reply
             * @property {boolean|null} [enter] ButtonAction enter
             */

            /**
             * Constructs a new ButtonAction.
             * @memberof kritor.common
             * @classdesc Represents a ButtonAction.
             * @implements IButtonAction
             * @constructor
             * @param {kritor.common.IButtonAction=} [properties] Properties to set
             */
            function ButtonAction(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ButtonAction type.
             * @member {number} type
             * @memberof kritor.common.ButtonAction
             * @instance
             */
            ButtonAction.prototype.type = 0;

            /**
             * ButtonAction permission.
             * @member {kritor.common.IButtonActionPermission|null|undefined} permission
             * @memberof kritor.common.ButtonAction
             * @instance
             */
            ButtonAction.prototype.permission = null;

            /**
             * ButtonAction unsupportedTips.
             * @member {string} unsupportedTips
             * @memberof kritor.common.ButtonAction
             * @instance
             */
            ButtonAction.prototype.unsupportedTips = "";

            /**
             * ButtonAction data.
             * @member {string} data
             * @memberof kritor.common.ButtonAction
             * @instance
             */
            ButtonAction.prototype.data = "";

            /**
             * ButtonAction reply.
             * @member {boolean} reply
             * @memberof kritor.common.ButtonAction
             * @instance
             */
            ButtonAction.prototype.reply = false;

            /**
             * ButtonAction enter.
             * @member {boolean} enter
             * @memberof kritor.common.ButtonAction
             * @instance
             */
            ButtonAction.prototype.enter = false;

            /**
             * Creates a new ButtonAction instance using the specified properties.
             * @function create
             * @memberof kritor.common.ButtonAction
             * @static
             * @param {kritor.common.IButtonAction=} [properties] Properties to set
             * @returns {kritor.common.ButtonAction} ButtonAction instance
             */
            ButtonAction.create = function create(properties) {
                return new ButtonAction(properties);
            };

            /**
             * Encodes the specified ButtonAction message. Does not implicitly {@link kritor.common.ButtonAction.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.ButtonAction
             * @static
             * @param {kritor.common.IButtonAction} message ButtonAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ButtonAction.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.permission != null && Object.hasOwnProperty.call(message, "permission"))
                    $root.kritor.common.ButtonActionPermission.encode(message.permission, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.unsupportedTips != null && Object.hasOwnProperty.call(message, "unsupportedTips"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.unsupportedTips);
                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.data);
                if (message.reply != null && Object.hasOwnProperty.call(message, "reply"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.reply);
                if (message.enter != null && Object.hasOwnProperty.call(message, "enter"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.enter);
                return writer;
            };

            /**
             * Encodes the specified ButtonAction message, length delimited. Does not implicitly {@link kritor.common.ButtonAction.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.ButtonAction
             * @static
             * @param {kritor.common.IButtonAction} message ButtonAction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ButtonAction.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ButtonAction message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.ButtonAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.ButtonAction} ButtonAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ButtonAction.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.ButtonAction();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.type = reader.int32();
                            break;
                        }
                    case 2: {
                            message.permission = $root.kritor.common.ButtonActionPermission.decode(reader, reader.uint32());
                            break;
                        }
                    case 3: {
                            message.unsupportedTips = reader.string();
                            break;
                        }
                    case 4: {
                            message.data = reader.string();
                            break;
                        }
                    case 5: {
                            message.reply = reader.bool();
                            break;
                        }
                    case 6: {
                            message.enter = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ButtonAction message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.ButtonAction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.ButtonAction} ButtonAction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ButtonAction.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ButtonAction message.
             * @function verify
             * @memberof kritor.common.ButtonAction
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ButtonAction.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    if (!$util.isInteger(message.type))
                        return "type: integer expected";
                if (message.permission != null && message.hasOwnProperty("permission")) {
                    let error = $root.kritor.common.ButtonActionPermission.verify(message.permission);
                    if (error)
                        return "permission." + error;
                }
                if (message.unsupportedTips != null && message.hasOwnProperty("unsupportedTips"))
                    if (!$util.isString(message.unsupportedTips))
                        return "unsupportedTips: string expected";
                if (message.data != null && message.hasOwnProperty("data"))
                    if (!$util.isString(message.data))
                        return "data: string expected";
                if (message.reply != null && message.hasOwnProperty("reply"))
                    if (typeof message.reply !== "boolean")
                        return "reply: boolean expected";
                if (message.enter != null && message.hasOwnProperty("enter"))
                    if (typeof message.enter !== "boolean")
                        return "enter: boolean expected";
                return null;
            };

            /**
             * Creates a ButtonAction message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.ButtonAction
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.ButtonAction} ButtonAction
             */
            ButtonAction.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.ButtonAction)
                    return object;
                let message = new $root.kritor.common.ButtonAction();
                if (object.type != null)
                    message.type = object.type | 0;
                if (object.permission != null) {
                    if (typeof object.permission !== "object")
                        throw TypeError(".kritor.common.ButtonAction.permission: object expected");
                    message.permission = $root.kritor.common.ButtonActionPermission.fromObject(object.permission);
                }
                if (object.unsupportedTips != null)
                    message.unsupportedTips = String(object.unsupportedTips);
                if (object.data != null)
                    message.data = String(object.data);
                if (object.reply != null)
                    message.reply = Boolean(object.reply);
                if (object.enter != null)
                    message.enter = Boolean(object.enter);
                return message;
            };

            /**
             * Creates a plain object from a ButtonAction message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.ButtonAction
             * @static
             * @param {kritor.common.ButtonAction} message ButtonAction
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ButtonAction.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.type = 0;
                    object.permission = null;
                    object.unsupportedTips = "";
                    object.data = "";
                    object.reply = false;
                    object.enter = false;
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = message.type;
                if (message.permission != null && message.hasOwnProperty("permission"))
                    object.permission = $root.kritor.common.ButtonActionPermission.toObject(message.permission, options);
                if (message.unsupportedTips != null && message.hasOwnProperty("unsupportedTips"))
                    object.unsupportedTips = message.unsupportedTips;
                if (message.data != null && message.hasOwnProperty("data"))
                    object.data = message.data;
                if (message.reply != null && message.hasOwnProperty("reply"))
                    object.reply = message.reply;
                if (message.enter != null && message.hasOwnProperty("enter"))
                    object.enter = message.enter;
                return object;
            };

            /**
             * Converts this ButtonAction to JSON.
             * @function toJSON
             * @memberof kritor.common.ButtonAction
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ButtonAction.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ButtonAction
             * @function getTypeUrl
             * @memberof kritor.common.ButtonAction
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ButtonAction.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.ButtonAction";
            };

            return ButtonAction;
        })();

        common.ButtonRender = (function() {

            /**
             * Properties of a ButtonRender.
             * @memberof kritor.common
             * @interface IButtonRender
             * @property {string|null} [label] ButtonRender label
             * @property {string|null} [visitedLabel] ButtonRender visitedLabel
             * @property {number|null} [style] ButtonRender style
             */

            /**
             * Constructs a new ButtonRender.
             * @memberof kritor.common
             * @classdesc Represents a ButtonRender.
             * @implements IButtonRender
             * @constructor
             * @param {kritor.common.IButtonRender=} [properties] Properties to set
             */
            function ButtonRender(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ButtonRender label.
             * @member {string} label
             * @memberof kritor.common.ButtonRender
             * @instance
             */
            ButtonRender.prototype.label = "";

            /**
             * ButtonRender visitedLabel.
             * @member {string} visitedLabel
             * @memberof kritor.common.ButtonRender
             * @instance
             */
            ButtonRender.prototype.visitedLabel = "";

            /**
             * ButtonRender style.
             * @member {number} style
             * @memberof kritor.common.ButtonRender
             * @instance
             */
            ButtonRender.prototype.style = 0;

            /**
             * Creates a new ButtonRender instance using the specified properties.
             * @function create
             * @memberof kritor.common.ButtonRender
             * @static
             * @param {kritor.common.IButtonRender=} [properties] Properties to set
             * @returns {kritor.common.ButtonRender} ButtonRender instance
             */
            ButtonRender.create = function create(properties) {
                return new ButtonRender(properties);
            };

            /**
             * Encodes the specified ButtonRender message. Does not implicitly {@link kritor.common.ButtonRender.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.ButtonRender
             * @static
             * @param {kritor.common.IButtonRender} message ButtonRender message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ButtonRender.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.label != null && Object.hasOwnProperty.call(message, "label"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.label);
                if (message.visitedLabel != null && Object.hasOwnProperty.call(message, "visitedLabel"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.visitedLabel);
                if (message.style != null && Object.hasOwnProperty.call(message, "style"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.style);
                return writer;
            };

            /**
             * Encodes the specified ButtonRender message, length delimited. Does not implicitly {@link kritor.common.ButtonRender.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.ButtonRender
             * @static
             * @param {kritor.common.IButtonRender} message ButtonRender message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ButtonRender.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ButtonRender message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.ButtonRender
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.ButtonRender} ButtonRender
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ButtonRender.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.ButtonRender();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.label = reader.string();
                            break;
                        }
                    case 2: {
                            message.visitedLabel = reader.string();
                            break;
                        }
                    case 3: {
                            message.style = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ButtonRender message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.ButtonRender
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.ButtonRender} ButtonRender
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ButtonRender.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ButtonRender message.
             * @function verify
             * @memberof kritor.common.ButtonRender
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ButtonRender.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.label != null && message.hasOwnProperty("label"))
                    if (!$util.isString(message.label))
                        return "label: string expected";
                if (message.visitedLabel != null && message.hasOwnProperty("visitedLabel"))
                    if (!$util.isString(message.visitedLabel))
                        return "visitedLabel: string expected";
                if (message.style != null && message.hasOwnProperty("style"))
                    if (!$util.isInteger(message.style))
                        return "style: integer expected";
                return null;
            };

            /**
             * Creates a ButtonRender message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.ButtonRender
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.ButtonRender} ButtonRender
             */
            ButtonRender.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.ButtonRender)
                    return object;
                let message = new $root.kritor.common.ButtonRender();
                if (object.label != null)
                    message.label = String(object.label);
                if (object.visitedLabel != null)
                    message.visitedLabel = String(object.visitedLabel);
                if (object.style != null)
                    message.style = object.style | 0;
                return message;
            };

            /**
             * Creates a plain object from a ButtonRender message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.ButtonRender
             * @static
             * @param {kritor.common.ButtonRender} message ButtonRender
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ButtonRender.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.label = "";
                    object.visitedLabel = "";
                    object.style = 0;
                }
                if (message.label != null && message.hasOwnProperty("label"))
                    object.label = message.label;
                if (message.visitedLabel != null && message.hasOwnProperty("visitedLabel"))
                    object.visitedLabel = message.visitedLabel;
                if (message.style != null && message.hasOwnProperty("style"))
                    object.style = message.style;
                return object;
            };

            /**
             * Converts this ButtonRender to JSON.
             * @function toJSON
             * @memberof kritor.common.ButtonRender
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ButtonRender.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ButtonRender
             * @function getTypeUrl
             * @memberof kritor.common.ButtonRender
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ButtonRender.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.ButtonRender";
            };

            return ButtonRender;
        })();

        common.Button = (function() {

            /**
             * Properties of a Button.
             * @memberof kritor.common
             * @interface IButton
             * @property {string|null} [id] Button id
             * @property {kritor.common.IButtonRender|null} [renderData] Button renderData
             * @property {kritor.common.IButtonAction|null} [action] Button action
             */

            /**
             * Constructs a new Button.
             * @memberof kritor.common
             * @classdesc Represents a Button.
             * @implements IButton
             * @constructor
             * @param {kritor.common.IButton=} [properties] Properties to set
             */
            function Button(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Button id.
             * @member {string} id
             * @memberof kritor.common.Button
             * @instance
             */
            Button.prototype.id = "";

            /**
             * Button renderData.
             * @member {kritor.common.IButtonRender|null|undefined} renderData
             * @memberof kritor.common.Button
             * @instance
             */
            Button.prototype.renderData = null;

            /**
             * Button action.
             * @member {kritor.common.IButtonAction|null|undefined} action
             * @memberof kritor.common.Button
             * @instance
             */
            Button.prototype.action = null;

            /**
             * Creates a new Button instance using the specified properties.
             * @function create
             * @memberof kritor.common.Button
             * @static
             * @param {kritor.common.IButton=} [properties] Properties to set
             * @returns {kritor.common.Button} Button instance
             */
            Button.create = function create(properties) {
                return new Button(properties);
            };

            /**
             * Encodes the specified Button message. Does not implicitly {@link kritor.common.Button.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.Button
             * @static
             * @param {kritor.common.IButton} message Button message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Button.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.renderData != null && Object.hasOwnProperty.call(message, "renderData"))
                    $root.kritor.common.ButtonRender.encode(message.renderData, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.action != null && Object.hasOwnProperty.call(message, "action"))
                    $root.kritor.common.ButtonAction.encode(message.action, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Button message, length delimited. Does not implicitly {@link kritor.common.Button.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.Button
             * @static
             * @param {kritor.common.IButton} message Button message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Button.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Button message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.Button
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.Button} Button
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Button.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.Button();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.id = reader.string();
                            break;
                        }
                    case 2: {
                            message.renderData = $root.kritor.common.ButtonRender.decode(reader, reader.uint32());
                            break;
                        }
                    case 3: {
                            message.action = $root.kritor.common.ButtonAction.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Button message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.Button
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.Button} Button
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Button.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Button message.
             * @function verify
             * @memberof kritor.common.Button
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Button.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.renderData != null && message.hasOwnProperty("renderData")) {
                    let error = $root.kritor.common.ButtonRender.verify(message.renderData);
                    if (error)
                        return "renderData." + error;
                }
                if (message.action != null && message.hasOwnProperty("action")) {
                    let error = $root.kritor.common.ButtonAction.verify(message.action);
                    if (error)
                        return "action." + error;
                }
                return null;
            };

            /**
             * Creates a Button message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.Button
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.Button} Button
             */
            Button.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.Button)
                    return object;
                let message = new $root.kritor.common.Button();
                if (object.id != null)
                    message.id = String(object.id);
                if (object.renderData != null) {
                    if (typeof object.renderData !== "object")
                        throw TypeError(".kritor.common.Button.renderData: object expected");
                    message.renderData = $root.kritor.common.ButtonRender.fromObject(object.renderData);
                }
                if (object.action != null) {
                    if (typeof object.action !== "object")
                        throw TypeError(".kritor.common.Button.action: object expected");
                    message.action = $root.kritor.common.ButtonAction.fromObject(object.action);
                }
                return message;
            };

            /**
             * Creates a plain object from a Button message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.Button
             * @static
             * @param {kritor.common.Button} message Button
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Button.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.id = "";
                    object.renderData = null;
                    object.action = null;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.renderData != null && message.hasOwnProperty("renderData"))
                    object.renderData = $root.kritor.common.ButtonRender.toObject(message.renderData, options);
                if (message.action != null && message.hasOwnProperty("action"))
                    object.action = $root.kritor.common.ButtonAction.toObject(message.action, options);
                return object;
            };

            /**
             * Converts this Button to JSON.
             * @function toJSON
             * @memberof kritor.common.Button
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Button.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Button
             * @function getTypeUrl
             * @memberof kritor.common.Button
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Button.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.Button";
            };

            return Button;
        })();

        common.KeyboardRow = (function() {

            /**
             * Properties of a KeyboardRow.
             * @memberof kritor.common
             * @interface IKeyboardRow
             * @property {Array.<kritor.common.IButton>|null} [buttons] KeyboardRow buttons
             */

            /**
             * Constructs a new KeyboardRow.
             * @memberof kritor.common
             * @classdesc Represents a KeyboardRow.
             * @implements IKeyboardRow
             * @constructor
             * @param {kritor.common.IKeyboardRow=} [properties] Properties to set
             */
            function KeyboardRow(properties) {
                this.buttons = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * KeyboardRow buttons.
             * @member {Array.<kritor.common.IButton>} buttons
             * @memberof kritor.common.KeyboardRow
             * @instance
             */
            KeyboardRow.prototype.buttons = $util.emptyArray;

            /**
             * Creates a new KeyboardRow instance using the specified properties.
             * @function create
             * @memberof kritor.common.KeyboardRow
             * @static
             * @param {kritor.common.IKeyboardRow=} [properties] Properties to set
             * @returns {kritor.common.KeyboardRow} KeyboardRow instance
             */
            KeyboardRow.create = function create(properties) {
                return new KeyboardRow(properties);
            };

            /**
             * Encodes the specified KeyboardRow message. Does not implicitly {@link kritor.common.KeyboardRow.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.KeyboardRow
             * @static
             * @param {kritor.common.IKeyboardRow} message KeyboardRow message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KeyboardRow.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.buttons != null && message.buttons.length)
                    for (let i = 0; i < message.buttons.length; ++i)
                        $root.kritor.common.Button.encode(message.buttons[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified KeyboardRow message, length delimited. Does not implicitly {@link kritor.common.KeyboardRow.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.KeyboardRow
             * @static
             * @param {kritor.common.IKeyboardRow} message KeyboardRow message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KeyboardRow.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KeyboardRow message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.KeyboardRow
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.KeyboardRow} KeyboardRow
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KeyboardRow.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.KeyboardRow();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.buttons && message.buttons.length))
                                message.buttons = [];
                            message.buttons.push($root.kritor.common.Button.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KeyboardRow message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.KeyboardRow
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.KeyboardRow} KeyboardRow
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KeyboardRow.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KeyboardRow message.
             * @function verify
             * @memberof kritor.common.KeyboardRow
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KeyboardRow.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.buttons != null && message.hasOwnProperty("buttons")) {
                    if (!Array.isArray(message.buttons))
                        return "buttons: array expected";
                    for (let i = 0; i < message.buttons.length; ++i) {
                        let error = $root.kritor.common.Button.verify(message.buttons[i]);
                        if (error)
                            return "buttons." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a KeyboardRow message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.KeyboardRow
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.KeyboardRow} KeyboardRow
             */
            KeyboardRow.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.KeyboardRow)
                    return object;
                let message = new $root.kritor.common.KeyboardRow();
                if (object.buttons) {
                    if (!Array.isArray(object.buttons))
                        throw TypeError(".kritor.common.KeyboardRow.buttons: array expected");
                    message.buttons = [];
                    for (let i = 0; i < object.buttons.length; ++i) {
                        if (typeof object.buttons[i] !== "object")
                            throw TypeError(".kritor.common.KeyboardRow.buttons: object expected");
                        message.buttons[i] = $root.kritor.common.Button.fromObject(object.buttons[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a KeyboardRow message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.KeyboardRow
             * @static
             * @param {kritor.common.KeyboardRow} message KeyboardRow
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KeyboardRow.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.buttons = [];
                if (message.buttons && message.buttons.length) {
                    object.buttons = [];
                    for (let j = 0; j < message.buttons.length; ++j)
                        object.buttons[j] = $root.kritor.common.Button.toObject(message.buttons[j], options);
                }
                return object;
            };

            /**
             * Converts this KeyboardRow to JSON.
             * @function toJSON
             * @memberof kritor.common.KeyboardRow
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KeyboardRow.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for KeyboardRow
             * @function getTypeUrl
             * @memberof kritor.common.KeyboardRow
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            KeyboardRow.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.KeyboardRow";
            };

            return KeyboardRow;
        })();

        common.KeyboardElement = (function() {

            /**
             * Properties of a KeyboardElement.
             * @memberof kritor.common
             * @interface IKeyboardElement
             * @property {Array.<kritor.common.IKeyboardRow>|null} [rows] KeyboardElement rows
             * @property {number|Long|null} [botAppid] KeyboardElement botAppid
             */

            /**
             * Constructs a new KeyboardElement.
             * @memberof kritor.common
             * @classdesc Represents a KeyboardElement.
             * @implements IKeyboardElement
             * @constructor
             * @param {kritor.common.IKeyboardElement=} [properties] Properties to set
             */
            function KeyboardElement(properties) {
                this.rows = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * KeyboardElement rows.
             * @member {Array.<kritor.common.IKeyboardRow>} rows
             * @memberof kritor.common.KeyboardElement
             * @instance
             */
            KeyboardElement.prototype.rows = $util.emptyArray;

            /**
             * KeyboardElement botAppid.
             * @member {number|Long} botAppid
             * @memberof kritor.common.KeyboardElement
             * @instance
             */
            KeyboardElement.prototype.botAppid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new KeyboardElement instance using the specified properties.
             * @function create
             * @memberof kritor.common.KeyboardElement
             * @static
             * @param {kritor.common.IKeyboardElement=} [properties] Properties to set
             * @returns {kritor.common.KeyboardElement} KeyboardElement instance
             */
            KeyboardElement.create = function create(properties) {
                return new KeyboardElement(properties);
            };

            /**
             * Encodes the specified KeyboardElement message. Does not implicitly {@link kritor.common.KeyboardElement.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.KeyboardElement
             * @static
             * @param {kritor.common.IKeyboardElement} message KeyboardElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KeyboardElement.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.rows != null && message.rows.length)
                    for (let i = 0; i < message.rows.length; ++i)
                        $root.kritor.common.KeyboardRow.encode(message.rows[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.botAppid != null && Object.hasOwnProperty.call(message, "botAppid"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.botAppid);
                return writer;
            };

            /**
             * Encodes the specified KeyboardElement message, length delimited. Does not implicitly {@link kritor.common.KeyboardElement.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.KeyboardElement
             * @static
             * @param {kritor.common.IKeyboardElement} message KeyboardElement message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KeyboardElement.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KeyboardElement message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.KeyboardElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.KeyboardElement} KeyboardElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KeyboardElement.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.KeyboardElement();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.rows && message.rows.length))
                                message.rows = [];
                            message.rows.push($root.kritor.common.KeyboardRow.decode(reader, reader.uint32()));
                            break;
                        }
                    case 2: {
                            message.botAppid = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KeyboardElement message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.KeyboardElement
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.KeyboardElement} KeyboardElement
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KeyboardElement.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KeyboardElement message.
             * @function verify
             * @memberof kritor.common.KeyboardElement
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KeyboardElement.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.rows != null && message.hasOwnProperty("rows")) {
                    if (!Array.isArray(message.rows))
                        return "rows: array expected";
                    for (let i = 0; i < message.rows.length; ++i) {
                        let error = $root.kritor.common.KeyboardRow.verify(message.rows[i]);
                        if (error)
                            return "rows." + error;
                    }
                }
                if (message.botAppid != null && message.hasOwnProperty("botAppid"))
                    if (!$util.isInteger(message.botAppid) && !(message.botAppid && $util.isInteger(message.botAppid.low) && $util.isInteger(message.botAppid.high)))
                        return "botAppid: integer|Long expected";
                return null;
            };

            /**
             * Creates a KeyboardElement message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.KeyboardElement
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.KeyboardElement} KeyboardElement
             */
            KeyboardElement.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.KeyboardElement)
                    return object;
                let message = new $root.kritor.common.KeyboardElement();
                if (object.rows) {
                    if (!Array.isArray(object.rows))
                        throw TypeError(".kritor.common.KeyboardElement.rows: array expected");
                    message.rows = [];
                    for (let i = 0; i < object.rows.length; ++i) {
                        if (typeof object.rows[i] !== "object")
                            throw TypeError(".kritor.common.KeyboardElement.rows: object expected");
                        message.rows[i] = $root.kritor.common.KeyboardRow.fromObject(object.rows[i]);
                    }
                }
                if (object.botAppid != null)
                    if ($util.Long)
                        (message.botAppid = $util.Long.fromValue(object.botAppid)).unsigned = true;
                    else if (typeof object.botAppid === "string")
                        message.botAppid = parseInt(object.botAppid, 10);
                    else if (typeof object.botAppid === "number")
                        message.botAppid = object.botAppid;
                    else if (typeof object.botAppid === "object")
                        message.botAppid = new $util.LongBits(object.botAppid.low >>> 0, object.botAppid.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a KeyboardElement message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.KeyboardElement
             * @static
             * @param {kritor.common.KeyboardElement} message KeyboardElement
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KeyboardElement.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.rows = [];
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.botAppid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.botAppid = options.longs === String ? "0" : 0;
                if (message.rows && message.rows.length) {
                    object.rows = [];
                    for (let j = 0; j < message.rows.length; ++j)
                        object.rows[j] = $root.kritor.common.KeyboardRow.toObject(message.rows[j], options);
                }
                if (message.botAppid != null && message.hasOwnProperty("botAppid"))
                    if (typeof message.botAppid === "number")
                        object.botAppid = options.longs === String ? String(message.botAppid) : message.botAppid;
                    else
                        object.botAppid = options.longs === String ? $util.Long.prototype.toString.call(message.botAppid) : options.longs === Number ? new $util.LongBits(message.botAppid.low >>> 0, message.botAppid.high >>> 0).toNumber(true) : message.botAppid;
                return object;
            };

            /**
             * Converts this KeyboardElement to JSON.
             * @function toJSON
             * @memberof kritor.common.KeyboardElement
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KeyboardElement.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for KeyboardElement
             * @function getTypeUrl
             * @memberof kritor.common.KeyboardElement
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            KeyboardElement.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.KeyboardElement";
            };

            return KeyboardElement;
        })();

        common.Request = (function() {

            /**
             * Properties of a Request.
             * @memberof kritor.common
             * @interface IRequest
             * @property {string|null} [cmd] Request cmd
             * @property {number|null} [seq] Request seq
             * @property {Uint8Array|null} [buf] Request buf
             * @property {boolean|null} [noResponse] Request noResponse
             */

            /**
             * Constructs a new Request.
             * @memberof kritor.common
             * @classdesc Represents a Request.
             * @implements IRequest
             * @constructor
             * @param {kritor.common.IRequest=} [properties] Properties to set
             */
            function Request(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Request cmd.
             * @member {string} cmd
             * @memberof kritor.common.Request
             * @instance
             */
            Request.prototype.cmd = "";

            /**
             * Request seq.
             * @member {number} seq
             * @memberof kritor.common.Request
             * @instance
             */
            Request.prototype.seq = 0;

            /**
             * Request buf.
             * @member {Uint8Array} buf
             * @memberof kritor.common.Request
             * @instance
             */
            Request.prototype.buf = $util.newBuffer([]);

            /**
             * Request noResponse.
             * @member {boolean} noResponse
             * @memberof kritor.common.Request
             * @instance
             */
            Request.prototype.noResponse = false;

            /**
             * Creates a new Request instance using the specified properties.
             * @function create
             * @memberof kritor.common.Request
             * @static
             * @param {kritor.common.IRequest=} [properties] Properties to set
             * @returns {kritor.common.Request} Request instance
             */
            Request.create = function create(properties) {
                return new Request(properties);
            };

            /**
             * Encodes the specified Request message. Does not implicitly {@link kritor.common.Request.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.Request
             * @static
             * @param {kritor.common.IRequest} message Request message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Request.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.cmd != null && Object.hasOwnProperty.call(message, "cmd"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.cmd);
                if (message.seq != null && Object.hasOwnProperty.call(message, "seq"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.seq);
                if (message.buf != null && Object.hasOwnProperty.call(message, "buf"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.buf);
                if (message.noResponse != null && Object.hasOwnProperty.call(message, "noResponse"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.noResponse);
                return writer;
            };

            /**
             * Encodes the specified Request message, length delimited. Does not implicitly {@link kritor.common.Request.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.Request
             * @static
             * @param {kritor.common.IRequest} message Request message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Request.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Request message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.Request
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.Request} Request
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Request.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.Request();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.cmd = reader.string();
                            break;
                        }
                    case 2: {
                            message.seq = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.buf = reader.bytes();
                            break;
                        }
                    case 4: {
                            message.noResponse = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Request message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.Request
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.Request} Request
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Request.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Request message.
             * @function verify
             * @memberof kritor.common.Request
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Request.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.cmd != null && message.hasOwnProperty("cmd"))
                    if (!$util.isString(message.cmd))
                        return "cmd: string expected";
                if (message.seq != null && message.hasOwnProperty("seq"))
                    if (!$util.isInteger(message.seq))
                        return "seq: integer expected";
                if (message.buf != null && message.hasOwnProperty("buf"))
                    if (!(message.buf && typeof message.buf.length === "number" || $util.isString(message.buf)))
                        return "buf: buffer expected";
                if (message.noResponse != null && message.hasOwnProperty("noResponse"))
                    if (typeof message.noResponse !== "boolean")
                        return "noResponse: boolean expected";
                return null;
            };

            /**
             * Creates a Request message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.Request
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.Request} Request
             */
            Request.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.Request)
                    return object;
                let message = new $root.kritor.common.Request();
                if (object.cmd != null)
                    message.cmd = String(object.cmd);
                if (object.seq != null)
                    message.seq = object.seq >>> 0;
                if (object.buf != null)
                    if (typeof object.buf === "string")
                        $util.base64.decode(object.buf, message.buf = $util.newBuffer($util.base64.length(object.buf)), 0);
                    else if (object.buf.length >= 0)
                        message.buf = object.buf;
                if (object.noResponse != null)
                    message.noResponse = Boolean(object.noResponse);
                return message;
            };

            /**
             * Creates a plain object from a Request message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.Request
             * @static
             * @param {kritor.common.Request} message Request
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Request.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.cmd = "";
                    object.seq = 0;
                    if (options.bytes === String)
                        object.buf = "";
                    else {
                        object.buf = [];
                        if (options.bytes !== Array)
                            object.buf = $util.newBuffer(object.buf);
                    }
                    object.noResponse = false;
                }
                if (message.cmd != null && message.hasOwnProperty("cmd"))
                    object.cmd = message.cmd;
                if (message.seq != null && message.hasOwnProperty("seq"))
                    object.seq = message.seq;
                if (message.buf != null && message.hasOwnProperty("buf"))
                    object.buf = options.bytes === String ? $util.base64.encode(message.buf, 0, message.buf.length) : options.bytes === Array ? Array.prototype.slice.call(message.buf) : message.buf;
                if (message.noResponse != null && message.hasOwnProperty("noResponse"))
                    object.noResponse = message.noResponse;
                return object;
            };

            /**
             * Converts this Request to JSON.
             * @function toJSON
             * @memberof kritor.common.Request
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Request.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Request
             * @function getTypeUrl
             * @memberof kritor.common.Request
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Request.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.Request";
            };

            return Request;
        })();

        common.Response = (function() {

            /**
             * Properties of a Response.
             * @memberof kritor.common
             * @interface IResponse
             * @property {string|null} [cmd] Response cmd
             * @property {number|null} [seq] Response seq
             * @property {kritor.common.Response.ResponseCode|null} [code] Response code
             * @property {string|null} [msg] Response msg
             * @property {Uint8Array|null} [buf] Response buf
             */

            /**
             * Constructs a new Response.
             * @memberof kritor.common
             * @classdesc Represents a Response.
             * @implements IResponse
             * @constructor
             * @param {kritor.common.IResponse=} [properties] Properties to set
             */
            function Response(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Response cmd.
             * @member {string} cmd
             * @memberof kritor.common.Response
             * @instance
             */
            Response.prototype.cmd = "";

            /**
             * Response seq.
             * @member {number} seq
             * @memberof kritor.common.Response
             * @instance
             */
            Response.prototype.seq = 0;

            /**
             * Response code.
             * @member {kritor.common.Response.ResponseCode} code
             * @memberof kritor.common.Response
             * @instance
             */
            Response.prototype.code = 0;

            /**
             * Response msg.
             * @member {string|null|undefined} msg
             * @memberof kritor.common.Response
             * @instance
             */
            Response.prototype.msg = null;

            /**
             * Response buf.
             * @member {Uint8Array} buf
             * @memberof kritor.common.Response
             * @instance
             */
            Response.prototype.buf = $util.newBuffer([]);

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * Response _msg.
             * @member {"msg"|undefined} _msg
             * @memberof kritor.common.Response
             * @instance
             */
            Object.defineProperty(Response.prototype, "_msg", {
                get: $util.oneOfGetter($oneOfFields = ["msg"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new Response instance using the specified properties.
             * @function create
             * @memberof kritor.common.Response
             * @static
             * @param {kritor.common.IResponse=} [properties] Properties to set
             * @returns {kritor.common.Response} Response instance
             */
            Response.create = function create(properties) {
                return new Response(properties);
            };

            /**
             * Encodes the specified Response message. Does not implicitly {@link kritor.common.Response.verify|verify} messages.
             * @function encode
             * @memberof kritor.common.Response
             * @static
             * @param {kritor.common.IResponse} message Response message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Response.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.cmd != null && Object.hasOwnProperty.call(message, "cmd"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.cmd);
                if (message.seq != null && Object.hasOwnProperty.call(message, "seq"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.seq);
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.code);
                if (message.msg != null && Object.hasOwnProperty.call(message, "msg"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.msg);
                if (message.buf != null && Object.hasOwnProperty.call(message, "buf"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.buf);
                return writer;
            };

            /**
             * Encodes the specified Response message, length delimited. Does not implicitly {@link kritor.common.Response.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.common.Response
             * @static
             * @param {kritor.common.IResponse} message Response message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Response.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Response message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.common.Response
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.common.Response} Response
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Response.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.common.Response();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.cmd = reader.string();
                            break;
                        }
                    case 2: {
                            message.seq = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.code = reader.int32();
                            break;
                        }
                    case 4: {
                            message.msg = reader.string();
                            break;
                        }
                    case 5: {
                            message.buf = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Response message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.common.Response
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.common.Response} Response
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Response.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Response message.
             * @function verify
             * @memberof kritor.common.Response
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Response.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.cmd != null && message.hasOwnProperty("cmd"))
                    if (!$util.isString(message.cmd))
                        return "cmd: string expected";
                if (message.seq != null && message.hasOwnProperty("seq"))
                    if (!$util.isInteger(message.seq))
                        return "seq: integer expected";
                if (message.code != null && message.hasOwnProperty("code"))
                    switch (message.code) {
                    default:
                        return "code: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                        break;
                    }
                if (message.msg != null && message.hasOwnProperty("msg")) {
                    properties._msg = 1;
                    if (!$util.isString(message.msg))
                        return "msg: string expected";
                }
                if (message.buf != null && message.hasOwnProperty("buf"))
                    if (!(message.buf && typeof message.buf.length === "number" || $util.isString(message.buf)))
                        return "buf: buffer expected";
                return null;
            };

            /**
             * Creates a Response message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.common.Response
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.common.Response} Response
             */
            Response.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.common.Response)
                    return object;
                let message = new $root.kritor.common.Response();
                if (object.cmd != null)
                    message.cmd = String(object.cmd);
                if (object.seq != null)
                    message.seq = object.seq >>> 0;
                switch (object.code) {
                default:
                    if (typeof object.code === "number") {
                        message.code = object.code;
                        break;
                    }
                    break;
                case "SUCCESS":
                case 0:
                    message.code = 0;
                    break;
                case "INVALID_ARGUMENT":
                case 1:
                    message.code = 1;
                    break;
                case "INTERNAL":
                case 2:
                    message.code = 2;
                    break;
                case "UNAUTHENTICATED":
                case 3:
                    message.code = 3;
                    break;
                case "PERMISSION_DENIED":
                case 4:
                    message.code = 4;
                    break;
                }
                if (object.msg != null)
                    message.msg = String(object.msg);
                if (object.buf != null)
                    if (typeof object.buf === "string")
                        $util.base64.decode(object.buf, message.buf = $util.newBuffer($util.base64.length(object.buf)), 0);
                    else if (object.buf.length >= 0)
                        message.buf = object.buf;
                return message;
            };

            /**
             * Creates a plain object from a Response message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.common.Response
             * @static
             * @param {kritor.common.Response} message Response
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Response.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.cmd = "";
                    object.seq = 0;
                    object.code = options.enums === String ? "SUCCESS" : 0;
                    if (options.bytes === String)
                        object.buf = "";
                    else {
                        object.buf = [];
                        if (options.bytes !== Array)
                            object.buf = $util.newBuffer(object.buf);
                    }
                }
                if (message.cmd != null && message.hasOwnProperty("cmd"))
                    object.cmd = message.cmd;
                if (message.seq != null && message.hasOwnProperty("seq"))
                    object.seq = message.seq;
                if (message.code != null && message.hasOwnProperty("code"))
                    object.code = options.enums === String ? $root.kritor.common.Response.ResponseCode[message.code] === undefined ? message.code : $root.kritor.common.Response.ResponseCode[message.code] : message.code;
                if (message.msg != null && message.hasOwnProperty("msg")) {
                    object.msg = message.msg;
                    if (options.oneofs)
                        object._msg = "msg";
                }
                if (message.buf != null && message.hasOwnProperty("buf"))
                    object.buf = options.bytes === String ? $util.base64.encode(message.buf, 0, message.buf.length) : options.bytes === Array ? Array.prototype.slice.call(message.buf) : message.buf;
                return object;
            };

            /**
             * Converts this Response to JSON.
             * @function toJSON
             * @memberof kritor.common.Response
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Response.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Response
             * @function getTypeUrl
             * @memberof kritor.common.Response
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Response.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.common.Response";
            };

            /**
             * ResponseCode enum.
             * @name kritor.common.Response.ResponseCode
             * @enum {number}
             * @property {number} SUCCESS=0 SUCCESS value
             * @property {number} INVALID_ARGUMENT=1 INVALID_ARGUMENT value
             * @property {number} INTERNAL=2 INTERNAL value
             * @property {number} UNAUTHENTICATED=3 UNAUTHENTICATED value
             * @property {number} PERMISSION_DENIED=4 PERMISSION_DENIED value
             */
            Response.ResponseCode = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "SUCCESS"] = 0;
                values[valuesById[1] = "INVALID_ARGUMENT"] = 1;
                values[valuesById[2] = "INTERNAL"] = 2;
                values[valuesById[3] = "UNAUTHENTICATED"] = 3;
                values[valuesById[4] = "PERMISSION_DENIED"] = 4;
                return values;
            })();

            return Response;
        })();

        return common;
    })();

    kritor.core = (function() {

        /**
         * Namespace core.
         * @memberof kritor
         * @namespace
         */
        const core = {};

        core.CoreService = (function() {

            /**
             * Constructs a new CoreService service.
             * @memberof kritor.core
             * @classdesc Represents a CoreService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function CoreService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (CoreService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = CoreService;

            /**
             * Creates new CoreService service using the specified rpc implementation.
             * @function create
             * @memberof kritor.core.CoreService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {CoreService} RPC service. Useful where requests and/or responses are streamed.
             */
            CoreService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link kritor.core.CoreService#getVersion}.
             * @memberof kritor.core.CoreService
             * @typedef GetVersionCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.core.GetVersionResponse} [response] GetVersionResponse
             */

            /**
             * Calls GetVersion.
             * @function getVersion
             * @memberof kritor.core.CoreService
             * @instance
             * @param {kritor.core.IGetVersionRequest} request GetVersionRequest message or plain object
             * @param {kritor.core.CoreService.GetVersionCallback} callback Node-style callback called with the error, if any, and GetVersionResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(CoreService.prototype.getVersion = function getVersion(request, callback) {
                return this.rpcCall(getVersion, $root.kritor.core.GetVersionRequest, $root.kritor.core.GetVersionResponse, request, callback);
            }, "name", { value: "GetVersion" });

            /**
             * Calls GetVersion.
             * @function getVersion
             * @memberof kritor.core.CoreService
             * @instance
             * @param {kritor.core.IGetVersionRequest} request GetVersionRequest message or plain object
             * @returns {Promise<kritor.core.GetVersionResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.core.CoreService#downloadFile}.
             * @memberof kritor.core.CoreService
             * @typedef DownloadFileCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.core.DownloadFileResponse} [response] DownloadFileResponse
             */

            /**
             * Calls DownloadFile.
             * @function downloadFile
             * @memberof kritor.core.CoreService
             * @instance
             * @param {kritor.core.IDownloadFileRequest} request DownloadFileRequest message or plain object
             * @param {kritor.core.CoreService.DownloadFileCallback} callback Node-style callback called with the error, if any, and DownloadFileResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(CoreService.prototype.downloadFile = function downloadFile(request, callback) {
                return this.rpcCall(downloadFile, $root.kritor.core.DownloadFileRequest, $root.kritor.core.DownloadFileResponse, request, callback);
            }, "name", { value: "DownloadFile" });

            /**
             * Calls DownloadFile.
             * @function downloadFile
             * @memberof kritor.core.CoreService
             * @instance
             * @param {kritor.core.IDownloadFileRequest} request DownloadFileRequest message or plain object
             * @returns {Promise<kritor.core.DownloadFileResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.core.CoreService#getCurrentAccount}.
             * @memberof kritor.core.CoreService
             * @typedef GetCurrentAccountCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.core.GetCurrentAccountResponse} [response] GetCurrentAccountResponse
             */

            /**
             * Calls GetCurrentAccount.
             * @function getCurrentAccount
             * @memberof kritor.core.CoreService
             * @instance
             * @param {kritor.core.IGetCurrentAccountRequest} request GetCurrentAccountRequest message or plain object
             * @param {kritor.core.CoreService.GetCurrentAccountCallback} callback Node-style callback called with the error, if any, and GetCurrentAccountResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(CoreService.prototype.getCurrentAccount = function getCurrentAccount(request, callback) {
                return this.rpcCall(getCurrentAccount, $root.kritor.core.GetCurrentAccountRequest, $root.kritor.core.GetCurrentAccountResponse, request, callback);
            }, "name", { value: "GetCurrentAccount" });

            /**
             * Calls GetCurrentAccount.
             * @function getCurrentAccount
             * @memberof kritor.core.CoreService
             * @instance
             * @param {kritor.core.IGetCurrentAccountRequest} request GetCurrentAccountRequest message or plain object
             * @returns {Promise<kritor.core.GetCurrentAccountResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.core.CoreService#switchAccount}.
             * @memberof kritor.core.CoreService
             * @typedef SwitchAccountCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.core.SwitchAccountResponse} [response] SwitchAccountResponse
             */

            /**
             * Calls SwitchAccount.
             * @function switchAccount
             * @memberof kritor.core.CoreService
             * @instance
             * @param {kritor.core.ISwitchAccountRequest} request SwitchAccountRequest message or plain object
             * @param {kritor.core.CoreService.SwitchAccountCallback} callback Node-style callback called with the error, if any, and SwitchAccountResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(CoreService.prototype.switchAccount = function switchAccount(request, callback) {
                return this.rpcCall(switchAccount, $root.kritor.core.SwitchAccountRequest, $root.kritor.core.SwitchAccountResponse, request, callback);
            }, "name", { value: "SwitchAccount" });

            /**
             * Calls SwitchAccount.
             * @function switchAccount
             * @memberof kritor.core.CoreService
             * @instance
             * @param {kritor.core.ISwitchAccountRequest} request SwitchAccountRequest message or plain object
             * @returns {Promise<kritor.core.SwitchAccountResponse>} Promise
             * @variation 2
             */

            return CoreService;
        })();

        core.GetVersionRequest = (function() {

            /**
             * Properties of a GetVersionRequest.
             * @memberof kritor.core
             * @interface IGetVersionRequest
             */

            /**
             * Constructs a new GetVersionRequest.
             * @memberof kritor.core
             * @classdesc Represents a GetVersionRequest.
             * @implements IGetVersionRequest
             * @constructor
             * @param {kritor.core.IGetVersionRequest=} [properties] Properties to set
             */
            function GetVersionRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new GetVersionRequest instance using the specified properties.
             * @function create
             * @memberof kritor.core.GetVersionRequest
             * @static
             * @param {kritor.core.IGetVersionRequest=} [properties] Properties to set
             * @returns {kritor.core.GetVersionRequest} GetVersionRequest instance
             */
            GetVersionRequest.create = function create(properties) {
                return new GetVersionRequest(properties);
            };

            /**
             * Encodes the specified GetVersionRequest message. Does not implicitly {@link kritor.core.GetVersionRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.core.GetVersionRequest
             * @static
             * @param {kritor.core.IGetVersionRequest} message GetVersionRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetVersionRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified GetVersionRequest message, length delimited. Does not implicitly {@link kritor.core.GetVersionRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.core.GetVersionRequest
             * @static
             * @param {kritor.core.IGetVersionRequest} message GetVersionRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetVersionRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetVersionRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.core.GetVersionRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.core.GetVersionRequest} GetVersionRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetVersionRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.core.GetVersionRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetVersionRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.core.GetVersionRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.core.GetVersionRequest} GetVersionRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetVersionRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetVersionRequest message.
             * @function verify
             * @memberof kritor.core.GetVersionRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetVersionRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a GetVersionRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.core.GetVersionRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.core.GetVersionRequest} GetVersionRequest
             */
            GetVersionRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.core.GetVersionRequest)
                    return object;
                return new $root.kritor.core.GetVersionRequest();
            };

            /**
             * Creates a plain object from a GetVersionRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.core.GetVersionRequest
             * @static
             * @param {kritor.core.GetVersionRequest} message GetVersionRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetVersionRequest.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this GetVersionRequest to JSON.
             * @function toJSON
             * @memberof kritor.core.GetVersionRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetVersionRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetVersionRequest
             * @function getTypeUrl
             * @memberof kritor.core.GetVersionRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetVersionRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.core.GetVersionRequest";
            };

            return GetVersionRequest;
        })();

        core.GetVersionResponse = (function() {

            /**
             * Properties of a GetVersionResponse.
             * @memberof kritor.core
             * @interface IGetVersionResponse
             * @property {string|null} [version] GetVersionResponse version
             * @property {string|null} [appName] GetVersionResponse appName
             */

            /**
             * Constructs a new GetVersionResponse.
             * @memberof kritor.core
             * @classdesc Represents a GetVersionResponse.
             * @implements IGetVersionResponse
             * @constructor
             * @param {kritor.core.IGetVersionResponse=} [properties] Properties to set
             */
            function GetVersionResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetVersionResponse version.
             * @member {string} version
             * @memberof kritor.core.GetVersionResponse
             * @instance
             */
            GetVersionResponse.prototype.version = "";

            /**
             * GetVersionResponse appName.
             * @member {string} appName
             * @memberof kritor.core.GetVersionResponse
             * @instance
             */
            GetVersionResponse.prototype.appName = "";

            /**
             * Creates a new GetVersionResponse instance using the specified properties.
             * @function create
             * @memberof kritor.core.GetVersionResponse
             * @static
             * @param {kritor.core.IGetVersionResponse=} [properties] Properties to set
             * @returns {kritor.core.GetVersionResponse} GetVersionResponse instance
             */
            GetVersionResponse.create = function create(properties) {
                return new GetVersionResponse(properties);
            };

            /**
             * Encodes the specified GetVersionResponse message. Does not implicitly {@link kritor.core.GetVersionResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.core.GetVersionResponse
             * @static
             * @param {kritor.core.IGetVersionResponse} message GetVersionResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetVersionResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.version);
                if (message.appName != null && Object.hasOwnProperty.call(message, "appName"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.appName);
                return writer;
            };

            /**
             * Encodes the specified GetVersionResponse message, length delimited. Does not implicitly {@link kritor.core.GetVersionResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.core.GetVersionResponse
             * @static
             * @param {kritor.core.IGetVersionResponse} message GetVersionResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetVersionResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetVersionResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.core.GetVersionResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.core.GetVersionResponse} GetVersionResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetVersionResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.core.GetVersionResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.version = reader.string();
                            break;
                        }
                    case 2: {
                            message.appName = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetVersionResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.core.GetVersionResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.core.GetVersionResponse} GetVersionResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetVersionResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetVersionResponse message.
             * @function verify
             * @memberof kritor.core.GetVersionResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetVersionResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.version != null && message.hasOwnProperty("version"))
                    if (!$util.isString(message.version))
                        return "version: string expected";
                if (message.appName != null && message.hasOwnProperty("appName"))
                    if (!$util.isString(message.appName))
                        return "appName: string expected";
                return null;
            };

            /**
             * Creates a GetVersionResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.core.GetVersionResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.core.GetVersionResponse} GetVersionResponse
             */
            GetVersionResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.core.GetVersionResponse)
                    return object;
                let message = new $root.kritor.core.GetVersionResponse();
                if (object.version != null)
                    message.version = String(object.version);
                if (object.appName != null)
                    message.appName = String(object.appName);
                return message;
            };

            /**
             * Creates a plain object from a GetVersionResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.core.GetVersionResponse
             * @static
             * @param {kritor.core.GetVersionResponse} message GetVersionResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetVersionResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.version = "";
                    object.appName = "";
                }
                if (message.version != null && message.hasOwnProperty("version"))
                    object.version = message.version;
                if (message.appName != null && message.hasOwnProperty("appName"))
                    object.appName = message.appName;
                return object;
            };

            /**
             * Converts this GetVersionResponse to JSON.
             * @function toJSON
             * @memberof kritor.core.GetVersionResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetVersionResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetVersionResponse
             * @function getTypeUrl
             * @memberof kritor.core.GetVersionResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetVersionResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.core.GetVersionResponse";
            };

            return GetVersionResponse;
        })();

        core.DownloadFileRequest = (function() {

            /**
             * Properties of a DownloadFileRequest.
             * @memberof kritor.core
             * @interface IDownloadFileRequest
             * @property {string|null} [url] DownloadFileRequest url
             * @property {string|null} [base64] DownloadFileRequest base64
             * @property {string|null} [rootPath] DownloadFileRequest rootPath
             * @property {string|null} [fileName] DownloadFileRequest fileName
             * @property {number|null} [threadCnt] DownloadFileRequest threadCnt
             * @property {string|null} [headers] DownloadFileRequest headers
             */

            /**
             * Constructs a new DownloadFileRequest.
             * @memberof kritor.core
             * @classdesc Represents a DownloadFileRequest.
             * @implements IDownloadFileRequest
             * @constructor
             * @param {kritor.core.IDownloadFileRequest=} [properties] Properties to set
             */
            function DownloadFileRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DownloadFileRequest url.
             * @member {string|null|undefined} url
             * @memberof kritor.core.DownloadFileRequest
             * @instance
             */
            DownloadFileRequest.prototype.url = null;

            /**
             * DownloadFileRequest base64.
             * @member {string|null|undefined} base64
             * @memberof kritor.core.DownloadFileRequest
             * @instance
             */
            DownloadFileRequest.prototype.base64 = null;

            /**
             * DownloadFileRequest rootPath.
             * @member {string|null|undefined} rootPath
             * @memberof kritor.core.DownloadFileRequest
             * @instance
             */
            DownloadFileRequest.prototype.rootPath = null;

            /**
             * DownloadFileRequest fileName.
             * @member {string|null|undefined} fileName
             * @memberof kritor.core.DownloadFileRequest
             * @instance
             */
            DownloadFileRequest.prototype.fileName = null;

            /**
             * DownloadFileRequest threadCnt.
             * @member {number|null|undefined} threadCnt
             * @memberof kritor.core.DownloadFileRequest
             * @instance
             */
            DownloadFileRequest.prototype.threadCnt = null;

            /**
             * DownloadFileRequest headers.
             * @member {string|null|undefined} headers
             * @memberof kritor.core.DownloadFileRequest
             * @instance
             */
            DownloadFileRequest.prototype.headers = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * DownloadFileRequest _url.
             * @member {"url"|undefined} _url
             * @memberof kritor.core.DownloadFileRequest
             * @instance
             */
            Object.defineProperty(DownloadFileRequest.prototype, "_url", {
                get: $util.oneOfGetter($oneOfFields = ["url"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * DownloadFileRequest _base64.
             * @member {"base64"|undefined} _base64
             * @memberof kritor.core.DownloadFileRequest
             * @instance
             */
            Object.defineProperty(DownloadFileRequest.prototype, "_base64", {
                get: $util.oneOfGetter($oneOfFields = ["base64"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * DownloadFileRequest _rootPath.
             * @member {"rootPath"|undefined} _rootPath
             * @memberof kritor.core.DownloadFileRequest
             * @instance
             */
            Object.defineProperty(DownloadFileRequest.prototype, "_rootPath", {
                get: $util.oneOfGetter($oneOfFields = ["rootPath"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * DownloadFileRequest _fileName.
             * @member {"fileName"|undefined} _fileName
             * @memberof kritor.core.DownloadFileRequest
             * @instance
             */
            Object.defineProperty(DownloadFileRequest.prototype, "_fileName", {
                get: $util.oneOfGetter($oneOfFields = ["fileName"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * DownloadFileRequest _threadCnt.
             * @member {"threadCnt"|undefined} _threadCnt
             * @memberof kritor.core.DownloadFileRequest
             * @instance
             */
            Object.defineProperty(DownloadFileRequest.prototype, "_threadCnt", {
                get: $util.oneOfGetter($oneOfFields = ["threadCnt"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * DownloadFileRequest _headers.
             * @member {"headers"|undefined} _headers
             * @memberof kritor.core.DownloadFileRequest
             * @instance
             */
            Object.defineProperty(DownloadFileRequest.prototype, "_headers", {
                get: $util.oneOfGetter($oneOfFields = ["headers"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new DownloadFileRequest instance using the specified properties.
             * @function create
             * @memberof kritor.core.DownloadFileRequest
             * @static
             * @param {kritor.core.IDownloadFileRequest=} [properties] Properties to set
             * @returns {kritor.core.DownloadFileRequest} DownloadFileRequest instance
             */
            DownloadFileRequest.create = function create(properties) {
                return new DownloadFileRequest(properties);
            };

            /**
             * Encodes the specified DownloadFileRequest message. Does not implicitly {@link kritor.core.DownloadFileRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.core.DownloadFileRequest
             * @static
             * @param {kritor.core.IDownloadFileRequest} message DownloadFileRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DownloadFileRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.url);
                if (message.base64 != null && Object.hasOwnProperty.call(message, "base64"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.base64);
                if (message.rootPath != null && Object.hasOwnProperty.call(message, "rootPath"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.rootPath);
                if (message.fileName != null && Object.hasOwnProperty.call(message, "fileName"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.fileName);
                if (message.threadCnt != null && Object.hasOwnProperty.call(message, "threadCnt"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.threadCnt);
                if (message.headers != null && Object.hasOwnProperty.call(message, "headers"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.headers);
                return writer;
            };

            /**
             * Encodes the specified DownloadFileRequest message, length delimited. Does not implicitly {@link kritor.core.DownloadFileRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.core.DownloadFileRequest
             * @static
             * @param {kritor.core.IDownloadFileRequest} message DownloadFileRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DownloadFileRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DownloadFileRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.core.DownloadFileRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.core.DownloadFileRequest} DownloadFileRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DownloadFileRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.core.DownloadFileRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.url = reader.string();
                            break;
                        }
                    case 2: {
                            message.base64 = reader.string();
                            break;
                        }
                    case 3: {
                            message.rootPath = reader.string();
                            break;
                        }
                    case 4: {
                            message.fileName = reader.string();
                            break;
                        }
                    case 5: {
                            message.threadCnt = reader.uint32();
                            break;
                        }
                    case 6: {
                            message.headers = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DownloadFileRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.core.DownloadFileRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.core.DownloadFileRequest} DownloadFileRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DownloadFileRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DownloadFileRequest message.
             * @function verify
             * @memberof kritor.core.DownloadFileRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DownloadFileRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.url != null && message.hasOwnProperty("url")) {
                    properties._url = 1;
                    if (!$util.isString(message.url))
                        return "url: string expected";
                }
                if (message.base64 != null && message.hasOwnProperty("base64")) {
                    properties._base64 = 1;
                    if (!$util.isString(message.base64))
                        return "base64: string expected";
                }
                if (message.rootPath != null && message.hasOwnProperty("rootPath")) {
                    properties._rootPath = 1;
                    if (!$util.isString(message.rootPath))
                        return "rootPath: string expected";
                }
                if (message.fileName != null && message.hasOwnProperty("fileName")) {
                    properties._fileName = 1;
                    if (!$util.isString(message.fileName))
                        return "fileName: string expected";
                }
                if (message.threadCnt != null && message.hasOwnProperty("threadCnt")) {
                    properties._threadCnt = 1;
                    if (!$util.isInteger(message.threadCnt))
                        return "threadCnt: integer expected";
                }
                if (message.headers != null && message.hasOwnProperty("headers")) {
                    properties._headers = 1;
                    if (!$util.isString(message.headers))
                        return "headers: string expected";
                }
                return null;
            };

            /**
             * Creates a DownloadFileRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.core.DownloadFileRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.core.DownloadFileRequest} DownloadFileRequest
             */
            DownloadFileRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.core.DownloadFileRequest)
                    return object;
                let message = new $root.kritor.core.DownloadFileRequest();
                if (object.url != null)
                    message.url = String(object.url);
                if (object.base64 != null)
                    message.base64 = String(object.base64);
                if (object.rootPath != null)
                    message.rootPath = String(object.rootPath);
                if (object.fileName != null)
                    message.fileName = String(object.fileName);
                if (object.threadCnt != null)
                    message.threadCnt = object.threadCnt >>> 0;
                if (object.headers != null)
                    message.headers = String(object.headers);
                return message;
            };

            /**
             * Creates a plain object from a DownloadFileRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.core.DownloadFileRequest
             * @static
             * @param {kritor.core.DownloadFileRequest} message DownloadFileRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DownloadFileRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (message.url != null && message.hasOwnProperty("url")) {
                    object.url = message.url;
                    if (options.oneofs)
                        object._url = "url";
                }
                if (message.base64 != null && message.hasOwnProperty("base64")) {
                    object.base64 = message.base64;
                    if (options.oneofs)
                        object._base64 = "base64";
                }
                if (message.rootPath != null && message.hasOwnProperty("rootPath")) {
                    object.rootPath = message.rootPath;
                    if (options.oneofs)
                        object._rootPath = "rootPath";
                }
                if (message.fileName != null && message.hasOwnProperty("fileName")) {
                    object.fileName = message.fileName;
                    if (options.oneofs)
                        object._fileName = "fileName";
                }
                if (message.threadCnt != null && message.hasOwnProperty("threadCnt")) {
                    object.threadCnt = message.threadCnt;
                    if (options.oneofs)
                        object._threadCnt = "threadCnt";
                }
                if (message.headers != null && message.hasOwnProperty("headers")) {
                    object.headers = message.headers;
                    if (options.oneofs)
                        object._headers = "headers";
                }
                return object;
            };

            /**
             * Converts this DownloadFileRequest to JSON.
             * @function toJSON
             * @memberof kritor.core.DownloadFileRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DownloadFileRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DownloadFileRequest
             * @function getTypeUrl
             * @memberof kritor.core.DownloadFileRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DownloadFileRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.core.DownloadFileRequest";
            };

            return DownloadFileRequest;
        })();

        core.DownloadFileResponse = (function() {

            /**
             * Properties of a DownloadFileResponse.
             * @memberof kritor.core
             * @interface IDownloadFileResponse
             * @property {string|null} [fileAbsolutePath] DownloadFileResponse fileAbsolutePath
             * @property {string|null} [fileMd5] DownloadFileResponse fileMd5
             */

            /**
             * Constructs a new DownloadFileResponse.
             * @memberof kritor.core
             * @classdesc Represents a DownloadFileResponse.
             * @implements IDownloadFileResponse
             * @constructor
             * @param {kritor.core.IDownloadFileResponse=} [properties] Properties to set
             */
            function DownloadFileResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DownloadFileResponse fileAbsolutePath.
             * @member {string} fileAbsolutePath
             * @memberof kritor.core.DownloadFileResponse
             * @instance
             */
            DownloadFileResponse.prototype.fileAbsolutePath = "";

            /**
             * DownloadFileResponse fileMd5.
             * @member {string} fileMd5
             * @memberof kritor.core.DownloadFileResponse
             * @instance
             */
            DownloadFileResponse.prototype.fileMd5 = "";

            /**
             * Creates a new DownloadFileResponse instance using the specified properties.
             * @function create
             * @memberof kritor.core.DownloadFileResponse
             * @static
             * @param {kritor.core.IDownloadFileResponse=} [properties] Properties to set
             * @returns {kritor.core.DownloadFileResponse} DownloadFileResponse instance
             */
            DownloadFileResponse.create = function create(properties) {
                return new DownloadFileResponse(properties);
            };

            /**
             * Encodes the specified DownloadFileResponse message. Does not implicitly {@link kritor.core.DownloadFileResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.core.DownloadFileResponse
             * @static
             * @param {kritor.core.IDownloadFileResponse} message DownloadFileResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DownloadFileResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.fileAbsolutePath != null && Object.hasOwnProperty.call(message, "fileAbsolutePath"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.fileAbsolutePath);
                if (message.fileMd5 != null && Object.hasOwnProperty.call(message, "fileMd5"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.fileMd5);
                return writer;
            };

            /**
             * Encodes the specified DownloadFileResponse message, length delimited. Does not implicitly {@link kritor.core.DownloadFileResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.core.DownloadFileResponse
             * @static
             * @param {kritor.core.IDownloadFileResponse} message DownloadFileResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DownloadFileResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DownloadFileResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.core.DownloadFileResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.core.DownloadFileResponse} DownloadFileResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DownloadFileResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.core.DownloadFileResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.fileAbsolutePath = reader.string();
                            break;
                        }
                    case 2: {
                            message.fileMd5 = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DownloadFileResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.core.DownloadFileResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.core.DownloadFileResponse} DownloadFileResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DownloadFileResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DownloadFileResponse message.
             * @function verify
             * @memberof kritor.core.DownloadFileResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DownloadFileResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.fileAbsolutePath != null && message.hasOwnProperty("fileAbsolutePath"))
                    if (!$util.isString(message.fileAbsolutePath))
                        return "fileAbsolutePath: string expected";
                if (message.fileMd5 != null && message.hasOwnProperty("fileMd5"))
                    if (!$util.isString(message.fileMd5))
                        return "fileMd5: string expected";
                return null;
            };

            /**
             * Creates a DownloadFileResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.core.DownloadFileResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.core.DownloadFileResponse} DownloadFileResponse
             */
            DownloadFileResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.core.DownloadFileResponse)
                    return object;
                let message = new $root.kritor.core.DownloadFileResponse();
                if (object.fileAbsolutePath != null)
                    message.fileAbsolutePath = String(object.fileAbsolutePath);
                if (object.fileMd5 != null)
                    message.fileMd5 = String(object.fileMd5);
                return message;
            };

            /**
             * Creates a plain object from a DownloadFileResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.core.DownloadFileResponse
             * @static
             * @param {kritor.core.DownloadFileResponse} message DownloadFileResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DownloadFileResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.fileAbsolutePath = "";
                    object.fileMd5 = "";
                }
                if (message.fileAbsolutePath != null && message.hasOwnProperty("fileAbsolutePath"))
                    object.fileAbsolutePath = message.fileAbsolutePath;
                if (message.fileMd5 != null && message.hasOwnProperty("fileMd5"))
                    object.fileMd5 = message.fileMd5;
                return object;
            };

            /**
             * Converts this DownloadFileResponse to JSON.
             * @function toJSON
             * @memberof kritor.core.DownloadFileResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DownloadFileResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DownloadFileResponse
             * @function getTypeUrl
             * @memberof kritor.core.DownloadFileResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DownloadFileResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.core.DownloadFileResponse";
            };

            return DownloadFileResponse;
        })();

        core.GetCurrentAccountRequest = (function() {

            /**
             * Properties of a GetCurrentAccountRequest.
             * @memberof kritor.core
             * @interface IGetCurrentAccountRequest
             */

            /**
             * Constructs a new GetCurrentAccountRequest.
             * @memberof kritor.core
             * @classdesc Represents a GetCurrentAccountRequest.
             * @implements IGetCurrentAccountRequest
             * @constructor
             * @param {kritor.core.IGetCurrentAccountRequest=} [properties] Properties to set
             */
            function GetCurrentAccountRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new GetCurrentAccountRequest instance using the specified properties.
             * @function create
             * @memberof kritor.core.GetCurrentAccountRequest
             * @static
             * @param {kritor.core.IGetCurrentAccountRequest=} [properties] Properties to set
             * @returns {kritor.core.GetCurrentAccountRequest} GetCurrentAccountRequest instance
             */
            GetCurrentAccountRequest.create = function create(properties) {
                return new GetCurrentAccountRequest(properties);
            };

            /**
             * Encodes the specified GetCurrentAccountRequest message. Does not implicitly {@link kritor.core.GetCurrentAccountRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.core.GetCurrentAccountRequest
             * @static
             * @param {kritor.core.IGetCurrentAccountRequest} message GetCurrentAccountRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetCurrentAccountRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified GetCurrentAccountRequest message, length delimited. Does not implicitly {@link kritor.core.GetCurrentAccountRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.core.GetCurrentAccountRequest
             * @static
             * @param {kritor.core.IGetCurrentAccountRequest} message GetCurrentAccountRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetCurrentAccountRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetCurrentAccountRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.core.GetCurrentAccountRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.core.GetCurrentAccountRequest} GetCurrentAccountRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetCurrentAccountRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.core.GetCurrentAccountRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetCurrentAccountRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.core.GetCurrentAccountRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.core.GetCurrentAccountRequest} GetCurrentAccountRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetCurrentAccountRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetCurrentAccountRequest message.
             * @function verify
             * @memberof kritor.core.GetCurrentAccountRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetCurrentAccountRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a GetCurrentAccountRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.core.GetCurrentAccountRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.core.GetCurrentAccountRequest} GetCurrentAccountRequest
             */
            GetCurrentAccountRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.core.GetCurrentAccountRequest)
                    return object;
                return new $root.kritor.core.GetCurrentAccountRequest();
            };

            /**
             * Creates a plain object from a GetCurrentAccountRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.core.GetCurrentAccountRequest
             * @static
             * @param {kritor.core.GetCurrentAccountRequest} message GetCurrentAccountRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetCurrentAccountRequest.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this GetCurrentAccountRequest to JSON.
             * @function toJSON
             * @memberof kritor.core.GetCurrentAccountRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetCurrentAccountRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetCurrentAccountRequest
             * @function getTypeUrl
             * @memberof kritor.core.GetCurrentAccountRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetCurrentAccountRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.core.GetCurrentAccountRequest";
            };

            return GetCurrentAccountRequest;
        })();

        core.GetCurrentAccountResponse = (function() {

            /**
             * Properties of a GetCurrentAccountResponse.
             * @memberof kritor.core
             * @interface IGetCurrentAccountResponse
             * @property {string|null} [accountUid] GetCurrentAccountResponse accountUid
             * @property {number|Long|null} [accountUin] GetCurrentAccountResponse accountUin
             * @property {string|null} [accountName] GetCurrentAccountResponse accountName
             */

            /**
             * Constructs a new GetCurrentAccountResponse.
             * @memberof kritor.core
             * @classdesc Represents a GetCurrentAccountResponse.
             * @implements IGetCurrentAccountResponse
             * @constructor
             * @param {kritor.core.IGetCurrentAccountResponse=} [properties] Properties to set
             */
            function GetCurrentAccountResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetCurrentAccountResponse accountUid.
             * @member {string} accountUid
             * @memberof kritor.core.GetCurrentAccountResponse
             * @instance
             */
            GetCurrentAccountResponse.prototype.accountUid = "";

            /**
             * GetCurrentAccountResponse accountUin.
             * @member {number|Long} accountUin
             * @memberof kritor.core.GetCurrentAccountResponse
             * @instance
             */
            GetCurrentAccountResponse.prototype.accountUin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GetCurrentAccountResponse accountName.
             * @member {string} accountName
             * @memberof kritor.core.GetCurrentAccountResponse
             * @instance
             */
            GetCurrentAccountResponse.prototype.accountName = "";

            /**
             * Creates a new GetCurrentAccountResponse instance using the specified properties.
             * @function create
             * @memberof kritor.core.GetCurrentAccountResponse
             * @static
             * @param {kritor.core.IGetCurrentAccountResponse=} [properties] Properties to set
             * @returns {kritor.core.GetCurrentAccountResponse} GetCurrentAccountResponse instance
             */
            GetCurrentAccountResponse.create = function create(properties) {
                return new GetCurrentAccountResponse(properties);
            };

            /**
             * Encodes the specified GetCurrentAccountResponse message. Does not implicitly {@link kritor.core.GetCurrentAccountResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.core.GetCurrentAccountResponse
             * @static
             * @param {kritor.core.IGetCurrentAccountResponse} message GetCurrentAccountResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetCurrentAccountResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.accountUid != null && Object.hasOwnProperty.call(message, "accountUid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.accountUid);
                if (message.accountUin != null && Object.hasOwnProperty.call(message, "accountUin"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.accountUin);
                if (message.accountName != null && Object.hasOwnProperty.call(message, "accountName"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.accountName);
                return writer;
            };

            /**
             * Encodes the specified GetCurrentAccountResponse message, length delimited. Does not implicitly {@link kritor.core.GetCurrentAccountResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.core.GetCurrentAccountResponse
             * @static
             * @param {kritor.core.IGetCurrentAccountResponse} message GetCurrentAccountResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetCurrentAccountResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetCurrentAccountResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.core.GetCurrentAccountResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.core.GetCurrentAccountResponse} GetCurrentAccountResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetCurrentAccountResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.core.GetCurrentAccountResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.accountUid = reader.string();
                            break;
                        }
                    case 2: {
                            message.accountUin = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.accountName = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetCurrentAccountResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.core.GetCurrentAccountResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.core.GetCurrentAccountResponse} GetCurrentAccountResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetCurrentAccountResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetCurrentAccountResponse message.
             * @function verify
             * @memberof kritor.core.GetCurrentAccountResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetCurrentAccountResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.accountUid != null && message.hasOwnProperty("accountUid"))
                    if (!$util.isString(message.accountUid))
                        return "accountUid: string expected";
                if (message.accountUin != null && message.hasOwnProperty("accountUin"))
                    if (!$util.isInteger(message.accountUin) && !(message.accountUin && $util.isInteger(message.accountUin.low) && $util.isInteger(message.accountUin.high)))
                        return "accountUin: integer|Long expected";
                if (message.accountName != null && message.hasOwnProperty("accountName"))
                    if (!$util.isString(message.accountName))
                        return "accountName: string expected";
                return null;
            };

            /**
             * Creates a GetCurrentAccountResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.core.GetCurrentAccountResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.core.GetCurrentAccountResponse} GetCurrentAccountResponse
             */
            GetCurrentAccountResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.core.GetCurrentAccountResponse)
                    return object;
                let message = new $root.kritor.core.GetCurrentAccountResponse();
                if (object.accountUid != null)
                    message.accountUid = String(object.accountUid);
                if (object.accountUin != null)
                    if ($util.Long)
                        (message.accountUin = $util.Long.fromValue(object.accountUin)).unsigned = true;
                    else if (typeof object.accountUin === "string")
                        message.accountUin = parseInt(object.accountUin, 10);
                    else if (typeof object.accountUin === "number")
                        message.accountUin = object.accountUin;
                    else if (typeof object.accountUin === "object")
                        message.accountUin = new $util.LongBits(object.accountUin.low >>> 0, object.accountUin.high >>> 0).toNumber(true);
                if (object.accountName != null)
                    message.accountName = String(object.accountName);
                return message;
            };

            /**
             * Creates a plain object from a GetCurrentAccountResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.core.GetCurrentAccountResponse
             * @static
             * @param {kritor.core.GetCurrentAccountResponse} message GetCurrentAccountResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetCurrentAccountResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.accountUid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.accountUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.accountUin = options.longs === String ? "0" : 0;
                    object.accountName = "";
                }
                if (message.accountUid != null && message.hasOwnProperty("accountUid"))
                    object.accountUid = message.accountUid;
                if (message.accountUin != null && message.hasOwnProperty("accountUin"))
                    if (typeof message.accountUin === "number")
                        object.accountUin = options.longs === String ? String(message.accountUin) : message.accountUin;
                    else
                        object.accountUin = options.longs === String ? $util.Long.prototype.toString.call(message.accountUin) : options.longs === Number ? new $util.LongBits(message.accountUin.low >>> 0, message.accountUin.high >>> 0).toNumber(true) : message.accountUin;
                if (message.accountName != null && message.hasOwnProperty("accountName"))
                    object.accountName = message.accountName;
                return object;
            };

            /**
             * Converts this GetCurrentAccountResponse to JSON.
             * @function toJSON
             * @memberof kritor.core.GetCurrentAccountResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetCurrentAccountResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetCurrentAccountResponse
             * @function getTypeUrl
             * @memberof kritor.core.GetCurrentAccountResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetCurrentAccountResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.core.GetCurrentAccountResponse";
            };

            return GetCurrentAccountResponse;
        })();

        core.SwitchAccountRequest = (function() {

            /**
             * Properties of a SwitchAccountRequest.
             * @memberof kritor.core
             * @interface ISwitchAccountRequest
             * @property {string|null} [accountUid] SwitchAccountRequest accountUid
             * @property {number|Long|null} [accountUin] SwitchAccountRequest accountUin
             * @property {string|null} [superTicket] SwitchAccountRequest superTicket
             */

            /**
             * Constructs a new SwitchAccountRequest.
             * @memberof kritor.core
             * @classdesc Represents a SwitchAccountRequest.
             * @implements ISwitchAccountRequest
             * @constructor
             * @param {kritor.core.ISwitchAccountRequest=} [properties] Properties to set
             */
            function SwitchAccountRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SwitchAccountRequest accountUid.
             * @member {string|null|undefined} accountUid
             * @memberof kritor.core.SwitchAccountRequest
             * @instance
             */
            SwitchAccountRequest.prototype.accountUid = null;

            /**
             * SwitchAccountRequest accountUin.
             * @member {number|Long|null|undefined} accountUin
             * @memberof kritor.core.SwitchAccountRequest
             * @instance
             */
            SwitchAccountRequest.prototype.accountUin = null;

            /**
             * SwitchAccountRequest superTicket.
             * @member {string} superTicket
             * @memberof kritor.core.SwitchAccountRequest
             * @instance
             */
            SwitchAccountRequest.prototype.superTicket = "";

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * SwitchAccountRequest account.
             * @member {"accountUid"|"accountUin"|undefined} account
             * @memberof kritor.core.SwitchAccountRequest
             * @instance
             */
            Object.defineProperty(SwitchAccountRequest.prototype, "account", {
                get: $util.oneOfGetter($oneOfFields = ["accountUid", "accountUin"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new SwitchAccountRequest instance using the specified properties.
             * @function create
             * @memberof kritor.core.SwitchAccountRequest
             * @static
             * @param {kritor.core.ISwitchAccountRequest=} [properties] Properties to set
             * @returns {kritor.core.SwitchAccountRequest} SwitchAccountRequest instance
             */
            SwitchAccountRequest.create = function create(properties) {
                return new SwitchAccountRequest(properties);
            };

            /**
             * Encodes the specified SwitchAccountRequest message. Does not implicitly {@link kritor.core.SwitchAccountRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.core.SwitchAccountRequest
             * @static
             * @param {kritor.core.ISwitchAccountRequest} message SwitchAccountRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SwitchAccountRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.accountUid != null && Object.hasOwnProperty.call(message, "accountUid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.accountUid);
                if (message.accountUin != null && Object.hasOwnProperty.call(message, "accountUin"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.accountUin);
                if (message.superTicket != null && Object.hasOwnProperty.call(message, "superTicket"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.superTicket);
                return writer;
            };

            /**
             * Encodes the specified SwitchAccountRequest message, length delimited. Does not implicitly {@link kritor.core.SwitchAccountRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.core.SwitchAccountRequest
             * @static
             * @param {kritor.core.ISwitchAccountRequest} message SwitchAccountRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SwitchAccountRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SwitchAccountRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.core.SwitchAccountRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.core.SwitchAccountRequest} SwitchAccountRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SwitchAccountRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.core.SwitchAccountRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.accountUid = reader.string();
                            break;
                        }
                    case 2: {
                            message.accountUin = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.superTicket = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SwitchAccountRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.core.SwitchAccountRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.core.SwitchAccountRequest} SwitchAccountRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SwitchAccountRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SwitchAccountRequest message.
             * @function verify
             * @memberof kritor.core.SwitchAccountRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SwitchAccountRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.accountUid != null && message.hasOwnProperty("accountUid")) {
                    properties.account = 1;
                    if (!$util.isString(message.accountUid))
                        return "accountUid: string expected";
                }
                if (message.accountUin != null && message.hasOwnProperty("accountUin")) {
                    if (properties.account === 1)
                        return "account: multiple values";
                    properties.account = 1;
                    if (!$util.isInteger(message.accountUin) && !(message.accountUin && $util.isInteger(message.accountUin.low) && $util.isInteger(message.accountUin.high)))
                        return "accountUin: integer|Long expected";
                }
                if (message.superTicket != null && message.hasOwnProperty("superTicket"))
                    if (!$util.isString(message.superTicket))
                        return "superTicket: string expected";
                return null;
            };

            /**
             * Creates a SwitchAccountRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.core.SwitchAccountRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.core.SwitchAccountRequest} SwitchAccountRequest
             */
            SwitchAccountRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.core.SwitchAccountRequest)
                    return object;
                let message = new $root.kritor.core.SwitchAccountRequest();
                if (object.accountUid != null)
                    message.accountUid = String(object.accountUid);
                if (object.accountUin != null)
                    if ($util.Long)
                        (message.accountUin = $util.Long.fromValue(object.accountUin)).unsigned = true;
                    else if (typeof object.accountUin === "string")
                        message.accountUin = parseInt(object.accountUin, 10);
                    else if (typeof object.accountUin === "number")
                        message.accountUin = object.accountUin;
                    else if (typeof object.accountUin === "object")
                        message.accountUin = new $util.LongBits(object.accountUin.low >>> 0, object.accountUin.high >>> 0).toNumber(true);
                if (object.superTicket != null)
                    message.superTicket = String(object.superTicket);
                return message;
            };

            /**
             * Creates a plain object from a SwitchAccountRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.core.SwitchAccountRequest
             * @static
             * @param {kritor.core.SwitchAccountRequest} message SwitchAccountRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SwitchAccountRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.superTicket = "";
                if (message.accountUid != null && message.hasOwnProperty("accountUid")) {
                    object.accountUid = message.accountUid;
                    if (options.oneofs)
                        object.account = "accountUid";
                }
                if (message.accountUin != null && message.hasOwnProperty("accountUin")) {
                    if (typeof message.accountUin === "number")
                        object.accountUin = options.longs === String ? String(message.accountUin) : message.accountUin;
                    else
                        object.accountUin = options.longs === String ? $util.Long.prototype.toString.call(message.accountUin) : options.longs === Number ? new $util.LongBits(message.accountUin.low >>> 0, message.accountUin.high >>> 0).toNumber(true) : message.accountUin;
                    if (options.oneofs)
                        object.account = "accountUin";
                }
                if (message.superTicket != null && message.hasOwnProperty("superTicket"))
                    object.superTicket = message.superTicket;
                return object;
            };

            /**
             * Converts this SwitchAccountRequest to JSON.
             * @function toJSON
             * @memberof kritor.core.SwitchAccountRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SwitchAccountRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SwitchAccountRequest
             * @function getTypeUrl
             * @memberof kritor.core.SwitchAccountRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SwitchAccountRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.core.SwitchAccountRequest";
            };

            return SwitchAccountRequest;
        })();

        core.SwitchAccountResponse = (function() {

            /**
             * Properties of a SwitchAccountResponse.
             * @memberof kritor.core
             * @interface ISwitchAccountResponse
             */

            /**
             * Constructs a new SwitchAccountResponse.
             * @memberof kritor.core
             * @classdesc Represents a SwitchAccountResponse.
             * @implements ISwitchAccountResponse
             * @constructor
             * @param {kritor.core.ISwitchAccountResponse=} [properties] Properties to set
             */
            function SwitchAccountResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new SwitchAccountResponse instance using the specified properties.
             * @function create
             * @memberof kritor.core.SwitchAccountResponse
             * @static
             * @param {kritor.core.ISwitchAccountResponse=} [properties] Properties to set
             * @returns {kritor.core.SwitchAccountResponse} SwitchAccountResponse instance
             */
            SwitchAccountResponse.create = function create(properties) {
                return new SwitchAccountResponse(properties);
            };

            /**
             * Encodes the specified SwitchAccountResponse message. Does not implicitly {@link kritor.core.SwitchAccountResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.core.SwitchAccountResponse
             * @static
             * @param {kritor.core.ISwitchAccountResponse} message SwitchAccountResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SwitchAccountResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified SwitchAccountResponse message, length delimited. Does not implicitly {@link kritor.core.SwitchAccountResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.core.SwitchAccountResponse
             * @static
             * @param {kritor.core.ISwitchAccountResponse} message SwitchAccountResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SwitchAccountResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SwitchAccountResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.core.SwitchAccountResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.core.SwitchAccountResponse} SwitchAccountResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SwitchAccountResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.core.SwitchAccountResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SwitchAccountResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.core.SwitchAccountResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.core.SwitchAccountResponse} SwitchAccountResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SwitchAccountResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SwitchAccountResponse message.
             * @function verify
             * @memberof kritor.core.SwitchAccountResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SwitchAccountResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a SwitchAccountResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.core.SwitchAccountResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.core.SwitchAccountResponse} SwitchAccountResponse
             */
            SwitchAccountResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.core.SwitchAccountResponse)
                    return object;
                return new $root.kritor.core.SwitchAccountResponse();
            };

            /**
             * Creates a plain object from a SwitchAccountResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.core.SwitchAccountResponse
             * @static
             * @param {kritor.core.SwitchAccountResponse} message SwitchAccountResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SwitchAccountResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this SwitchAccountResponse to JSON.
             * @function toJSON
             * @memberof kritor.core.SwitchAccountResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SwitchAccountResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SwitchAccountResponse
             * @function getTypeUrl
             * @memberof kritor.core.SwitchAccountResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SwitchAccountResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.core.SwitchAccountResponse";
            };

            return SwitchAccountResponse;
        })();

        return core;
    })();

    kritor.customization = (function() {

        /**
         * Namespace customization.
         * @memberof kritor
         * @namespace
         */
        const customization = {};

        customization.CustomizationService = (function() {

            /**
             * Constructs a new CustomizationService service.
             * @memberof kritor.customization
             * @classdesc Represents a CustomizationService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function CustomizationService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (CustomizationService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = CustomizationService;

            /**
             * Creates new CustomizationService service using the specified rpc implementation.
             * @function create
             * @memberof kritor.customization.CustomizationService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {CustomizationService} RPC service. Useful where requests and/or responses are streamed.
             */
            CustomizationService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link kritor.customization.CustomizationService#callFunction}.
             * @memberof kritor.customization.CustomizationService
             * @typedef CallFunctionCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.common.Response} [response] Response
             */

            /**
             * Calls CallFunction.
             * @function callFunction
             * @memberof kritor.customization.CustomizationService
             * @instance
             * @param {kritor.common.IRequest} request Request message or plain object
             * @param {kritor.customization.CustomizationService.CallFunctionCallback} callback Node-style callback called with the error, if any, and Response
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(CustomizationService.prototype.callFunction = function callFunction(request, callback) {
                return this.rpcCall(callFunction, $root.kritor.common.Request, $root.kritor.common.Response, request, callback);
            }, "name", { value: "CallFunction" });

            /**
             * Calls CallFunction.
             * @function callFunction
             * @memberof kritor.customization.CustomizationService
             * @instance
             * @param {kritor.common.IRequest} request Request message or plain object
             * @returns {Promise<kritor.common.Response>} Promise
             * @variation 2
             */

            return CustomizationService;
        })();

        return customization;
    })();

    kritor.developer = (function() {

        /**
         * Namespace developer.
         * @memberof kritor
         * @namespace
         */
        const developer = {};

        developer.DeveloperService = (function() {

            /**
             * Constructs a new DeveloperService service.
             * @memberof kritor.developer
             * @classdesc Represents a DeveloperService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function DeveloperService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (DeveloperService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = DeveloperService;

            /**
             * Creates new DeveloperService service using the specified rpc implementation.
             * @function create
             * @memberof kritor.developer.DeveloperService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {DeveloperService} RPC service. Useful where requests and/or responses are streamed.
             */
            DeveloperService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link kritor.developer.DeveloperService#shell}.
             * @memberof kritor.developer.DeveloperService
             * @typedef ShellCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.developer.ShellResponse} [response] ShellResponse
             */

            /**
             * Calls Shell.
             * @function shell
             * @memberof kritor.developer.DeveloperService
             * @instance
             * @param {kritor.developer.IShellRequest} request ShellRequest message or plain object
             * @param {kritor.developer.DeveloperService.ShellCallback} callback Node-style callback called with the error, if any, and ShellResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(DeveloperService.prototype.shell = function shell(request, callback) {
                return this.rpcCall(shell, $root.kritor.developer.ShellRequest, $root.kritor.developer.ShellResponse, request, callback);
            }, "name", { value: "Shell" });

            /**
             * Calls Shell.
             * @function shell
             * @memberof kritor.developer.DeveloperService
             * @instance
             * @param {kritor.developer.IShellRequest} request ShellRequest message or plain object
             * @returns {Promise<kritor.developer.ShellResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.developer.DeveloperService#getLog}.
             * @memberof kritor.developer.DeveloperService
             * @typedef GetLogCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.developer.GetLogResponse} [response] GetLogResponse
             */

            /**
             * Calls GetLog.
             * @function getLog
             * @memberof kritor.developer.DeveloperService
             * @instance
             * @param {kritor.developer.IGetLogRequest} request GetLogRequest message or plain object
             * @param {kritor.developer.DeveloperService.GetLogCallback} callback Node-style callback called with the error, if any, and GetLogResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(DeveloperService.prototype.getLog = function getLog(request, callback) {
                return this.rpcCall(getLog, $root.kritor.developer.GetLogRequest, $root.kritor.developer.GetLogResponse, request, callback);
            }, "name", { value: "GetLog" });

            /**
             * Calls GetLog.
             * @function getLog
             * @memberof kritor.developer.DeveloperService
             * @instance
             * @param {kritor.developer.IGetLogRequest} request GetLogRequest message or plain object
             * @returns {Promise<kritor.developer.GetLogResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.developer.DeveloperService#clearCache}.
             * @memberof kritor.developer.DeveloperService
             * @typedef ClearCacheCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.developer.ClearCacheResponse} [response] ClearCacheResponse
             */

            /**
             * Calls ClearCache.
             * @function clearCache
             * @memberof kritor.developer.DeveloperService
             * @instance
             * @param {kritor.developer.IClearCacheRequest} request ClearCacheRequest message or plain object
             * @param {kritor.developer.DeveloperService.ClearCacheCallback} callback Node-style callback called with the error, if any, and ClearCacheResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(DeveloperService.prototype.clearCache = function clearCache(request, callback) {
                return this.rpcCall(clearCache, $root.kritor.developer.ClearCacheRequest, $root.kritor.developer.ClearCacheResponse, request, callback);
            }, "name", { value: "ClearCache" });

            /**
             * Calls ClearCache.
             * @function clearCache
             * @memberof kritor.developer.DeveloperService
             * @instance
             * @param {kritor.developer.IClearCacheRequest} request ClearCacheRequest message or plain object
             * @returns {Promise<kritor.developer.ClearCacheResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.developer.DeveloperService#getDeviceBattery}.
             * @memberof kritor.developer.DeveloperService
             * @typedef GetDeviceBatteryCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.developer.GetDeviceBatteryResponse} [response] GetDeviceBatteryResponse
             */

            /**
             * Calls GetDeviceBattery.
             * @function getDeviceBattery
             * @memberof kritor.developer.DeveloperService
             * @instance
             * @param {kritor.developer.IGetDeviceBatteryRequest} request GetDeviceBatteryRequest message or plain object
             * @param {kritor.developer.DeveloperService.GetDeviceBatteryCallback} callback Node-style callback called with the error, if any, and GetDeviceBatteryResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(DeveloperService.prototype.getDeviceBattery = function getDeviceBattery(request, callback) {
                return this.rpcCall(getDeviceBattery, $root.kritor.developer.GetDeviceBatteryRequest, $root.kritor.developer.GetDeviceBatteryResponse, request, callback);
            }, "name", { value: "GetDeviceBattery" });

            /**
             * Calls GetDeviceBattery.
             * @function getDeviceBattery
             * @memberof kritor.developer.DeveloperService
             * @instance
             * @param {kritor.developer.IGetDeviceBatteryRequest} request GetDeviceBatteryRequest message or plain object
             * @returns {Promise<kritor.developer.GetDeviceBatteryResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.developer.DeveloperService#uploadImage}.
             * @memberof kritor.developer.DeveloperService
             * @typedef UploadImageCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.developer.UploadImageResponse} [response] UploadImageResponse
             */

            /**
             * Calls UploadImage.
             * @function uploadImage
             * @memberof kritor.developer.DeveloperService
             * @instance
             * @param {kritor.developer.IUploadImageRequest} request UploadImageRequest message or plain object
             * @param {kritor.developer.DeveloperService.UploadImageCallback} callback Node-style callback called with the error, if any, and UploadImageResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(DeveloperService.prototype.uploadImage = function uploadImage(request, callback) {
                return this.rpcCall(uploadImage, $root.kritor.developer.UploadImageRequest, $root.kritor.developer.UploadImageResponse, request, callback);
            }, "name", { value: "UploadImage" });

            /**
             * Calls UploadImage.
             * @function uploadImage
             * @memberof kritor.developer.DeveloperService
             * @instance
             * @param {kritor.developer.IUploadImageRequest} request UploadImageRequest message or plain object
             * @returns {Promise<kritor.developer.UploadImageResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.developer.DeveloperService#sendPacket}.
             * @memberof kritor.developer.DeveloperService
             * @typedef SendPacketCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.developer.SendPacketResponse} [response] SendPacketResponse
             */

            /**
             * Calls SendPacket.
             * @function sendPacket
             * @memberof kritor.developer.DeveloperService
             * @instance
             * @param {kritor.developer.ISendPacketRequest} request SendPacketRequest message or plain object
             * @param {kritor.developer.DeveloperService.SendPacketCallback} callback Node-style callback called with the error, if any, and SendPacketResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(DeveloperService.prototype.sendPacket = function sendPacket(request, callback) {
                return this.rpcCall(sendPacket, $root.kritor.developer.SendPacketRequest, $root.kritor.developer.SendPacketResponse, request, callback);
            }, "name", { value: "SendPacket" });

            /**
             * Calls SendPacket.
             * @function sendPacket
             * @memberof kritor.developer.DeveloperService
             * @instance
             * @param {kritor.developer.ISendPacketRequest} request SendPacketRequest message or plain object
             * @returns {Promise<kritor.developer.SendPacketResponse>} Promise
             * @variation 2
             */

            return DeveloperService;
        })();

        developer.ShellRequest = (function() {

            /**
             * Properties of a ShellRequest.
             * @memberof kritor.developer
             * @interface IShellRequest
             * @property {string|null} [command] ShellRequest command
             * @property {string|null} [directory] ShellRequest directory
             */

            /**
             * Constructs a new ShellRequest.
             * @memberof kritor.developer
             * @classdesc Represents a ShellRequest.
             * @implements IShellRequest
             * @constructor
             * @param {kritor.developer.IShellRequest=} [properties] Properties to set
             */
            function ShellRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ShellRequest command.
             * @member {string} command
             * @memberof kritor.developer.ShellRequest
             * @instance
             */
            ShellRequest.prototype.command = "";

            /**
             * ShellRequest directory.
             * @member {string} directory
             * @memberof kritor.developer.ShellRequest
             * @instance
             */
            ShellRequest.prototype.directory = "";

            /**
             * Creates a new ShellRequest instance using the specified properties.
             * @function create
             * @memberof kritor.developer.ShellRequest
             * @static
             * @param {kritor.developer.IShellRequest=} [properties] Properties to set
             * @returns {kritor.developer.ShellRequest} ShellRequest instance
             */
            ShellRequest.create = function create(properties) {
                return new ShellRequest(properties);
            };

            /**
             * Encodes the specified ShellRequest message. Does not implicitly {@link kritor.developer.ShellRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.developer.ShellRequest
             * @static
             * @param {kritor.developer.IShellRequest} message ShellRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ShellRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.command != null && Object.hasOwnProperty.call(message, "command"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.command);
                if (message.directory != null && Object.hasOwnProperty.call(message, "directory"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.directory);
                return writer;
            };

            /**
             * Encodes the specified ShellRequest message, length delimited. Does not implicitly {@link kritor.developer.ShellRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.developer.ShellRequest
             * @static
             * @param {kritor.developer.IShellRequest} message ShellRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ShellRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ShellRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.developer.ShellRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.developer.ShellRequest} ShellRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ShellRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.developer.ShellRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.command = reader.string();
                            break;
                        }
                    case 2: {
                            message.directory = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ShellRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.developer.ShellRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.developer.ShellRequest} ShellRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ShellRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ShellRequest message.
             * @function verify
             * @memberof kritor.developer.ShellRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ShellRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.command != null && message.hasOwnProperty("command"))
                    if (!$util.isString(message.command))
                        return "command: string expected";
                if (message.directory != null && message.hasOwnProperty("directory"))
                    if (!$util.isString(message.directory))
                        return "directory: string expected";
                return null;
            };

            /**
             * Creates a ShellRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.developer.ShellRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.developer.ShellRequest} ShellRequest
             */
            ShellRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.developer.ShellRequest)
                    return object;
                let message = new $root.kritor.developer.ShellRequest();
                if (object.command != null)
                    message.command = String(object.command);
                if (object.directory != null)
                    message.directory = String(object.directory);
                return message;
            };

            /**
             * Creates a plain object from a ShellRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.developer.ShellRequest
             * @static
             * @param {kritor.developer.ShellRequest} message ShellRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ShellRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.command = "";
                    object.directory = "";
                }
                if (message.command != null && message.hasOwnProperty("command"))
                    object.command = message.command;
                if (message.directory != null && message.hasOwnProperty("directory"))
                    object.directory = message.directory;
                return object;
            };

            /**
             * Converts this ShellRequest to JSON.
             * @function toJSON
             * @memberof kritor.developer.ShellRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ShellRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ShellRequest
             * @function getTypeUrl
             * @memberof kritor.developer.ShellRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ShellRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.developer.ShellRequest";
            };

            return ShellRequest;
        })();

        developer.ShellResponse = (function() {

            /**
             * Properties of a ShellResponse.
             * @memberof kritor.developer
             * @interface IShellResponse
             * @property {boolean|null} [isSuccess] ShellResponse isSuccess
             * @property {string|null} [data] ShellResponse data
             */

            /**
             * Constructs a new ShellResponse.
             * @memberof kritor.developer
             * @classdesc Represents a ShellResponse.
             * @implements IShellResponse
             * @constructor
             * @param {kritor.developer.IShellResponse=} [properties] Properties to set
             */
            function ShellResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ShellResponse isSuccess.
             * @member {boolean} isSuccess
             * @memberof kritor.developer.ShellResponse
             * @instance
             */
            ShellResponse.prototype.isSuccess = false;

            /**
             * ShellResponse data.
             * @member {string} data
             * @memberof kritor.developer.ShellResponse
             * @instance
             */
            ShellResponse.prototype.data = "";

            /**
             * Creates a new ShellResponse instance using the specified properties.
             * @function create
             * @memberof kritor.developer.ShellResponse
             * @static
             * @param {kritor.developer.IShellResponse=} [properties] Properties to set
             * @returns {kritor.developer.ShellResponse} ShellResponse instance
             */
            ShellResponse.create = function create(properties) {
                return new ShellResponse(properties);
            };

            /**
             * Encodes the specified ShellResponse message. Does not implicitly {@link kritor.developer.ShellResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.developer.ShellResponse
             * @static
             * @param {kritor.developer.IShellResponse} message ShellResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ShellResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.isSuccess != null && Object.hasOwnProperty.call(message, "isSuccess"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.isSuccess);
                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.data);
                return writer;
            };

            /**
             * Encodes the specified ShellResponse message, length delimited. Does not implicitly {@link kritor.developer.ShellResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.developer.ShellResponse
             * @static
             * @param {kritor.developer.IShellResponse} message ShellResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ShellResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ShellResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.developer.ShellResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.developer.ShellResponse} ShellResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ShellResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.developer.ShellResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.isSuccess = reader.bool();
                            break;
                        }
                    case 2: {
                            message.data = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ShellResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.developer.ShellResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.developer.ShellResponse} ShellResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ShellResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ShellResponse message.
             * @function verify
             * @memberof kritor.developer.ShellResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ShellResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.isSuccess != null && message.hasOwnProperty("isSuccess"))
                    if (typeof message.isSuccess !== "boolean")
                        return "isSuccess: boolean expected";
                if (message.data != null && message.hasOwnProperty("data"))
                    if (!$util.isString(message.data))
                        return "data: string expected";
                return null;
            };

            /**
             * Creates a ShellResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.developer.ShellResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.developer.ShellResponse} ShellResponse
             */
            ShellResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.developer.ShellResponse)
                    return object;
                let message = new $root.kritor.developer.ShellResponse();
                if (object.isSuccess != null)
                    message.isSuccess = Boolean(object.isSuccess);
                if (object.data != null)
                    message.data = String(object.data);
                return message;
            };

            /**
             * Creates a plain object from a ShellResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.developer.ShellResponse
             * @static
             * @param {kritor.developer.ShellResponse} message ShellResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ShellResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.isSuccess = false;
                    object.data = "";
                }
                if (message.isSuccess != null && message.hasOwnProperty("isSuccess"))
                    object.isSuccess = message.isSuccess;
                if (message.data != null && message.hasOwnProperty("data"))
                    object.data = message.data;
                return object;
            };

            /**
             * Converts this ShellResponse to JSON.
             * @function toJSON
             * @memberof kritor.developer.ShellResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ShellResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ShellResponse
             * @function getTypeUrl
             * @memberof kritor.developer.ShellResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ShellResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.developer.ShellResponse";
            };

            return ShellResponse;
        })();

        developer.GetLogRequest = (function() {

            /**
             * Properties of a GetLogRequest.
             * @memberof kritor.developer
             * @interface IGetLogRequest
             * @property {number|Long|null} [start] GetLogRequest start
             * @property {boolean|null} [recent] GetLogRequest recent
             */

            /**
             * Constructs a new GetLogRequest.
             * @memberof kritor.developer
             * @classdesc Represents a GetLogRequest.
             * @implements IGetLogRequest
             * @constructor
             * @param {kritor.developer.IGetLogRequest=} [properties] Properties to set
             */
            function GetLogRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetLogRequest start.
             * @member {number|Long} start
             * @memberof kritor.developer.GetLogRequest
             * @instance
             */
            GetLogRequest.prototype.start = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GetLogRequest recent.
             * @member {boolean} recent
             * @memberof kritor.developer.GetLogRequest
             * @instance
             */
            GetLogRequest.prototype.recent = false;

            /**
             * Creates a new GetLogRequest instance using the specified properties.
             * @function create
             * @memberof kritor.developer.GetLogRequest
             * @static
             * @param {kritor.developer.IGetLogRequest=} [properties] Properties to set
             * @returns {kritor.developer.GetLogRequest} GetLogRequest instance
             */
            GetLogRequest.create = function create(properties) {
                return new GetLogRequest(properties);
            };

            /**
             * Encodes the specified GetLogRequest message. Does not implicitly {@link kritor.developer.GetLogRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.developer.GetLogRequest
             * @static
             * @param {kritor.developer.IGetLogRequest} message GetLogRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetLogRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.start != null && Object.hasOwnProperty.call(message, "start"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.start);
                if (message.recent != null && Object.hasOwnProperty.call(message, "recent"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.recent);
                return writer;
            };

            /**
             * Encodes the specified GetLogRequest message, length delimited. Does not implicitly {@link kritor.developer.GetLogRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.developer.GetLogRequest
             * @static
             * @param {kritor.developer.IGetLogRequest} message GetLogRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetLogRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetLogRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.developer.GetLogRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.developer.GetLogRequest} GetLogRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetLogRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.developer.GetLogRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.start = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.recent = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetLogRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.developer.GetLogRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.developer.GetLogRequest} GetLogRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetLogRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetLogRequest message.
             * @function verify
             * @memberof kritor.developer.GetLogRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetLogRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.start != null && message.hasOwnProperty("start"))
                    if (!$util.isInteger(message.start) && !(message.start && $util.isInteger(message.start.low) && $util.isInteger(message.start.high)))
                        return "start: integer|Long expected";
                if (message.recent != null && message.hasOwnProperty("recent"))
                    if (typeof message.recent !== "boolean")
                        return "recent: boolean expected";
                return null;
            };

            /**
             * Creates a GetLogRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.developer.GetLogRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.developer.GetLogRequest} GetLogRequest
             */
            GetLogRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.developer.GetLogRequest)
                    return object;
                let message = new $root.kritor.developer.GetLogRequest();
                if (object.start != null)
                    if ($util.Long)
                        (message.start = $util.Long.fromValue(object.start)).unsigned = true;
                    else if (typeof object.start === "string")
                        message.start = parseInt(object.start, 10);
                    else if (typeof object.start === "number")
                        message.start = object.start;
                    else if (typeof object.start === "object")
                        message.start = new $util.LongBits(object.start.low >>> 0, object.start.high >>> 0).toNumber(true);
                if (object.recent != null)
                    message.recent = Boolean(object.recent);
                return message;
            };

            /**
             * Creates a plain object from a GetLogRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.developer.GetLogRequest
             * @static
             * @param {kritor.developer.GetLogRequest} message GetLogRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetLogRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.start = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.start = options.longs === String ? "0" : 0;
                    object.recent = false;
                }
                if (message.start != null && message.hasOwnProperty("start"))
                    if (typeof message.start === "number")
                        object.start = options.longs === String ? String(message.start) : message.start;
                    else
                        object.start = options.longs === String ? $util.Long.prototype.toString.call(message.start) : options.longs === Number ? new $util.LongBits(message.start.low >>> 0, message.start.high >>> 0).toNumber(true) : message.start;
                if (message.recent != null && message.hasOwnProperty("recent"))
                    object.recent = message.recent;
                return object;
            };

            /**
             * Converts this GetLogRequest to JSON.
             * @function toJSON
             * @memberof kritor.developer.GetLogRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetLogRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetLogRequest
             * @function getTypeUrl
             * @memberof kritor.developer.GetLogRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetLogRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.developer.GetLogRequest";
            };

            return GetLogRequest;
        })();

        developer.GetLogResponse = (function() {

            /**
             * Properties of a GetLogResponse.
             * @memberof kritor.developer
             * @interface IGetLogResponse
             * @property {boolean|null} [isSuccess] GetLogResponse isSuccess
             * @property {string|null} [log] GetLogResponse log
             */

            /**
             * Constructs a new GetLogResponse.
             * @memberof kritor.developer
             * @classdesc Represents a GetLogResponse.
             * @implements IGetLogResponse
             * @constructor
             * @param {kritor.developer.IGetLogResponse=} [properties] Properties to set
             */
            function GetLogResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetLogResponse isSuccess.
             * @member {boolean} isSuccess
             * @memberof kritor.developer.GetLogResponse
             * @instance
             */
            GetLogResponse.prototype.isSuccess = false;

            /**
             * GetLogResponse log.
             * @member {string} log
             * @memberof kritor.developer.GetLogResponse
             * @instance
             */
            GetLogResponse.prototype.log = "";

            /**
             * Creates a new GetLogResponse instance using the specified properties.
             * @function create
             * @memberof kritor.developer.GetLogResponse
             * @static
             * @param {kritor.developer.IGetLogResponse=} [properties] Properties to set
             * @returns {kritor.developer.GetLogResponse} GetLogResponse instance
             */
            GetLogResponse.create = function create(properties) {
                return new GetLogResponse(properties);
            };

            /**
             * Encodes the specified GetLogResponse message. Does not implicitly {@link kritor.developer.GetLogResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.developer.GetLogResponse
             * @static
             * @param {kritor.developer.IGetLogResponse} message GetLogResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetLogResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.isSuccess != null && Object.hasOwnProperty.call(message, "isSuccess"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.isSuccess);
                if (message.log != null && Object.hasOwnProperty.call(message, "log"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.log);
                return writer;
            };

            /**
             * Encodes the specified GetLogResponse message, length delimited. Does not implicitly {@link kritor.developer.GetLogResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.developer.GetLogResponse
             * @static
             * @param {kritor.developer.IGetLogResponse} message GetLogResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetLogResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetLogResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.developer.GetLogResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.developer.GetLogResponse} GetLogResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetLogResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.developer.GetLogResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.isSuccess = reader.bool();
                            break;
                        }
                    case 2: {
                            message.log = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetLogResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.developer.GetLogResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.developer.GetLogResponse} GetLogResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetLogResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetLogResponse message.
             * @function verify
             * @memberof kritor.developer.GetLogResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetLogResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.isSuccess != null && message.hasOwnProperty("isSuccess"))
                    if (typeof message.isSuccess !== "boolean")
                        return "isSuccess: boolean expected";
                if (message.log != null && message.hasOwnProperty("log"))
                    if (!$util.isString(message.log))
                        return "log: string expected";
                return null;
            };

            /**
             * Creates a GetLogResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.developer.GetLogResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.developer.GetLogResponse} GetLogResponse
             */
            GetLogResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.developer.GetLogResponse)
                    return object;
                let message = new $root.kritor.developer.GetLogResponse();
                if (object.isSuccess != null)
                    message.isSuccess = Boolean(object.isSuccess);
                if (object.log != null)
                    message.log = String(object.log);
                return message;
            };

            /**
             * Creates a plain object from a GetLogResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.developer.GetLogResponse
             * @static
             * @param {kritor.developer.GetLogResponse} message GetLogResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetLogResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.isSuccess = false;
                    object.log = "";
                }
                if (message.isSuccess != null && message.hasOwnProperty("isSuccess"))
                    object.isSuccess = message.isSuccess;
                if (message.log != null && message.hasOwnProperty("log"))
                    object.log = message.log;
                return object;
            };

            /**
             * Converts this GetLogResponse to JSON.
             * @function toJSON
             * @memberof kritor.developer.GetLogResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetLogResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetLogResponse
             * @function getTypeUrl
             * @memberof kritor.developer.GetLogResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetLogResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.developer.GetLogResponse";
            };

            return GetLogResponse;
        })();

        developer.ClearCacheRequest = (function() {

            /**
             * Properties of a ClearCacheRequest.
             * @memberof kritor.developer
             * @interface IClearCacheRequest
             */

            /**
             * Constructs a new ClearCacheRequest.
             * @memberof kritor.developer
             * @classdesc Represents a ClearCacheRequest.
             * @implements IClearCacheRequest
             * @constructor
             * @param {kritor.developer.IClearCacheRequest=} [properties] Properties to set
             */
            function ClearCacheRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new ClearCacheRequest instance using the specified properties.
             * @function create
             * @memberof kritor.developer.ClearCacheRequest
             * @static
             * @param {kritor.developer.IClearCacheRequest=} [properties] Properties to set
             * @returns {kritor.developer.ClearCacheRequest} ClearCacheRequest instance
             */
            ClearCacheRequest.create = function create(properties) {
                return new ClearCacheRequest(properties);
            };

            /**
             * Encodes the specified ClearCacheRequest message. Does not implicitly {@link kritor.developer.ClearCacheRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.developer.ClearCacheRequest
             * @static
             * @param {kritor.developer.IClearCacheRequest} message ClearCacheRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ClearCacheRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified ClearCacheRequest message, length delimited. Does not implicitly {@link kritor.developer.ClearCacheRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.developer.ClearCacheRequest
             * @static
             * @param {kritor.developer.IClearCacheRequest} message ClearCacheRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ClearCacheRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ClearCacheRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.developer.ClearCacheRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.developer.ClearCacheRequest} ClearCacheRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ClearCacheRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.developer.ClearCacheRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ClearCacheRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.developer.ClearCacheRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.developer.ClearCacheRequest} ClearCacheRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ClearCacheRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ClearCacheRequest message.
             * @function verify
             * @memberof kritor.developer.ClearCacheRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ClearCacheRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a ClearCacheRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.developer.ClearCacheRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.developer.ClearCacheRequest} ClearCacheRequest
             */
            ClearCacheRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.developer.ClearCacheRequest)
                    return object;
                return new $root.kritor.developer.ClearCacheRequest();
            };

            /**
             * Creates a plain object from a ClearCacheRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.developer.ClearCacheRequest
             * @static
             * @param {kritor.developer.ClearCacheRequest} message ClearCacheRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ClearCacheRequest.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this ClearCacheRequest to JSON.
             * @function toJSON
             * @memberof kritor.developer.ClearCacheRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ClearCacheRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ClearCacheRequest
             * @function getTypeUrl
             * @memberof kritor.developer.ClearCacheRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ClearCacheRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.developer.ClearCacheRequest";
            };

            return ClearCacheRequest;
        })();

        developer.ClearCacheResponse = (function() {

            /**
             * Properties of a ClearCacheResponse.
             * @memberof kritor.developer
             * @interface IClearCacheResponse
             */

            /**
             * Constructs a new ClearCacheResponse.
             * @memberof kritor.developer
             * @classdesc Represents a ClearCacheResponse.
             * @implements IClearCacheResponse
             * @constructor
             * @param {kritor.developer.IClearCacheResponse=} [properties] Properties to set
             */
            function ClearCacheResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new ClearCacheResponse instance using the specified properties.
             * @function create
             * @memberof kritor.developer.ClearCacheResponse
             * @static
             * @param {kritor.developer.IClearCacheResponse=} [properties] Properties to set
             * @returns {kritor.developer.ClearCacheResponse} ClearCacheResponse instance
             */
            ClearCacheResponse.create = function create(properties) {
                return new ClearCacheResponse(properties);
            };

            /**
             * Encodes the specified ClearCacheResponse message. Does not implicitly {@link kritor.developer.ClearCacheResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.developer.ClearCacheResponse
             * @static
             * @param {kritor.developer.IClearCacheResponse} message ClearCacheResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ClearCacheResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified ClearCacheResponse message, length delimited. Does not implicitly {@link kritor.developer.ClearCacheResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.developer.ClearCacheResponse
             * @static
             * @param {kritor.developer.IClearCacheResponse} message ClearCacheResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ClearCacheResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ClearCacheResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.developer.ClearCacheResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.developer.ClearCacheResponse} ClearCacheResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ClearCacheResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.developer.ClearCacheResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ClearCacheResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.developer.ClearCacheResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.developer.ClearCacheResponse} ClearCacheResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ClearCacheResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ClearCacheResponse message.
             * @function verify
             * @memberof kritor.developer.ClearCacheResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ClearCacheResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a ClearCacheResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.developer.ClearCacheResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.developer.ClearCacheResponse} ClearCacheResponse
             */
            ClearCacheResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.developer.ClearCacheResponse)
                    return object;
                return new $root.kritor.developer.ClearCacheResponse();
            };

            /**
             * Creates a plain object from a ClearCacheResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.developer.ClearCacheResponse
             * @static
             * @param {kritor.developer.ClearCacheResponse} message ClearCacheResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ClearCacheResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this ClearCacheResponse to JSON.
             * @function toJSON
             * @memberof kritor.developer.ClearCacheResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ClearCacheResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ClearCacheResponse
             * @function getTypeUrl
             * @memberof kritor.developer.ClearCacheResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ClearCacheResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.developer.ClearCacheResponse";
            };

            return ClearCacheResponse;
        })();

        developer.GetDeviceBatteryRequest = (function() {

            /**
             * Properties of a GetDeviceBatteryRequest.
             * @memberof kritor.developer
             * @interface IGetDeviceBatteryRequest
             */

            /**
             * Constructs a new GetDeviceBatteryRequest.
             * @memberof kritor.developer
             * @classdesc Represents a GetDeviceBatteryRequest.
             * @implements IGetDeviceBatteryRequest
             * @constructor
             * @param {kritor.developer.IGetDeviceBatteryRequest=} [properties] Properties to set
             */
            function GetDeviceBatteryRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new GetDeviceBatteryRequest instance using the specified properties.
             * @function create
             * @memberof kritor.developer.GetDeviceBatteryRequest
             * @static
             * @param {kritor.developer.IGetDeviceBatteryRequest=} [properties] Properties to set
             * @returns {kritor.developer.GetDeviceBatteryRequest} GetDeviceBatteryRequest instance
             */
            GetDeviceBatteryRequest.create = function create(properties) {
                return new GetDeviceBatteryRequest(properties);
            };

            /**
             * Encodes the specified GetDeviceBatteryRequest message. Does not implicitly {@link kritor.developer.GetDeviceBatteryRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.developer.GetDeviceBatteryRequest
             * @static
             * @param {kritor.developer.IGetDeviceBatteryRequest} message GetDeviceBatteryRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetDeviceBatteryRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified GetDeviceBatteryRequest message, length delimited. Does not implicitly {@link kritor.developer.GetDeviceBatteryRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.developer.GetDeviceBatteryRequest
             * @static
             * @param {kritor.developer.IGetDeviceBatteryRequest} message GetDeviceBatteryRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetDeviceBatteryRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetDeviceBatteryRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.developer.GetDeviceBatteryRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.developer.GetDeviceBatteryRequest} GetDeviceBatteryRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetDeviceBatteryRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.developer.GetDeviceBatteryRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetDeviceBatteryRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.developer.GetDeviceBatteryRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.developer.GetDeviceBatteryRequest} GetDeviceBatteryRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetDeviceBatteryRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetDeviceBatteryRequest message.
             * @function verify
             * @memberof kritor.developer.GetDeviceBatteryRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetDeviceBatteryRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a GetDeviceBatteryRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.developer.GetDeviceBatteryRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.developer.GetDeviceBatteryRequest} GetDeviceBatteryRequest
             */
            GetDeviceBatteryRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.developer.GetDeviceBatteryRequest)
                    return object;
                return new $root.kritor.developer.GetDeviceBatteryRequest();
            };

            /**
             * Creates a plain object from a GetDeviceBatteryRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.developer.GetDeviceBatteryRequest
             * @static
             * @param {kritor.developer.GetDeviceBatteryRequest} message GetDeviceBatteryRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetDeviceBatteryRequest.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this GetDeviceBatteryRequest to JSON.
             * @function toJSON
             * @memberof kritor.developer.GetDeviceBatteryRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetDeviceBatteryRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetDeviceBatteryRequest
             * @function getTypeUrl
             * @memberof kritor.developer.GetDeviceBatteryRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetDeviceBatteryRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.developer.GetDeviceBatteryRequest";
            };

            return GetDeviceBatteryRequest;
        })();

        developer.GetDeviceBatteryResponse = (function() {

            /**
             * Properties of a GetDeviceBatteryResponse.
             * @memberof kritor.developer
             * @interface IGetDeviceBatteryResponse
             * @property {number|null} [battery] GetDeviceBatteryResponse battery
             * @property {number|null} [scale] GetDeviceBatteryResponse scale
             * @property {number|null} [status] GetDeviceBatteryResponse status
             */

            /**
             * Constructs a new GetDeviceBatteryResponse.
             * @memberof kritor.developer
             * @classdesc Represents a GetDeviceBatteryResponse.
             * @implements IGetDeviceBatteryResponse
             * @constructor
             * @param {kritor.developer.IGetDeviceBatteryResponse=} [properties] Properties to set
             */
            function GetDeviceBatteryResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetDeviceBatteryResponse battery.
             * @member {number} battery
             * @memberof kritor.developer.GetDeviceBatteryResponse
             * @instance
             */
            GetDeviceBatteryResponse.prototype.battery = 0;

            /**
             * GetDeviceBatteryResponse scale.
             * @member {number} scale
             * @memberof kritor.developer.GetDeviceBatteryResponse
             * @instance
             */
            GetDeviceBatteryResponse.prototype.scale = 0;

            /**
             * GetDeviceBatteryResponse status.
             * @member {number} status
             * @memberof kritor.developer.GetDeviceBatteryResponse
             * @instance
             */
            GetDeviceBatteryResponse.prototype.status = 0;

            /**
             * Creates a new GetDeviceBatteryResponse instance using the specified properties.
             * @function create
             * @memberof kritor.developer.GetDeviceBatteryResponse
             * @static
             * @param {kritor.developer.IGetDeviceBatteryResponse=} [properties] Properties to set
             * @returns {kritor.developer.GetDeviceBatteryResponse} GetDeviceBatteryResponse instance
             */
            GetDeviceBatteryResponse.create = function create(properties) {
                return new GetDeviceBatteryResponse(properties);
            };

            /**
             * Encodes the specified GetDeviceBatteryResponse message. Does not implicitly {@link kritor.developer.GetDeviceBatteryResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.developer.GetDeviceBatteryResponse
             * @static
             * @param {kritor.developer.IGetDeviceBatteryResponse} message GetDeviceBatteryResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetDeviceBatteryResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.battery != null && Object.hasOwnProperty.call(message, "battery"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.battery);
                if (message.scale != null && Object.hasOwnProperty.call(message, "scale"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.scale);
                if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.status);
                return writer;
            };

            /**
             * Encodes the specified GetDeviceBatteryResponse message, length delimited. Does not implicitly {@link kritor.developer.GetDeviceBatteryResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.developer.GetDeviceBatteryResponse
             * @static
             * @param {kritor.developer.IGetDeviceBatteryResponse} message GetDeviceBatteryResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetDeviceBatteryResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetDeviceBatteryResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.developer.GetDeviceBatteryResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.developer.GetDeviceBatteryResponse} GetDeviceBatteryResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetDeviceBatteryResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.developer.GetDeviceBatteryResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.battery = reader.uint32();
                            break;
                        }
                    case 2: {
                            message.scale = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.status = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetDeviceBatteryResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.developer.GetDeviceBatteryResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.developer.GetDeviceBatteryResponse} GetDeviceBatteryResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetDeviceBatteryResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetDeviceBatteryResponse message.
             * @function verify
             * @memberof kritor.developer.GetDeviceBatteryResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetDeviceBatteryResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.battery != null && message.hasOwnProperty("battery"))
                    if (!$util.isInteger(message.battery))
                        return "battery: integer expected";
                if (message.scale != null && message.hasOwnProperty("scale"))
                    if (!$util.isInteger(message.scale))
                        return "scale: integer expected";
                if (message.status != null && message.hasOwnProperty("status"))
                    if (!$util.isInteger(message.status))
                        return "status: integer expected";
                return null;
            };

            /**
             * Creates a GetDeviceBatteryResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.developer.GetDeviceBatteryResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.developer.GetDeviceBatteryResponse} GetDeviceBatteryResponse
             */
            GetDeviceBatteryResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.developer.GetDeviceBatteryResponse)
                    return object;
                let message = new $root.kritor.developer.GetDeviceBatteryResponse();
                if (object.battery != null)
                    message.battery = object.battery >>> 0;
                if (object.scale != null)
                    message.scale = object.scale >>> 0;
                if (object.status != null)
                    message.status = object.status >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a GetDeviceBatteryResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.developer.GetDeviceBatteryResponse
             * @static
             * @param {kritor.developer.GetDeviceBatteryResponse} message GetDeviceBatteryResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetDeviceBatteryResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.battery = 0;
                    object.scale = 0;
                    object.status = 0;
                }
                if (message.battery != null && message.hasOwnProperty("battery"))
                    object.battery = message.battery;
                if (message.scale != null && message.hasOwnProperty("scale"))
                    object.scale = message.scale;
                if (message.status != null && message.hasOwnProperty("status"))
                    object.status = message.status;
                return object;
            };

            /**
             * Converts this GetDeviceBatteryResponse to JSON.
             * @function toJSON
             * @memberof kritor.developer.GetDeviceBatteryResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetDeviceBatteryResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetDeviceBatteryResponse
             * @function getTypeUrl
             * @memberof kritor.developer.GetDeviceBatteryResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetDeviceBatteryResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.developer.GetDeviceBatteryResponse";
            };

            return GetDeviceBatteryResponse;
        })();

        developer.UploadImageRequest = (function() {

            /**
             * Properties of an UploadImageRequest.
             * @memberof kritor.developer
             * @interface IUploadImageRequest
             * @property {Uint8Array|null} [file] UploadImageRequest file
             * @property {string|null} [fileName] UploadImageRequest fileName
             * @property {string|null} [filePath] UploadImageRequest filePath
             * @property {string|null} [fileUrl] UploadImageRequest fileUrl
             * @property {number|Long|null} [groupId] UploadImageRequest groupId
             */

            /**
             * Constructs a new UploadImageRequest.
             * @memberof kritor.developer
             * @classdesc Represents an UploadImageRequest.
             * @implements IUploadImageRequest
             * @constructor
             * @param {kritor.developer.IUploadImageRequest=} [properties] Properties to set
             */
            function UploadImageRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * UploadImageRequest file.
             * @member {Uint8Array|null|undefined} file
             * @memberof kritor.developer.UploadImageRequest
             * @instance
             */
            UploadImageRequest.prototype.file = null;

            /**
             * UploadImageRequest fileName.
             * @member {string|null|undefined} fileName
             * @memberof kritor.developer.UploadImageRequest
             * @instance
             */
            UploadImageRequest.prototype.fileName = null;

            /**
             * UploadImageRequest filePath.
             * @member {string|null|undefined} filePath
             * @memberof kritor.developer.UploadImageRequest
             * @instance
             */
            UploadImageRequest.prototype.filePath = null;

            /**
             * UploadImageRequest fileUrl.
             * @member {string|null|undefined} fileUrl
             * @memberof kritor.developer.UploadImageRequest
             * @instance
             */
            UploadImageRequest.prototype.fileUrl = null;

            /**
             * UploadImageRequest groupId.
             * @member {number|Long} groupId
             * @memberof kritor.developer.UploadImageRequest
             * @instance
             */
            UploadImageRequest.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * UploadImageRequest data.
             * @member {"file"|"fileName"|"filePath"|"fileUrl"|undefined} data
             * @memberof kritor.developer.UploadImageRequest
             * @instance
             */
            Object.defineProperty(UploadImageRequest.prototype, "data", {
                get: $util.oneOfGetter($oneOfFields = ["file", "fileName", "filePath", "fileUrl"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new UploadImageRequest instance using the specified properties.
             * @function create
             * @memberof kritor.developer.UploadImageRequest
             * @static
             * @param {kritor.developer.IUploadImageRequest=} [properties] Properties to set
             * @returns {kritor.developer.UploadImageRequest} UploadImageRequest instance
             */
            UploadImageRequest.create = function create(properties) {
                return new UploadImageRequest(properties);
            };

            /**
             * Encodes the specified UploadImageRequest message. Does not implicitly {@link kritor.developer.UploadImageRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.developer.UploadImageRequest
             * @static
             * @param {kritor.developer.IUploadImageRequest} message UploadImageRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UploadImageRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.file != null && Object.hasOwnProperty.call(message, "file"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.file);
                if (message.fileName != null && Object.hasOwnProperty.call(message, "fileName"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.fileName);
                if (message.filePath != null && Object.hasOwnProperty.call(message, "filePath"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.filePath);
                if (message.fileUrl != null && Object.hasOwnProperty.call(message, "fileUrl"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.fileUrl);
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.groupId);
                return writer;
            };

            /**
             * Encodes the specified UploadImageRequest message, length delimited. Does not implicitly {@link kritor.developer.UploadImageRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.developer.UploadImageRequest
             * @static
             * @param {kritor.developer.IUploadImageRequest} message UploadImageRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UploadImageRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an UploadImageRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.developer.UploadImageRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.developer.UploadImageRequest} UploadImageRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UploadImageRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.developer.UploadImageRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.file = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.fileName = reader.string();
                            break;
                        }
                    case 3: {
                            message.filePath = reader.string();
                            break;
                        }
                    case 4: {
                            message.fileUrl = reader.string();
                            break;
                        }
                    case 5: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an UploadImageRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.developer.UploadImageRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.developer.UploadImageRequest} UploadImageRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UploadImageRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an UploadImageRequest message.
             * @function verify
             * @memberof kritor.developer.UploadImageRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UploadImageRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.file != null && message.hasOwnProperty("file")) {
                    properties.data = 1;
                    if (!(message.file && typeof message.file.length === "number" || $util.isString(message.file)))
                        return "file: buffer expected";
                }
                if (message.fileName != null && message.hasOwnProperty("fileName")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    if (!$util.isString(message.fileName))
                        return "fileName: string expected";
                }
                if (message.filePath != null && message.hasOwnProperty("filePath")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    if (!$util.isString(message.filePath))
                        return "filePath: string expected";
                }
                if (message.fileUrl != null && message.hasOwnProperty("fileUrl")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    if (!$util.isString(message.fileUrl))
                        return "fileUrl: string expected";
                }
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                return null;
            };

            /**
             * Creates an UploadImageRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.developer.UploadImageRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.developer.UploadImageRequest} UploadImageRequest
             */
            UploadImageRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.developer.UploadImageRequest)
                    return object;
                let message = new $root.kritor.developer.UploadImageRequest();
                if (object.file != null)
                    if (typeof object.file === "string")
                        $util.base64.decode(object.file, message.file = $util.newBuffer($util.base64.length(object.file)), 0);
                    else if (object.file.length >= 0)
                        message.file = object.file;
                if (object.fileName != null)
                    message.fileName = String(object.fileName);
                if (object.filePath != null)
                    message.filePath = String(object.filePath);
                if (object.fileUrl != null)
                    message.fileUrl = String(object.fileUrl);
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from an UploadImageRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.developer.UploadImageRequest
             * @static
             * @param {kritor.developer.UploadImageRequest} message UploadImageRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UploadImageRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                if (message.file != null && message.hasOwnProperty("file")) {
                    object.file = options.bytes === String ? $util.base64.encode(message.file, 0, message.file.length) : options.bytes === Array ? Array.prototype.slice.call(message.file) : message.file;
                    if (options.oneofs)
                        object.data = "file";
                }
                if (message.fileName != null && message.hasOwnProperty("fileName")) {
                    object.fileName = message.fileName;
                    if (options.oneofs)
                        object.data = "fileName";
                }
                if (message.filePath != null && message.hasOwnProperty("filePath")) {
                    object.filePath = message.filePath;
                    if (options.oneofs)
                        object.data = "filePath";
                }
                if (message.fileUrl != null && message.hasOwnProperty("fileUrl")) {
                    object.fileUrl = message.fileUrl;
                    if (options.oneofs)
                        object.data = "fileUrl";
                }
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                return object;
            };

            /**
             * Converts this UploadImageRequest to JSON.
             * @function toJSON
             * @memberof kritor.developer.UploadImageRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UploadImageRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for UploadImageRequest
             * @function getTypeUrl
             * @memberof kritor.developer.UploadImageRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            UploadImageRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.developer.UploadImageRequest";
            };

            return UploadImageRequest;
        })();

        developer.UploadImageResponse = (function() {

            /**
             * Properties of an UploadImageResponse.
             * @memberof kritor.developer
             * @interface IUploadImageResponse
             * @property {boolean|null} [isSuccess] UploadImageResponse isSuccess
             * @property {string|null} [imageUrl] UploadImageResponse imageUrl
             */

            /**
             * Constructs a new UploadImageResponse.
             * @memberof kritor.developer
             * @classdesc Represents an UploadImageResponse.
             * @implements IUploadImageResponse
             * @constructor
             * @param {kritor.developer.IUploadImageResponse=} [properties] Properties to set
             */
            function UploadImageResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * UploadImageResponse isSuccess.
             * @member {boolean} isSuccess
             * @memberof kritor.developer.UploadImageResponse
             * @instance
             */
            UploadImageResponse.prototype.isSuccess = false;

            /**
             * UploadImageResponse imageUrl.
             * @member {string} imageUrl
             * @memberof kritor.developer.UploadImageResponse
             * @instance
             */
            UploadImageResponse.prototype.imageUrl = "";

            /**
             * Creates a new UploadImageResponse instance using the specified properties.
             * @function create
             * @memberof kritor.developer.UploadImageResponse
             * @static
             * @param {kritor.developer.IUploadImageResponse=} [properties] Properties to set
             * @returns {kritor.developer.UploadImageResponse} UploadImageResponse instance
             */
            UploadImageResponse.create = function create(properties) {
                return new UploadImageResponse(properties);
            };

            /**
             * Encodes the specified UploadImageResponse message. Does not implicitly {@link kritor.developer.UploadImageResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.developer.UploadImageResponse
             * @static
             * @param {kritor.developer.IUploadImageResponse} message UploadImageResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UploadImageResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.isSuccess != null && Object.hasOwnProperty.call(message, "isSuccess"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.isSuccess);
                if (message.imageUrl != null && Object.hasOwnProperty.call(message, "imageUrl"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.imageUrl);
                return writer;
            };

            /**
             * Encodes the specified UploadImageResponse message, length delimited. Does not implicitly {@link kritor.developer.UploadImageResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.developer.UploadImageResponse
             * @static
             * @param {kritor.developer.IUploadImageResponse} message UploadImageResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UploadImageResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an UploadImageResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.developer.UploadImageResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.developer.UploadImageResponse} UploadImageResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UploadImageResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.developer.UploadImageResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.isSuccess = reader.bool();
                            break;
                        }
                    case 2: {
                            message.imageUrl = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an UploadImageResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.developer.UploadImageResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.developer.UploadImageResponse} UploadImageResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UploadImageResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an UploadImageResponse message.
             * @function verify
             * @memberof kritor.developer.UploadImageResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UploadImageResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.isSuccess != null && message.hasOwnProperty("isSuccess"))
                    if (typeof message.isSuccess !== "boolean")
                        return "isSuccess: boolean expected";
                if (message.imageUrl != null && message.hasOwnProperty("imageUrl"))
                    if (!$util.isString(message.imageUrl))
                        return "imageUrl: string expected";
                return null;
            };

            /**
             * Creates an UploadImageResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.developer.UploadImageResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.developer.UploadImageResponse} UploadImageResponse
             */
            UploadImageResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.developer.UploadImageResponse)
                    return object;
                let message = new $root.kritor.developer.UploadImageResponse();
                if (object.isSuccess != null)
                    message.isSuccess = Boolean(object.isSuccess);
                if (object.imageUrl != null)
                    message.imageUrl = String(object.imageUrl);
                return message;
            };

            /**
             * Creates a plain object from an UploadImageResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.developer.UploadImageResponse
             * @static
             * @param {kritor.developer.UploadImageResponse} message UploadImageResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UploadImageResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.isSuccess = false;
                    object.imageUrl = "";
                }
                if (message.isSuccess != null && message.hasOwnProperty("isSuccess"))
                    object.isSuccess = message.isSuccess;
                if (message.imageUrl != null && message.hasOwnProperty("imageUrl"))
                    object.imageUrl = message.imageUrl;
                return object;
            };

            /**
             * Converts this UploadImageResponse to JSON.
             * @function toJSON
             * @memberof kritor.developer.UploadImageResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UploadImageResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for UploadImageResponse
             * @function getTypeUrl
             * @memberof kritor.developer.UploadImageResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            UploadImageResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.developer.UploadImageResponse";
            };

            return UploadImageResponse;
        })();

        developer.SendPacketRequest = (function() {

            /**
             * Properties of a SendPacketRequest.
             * @memberof kritor.developer
             * @interface ISendPacketRequest
             * @property {string|null} [command] SendPacketRequest command
             * @property {Uint8Array|null} [requestBuffer] SendPacketRequest requestBuffer
             * @property {boolean|null} [isProtobuf] SendPacketRequest isProtobuf
             * @property {Object.<string,string>|null} [attrs] SendPacketRequest attrs
             */

            /**
             * Constructs a new SendPacketRequest.
             * @memberof kritor.developer
             * @classdesc Represents a SendPacketRequest.
             * @implements ISendPacketRequest
             * @constructor
             * @param {kritor.developer.ISendPacketRequest=} [properties] Properties to set
             */
            function SendPacketRequest(properties) {
                this.attrs = {};
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SendPacketRequest command.
             * @member {string} command
             * @memberof kritor.developer.SendPacketRequest
             * @instance
             */
            SendPacketRequest.prototype.command = "";

            /**
             * SendPacketRequest requestBuffer.
             * @member {Uint8Array} requestBuffer
             * @memberof kritor.developer.SendPacketRequest
             * @instance
             */
            SendPacketRequest.prototype.requestBuffer = $util.newBuffer([]);

            /**
             * SendPacketRequest isProtobuf.
             * @member {boolean} isProtobuf
             * @memberof kritor.developer.SendPacketRequest
             * @instance
             */
            SendPacketRequest.prototype.isProtobuf = false;

            /**
             * SendPacketRequest attrs.
             * @member {Object.<string,string>} attrs
             * @memberof kritor.developer.SendPacketRequest
             * @instance
             */
            SendPacketRequest.prototype.attrs = $util.emptyObject;

            /**
             * Creates a new SendPacketRequest instance using the specified properties.
             * @function create
             * @memberof kritor.developer.SendPacketRequest
             * @static
             * @param {kritor.developer.ISendPacketRequest=} [properties] Properties to set
             * @returns {kritor.developer.SendPacketRequest} SendPacketRequest instance
             */
            SendPacketRequest.create = function create(properties) {
                return new SendPacketRequest(properties);
            };

            /**
             * Encodes the specified SendPacketRequest message. Does not implicitly {@link kritor.developer.SendPacketRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.developer.SendPacketRequest
             * @static
             * @param {kritor.developer.ISendPacketRequest} message SendPacketRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SendPacketRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.command != null && Object.hasOwnProperty.call(message, "command"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.command);
                if (message.requestBuffer != null && Object.hasOwnProperty.call(message, "requestBuffer"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.requestBuffer);
                if (message.isProtobuf != null && Object.hasOwnProperty.call(message, "isProtobuf"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isProtobuf);
                if (message.attrs != null && Object.hasOwnProperty.call(message, "attrs"))
                    for (let keys = Object.keys(message.attrs), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 4, wireType 2 =*/34).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.attrs[keys[i]]).ldelim();
                return writer;
            };

            /**
             * Encodes the specified SendPacketRequest message, length delimited. Does not implicitly {@link kritor.developer.SendPacketRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.developer.SendPacketRequest
             * @static
             * @param {kritor.developer.ISendPacketRequest} message SendPacketRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SendPacketRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SendPacketRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.developer.SendPacketRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.developer.SendPacketRequest} SendPacketRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SendPacketRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.developer.SendPacketRequest(), key, value;
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.command = reader.string();
                            break;
                        }
                    case 2: {
                            message.requestBuffer = reader.bytes();
                            break;
                        }
                    case 3: {
                            message.isProtobuf = reader.bool();
                            break;
                        }
                    case 4: {
                            if (message.attrs === $util.emptyObject)
                                message.attrs = {};
                            let end2 = reader.uint32() + reader.pos;
                            key = "";
                            value = "";
                            while (reader.pos < end2) {
                                let tag2 = reader.uint32();
                                switch (tag2 >>> 3) {
                                case 1:
                                    key = reader.string();
                                    break;
                                case 2:
                                    value = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag2 & 7);
                                    break;
                                }
                            }
                            message.attrs[key] = value;
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SendPacketRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.developer.SendPacketRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.developer.SendPacketRequest} SendPacketRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SendPacketRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SendPacketRequest message.
             * @function verify
             * @memberof kritor.developer.SendPacketRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SendPacketRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.command != null && message.hasOwnProperty("command"))
                    if (!$util.isString(message.command))
                        return "command: string expected";
                if (message.requestBuffer != null && message.hasOwnProperty("requestBuffer"))
                    if (!(message.requestBuffer && typeof message.requestBuffer.length === "number" || $util.isString(message.requestBuffer)))
                        return "requestBuffer: buffer expected";
                if (message.isProtobuf != null && message.hasOwnProperty("isProtobuf"))
                    if (typeof message.isProtobuf !== "boolean")
                        return "isProtobuf: boolean expected";
                if (message.attrs != null && message.hasOwnProperty("attrs")) {
                    if (!$util.isObject(message.attrs))
                        return "attrs: object expected";
                    let key = Object.keys(message.attrs);
                    for (let i = 0; i < key.length; ++i)
                        if (!$util.isString(message.attrs[key[i]]))
                            return "attrs: string{k:string} expected";
                }
                return null;
            };

            /**
             * Creates a SendPacketRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.developer.SendPacketRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.developer.SendPacketRequest} SendPacketRequest
             */
            SendPacketRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.developer.SendPacketRequest)
                    return object;
                let message = new $root.kritor.developer.SendPacketRequest();
                if (object.command != null)
                    message.command = String(object.command);
                if (object.requestBuffer != null)
                    if (typeof object.requestBuffer === "string")
                        $util.base64.decode(object.requestBuffer, message.requestBuffer = $util.newBuffer($util.base64.length(object.requestBuffer)), 0);
                    else if (object.requestBuffer.length >= 0)
                        message.requestBuffer = object.requestBuffer;
                if (object.isProtobuf != null)
                    message.isProtobuf = Boolean(object.isProtobuf);
                if (object.attrs) {
                    if (typeof object.attrs !== "object")
                        throw TypeError(".kritor.developer.SendPacketRequest.attrs: object expected");
                    message.attrs = {};
                    for (let keys = Object.keys(object.attrs), i = 0; i < keys.length; ++i)
                        message.attrs[keys[i]] = String(object.attrs[keys[i]]);
                }
                return message;
            };

            /**
             * Creates a plain object from a SendPacketRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.developer.SendPacketRequest
             * @static
             * @param {kritor.developer.SendPacketRequest} message SendPacketRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SendPacketRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.objects || options.defaults)
                    object.attrs = {};
                if (options.defaults) {
                    object.command = "";
                    if (options.bytes === String)
                        object.requestBuffer = "";
                    else {
                        object.requestBuffer = [];
                        if (options.bytes !== Array)
                            object.requestBuffer = $util.newBuffer(object.requestBuffer);
                    }
                    object.isProtobuf = false;
                }
                if (message.command != null && message.hasOwnProperty("command"))
                    object.command = message.command;
                if (message.requestBuffer != null && message.hasOwnProperty("requestBuffer"))
                    object.requestBuffer = options.bytes === String ? $util.base64.encode(message.requestBuffer, 0, message.requestBuffer.length) : options.bytes === Array ? Array.prototype.slice.call(message.requestBuffer) : message.requestBuffer;
                if (message.isProtobuf != null && message.hasOwnProperty("isProtobuf"))
                    object.isProtobuf = message.isProtobuf;
                let keys2;
                if (message.attrs && (keys2 = Object.keys(message.attrs)).length) {
                    object.attrs = {};
                    for (let j = 0; j < keys2.length; ++j)
                        object.attrs[keys2[j]] = message.attrs[keys2[j]];
                }
                return object;
            };

            /**
             * Converts this SendPacketRequest to JSON.
             * @function toJSON
             * @memberof kritor.developer.SendPacketRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SendPacketRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SendPacketRequest
             * @function getTypeUrl
             * @memberof kritor.developer.SendPacketRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SendPacketRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.developer.SendPacketRequest";
            };

            return SendPacketRequest;
        })();

        developer.SendPacketResponse = (function() {

            /**
             * Properties of a SendPacketResponse.
             * @memberof kritor.developer
             * @interface ISendPacketResponse
             * @property {boolean|null} [isSuccess] SendPacketResponse isSuccess
             * @property {Uint8Array|null} [responseBuffer] SendPacketResponse responseBuffer
             */

            /**
             * Constructs a new SendPacketResponse.
             * @memberof kritor.developer
             * @classdesc Represents a SendPacketResponse.
             * @implements ISendPacketResponse
             * @constructor
             * @param {kritor.developer.ISendPacketResponse=} [properties] Properties to set
             */
            function SendPacketResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SendPacketResponse isSuccess.
             * @member {boolean} isSuccess
             * @memberof kritor.developer.SendPacketResponse
             * @instance
             */
            SendPacketResponse.prototype.isSuccess = false;

            /**
             * SendPacketResponse responseBuffer.
             * @member {Uint8Array} responseBuffer
             * @memberof kritor.developer.SendPacketResponse
             * @instance
             */
            SendPacketResponse.prototype.responseBuffer = $util.newBuffer([]);

            /**
             * Creates a new SendPacketResponse instance using the specified properties.
             * @function create
             * @memberof kritor.developer.SendPacketResponse
             * @static
             * @param {kritor.developer.ISendPacketResponse=} [properties] Properties to set
             * @returns {kritor.developer.SendPacketResponse} SendPacketResponse instance
             */
            SendPacketResponse.create = function create(properties) {
                return new SendPacketResponse(properties);
            };

            /**
             * Encodes the specified SendPacketResponse message. Does not implicitly {@link kritor.developer.SendPacketResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.developer.SendPacketResponse
             * @static
             * @param {kritor.developer.ISendPacketResponse} message SendPacketResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SendPacketResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.isSuccess != null && Object.hasOwnProperty.call(message, "isSuccess"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.isSuccess);
                if (message.responseBuffer != null && Object.hasOwnProperty.call(message, "responseBuffer"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.responseBuffer);
                return writer;
            };

            /**
             * Encodes the specified SendPacketResponse message, length delimited. Does not implicitly {@link kritor.developer.SendPacketResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.developer.SendPacketResponse
             * @static
             * @param {kritor.developer.ISendPacketResponse} message SendPacketResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SendPacketResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SendPacketResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.developer.SendPacketResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.developer.SendPacketResponse} SendPacketResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SendPacketResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.developer.SendPacketResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.isSuccess = reader.bool();
                            break;
                        }
                    case 2: {
                            message.responseBuffer = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SendPacketResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.developer.SendPacketResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.developer.SendPacketResponse} SendPacketResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SendPacketResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SendPacketResponse message.
             * @function verify
             * @memberof kritor.developer.SendPacketResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SendPacketResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.isSuccess != null && message.hasOwnProperty("isSuccess"))
                    if (typeof message.isSuccess !== "boolean")
                        return "isSuccess: boolean expected";
                if (message.responseBuffer != null && message.hasOwnProperty("responseBuffer"))
                    if (!(message.responseBuffer && typeof message.responseBuffer.length === "number" || $util.isString(message.responseBuffer)))
                        return "responseBuffer: buffer expected";
                return null;
            };

            /**
             * Creates a SendPacketResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.developer.SendPacketResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.developer.SendPacketResponse} SendPacketResponse
             */
            SendPacketResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.developer.SendPacketResponse)
                    return object;
                let message = new $root.kritor.developer.SendPacketResponse();
                if (object.isSuccess != null)
                    message.isSuccess = Boolean(object.isSuccess);
                if (object.responseBuffer != null)
                    if (typeof object.responseBuffer === "string")
                        $util.base64.decode(object.responseBuffer, message.responseBuffer = $util.newBuffer($util.base64.length(object.responseBuffer)), 0);
                    else if (object.responseBuffer.length >= 0)
                        message.responseBuffer = object.responseBuffer;
                return message;
            };

            /**
             * Creates a plain object from a SendPacketResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.developer.SendPacketResponse
             * @static
             * @param {kritor.developer.SendPacketResponse} message SendPacketResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SendPacketResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.isSuccess = false;
                    if (options.bytes === String)
                        object.responseBuffer = "";
                    else {
                        object.responseBuffer = [];
                        if (options.bytes !== Array)
                            object.responseBuffer = $util.newBuffer(object.responseBuffer);
                    }
                }
                if (message.isSuccess != null && message.hasOwnProperty("isSuccess"))
                    object.isSuccess = message.isSuccess;
                if (message.responseBuffer != null && message.hasOwnProperty("responseBuffer"))
                    object.responseBuffer = options.bytes === String ? $util.base64.encode(message.responseBuffer, 0, message.responseBuffer.length) : options.bytes === Array ? Array.prototype.slice.call(message.responseBuffer) : message.responseBuffer;
                return object;
            };

            /**
             * Converts this SendPacketResponse to JSON.
             * @function toJSON
             * @memberof kritor.developer.SendPacketResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SendPacketResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SendPacketResponse
             * @function getTypeUrl
             * @memberof kritor.developer.SendPacketResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SendPacketResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.developer.SendPacketResponse";
            };

            return SendPacketResponse;
        })();

        developer.QsignService = (function() {

            /**
             * Constructs a new QsignService service.
             * @memberof kritor.developer
             * @classdesc Represents a QsignService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function QsignService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (QsignService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = QsignService;

            /**
             * Creates new QsignService service using the specified rpc implementation.
             * @function create
             * @memberof kritor.developer.QsignService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {QsignService} RPC service. Useful where requests and/or responses are streamed.
             */
            QsignService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link kritor.developer.QsignService#sign}.
             * @memberof kritor.developer.QsignService
             * @typedef SignCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.developer.SignResponse} [response] SignResponse
             */

            /**
             * Calls Sign.
             * @function sign
             * @memberof kritor.developer.QsignService
             * @instance
             * @param {kritor.developer.ISignRequest} request SignRequest message or plain object
             * @param {kritor.developer.QsignService.SignCallback} callback Node-style callback called with the error, if any, and SignResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(QsignService.prototype.sign = function sign(request, callback) {
                return this.rpcCall(sign, $root.kritor.developer.SignRequest, $root.kritor.developer.SignResponse, request, callback);
            }, "name", { value: "Sign" });

            /**
             * Calls Sign.
             * @function sign
             * @memberof kritor.developer.QsignService
             * @instance
             * @param {kritor.developer.ISignRequest} request SignRequest message or plain object
             * @returns {Promise<kritor.developer.SignResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.developer.QsignService#energy}.
             * @memberof kritor.developer.QsignService
             * @typedef EnergyCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.developer.EnergyResponse} [response] EnergyResponse
             */

            /**
             * Calls Energy.
             * @function energy
             * @memberof kritor.developer.QsignService
             * @instance
             * @param {kritor.developer.IEnergyRequest} request EnergyRequest message or plain object
             * @param {kritor.developer.QsignService.EnergyCallback} callback Node-style callback called with the error, if any, and EnergyResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(QsignService.prototype.energy = function energy(request, callback) {
                return this.rpcCall(energy, $root.kritor.developer.EnergyRequest, $root.kritor.developer.EnergyResponse, request, callback);
            }, "name", { value: "Energy" });

            /**
             * Calls Energy.
             * @function energy
             * @memberof kritor.developer.QsignService
             * @instance
             * @param {kritor.developer.IEnergyRequest} request EnergyRequest message or plain object
             * @returns {Promise<kritor.developer.EnergyResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.developer.QsignService#getCmdWhitelist}.
             * @memberof kritor.developer.QsignService
             * @typedef GetCmdWhitelistCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.developer.GetCmdWhitelistResponse} [response] GetCmdWhitelistResponse
             */

            /**
             * Calls GetCmdWhitelist.
             * @function getCmdWhitelist
             * @memberof kritor.developer.QsignService
             * @instance
             * @param {kritor.developer.IGetCmdWhitelistRequest} request GetCmdWhitelistRequest message or plain object
             * @param {kritor.developer.QsignService.GetCmdWhitelistCallback} callback Node-style callback called with the error, if any, and GetCmdWhitelistResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(QsignService.prototype.getCmdWhitelist = function getCmdWhitelist(request, callback) {
                return this.rpcCall(getCmdWhitelist, $root.kritor.developer.GetCmdWhitelistRequest, $root.kritor.developer.GetCmdWhitelistResponse, request, callback);
            }, "name", { value: "GetCmdWhitelist" });

            /**
             * Calls GetCmdWhitelist.
             * @function getCmdWhitelist
             * @memberof kritor.developer.QsignService
             * @instance
             * @param {kritor.developer.IGetCmdWhitelistRequest} request GetCmdWhitelistRequest message or plain object
             * @returns {Promise<kritor.developer.GetCmdWhitelistResponse>} Promise
             * @variation 2
             */

            return QsignService;
        })();

        developer.SignRequest = (function() {

            /**
             * Properties of a SignRequest.
             * @memberof kritor.developer
             * @interface ISignRequest
             * @property {string|null} [uin] SignRequest uin
             * @property {string|null} [command] SignRequest command
             * @property {number|null} [seq] SignRequest seq
             * @property {Uint8Array|null} [buffer] SignRequest buffer
             * @property {string|null} [qua] SignRequest qua
             */

            /**
             * Constructs a new SignRequest.
             * @memberof kritor.developer
             * @classdesc Represents a SignRequest.
             * @implements ISignRequest
             * @constructor
             * @param {kritor.developer.ISignRequest=} [properties] Properties to set
             */
            function SignRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SignRequest uin.
             * @member {string} uin
             * @memberof kritor.developer.SignRequest
             * @instance
             */
            SignRequest.prototype.uin = "";

            /**
             * SignRequest command.
             * @member {string} command
             * @memberof kritor.developer.SignRequest
             * @instance
             */
            SignRequest.prototype.command = "";

            /**
             * SignRequest seq.
             * @member {number} seq
             * @memberof kritor.developer.SignRequest
             * @instance
             */
            SignRequest.prototype.seq = 0;

            /**
             * SignRequest buffer.
             * @member {Uint8Array} buffer
             * @memberof kritor.developer.SignRequest
             * @instance
             */
            SignRequest.prototype.buffer = $util.newBuffer([]);

            /**
             * SignRequest qua.
             * @member {string|null|undefined} qua
             * @memberof kritor.developer.SignRequest
             * @instance
             */
            SignRequest.prototype.qua = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * SignRequest _qua.
             * @member {"qua"|undefined} _qua
             * @memberof kritor.developer.SignRequest
             * @instance
             */
            Object.defineProperty(SignRequest.prototype, "_qua", {
                get: $util.oneOfGetter($oneOfFields = ["qua"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new SignRequest instance using the specified properties.
             * @function create
             * @memberof kritor.developer.SignRequest
             * @static
             * @param {kritor.developer.ISignRequest=} [properties] Properties to set
             * @returns {kritor.developer.SignRequest} SignRequest instance
             */
            SignRequest.create = function create(properties) {
                return new SignRequest(properties);
            };

            /**
             * Encodes the specified SignRequest message. Does not implicitly {@link kritor.developer.SignRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.developer.SignRequest
             * @static
             * @param {kritor.developer.ISignRequest} message SignRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SignRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uin != null && Object.hasOwnProperty.call(message, "uin"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.uin);
                if (message.command != null && Object.hasOwnProperty.call(message, "command"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.command);
                if (message.seq != null && Object.hasOwnProperty.call(message, "seq"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.seq);
                if (message.buffer != null && Object.hasOwnProperty.call(message, "buffer"))
                    writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.buffer);
                if (message.qua != null && Object.hasOwnProperty.call(message, "qua"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.qua);
                return writer;
            };

            /**
             * Encodes the specified SignRequest message, length delimited. Does not implicitly {@link kritor.developer.SignRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.developer.SignRequest
             * @static
             * @param {kritor.developer.ISignRequest} message SignRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SignRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SignRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.developer.SignRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.developer.SignRequest} SignRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SignRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.developer.SignRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.uin = reader.string();
                            break;
                        }
                    case 2: {
                            message.command = reader.string();
                            break;
                        }
                    case 3: {
                            message.seq = reader.uint32();
                            break;
                        }
                    case 4: {
                            message.buffer = reader.bytes();
                            break;
                        }
                    case 6: {
                            message.qua = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SignRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.developer.SignRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.developer.SignRequest} SignRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SignRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SignRequest message.
             * @function verify
             * @memberof kritor.developer.SignRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SignRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.uin != null && message.hasOwnProperty("uin"))
                    if (!$util.isString(message.uin))
                        return "uin: string expected";
                if (message.command != null && message.hasOwnProperty("command"))
                    if (!$util.isString(message.command))
                        return "command: string expected";
                if (message.seq != null && message.hasOwnProperty("seq"))
                    if (!$util.isInteger(message.seq))
                        return "seq: integer expected";
                if (message.buffer != null && message.hasOwnProperty("buffer"))
                    if (!(message.buffer && typeof message.buffer.length === "number" || $util.isString(message.buffer)))
                        return "buffer: buffer expected";
                if (message.qua != null && message.hasOwnProperty("qua")) {
                    properties._qua = 1;
                    if (!$util.isString(message.qua))
                        return "qua: string expected";
                }
                return null;
            };

            /**
             * Creates a SignRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.developer.SignRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.developer.SignRequest} SignRequest
             */
            SignRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.developer.SignRequest)
                    return object;
                let message = new $root.kritor.developer.SignRequest();
                if (object.uin != null)
                    message.uin = String(object.uin);
                if (object.command != null)
                    message.command = String(object.command);
                if (object.seq != null)
                    message.seq = object.seq >>> 0;
                if (object.buffer != null)
                    if (typeof object.buffer === "string")
                        $util.base64.decode(object.buffer, message.buffer = $util.newBuffer($util.base64.length(object.buffer)), 0);
                    else if (object.buffer.length >= 0)
                        message.buffer = object.buffer;
                if (object.qua != null)
                    message.qua = String(object.qua);
                return message;
            };

            /**
             * Creates a plain object from a SignRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.developer.SignRequest
             * @static
             * @param {kritor.developer.SignRequest} message SignRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SignRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.uin = "";
                    object.command = "";
                    object.seq = 0;
                    if (options.bytes === String)
                        object.buffer = "";
                    else {
                        object.buffer = [];
                        if (options.bytes !== Array)
                            object.buffer = $util.newBuffer(object.buffer);
                    }
                }
                if (message.uin != null && message.hasOwnProperty("uin"))
                    object.uin = message.uin;
                if (message.command != null && message.hasOwnProperty("command"))
                    object.command = message.command;
                if (message.seq != null && message.hasOwnProperty("seq"))
                    object.seq = message.seq;
                if (message.buffer != null && message.hasOwnProperty("buffer"))
                    object.buffer = options.bytes === String ? $util.base64.encode(message.buffer, 0, message.buffer.length) : options.bytes === Array ? Array.prototype.slice.call(message.buffer) : message.buffer;
                if (message.qua != null && message.hasOwnProperty("qua")) {
                    object.qua = message.qua;
                    if (options.oneofs)
                        object._qua = "qua";
                }
                return object;
            };

            /**
             * Converts this SignRequest to JSON.
             * @function toJSON
             * @memberof kritor.developer.SignRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SignRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SignRequest
             * @function getTypeUrl
             * @memberof kritor.developer.SignRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SignRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.developer.SignRequest";
            };

            return SignRequest;
        })();

        developer.SignResponse = (function() {

            /**
             * Properties of a SignResponse.
             * @memberof kritor.developer
             * @interface ISignResponse
             * @property {Uint8Array|null} [secSig] SignResponse secSig
             * @property {Uint8Array|null} [secDeviceToken] SignResponse secDeviceToken
             * @property {Uint8Array|null} [secExtra] SignResponse secExtra
             */

            /**
             * Constructs a new SignResponse.
             * @memberof kritor.developer
             * @classdesc Represents a SignResponse.
             * @implements ISignResponse
             * @constructor
             * @param {kritor.developer.ISignResponse=} [properties] Properties to set
             */
            function SignResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SignResponse secSig.
             * @member {Uint8Array} secSig
             * @memberof kritor.developer.SignResponse
             * @instance
             */
            SignResponse.prototype.secSig = $util.newBuffer([]);

            /**
             * SignResponse secDeviceToken.
             * @member {Uint8Array} secDeviceToken
             * @memberof kritor.developer.SignResponse
             * @instance
             */
            SignResponse.prototype.secDeviceToken = $util.newBuffer([]);

            /**
             * SignResponse secExtra.
             * @member {Uint8Array} secExtra
             * @memberof kritor.developer.SignResponse
             * @instance
             */
            SignResponse.prototype.secExtra = $util.newBuffer([]);

            /**
             * Creates a new SignResponse instance using the specified properties.
             * @function create
             * @memberof kritor.developer.SignResponse
             * @static
             * @param {kritor.developer.ISignResponse=} [properties] Properties to set
             * @returns {kritor.developer.SignResponse} SignResponse instance
             */
            SignResponse.create = function create(properties) {
                return new SignResponse(properties);
            };

            /**
             * Encodes the specified SignResponse message. Does not implicitly {@link kritor.developer.SignResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.developer.SignResponse
             * @static
             * @param {kritor.developer.ISignResponse} message SignResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SignResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.secSig != null && Object.hasOwnProperty.call(message, "secSig"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.secSig);
                if (message.secDeviceToken != null && Object.hasOwnProperty.call(message, "secDeviceToken"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.secDeviceToken);
                if (message.secExtra != null && Object.hasOwnProperty.call(message, "secExtra"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.secExtra);
                return writer;
            };

            /**
             * Encodes the specified SignResponse message, length delimited. Does not implicitly {@link kritor.developer.SignResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.developer.SignResponse
             * @static
             * @param {kritor.developer.ISignResponse} message SignResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SignResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SignResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.developer.SignResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.developer.SignResponse} SignResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SignResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.developer.SignResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.secSig = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.secDeviceToken = reader.bytes();
                            break;
                        }
                    case 3: {
                            message.secExtra = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SignResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.developer.SignResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.developer.SignResponse} SignResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SignResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SignResponse message.
             * @function verify
             * @memberof kritor.developer.SignResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SignResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.secSig != null && message.hasOwnProperty("secSig"))
                    if (!(message.secSig && typeof message.secSig.length === "number" || $util.isString(message.secSig)))
                        return "secSig: buffer expected";
                if (message.secDeviceToken != null && message.hasOwnProperty("secDeviceToken"))
                    if (!(message.secDeviceToken && typeof message.secDeviceToken.length === "number" || $util.isString(message.secDeviceToken)))
                        return "secDeviceToken: buffer expected";
                if (message.secExtra != null && message.hasOwnProperty("secExtra"))
                    if (!(message.secExtra && typeof message.secExtra.length === "number" || $util.isString(message.secExtra)))
                        return "secExtra: buffer expected";
                return null;
            };

            /**
             * Creates a SignResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.developer.SignResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.developer.SignResponse} SignResponse
             */
            SignResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.developer.SignResponse)
                    return object;
                let message = new $root.kritor.developer.SignResponse();
                if (object.secSig != null)
                    if (typeof object.secSig === "string")
                        $util.base64.decode(object.secSig, message.secSig = $util.newBuffer($util.base64.length(object.secSig)), 0);
                    else if (object.secSig.length >= 0)
                        message.secSig = object.secSig;
                if (object.secDeviceToken != null)
                    if (typeof object.secDeviceToken === "string")
                        $util.base64.decode(object.secDeviceToken, message.secDeviceToken = $util.newBuffer($util.base64.length(object.secDeviceToken)), 0);
                    else if (object.secDeviceToken.length >= 0)
                        message.secDeviceToken = object.secDeviceToken;
                if (object.secExtra != null)
                    if (typeof object.secExtra === "string")
                        $util.base64.decode(object.secExtra, message.secExtra = $util.newBuffer($util.base64.length(object.secExtra)), 0);
                    else if (object.secExtra.length >= 0)
                        message.secExtra = object.secExtra;
                return message;
            };

            /**
             * Creates a plain object from a SignResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.developer.SignResponse
             * @static
             * @param {kritor.developer.SignResponse} message SignResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SignResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.secSig = "";
                    else {
                        object.secSig = [];
                        if (options.bytes !== Array)
                            object.secSig = $util.newBuffer(object.secSig);
                    }
                    if (options.bytes === String)
                        object.secDeviceToken = "";
                    else {
                        object.secDeviceToken = [];
                        if (options.bytes !== Array)
                            object.secDeviceToken = $util.newBuffer(object.secDeviceToken);
                    }
                    if (options.bytes === String)
                        object.secExtra = "";
                    else {
                        object.secExtra = [];
                        if (options.bytes !== Array)
                            object.secExtra = $util.newBuffer(object.secExtra);
                    }
                }
                if (message.secSig != null && message.hasOwnProperty("secSig"))
                    object.secSig = options.bytes === String ? $util.base64.encode(message.secSig, 0, message.secSig.length) : options.bytes === Array ? Array.prototype.slice.call(message.secSig) : message.secSig;
                if (message.secDeviceToken != null && message.hasOwnProperty("secDeviceToken"))
                    object.secDeviceToken = options.bytes === String ? $util.base64.encode(message.secDeviceToken, 0, message.secDeviceToken.length) : options.bytes === Array ? Array.prototype.slice.call(message.secDeviceToken) : message.secDeviceToken;
                if (message.secExtra != null && message.hasOwnProperty("secExtra"))
                    object.secExtra = options.bytes === String ? $util.base64.encode(message.secExtra, 0, message.secExtra.length) : options.bytes === Array ? Array.prototype.slice.call(message.secExtra) : message.secExtra;
                return object;
            };

            /**
             * Converts this SignResponse to JSON.
             * @function toJSON
             * @memberof kritor.developer.SignResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SignResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SignResponse
             * @function getTypeUrl
             * @memberof kritor.developer.SignResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SignResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.developer.SignResponse";
            };

            return SignResponse;
        })();

        developer.EnergyRequest = (function() {

            /**
             * Properties of an EnergyRequest.
             * @memberof kritor.developer
             * @interface IEnergyRequest
             * @property {string|null} [data] EnergyRequest data
             * @property {Uint8Array|null} [salt] EnergyRequest salt
             */

            /**
             * Constructs a new EnergyRequest.
             * @memberof kritor.developer
             * @classdesc Represents an EnergyRequest.
             * @implements IEnergyRequest
             * @constructor
             * @param {kritor.developer.IEnergyRequest=} [properties] Properties to set
             */
            function EnergyRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EnergyRequest data.
             * @member {string} data
             * @memberof kritor.developer.EnergyRequest
             * @instance
             */
            EnergyRequest.prototype.data = "";

            /**
             * EnergyRequest salt.
             * @member {Uint8Array} salt
             * @memberof kritor.developer.EnergyRequest
             * @instance
             */
            EnergyRequest.prototype.salt = $util.newBuffer([]);

            /**
             * Creates a new EnergyRequest instance using the specified properties.
             * @function create
             * @memberof kritor.developer.EnergyRequest
             * @static
             * @param {kritor.developer.IEnergyRequest=} [properties] Properties to set
             * @returns {kritor.developer.EnergyRequest} EnergyRequest instance
             */
            EnergyRequest.create = function create(properties) {
                return new EnergyRequest(properties);
            };

            /**
             * Encodes the specified EnergyRequest message. Does not implicitly {@link kritor.developer.EnergyRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.developer.EnergyRequest
             * @static
             * @param {kritor.developer.IEnergyRequest} message EnergyRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnergyRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.data);
                if (message.salt != null && Object.hasOwnProperty.call(message, "salt"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.salt);
                return writer;
            };

            /**
             * Encodes the specified EnergyRequest message, length delimited. Does not implicitly {@link kritor.developer.EnergyRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.developer.EnergyRequest
             * @static
             * @param {kritor.developer.IEnergyRequest} message EnergyRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnergyRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EnergyRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.developer.EnergyRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.developer.EnergyRequest} EnergyRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnergyRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.developer.EnergyRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 2: {
                            message.data = reader.string();
                            break;
                        }
                    case 3: {
                            message.salt = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EnergyRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.developer.EnergyRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.developer.EnergyRequest} EnergyRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnergyRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EnergyRequest message.
             * @function verify
             * @memberof kritor.developer.EnergyRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EnergyRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.data != null && message.hasOwnProperty("data"))
                    if (!$util.isString(message.data))
                        return "data: string expected";
                if (message.salt != null && message.hasOwnProperty("salt"))
                    if (!(message.salt && typeof message.salt.length === "number" || $util.isString(message.salt)))
                        return "salt: buffer expected";
                return null;
            };

            /**
             * Creates an EnergyRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.developer.EnergyRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.developer.EnergyRequest} EnergyRequest
             */
            EnergyRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.developer.EnergyRequest)
                    return object;
                let message = new $root.kritor.developer.EnergyRequest();
                if (object.data != null)
                    message.data = String(object.data);
                if (object.salt != null)
                    if (typeof object.salt === "string")
                        $util.base64.decode(object.salt, message.salt = $util.newBuffer($util.base64.length(object.salt)), 0);
                    else if (object.salt.length >= 0)
                        message.salt = object.salt;
                return message;
            };

            /**
             * Creates a plain object from an EnergyRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.developer.EnergyRequest
             * @static
             * @param {kritor.developer.EnergyRequest} message EnergyRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnergyRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.data = "";
                    if (options.bytes === String)
                        object.salt = "";
                    else {
                        object.salt = [];
                        if (options.bytes !== Array)
                            object.salt = $util.newBuffer(object.salt);
                    }
                }
                if (message.data != null && message.hasOwnProperty("data"))
                    object.data = message.data;
                if (message.salt != null && message.hasOwnProperty("salt"))
                    object.salt = options.bytes === String ? $util.base64.encode(message.salt, 0, message.salt.length) : options.bytes === Array ? Array.prototype.slice.call(message.salt) : message.salt;
                return object;
            };

            /**
             * Converts this EnergyRequest to JSON.
             * @function toJSON
             * @memberof kritor.developer.EnergyRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EnergyRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for EnergyRequest
             * @function getTypeUrl
             * @memberof kritor.developer.EnergyRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            EnergyRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.developer.EnergyRequest";
            };

            return EnergyRequest;
        })();

        developer.EnergyResponse = (function() {

            /**
             * Properties of an EnergyResponse.
             * @memberof kritor.developer
             * @interface IEnergyResponse
             * @property {Uint8Array|null} [result] EnergyResponse result
             */

            /**
             * Constructs a new EnergyResponse.
             * @memberof kritor.developer
             * @classdesc Represents an EnergyResponse.
             * @implements IEnergyResponse
             * @constructor
             * @param {kritor.developer.IEnergyResponse=} [properties] Properties to set
             */
            function EnergyResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EnergyResponse result.
             * @member {Uint8Array} result
             * @memberof kritor.developer.EnergyResponse
             * @instance
             */
            EnergyResponse.prototype.result = $util.newBuffer([]);

            /**
             * Creates a new EnergyResponse instance using the specified properties.
             * @function create
             * @memberof kritor.developer.EnergyResponse
             * @static
             * @param {kritor.developer.IEnergyResponse=} [properties] Properties to set
             * @returns {kritor.developer.EnergyResponse} EnergyResponse instance
             */
            EnergyResponse.create = function create(properties) {
                return new EnergyResponse(properties);
            };

            /**
             * Encodes the specified EnergyResponse message. Does not implicitly {@link kritor.developer.EnergyResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.developer.EnergyResponse
             * @static
             * @param {kritor.developer.IEnergyResponse} message EnergyResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnergyResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.result != null && Object.hasOwnProperty.call(message, "result"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.result);
                return writer;
            };

            /**
             * Encodes the specified EnergyResponse message, length delimited. Does not implicitly {@link kritor.developer.EnergyResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.developer.EnergyResponse
             * @static
             * @param {kritor.developer.IEnergyResponse} message EnergyResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnergyResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EnergyResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.developer.EnergyResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.developer.EnergyResponse} EnergyResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnergyResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.developer.EnergyResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.result = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EnergyResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.developer.EnergyResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.developer.EnergyResponse} EnergyResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnergyResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EnergyResponse message.
             * @function verify
             * @memberof kritor.developer.EnergyResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EnergyResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.result != null && message.hasOwnProperty("result"))
                    if (!(message.result && typeof message.result.length === "number" || $util.isString(message.result)))
                        return "result: buffer expected";
                return null;
            };

            /**
             * Creates an EnergyResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.developer.EnergyResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.developer.EnergyResponse} EnergyResponse
             */
            EnergyResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.developer.EnergyResponse)
                    return object;
                let message = new $root.kritor.developer.EnergyResponse();
                if (object.result != null)
                    if (typeof object.result === "string")
                        $util.base64.decode(object.result, message.result = $util.newBuffer($util.base64.length(object.result)), 0);
                    else if (object.result.length >= 0)
                        message.result = object.result;
                return message;
            };

            /**
             * Creates a plain object from an EnergyResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.developer.EnergyResponse
             * @static
             * @param {kritor.developer.EnergyResponse} message EnergyResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnergyResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if (options.bytes === String)
                        object.result = "";
                    else {
                        object.result = [];
                        if (options.bytes !== Array)
                            object.result = $util.newBuffer(object.result);
                    }
                if (message.result != null && message.hasOwnProperty("result"))
                    object.result = options.bytes === String ? $util.base64.encode(message.result, 0, message.result.length) : options.bytes === Array ? Array.prototype.slice.call(message.result) : message.result;
                return object;
            };

            /**
             * Converts this EnergyResponse to JSON.
             * @function toJSON
             * @memberof kritor.developer.EnergyResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EnergyResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for EnergyResponse
             * @function getTypeUrl
             * @memberof kritor.developer.EnergyResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            EnergyResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.developer.EnergyResponse";
            };

            return EnergyResponse;
        })();

        developer.GetCmdWhitelistRequest = (function() {

            /**
             * Properties of a GetCmdWhitelistRequest.
             * @memberof kritor.developer
             * @interface IGetCmdWhitelistRequest
             */

            /**
             * Constructs a new GetCmdWhitelistRequest.
             * @memberof kritor.developer
             * @classdesc Represents a GetCmdWhitelistRequest.
             * @implements IGetCmdWhitelistRequest
             * @constructor
             * @param {kritor.developer.IGetCmdWhitelistRequest=} [properties] Properties to set
             */
            function GetCmdWhitelistRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new GetCmdWhitelistRequest instance using the specified properties.
             * @function create
             * @memberof kritor.developer.GetCmdWhitelistRequest
             * @static
             * @param {kritor.developer.IGetCmdWhitelistRequest=} [properties] Properties to set
             * @returns {kritor.developer.GetCmdWhitelistRequest} GetCmdWhitelistRequest instance
             */
            GetCmdWhitelistRequest.create = function create(properties) {
                return new GetCmdWhitelistRequest(properties);
            };

            /**
             * Encodes the specified GetCmdWhitelistRequest message. Does not implicitly {@link kritor.developer.GetCmdWhitelistRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.developer.GetCmdWhitelistRequest
             * @static
             * @param {kritor.developer.IGetCmdWhitelistRequest} message GetCmdWhitelistRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetCmdWhitelistRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified GetCmdWhitelistRequest message, length delimited. Does not implicitly {@link kritor.developer.GetCmdWhitelistRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.developer.GetCmdWhitelistRequest
             * @static
             * @param {kritor.developer.IGetCmdWhitelistRequest} message GetCmdWhitelistRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetCmdWhitelistRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetCmdWhitelistRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.developer.GetCmdWhitelistRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.developer.GetCmdWhitelistRequest} GetCmdWhitelistRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetCmdWhitelistRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.developer.GetCmdWhitelistRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetCmdWhitelistRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.developer.GetCmdWhitelistRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.developer.GetCmdWhitelistRequest} GetCmdWhitelistRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetCmdWhitelistRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetCmdWhitelistRequest message.
             * @function verify
             * @memberof kritor.developer.GetCmdWhitelistRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetCmdWhitelistRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a GetCmdWhitelistRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.developer.GetCmdWhitelistRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.developer.GetCmdWhitelistRequest} GetCmdWhitelistRequest
             */
            GetCmdWhitelistRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.developer.GetCmdWhitelistRequest)
                    return object;
                return new $root.kritor.developer.GetCmdWhitelistRequest();
            };

            /**
             * Creates a plain object from a GetCmdWhitelistRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.developer.GetCmdWhitelistRequest
             * @static
             * @param {kritor.developer.GetCmdWhitelistRequest} message GetCmdWhitelistRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetCmdWhitelistRequest.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this GetCmdWhitelistRequest to JSON.
             * @function toJSON
             * @memberof kritor.developer.GetCmdWhitelistRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetCmdWhitelistRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetCmdWhitelistRequest
             * @function getTypeUrl
             * @memberof kritor.developer.GetCmdWhitelistRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetCmdWhitelistRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.developer.GetCmdWhitelistRequest";
            };

            return GetCmdWhitelistRequest;
        })();

        developer.GetCmdWhitelistResponse = (function() {

            /**
             * Properties of a GetCmdWhitelistResponse.
             * @memberof kritor.developer
             * @interface IGetCmdWhitelistResponse
             * @property {Array.<string>|null} [commands] GetCmdWhitelistResponse commands
             */

            /**
             * Constructs a new GetCmdWhitelistResponse.
             * @memberof kritor.developer
             * @classdesc Represents a GetCmdWhitelistResponse.
             * @implements IGetCmdWhitelistResponse
             * @constructor
             * @param {kritor.developer.IGetCmdWhitelistResponse=} [properties] Properties to set
             */
            function GetCmdWhitelistResponse(properties) {
                this.commands = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetCmdWhitelistResponse commands.
             * @member {Array.<string>} commands
             * @memberof kritor.developer.GetCmdWhitelistResponse
             * @instance
             */
            GetCmdWhitelistResponse.prototype.commands = $util.emptyArray;

            /**
             * Creates a new GetCmdWhitelistResponse instance using the specified properties.
             * @function create
             * @memberof kritor.developer.GetCmdWhitelistResponse
             * @static
             * @param {kritor.developer.IGetCmdWhitelistResponse=} [properties] Properties to set
             * @returns {kritor.developer.GetCmdWhitelistResponse} GetCmdWhitelistResponse instance
             */
            GetCmdWhitelistResponse.create = function create(properties) {
                return new GetCmdWhitelistResponse(properties);
            };

            /**
             * Encodes the specified GetCmdWhitelistResponse message. Does not implicitly {@link kritor.developer.GetCmdWhitelistResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.developer.GetCmdWhitelistResponse
             * @static
             * @param {kritor.developer.IGetCmdWhitelistResponse} message GetCmdWhitelistResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetCmdWhitelistResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.commands != null && message.commands.length)
                    for (let i = 0; i < message.commands.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.commands[i]);
                return writer;
            };

            /**
             * Encodes the specified GetCmdWhitelistResponse message, length delimited. Does not implicitly {@link kritor.developer.GetCmdWhitelistResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.developer.GetCmdWhitelistResponse
             * @static
             * @param {kritor.developer.IGetCmdWhitelistResponse} message GetCmdWhitelistResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetCmdWhitelistResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetCmdWhitelistResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.developer.GetCmdWhitelistResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.developer.GetCmdWhitelistResponse} GetCmdWhitelistResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetCmdWhitelistResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.developer.GetCmdWhitelistResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.commands && message.commands.length))
                                message.commands = [];
                            message.commands.push(reader.string());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetCmdWhitelistResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.developer.GetCmdWhitelistResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.developer.GetCmdWhitelistResponse} GetCmdWhitelistResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetCmdWhitelistResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetCmdWhitelistResponse message.
             * @function verify
             * @memberof kritor.developer.GetCmdWhitelistResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetCmdWhitelistResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.commands != null && message.hasOwnProperty("commands")) {
                    if (!Array.isArray(message.commands))
                        return "commands: array expected";
                    for (let i = 0; i < message.commands.length; ++i)
                        if (!$util.isString(message.commands[i]))
                            return "commands: string[] expected";
                }
                return null;
            };

            /**
             * Creates a GetCmdWhitelistResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.developer.GetCmdWhitelistResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.developer.GetCmdWhitelistResponse} GetCmdWhitelistResponse
             */
            GetCmdWhitelistResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.developer.GetCmdWhitelistResponse)
                    return object;
                let message = new $root.kritor.developer.GetCmdWhitelistResponse();
                if (object.commands) {
                    if (!Array.isArray(object.commands))
                        throw TypeError(".kritor.developer.GetCmdWhitelistResponse.commands: array expected");
                    message.commands = [];
                    for (let i = 0; i < object.commands.length; ++i)
                        message.commands[i] = String(object.commands[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a GetCmdWhitelistResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.developer.GetCmdWhitelistResponse
             * @static
             * @param {kritor.developer.GetCmdWhitelistResponse} message GetCmdWhitelistResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetCmdWhitelistResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.commands = [];
                if (message.commands && message.commands.length) {
                    object.commands = [];
                    for (let j = 0; j < message.commands.length; ++j)
                        object.commands[j] = message.commands[j];
                }
                return object;
            };

            /**
             * Converts this GetCmdWhitelistResponse to JSON.
             * @function toJSON
             * @memberof kritor.developer.GetCmdWhitelistResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetCmdWhitelistResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetCmdWhitelistResponse
             * @function getTypeUrl
             * @memberof kritor.developer.GetCmdWhitelistResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetCmdWhitelistResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.developer.GetCmdWhitelistResponse";
            };

            return GetCmdWhitelistResponse;
        })();

        return developer;
    })();

    kritor.event = (function() {

        /**
         * Namespace event.
         * @memberof kritor
         * @namespace
         */
        const event = {};

        event.EventService = (function() {

            /**
             * Constructs a new EventService service.
             * @memberof kritor.event
             * @classdesc Represents an EventService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function EventService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (EventService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = EventService;

            /**
             * Creates new EventService service using the specified rpc implementation.
             * @function create
             * @memberof kritor.event.EventService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {EventService} RPC service. Useful where requests and/or responses are streamed.
             */
            EventService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link kritor.event.EventService#registerActiveListener}.
             * @memberof kritor.event.EventService
             * @typedef RegisterActiveListenerCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.event.EventStructure} [response] EventStructure
             */

            /**
             * Calls RegisterActiveListener.
             * @function registerActiveListener
             * @memberof kritor.event.EventService
             * @instance
             * @param {kritor.event.IRequestPushEvent} request RequestPushEvent message or plain object
             * @param {kritor.event.EventService.RegisterActiveListenerCallback} callback Node-style callback called with the error, if any, and EventStructure
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(EventService.prototype.registerActiveListener = function registerActiveListener(request, callback) {
                return this.rpcCall(registerActiveListener, $root.kritor.event.RequestPushEvent, $root.kritor.event.EventStructure, request, callback);
            }, "name", { value: "RegisterActiveListener" });

            /**
             * Calls RegisterActiveListener.
             * @function registerActiveListener
             * @memberof kritor.event.EventService
             * @instance
             * @param {kritor.event.IRequestPushEvent} request RequestPushEvent message or plain object
             * @returns {Promise<kritor.event.EventStructure>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.event.EventService#registerPassiveListener}.
             * @memberof kritor.event.EventService
             * @typedef RegisterPassiveListenerCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.event.RequestPushEvent} [response] RequestPushEvent
             */

            /**
             * Calls RegisterPassiveListener.
             * @function registerPassiveListener
             * @memberof kritor.event.EventService
             * @instance
             * @param {kritor.event.IEventStructure} request EventStructure message or plain object
             * @param {kritor.event.EventService.RegisterPassiveListenerCallback} callback Node-style callback called with the error, if any, and RequestPushEvent
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(EventService.prototype.registerPassiveListener = function registerPassiveListener(request, callback) {
                return this.rpcCall(registerPassiveListener, $root.kritor.event.EventStructure, $root.kritor.event.RequestPushEvent, request, callback);
            }, "name", { value: "RegisterPassiveListener" });

            /**
             * Calls RegisterPassiveListener.
             * @function registerPassiveListener
             * @memberof kritor.event.EventService
             * @instance
             * @param {kritor.event.IEventStructure} request EventStructure message or plain object
             * @returns {Promise<kritor.event.RequestPushEvent>} Promise
             * @variation 2
             */

            return EventService;
        })();

        /**
         * EventType enum.
         * @name kritor.event.EventType
         * @enum {number}
         * @property {number} EVENT_TYPE_CORE_EVENT=0 EVENT_TYPE_CORE_EVENT value
         * @property {number} EVENT_TYPE_MESSAGE=1 EVENT_TYPE_MESSAGE value
         * @property {number} EVENT_TYPE_NOTICE=2 EVENT_TYPE_NOTICE value
         * @property {number} EVENT_TYPE_REQUEST=3 EVENT_TYPE_REQUEST value
         */
        event.EventType = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "EVENT_TYPE_CORE_EVENT"] = 0;
            values[valuesById[1] = "EVENT_TYPE_MESSAGE"] = 1;
            values[valuesById[2] = "EVENT_TYPE_NOTICE"] = 2;
            values[valuesById[3] = "EVENT_TYPE_REQUEST"] = 3;
            return values;
        })();

        event.RequestPushEvent = (function() {

            /**
             * Properties of a RequestPushEvent.
             * @memberof kritor.event
             * @interface IRequestPushEvent
             * @property {kritor.event.EventType|null} [type] RequestPushEvent type
             */

            /**
             * Constructs a new RequestPushEvent.
             * @memberof kritor.event
             * @classdesc Represents a RequestPushEvent.
             * @implements IRequestPushEvent
             * @constructor
             * @param {kritor.event.IRequestPushEvent=} [properties] Properties to set
             */
            function RequestPushEvent(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RequestPushEvent type.
             * @member {kritor.event.EventType} type
             * @memberof kritor.event.RequestPushEvent
             * @instance
             */
            RequestPushEvent.prototype.type = 0;

            /**
             * Creates a new RequestPushEvent instance using the specified properties.
             * @function create
             * @memberof kritor.event.RequestPushEvent
             * @static
             * @param {kritor.event.IRequestPushEvent=} [properties] Properties to set
             * @returns {kritor.event.RequestPushEvent} RequestPushEvent instance
             */
            RequestPushEvent.create = function create(properties) {
                return new RequestPushEvent(properties);
            };

            /**
             * Encodes the specified RequestPushEvent message. Does not implicitly {@link kritor.event.RequestPushEvent.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.RequestPushEvent
             * @static
             * @param {kritor.event.IRequestPushEvent} message RequestPushEvent message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RequestPushEvent.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                return writer;
            };

            /**
             * Encodes the specified RequestPushEvent message, length delimited. Does not implicitly {@link kritor.event.RequestPushEvent.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.RequestPushEvent
             * @static
             * @param {kritor.event.IRequestPushEvent} message RequestPushEvent message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RequestPushEvent.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RequestPushEvent message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.RequestPushEvent
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.RequestPushEvent} RequestPushEvent
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RequestPushEvent.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.RequestPushEvent();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.type = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RequestPushEvent message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.RequestPushEvent
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.RequestPushEvent} RequestPushEvent
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RequestPushEvent.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RequestPushEvent message.
             * @function verify
             * @memberof kritor.event.RequestPushEvent
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RequestPushEvent.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                return null;
            };

            /**
             * Creates a RequestPushEvent message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.RequestPushEvent
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.RequestPushEvent} RequestPushEvent
             */
            RequestPushEvent.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.RequestPushEvent)
                    return object;
                let message = new $root.kritor.event.RequestPushEvent();
                switch (object.type) {
                default:
                    if (typeof object.type === "number") {
                        message.type = object.type;
                        break;
                    }
                    break;
                case "EVENT_TYPE_CORE_EVENT":
                case 0:
                    message.type = 0;
                    break;
                case "EVENT_TYPE_MESSAGE":
                case 1:
                    message.type = 1;
                    break;
                case "EVENT_TYPE_NOTICE":
                case 2:
                    message.type = 2;
                    break;
                case "EVENT_TYPE_REQUEST":
                case 3:
                    message.type = 3;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a RequestPushEvent message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.RequestPushEvent
             * @static
             * @param {kritor.event.RequestPushEvent} message RequestPushEvent
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RequestPushEvent.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.type = options.enums === String ? "EVENT_TYPE_CORE_EVENT" : 0;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.kritor.event.EventType[message.type] === undefined ? message.type : $root.kritor.event.EventType[message.type] : message.type;
                return object;
            };

            /**
             * Converts this RequestPushEvent to JSON.
             * @function toJSON
             * @memberof kritor.event.RequestPushEvent
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RequestPushEvent.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for RequestPushEvent
             * @function getTypeUrl
             * @memberof kritor.event.RequestPushEvent
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            RequestPushEvent.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.RequestPushEvent";
            };

            return RequestPushEvent;
        })();

        event.EventStructure = (function() {

            /**
             * Properties of an EventStructure.
             * @memberof kritor.event
             * @interface IEventStructure
             * @property {kritor.event.EventType|null} [type] EventStructure type
             * @property {kritor.common.IPushMessageBody|null} [message] EventStructure message
             * @property {kritor.event.IRequestsEvent|null} [request] EventStructure request
             * @property {kritor.event.INoticeEvent|null} [notice] EventStructure notice
             */

            /**
             * Constructs a new EventStructure.
             * @memberof kritor.event
             * @classdesc Represents an EventStructure.
             * @implements IEventStructure
             * @constructor
             * @param {kritor.event.IEventStructure=} [properties] Properties to set
             */
            function EventStructure(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EventStructure type.
             * @member {kritor.event.EventType} type
             * @memberof kritor.event.EventStructure
             * @instance
             */
            EventStructure.prototype.type = 0;

            /**
             * EventStructure message.
             * @member {kritor.common.IPushMessageBody|null|undefined} message
             * @memberof kritor.event.EventStructure
             * @instance
             */
            EventStructure.prototype.message = null;

            /**
             * EventStructure request.
             * @member {kritor.event.IRequestsEvent|null|undefined} request
             * @memberof kritor.event.EventStructure
             * @instance
             */
            EventStructure.prototype.request = null;

            /**
             * EventStructure notice.
             * @member {kritor.event.INoticeEvent|null|undefined} notice
             * @memberof kritor.event.EventStructure
             * @instance
             */
            EventStructure.prototype.notice = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * EventStructure event.
             * @member {"message"|"request"|"notice"|undefined} event
             * @memberof kritor.event.EventStructure
             * @instance
             */
            Object.defineProperty(EventStructure.prototype, "event", {
                get: $util.oneOfGetter($oneOfFields = ["message", "request", "notice"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new EventStructure instance using the specified properties.
             * @function create
             * @memberof kritor.event.EventStructure
             * @static
             * @param {kritor.event.IEventStructure=} [properties] Properties to set
             * @returns {kritor.event.EventStructure} EventStructure instance
             */
            EventStructure.create = function create(properties) {
                return new EventStructure(properties);
            };

            /**
             * Encodes the specified EventStructure message. Does not implicitly {@link kritor.event.EventStructure.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.EventStructure
             * @static
             * @param {kritor.event.IEventStructure} message EventStructure message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EventStructure.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                    $root.kritor.common.PushMessageBody.encode(message.message, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.request != null && Object.hasOwnProperty.call(message, "request"))
                    $root.kritor.event.RequestsEvent.encode(message.request, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.notice != null && Object.hasOwnProperty.call(message, "notice"))
                    $root.kritor.event.NoticeEvent.encode(message.notice, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified EventStructure message, length delimited. Does not implicitly {@link kritor.event.EventStructure.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.EventStructure
             * @static
             * @param {kritor.event.IEventStructure} message EventStructure message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EventStructure.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EventStructure message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.EventStructure
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.EventStructure} EventStructure
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EventStructure.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.EventStructure();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.type = reader.int32();
                            break;
                        }
                    case 2: {
                            message.message = $root.kritor.common.PushMessageBody.decode(reader, reader.uint32());
                            break;
                        }
                    case 3: {
                            message.request = $root.kritor.event.RequestsEvent.decode(reader, reader.uint32());
                            break;
                        }
                    case 4: {
                            message.notice = $root.kritor.event.NoticeEvent.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EventStructure message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.EventStructure
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.EventStructure} EventStructure
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EventStructure.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EventStructure message.
             * @function verify
             * @memberof kritor.event.EventStructure
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EventStructure.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.message != null && message.hasOwnProperty("message")) {
                    properties.event = 1;
                    {
                        let error = $root.kritor.common.PushMessageBody.verify(message.message);
                        if (error)
                            return "message." + error;
                    }
                }
                if (message.request != null && message.hasOwnProperty("request")) {
                    if (properties.event === 1)
                        return "event: multiple values";
                    properties.event = 1;
                    {
                        let error = $root.kritor.event.RequestsEvent.verify(message.request);
                        if (error)
                            return "request." + error;
                    }
                }
                if (message.notice != null && message.hasOwnProperty("notice")) {
                    if (properties.event === 1)
                        return "event: multiple values";
                    properties.event = 1;
                    {
                        let error = $root.kritor.event.NoticeEvent.verify(message.notice);
                        if (error)
                            return "notice." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an EventStructure message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.EventStructure
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.EventStructure} EventStructure
             */
            EventStructure.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.EventStructure)
                    return object;
                let message = new $root.kritor.event.EventStructure();
                switch (object.type) {
                default:
                    if (typeof object.type === "number") {
                        message.type = object.type;
                        break;
                    }
                    break;
                case "EVENT_TYPE_CORE_EVENT":
                case 0:
                    message.type = 0;
                    break;
                case "EVENT_TYPE_MESSAGE":
                case 1:
                    message.type = 1;
                    break;
                case "EVENT_TYPE_NOTICE":
                case 2:
                    message.type = 2;
                    break;
                case "EVENT_TYPE_REQUEST":
                case 3:
                    message.type = 3;
                    break;
                }
                if (object.message != null) {
                    if (typeof object.message !== "object")
                        throw TypeError(".kritor.event.EventStructure.message: object expected");
                    message.message = $root.kritor.common.PushMessageBody.fromObject(object.message);
                }
                if (object.request != null) {
                    if (typeof object.request !== "object")
                        throw TypeError(".kritor.event.EventStructure.request: object expected");
                    message.request = $root.kritor.event.RequestsEvent.fromObject(object.request);
                }
                if (object.notice != null) {
                    if (typeof object.notice !== "object")
                        throw TypeError(".kritor.event.EventStructure.notice: object expected");
                    message.notice = $root.kritor.event.NoticeEvent.fromObject(object.notice);
                }
                return message;
            };

            /**
             * Creates a plain object from an EventStructure message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.EventStructure
             * @static
             * @param {kritor.event.EventStructure} message EventStructure
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EventStructure.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.type = options.enums === String ? "EVENT_TYPE_CORE_EVENT" : 0;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.kritor.event.EventType[message.type] === undefined ? message.type : $root.kritor.event.EventType[message.type] : message.type;
                if (message.message != null && message.hasOwnProperty("message")) {
                    object.message = $root.kritor.common.PushMessageBody.toObject(message.message, options);
                    if (options.oneofs)
                        object.event = "message";
                }
                if (message.request != null && message.hasOwnProperty("request")) {
                    object.request = $root.kritor.event.RequestsEvent.toObject(message.request, options);
                    if (options.oneofs)
                        object.event = "request";
                }
                if (message.notice != null && message.hasOwnProperty("notice")) {
                    object.notice = $root.kritor.event.NoticeEvent.toObject(message.notice, options);
                    if (options.oneofs)
                        object.event = "notice";
                }
                return object;
            };

            /**
             * Converts this EventStructure to JSON.
             * @function toJSON
             * @memberof kritor.event.EventStructure
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EventStructure.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for EventStructure
             * @function getTypeUrl
             * @memberof kritor.event.EventStructure
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            EventStructure.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.EventStructure";
            };

            return EventStructure;
        })();

        event.NoticeEvent = (function() {

            /**
             * Properties of a NoticeEvent.
             * @memberof kritor.event
             * @interface INoticeEvent
             * @property {kritor.event.NoticeEvent.NoticeType|null} [type] NoticeEvent type
             * @property {number|null} [time] NoticeEvent time
             * @property {kritor.event.IFriendPokeNotice|null} [friendPoke] NoticeEvent friendPoke
             * @property {kritor.event.IFriendRecallNotice|null} [friendRecall] NoticeEvent friendRecall
             * @property {kritor.event.IFriendFileUploadedNotice|null} [friendFileUploaded] NoticeEvent friendFileUploaded
             * @property {kritor.event.IGroupPokeNotice|null} [groupPoke] NoticeEvent groupPoke
             * @property {kritor.event.IGroupCardChangedNotice|null} [groupCardChanged] NoticeEvent groupCardChanged
             * @property {kritor.event.IGroupUniqueTitleChangedNotice|null} [groupMemberUniqueTitleChanged] NoticeEvent groupMemberUniqueTitleChanged
             * @property {kritor.event.IGroupEssenceMessageNotice|null} [groupEssenceChanged] NoticeEvent groupEssenceChanged
             * @property {kritor.event.IGroupRecallNotice|null} [groupRecall] NoticeEvent groupRecall
             * @property {kritor.event.IGroupMemberIncreasedNotice|null} [groupMemberIncrease] NoticeEvent groupMemberIncrease
             * @property {kritor.event.IGroupMemberDecreasedNotice|null} [groupMemberDecrease] NoticeEvent groupMemberDecrease
             * @property {kritor.event.IGroupAdminChangedNotice|null} [groupAdminChange] NoticeEvent groupAdminChange
             * @property {kritor.event.IGroupMemberBanNotice|null} [groupMemberBan] NoticeEvent groupMemberBan
             * @property {kritor.event.IGroupSignInNotice|null} [groupSignIn] NoticeEvent groupSignIn
             * @property {kritor.event.IGroupWholeBanNotice|null} [groupWholeBan] NoticeEvent groupWholeBan
             * @property {kritor.event.IGroupFileUploadedNotice|null} [groupFileUploaded] NoticeEvent groupFileUploaded
             */

            /**
             * Constructs a new NoticeEvent.
             * @memberof kritor.event
             * @classdesc Represents a NoticeEvent.
             * @implements INoticeEvent
             * @constructor
             * @param {kritor.event.INoticeEvent=} [properties] Properties to set
             */
            function NoticeEvent(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NoticeEvent type.
             * @member {kritor.event.NoticeEvent.NoticeType} type
             * @memberof kritor.event.NoticeEvent
             * @instance
             */
            NoticeEvent.prototype.type = 0;

            /**
             * NoticeEvent time.
             * @member {number} time
             * @memberof kritor.event.NoticeEvent
             * @instance
             */
            NoticeEvent.prototype.time = 0;

            /**
             * NoticeEvent friendPoke.
             * @member {kritor.event.IFriendPokeNotice|null|undefined} friendPoke
             * @memberof kritor.event.NoticeEvent
             * @instance
             */
            NoticeEvent.prototype.friendPoke = null;

            /**
             * NoticeEvent friendRecall.
             * @member {kritor.event.IFriendRecallNotice|null|undefined} friendRecall
             * @memberof kritor.event.NoticeEvent
             * @instance
             */
            NoticeEvent.prototype.friendRecall = null;

            /**
             * NoticeEvent friendFileUploaded.
             * @member {kritor.event.IFriendFileUploadedNotice|null|undefined} friendFileUploaded
             * @memberof kritor.event.NoticeEvent
             * @instance
             */
            NoticeEvent.prototype.friendFileUploaded = null;

            /**
             * NoticeEvent groupPoke.
             * @member {kritor.event.IGroupPokeNotice|null|undefined} groupPoke
             * @memberof kritor.event.NoticeEvent
             * @instance
             */
            NoticeEvent.prototype.groupPoke = null;

            /**
             * NoticeEvent groupCardChanged.
             * @member {kritor.event.IGroupCardChangedNotice|null|undefined} groupCardChanged
             * @memberof kritor.event.NoticeEvent
             * @instance
             */
            NoticeEvent.prototype.groupCardChanged = null;

            /**
             * NoticeEvent groupMemberUniqueTitleChanged.
             * @member {kritor.event.IGroupUniqueTitleChangedNotice|null|undefined} groupMemberUniqueTitleChanged
             * @memberof kritor.event.NoticeEvent
             * @instance
             */
            NoticeEvent.prototype.groupMemberUniqueTitleChanged = null;

            /**
             * NoticeEvent groupEssenceChanged.
             * @member {kritor.event.IGroupEssenceMessageNotice|null|undefined} groupEssenceChanged
             * @memberof kritor.event.NoticeEvent
             * @instance
             */
            NoticeEvent.prototype.groupEssenceChanged = null;

            /**
             * NoticeEvent groupRecall.
             * @member {kritor.event.IGroupRecallNotice|null|undefined} groupRecall
             * @memberof kritor.event.NoticeEvent
             * @instance
             */
            NoticeEvent.prototype.groupRecall = null;

            /**
             * NoticeEvent groupMemberIncrease.
             * @member {kritor.event.IGroupMemberIncreasedNotice|null|undefined} groupMemberIncrease
             * @memberof kritor.event.NoticeEvent
             * @instance
             */
            NoticeEvent.prototype.groupMemberIncrease = null;

            /**
             * NoticeEvent groupMemberDecrease.
             * @member {kritor.event.IGroupMemberDecreasedNotice|null|undefined} groupMemberDecrease
             * @memberof kritor.event.NoticeEvent
             * @instance
             */
            NoticeEvent.prototype.groupMemberDecrease = null;

            /**
             * NoticeEvent groupAdminChange.
             * @member {kritor.event.IGroupAdminChangedNotice|null|undefined} groupAdminChange
             * @memberof kritor.event.NoticeEvent
             * @instance
             */
            NoticeEvent.prototype.groupAdminChange = null;

            /**
             * NoticeEvent groupMemberBan.
             * @member {kritor.event.IGroupMemberBanNotice|null|undefined} groupMemberBan
             * @memberof kritor.event.NoticeEvent
             * @instance
             */
            NoticeEvent.prototype.groupMemberBan = null;

            /**
             * NoticeEvent groupSignIn.
             * @member {kritor.event.IGroupSignInNotice|null|undefined} groupSignIn
             * @memberof kritor.event.NoticeEvent
             * @instance
             */
            NoticeEvent.prototype.groupSignIn = null;

            /**
             * NoticeEvent groupWholeBan.
             * @member {kritor.event.IGroupWholeBanNotice|null|undefined} groupWholeBan
             * @memberof kritor.event.NoticeEvent
             * @instance
             */
            NoticeEvent.prototype.groupWholeBan = null;

            /**
             * NoticeEvent groupFileUploaded.
             * @member {kritor.event.IGroupFileUploadedNotice|null|undefined} groupFileUploaded
             * @memberof kritor.event.NoticeEvent
             * @instance
             */
            NoticeEvent.prototype.groupFileUploaded = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * NoticeEvent notice.
             * @member {"friendPoke"|"friendRecall"|"friendFileUploaded"|"groupPoke"|"groupCardChanged"|"groupMemberUniqueTitleChanged"|"groupEssenceChanged"|"groupRecall"|"groupMemberIncrease"|"groupMemberDecrease"|"groupAdminChange"|"groupMemberBan"|"groupSignIn"|"groupWholeBan"|"groupFileUploaded"|undefined} notice
             * @memberof kritor.event.NoticeEvent
             * @instance
             */
            Object.defineProperty(NoticeEvent.prototype, "notice", {
                get: $util.oneOfGetter($oneOfFields = ["friendPoke", "friendRecall", "friendFileUploaded", "groupPoke", "groupCardChanged", "groupMemberUniqueTitleChanged", "groupEssenceChanged", "groupRecall", "groupMemberIncrease", "groupMemberDecrease", "groupAdminChange", "groupMemberBan", "groupSignIn", "groupWholeBan", "groupFileUploaded"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new NoticeEvent instance using the specified properties.
             * @function create
             * @memberof kritor.event.NoticeEvent
             * @static
             * @param {kritor.event.INoticeEvent=} [properties] Properties to set
             * @returns {kritor.event.NoticeEvent} NoticeEvent instance
             */
            NoticeEvent.create = function create(properties) {
                return new NoticeEvent(properties);
            };

            /**
             * Encodes the specified NoticeEvent message. Does not implicitly {@link kritor.event.NoticeEvent.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.NoticeEvent
             * @static
             * @param {kritor.event.INoticeEvent} message NoticeEvent message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NoticeEvent.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.time);
                if (message.friendPoke != null && Object.hasOwnProperty.call(message, "friendPoke"))
                    $root.kritor.event.FriendPokeNotice.encode(message.friendPoke, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                if (message.friendRecall != null && Object.hasOwnProperty.call(message, "friendRecall"))
                    $root.kritor.event.FriendRecallNotice.encode(message.friendRecall, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                if (message.friendFileUploaded != null && Object.hasOwnProperty.call(message, "friendFileUploaded"))
                    $root.kritor.event.FriendFileUploadedNotice.encode(message.friendFileUploaded, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                if (message.groupPoke != null && Object.hasOwnProperty.call(message, "groupPoke"))
                    $root.kritor.event.GroupPokeNotice.encode(message.groupPoke, writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
                if (message.groupCardChanged != null && Object.hasOwnProperty.call(message, "groupCardChanged"))
                    $root.kritor.event.GroupCardChangedNotice.encode(message.groupCardChanged, writer.uint32(/* id 21, wireType 2 =*/170).fork()).ldelim();
                if (message.groupMemberUniqueTitleChanged != null && Object.hasOwnProperty.call(message, "groupMemberUniqueTitleChanged"))
                    $root.kritor.event.GroupUniqueTitleChangedNotice.encode(message.groupMemberUniqueTitleChanged, writer.uint32(/* id 22, wireType 2 =*/178).fork()).ldelim();
                if (message.groupEssenceChanged != null && Object.hasOwnProperty.call(message, "groupEssenceChanged"))
                    $root.kritor.event.GroupEssenceMessageNotice.encode(message.groupEssenceChanged, writer.uint32(/* id 23, wireType 2 =*/186).fork()).ldelim();
                if (message.groupRecall != null && Object.hasOwnProperty.call(message, "groupRecall"))
                    $root.kritor.event.GroupRecallNotice.encode(message.groupRecall, writer.uint32(/* id 24, wireType 2 =*/194).fork()).ldelim();
                if (message.groupMemberIncrease != null && Object.hasOwnProperty.call(message, "groupMemberIncrease"))
                    $root.kritor.event.GroupMemberIncreasedNotice.encode(message.groupMemberIncrease, writer.uint32(/* id 25, wireType 2 =*/202).fork()).ldelim();
                if (message.groupMemberDecrease != null && Object.hasOwnProperty.call(message, "groupMemberDecrease"))
                    $root.kritor.event.GroupMemberDecreasedNotice.encode(message.groupMemberDecrease, writer.uint32(/* id 26, wireType 2 =*/210).fork()).ldelim();
                if (message.groupAdminChange != null && Object.hasOwnProperty.call(message, "groupAdminChange"))
                    $root.kritor.event.GroupAdminChangedNotice.encode(message.groupAdminChange, writer.uint32(/* id 27, wireType 2 =*/218).fork()).ldelim();
                if (message.groupMemberBan != null && Object.hasOwnProperty.call(message, "groupMemberBan"))
                    $root.kritor.event.GroupMemberBanNotice.encode(message.groupMemberBan, writer.uint32(/* id 28, wireType 2 =*/226).fork()).ldelim();
                if (message.groupSignIn != null && Object.hasOwnProperty.call(message, "groupSignIn"))
                    $root.kritor.event.GroupSignInNotice.encode(message.groupSignIn, writer.uint32(/* id 29, wireType 2 =*/234).fork()).ldelim();
                if (message.groupWholeBan != null && Object.hasOwnProperty.call(message, "groupWholeBan"))
                    $root.kritor.event.GroupWholeBanNotice.encode(message.groupWholeBan, writer.uint32(/* id 30, wireType 2 =*/242).fork()).ldelim();
                if (message.groupFileUploaded != null && Object.hasOwnProperty.call(message, "groupFileUploaded"))
                    $root.kritor.event.GroupFileUploadedNotice.encode(message.groupFileUploaded, writer.uint32(/* id 31, wireType 2 =*/250).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified NoticeEvent message, length delimited. Does not implicitly {@link kritor.event.NoticeEvent.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.NoticeEvent
             * @static
             * @param {kritor.event.INoticeEvent} message NoticeEvent message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NoticeEvent.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NoticeEvent message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.NoticeEvent
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.NoticeEvent} NoticeEvent
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NoticeEvent.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.NoticeEvent();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.type = reader.int32();
                            break;
                        }
                    case 2: {
                            message.time = reader.uint32();
                            break;
                        }
                    case 10: {
                            message.friendPoke = $root.kritor.event.FriendPokeNotice.decode(reader, reader.uint32());
                            break;
                        }
                    case 11: {
                            message.friendRecall = $root.kritor.event.FriendRecallNotice.decode(reader, reader.uint32());
                            break;
                        }
                    case 12: {
                            message.friendFileUploaded = $root.kritor.event.FriendFileUploadedNotice.decode(reader, reader.uint32());
                            break;
                        }
                    case 20: {
                            message.groupPoke = $root.kritor.event.GroupPokeNotice.decode(reader, reader.uint32());
                            break;
                        }
                    case 21: {
                            message.groupCardChanged = $root.kritor.event.GroupCardChangedNotice.decode(reader, reader.uint32());
                            break;
                        }
                    case 22: {
                            message.groupMemberUniqueTitleChanged = $root.kritor.event.GroupUniqueTitleChangedNotice.decode(reader, reader.uint32());
                            break;
                        }
                    case 23: {
                            message.groupEssenceChanged = $root.kritor.event.GroupEssenceMessageNotice.decode(reader, reader.uint32());
                            break;
                        }
                    case 24: {
                            message.groupRecall = $root.kritor.event.GroupRecallNotice.decode(reader, reader.uint32());
                            break;
                        }
                    case 25: {
                            message.groupMemberIncrease = $root.kritor.event.GroupMemberIncreasedNotice.decode(reader, reader.uint32());
                            break;
                        }
                    case 26: {
                            message.groupMemberDecrease = $root.kritor.event.GroupMemberDecreasedNotice.decode(reader, reader.uint32());
                            break;
                        }
                    case 27: {
                            message.groupAdminChange = $root.kritor.event.GroupAdminChangedNotice.decode(reader, reader.uint32());
                            break;
                        }
                    case 28: {
                            message.groupMemberBan = $root.kritor.event.GroupMemberBanNotice.decode(reader, reader.uint32());
                            break;
                        }
                    case 29: {
                            message.groupSignIn = $root.kritor.event.GroupSignInNotice.decode(reader, reader.uint32());
                            break;
                        }
                    case 30: {
                            message.groupWholeBan = $root.kritor.event.GroupWholeBanNotice.decode(reader, reader.uint32());
                            break;
                        }
                    case 31: {
                            message.groupFileUploaded = $root.kritor.event.GroupFileUploadedNotice.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NoticeEvent message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.NoticeEvent
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.NoticeEvent} NoticeEvent
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NoticeEvent.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NoticeEvent message.
             * @function verify
             * @memberof kritor.event.NoticeEvent
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NoticeEvent.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 10:
                    case 11:
                    case 12:
                    case 20:
                    case 21:
                    case 22:
                    case 23:
                    case 24:
                    case 25:
                    case 26:
                    case 27:
                    case 28:
                    case 29:
                    case 30:
                    case 31:
                        break;
                    }
                if (message.time != null && message.hasOwnProperty("time"))
                    if (!$util.isInteger(message.time))
                        return "time: integer expected";
                if (message.friendPoke != null && message.hasOwnProperty("friendPoke")) {
                    properties.notice = 1;
                    {
                        let error = $root.kritor.event.FriendPokeNotice.verify(message.friendPoke);
                        if (error)
                            return "friendPoke." + error;
                    }
                }
                if (message.friendRecall != null && message.hasOwnProperty("friendRecall")) {
                    if (properties.notice === 1)
                        return "notice: multiple values";
                    properties.notice = 1;
                    {
                        let error = $root.kritor.event.FriendRecallNotice.verify(message.friendRecall);
                        if (error)
                            return "friendRecall." + error;
                    }
                }
                if (message.friendFileUploaded != null && message.hasOwnProperty("friendFileUploaded")) {
                    if (properties.notice === 1)
                        return "notice: multiple values";
                    properties.notice = 1;
                    {
                        let error = $root.kritor.event.FriendFileUploadedNotice.verify(message.friendFileUploaded);
                        if (error)
                            return "friendFileUploaded." + error;
                    }
                }
                if (message.groupPoke != null && message.hasOwnProperty("groupPoke")) {
                    if (properties.notice === 1)
                        return "notice: multiple values";
                    properties.notice = 1;
                    {
                        let error = $root.kritor.event.GroupPokeNotice.verify(message.groupPoke);
                        if (error)
                            return "groupPoke." + error;
                    }
                }
                if (message.groupCardChanged != null && message.hasOwnProperty("groupCardChanged")) {
                    if (properties.notice === 1)
                        return "notice: multiple values";
                    properties.notice = 1;
                    {
                        let error = $root.kritor.event.GroupCardChangedNotice.verify(message.groupCardChanged);
                        if (error)
                            return "groupCardChanged." + error;
                    }
                }
                if (message.groupMemberUniqueTitleChanged != null && message.hasOwnProperty("groupMemberUniqueTitleChanged")) {
                    if (properties.notice === 1)
                        return "notice: multiple values";
                    properties.notice = 1;
                    {
                        let error = $root.kritor.event.GroupUniqueTitleChangedNotice.verify(message.groupMemberUniqueTitleChanged);
                        if (error)
                            return "groupMemberUniqueTitleChanged." + error;
                    }
                }
                if (message.groupEssenceChanged != null && message.hasOwnProperty("groupEssenceChanged")) {
                    if (properties.notice === 1)
                        return "notice: multiple values";
                    properties.notice = 1;
                    {
                        let error = $root.kritor.event.GroupEssenceMessageNotice.verify(message.groupEssenceChanged);
                        if (error)
                            return "groupEssenceChanged." + error;
                    }
                }
                if (message.groupRecall != null && message.hasOwnProperty("groupRecall")) {
                    if (properties.notice === 1)
                        return "notice: multiple values";
                    properties.notice = 1;
                    {
                        let error = $root.kritor.event.GroupRecallNotice.verify(message.groupRecall);
                        if (error)
                            return "groupRecall." + error;
                    }
                }
                if (message.groupMemberIncrease != null && message.hasOwnProperty("groupMemberIncrease")) {
                    if (properties.notice === 1)
                        return "notice: multiple values";
                    properties.notice = 1;
                    {
                        let error = $root.kritor.event.GroupMemberIncreasedNotice.verify(message.groupMemberIncrease);
                        if (error)
                            return "groupMemberIncrease." + error;
                    }
                }
                if (message.groupMemberDecrease != null && message.hasOwnProperty("groupMemberDecrease")) {
                    if (properties.notice === 1)
                        return "notice: multiple values";
                    properties.notice = 1;
                    {
                        let error = $root.kritor.event.GroupMemberDecreasedNotice.verify(message.groupMemberDecrease);
                        if (error)
                            return "groupMemberDecrease." + error;
                    }
                }
                if (message.groupAdminChange != null && message.hasOwnProperty("groupAdminChange")) {
                    if (properties.notice === 1)
                        return "notice: multiple values";
                    properties.notice = 1;
                    {
                        let error = $root.kritor.event.GroupAdminChangedNotice.verify(message.groupAdminChange);
                        if (error)
                            return "groupAdminChange." + error;
                    }
                }
                if (message.groupMemberBan != null && message.hasOwnProperty("groupMemberBan")) {
                    if (properties.notice === 1)
                        return "notice: multiple values";
                    properties.notice = 1;
                    {
                        let error = $root.kritor.event.GroupMemberBanNotice.verify(message.groupMemberBan);
                        if (error)
                            return "groupMemberBan." + error;
                    }
                }
                if (message.groupSignIn != null && message.hasOwnProperty("groupSignIn")) {
                    if (properties.notice === 1)
                        return "notice: multiple values";
                    properties.notice = 1;
                    {
                        let error = $root.kritor.event.GroupSignInNotice.verify(message.groupSignIn);
                        if (error)
                            return "groupSignIn." + error;
                    }
                }
                if (message.groupWholeBan != null && message.hasOwnProperty("groupWholeBan")) {
                    if (properties.notice === 1)
                        return "notice: multiple values";
                    properties.notice = 1;
                    {
                        let error = $root.kritor.event.GroupWholeBanNotice.verify(message.groupWholeBan);
                        if (error)
                            return "groupWholeBan." + error;
                    }
                }
                if (message.groupFileUploaded != null && message.hasOwnProperty("groupFileUploaded")) {
                    if (properties.notice === 1)
                        return "notice: multiple values";
                    properties.notice = 1;
                    {
                        let error = $root.kritor.event.GroupFileUploadedNotice.verify(message.groupFileUploaded);
                        if (error)
                            return "groupFileUploaded." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a NoticeEvent message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.NoticeEvent
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.NoticeEvent} NoticeEvent
             */
            NoticeEvent.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.NoticeEvent)
                    return object;
                let message = new $root.kritor.event.NoticeEvent();
                switch (object.type) {
                default:
                    if (typeof object.type === "number") {
                        message.type = object.type;
                        break;
                    }
                    break;
                case "UNKNOWN":
                case 0:
                    message.type = 0;
                    break;
                case "FRIEND_POKE":
                case 10:
                    message.type = 10;
                    break;
                case "FRIEND_RECALL":
                case 11:
                    message.type = 11;
                    break;
                case "FRIEND_FILE_COME":
                case 12:
                    message.type = 12;
                    break;
                case "GROUP_POKE":
                case 20:
                    message.type = 20;
                    break;
                case "GROUP_CARD_CHANGED":
                case 21:
                    message.type = 21;
                    break;
                case "GROUP_MEMBER_UNIQUE_TITLE_CHANGED":
                case 22:
                    message.type = 22;
                    break;
                case "GROUP_ESSENCE_CHANGED":
                case 23:
                    message.type = 23;
                    break;
                case "GROUP_RECALL":
                case 24:
                    message.type = 24;
                    break;
                case "GROUP_MEMBER_INCREASE":
                case 25:
                    message.type = 25;
                    break;
                case "GROUP_MEMBER_DECREASE":
                case 26:
                    message.type = 26;
                    break;
                case "GROUP_ADMIN_CHANGED":
                case 27:
                    message.type = 27;
                    break;
                case "GROUP_MEMBER_BANNED":
                case 28:
                    message.type = 28;
                    break;
                case "GROUP_SIGN":
                case 29:
                    message.type = 29;
                    break;
                case "GROUP_WHOLE_BAN":
                case 30:
                    message.type = 30;
                    break;
                case "GROUP_FILE_COME":
                case 31:
                    message.type = 31;
                    break;
                }
                if (object.time != null)
                    message.time = object.time >>> 0;
                if (object.friendPoke != null) {
                    if (typeof object.friendPoke !== "object")
                        throw TypeError(".kritor.event.NoticeEvent.friendPoke: object expected");
                    message.friendPoke = $root.kritor.event.FriendPokeNotice.fromObject(object.friendPoke);
                }
                if (object.friendRecall != null) {
                    if (typeof object.friendRecall !== "object")
                        throw TypeError(".kritor.event.NoticeEvent.friendRecall: object expected");
                    message.friendRecall = $root.kritor.event.FriendRecallNotice.fromObject(object.friendRecall);
                }
                if (object.friendFileUploaded != null) {
                    if (typeof object.friendFileUploaded !== "object")
                        throw TypeError(".kritor.event.NoticeEvent.friendFileUploaded: object expected");
                    message.friendFileUploaded = $root.kritor.event.FriendFileUploadedNotice.fromObject(object.friendFileUploaded);
                }
                if (object.groupPoke != null) {
                    if (typeof object.groupPoke !== "object")
                        throw TypeError(".kritor.event.NoticeEvent.groupPoke: object expected");
                    message.groupPoke = $root.kritor.event.GroupPokeNotice.fromObject(object.groupPoke);
                }
                if (object.groupCardChanged != null) {
                    if (typeof object.groupCardChanged !== "object")
                        throw TypeError(".kritor.event.NoticeEvent.groupCardChanged: object expected");
                    message.groupCardChanged = $root.kritor.event.GroupCardChangedNotice.fromObject(object.groupCardChanged);
                }
                if (object.groupMemberUniqueTitleChanged != null) {
                    if (typeof object.groupMemberUniqueTitleChanged !== "object")
                        throw TypeError(".kritor.event.NoticeEvent.groupMemberUniqueTitleChanged: object expected");
                    message.groupMemberUniqueTitleChanged = $root.kritor.event.GroupUniqueTitleChangedNotice.fromObject(object.groupMemberUniqueTitleChanged);
                }
                if (object.groupEssenceChanged != null) {
                    if (typeof object.groupEssenceChanged !== "object")
                        throw TypeError(".kritor.event.NoticeEvent.groupEssenceChanged: object expected");
                    message.groupEssenceChanged = $root.kritor.event.GroupEssenceMessageNotice.fromObject(object.groupEssenceChanged);
                }
                if (object.groupRecall != null) {
                    if (typeof object.groupRecall !== "object")
                        throw TypeError(".kritor.event.NoticeEvent.groupRecall: object expected");
                    message.groupRecall = $root.kritor.event.GroupRecallNotice.fromObject(object.groupRecall);
                }
                if (object.groupMemberIncrease != null) {
                    if (typeof object.groupMemberIncrease !== "object")
                        throw TypeError(".kritor.event.NoticeEvent.groupMemberIncrease: object expected");
                    message.groupMemberIncrease = $root.kritor.event.GroupMemberIncreasedNotice.fromObject(object.groupMemberIncrease);
                }
                if (object.groupMemberDecrease != null) {
                    if (typeof object.groupMemberDecrease !== "object")
                        throw TypeError(".kritor.event.NoticeEvent.groupMemberDecrease: object expected");
                    message.groupMemberDecrease = $root.kritor.event.GroupMemberDecreasedNotice.fromObject(object.groupMemberDecrease);
                }
                if (object.groupAdminChange != null) {
                    if (typeof object.groupAdminChange !== "object")
                        throw TypeError(".kritor.event.NoticeEvent.groupAdminChange: object expected");
                    message.groupAdminChange = $root.kritor.event.GroupAdminChangedNotice.fromObject(object.groupAdminChange);
                }
                if (object.groupMemberBan != null) {
                    if (typeof object.groupMemberBan !== "object")
                        throw TypeError(".kritor.event.NoticeEvent.groupMemberBan: object expected");
                    message.groupMemberBan = $root.kritor.event.GroupMemberBanNotice.fromObject(object.groupMemberBan);
                }
                if (object.groupSignIn != null) {
                    if (typeof object.groupSignIn !== "object")
                        throw TypeError(".kritor.event.NoticeEvent.groupSignIn: object expected");
                    message.groupSignIn = $root.kritor.event.GroupSignInNotice.fromObject(object.groupSignIn);
                }
                if (object.groupWholeBan != null) {
                    if (typeof object.groupWholeBan !== "object")
                        throw TypeError(".kritor.event.NoticeEvent.groupWholeBan: object expected");
                    message.groupWholeBan = $root.kritor.event.GroupWholeBanNotice.fromObject(object.groupWholeBan);
                }
                if (object.groupFileUploaded != null) {
                    if (typeof object.groupFileUploaded !== "object")
                        throw TypeError(".kritor.event.NoticeEvent.groupFileUploaded: object expected");
                    message.groupFileUploaded = $root.kritor.event.GroupFileUploadedNotice.fromObject(object.groupFileUploaded);
                }
                return message;
            };

            /**
             * Creates a plain object from a NoticeEvent message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.NoticeEvent
             * @static
             * @param {kritor.event.NoticeEvent} message NoticeEvent
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NoticeEvent.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.type = options.enums === String ? "UNKNOWN" : 0;
                    object.time = 0;
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.kritor.event.NoticeEvent.NoticeType[message.type] === undefined ? message.type : $root.kritor.event.NoticeEvent.NoticeType[message.type] : message.type;
                if (message.time != null && message.hasOwnProperty("time"))
                    object.time = message.time;
                if (message.friendPoke != null && message.hasOwnProperty("friendPoke")) {
                    object.friendPoke = $root.kritor.event.FriendPokeNotice.toObject(message.friendPoke, options);
                    if (options.oneofs)
                        object.notice = "friendPoke";
                }
                if (message.friendRecall != null && message.hasOwnProperty("friendRecall")) {
                    object.friendRecall = $root.kritor.event.FriendRecallNotice.toObject(message.friendRecall, options);
                    if (options.oneofs)
                        object.notice = "friendRecall";
                }
                if (message.friendFileUploaded != null && message.hasOwnProperty("friendFileUploaded")) {
                    object.friendFileUploaded = $root.kritor.event.FriendFileUploadedNotice.toObject(message.friendFileUploaded, options);
                    if (options.oneofs)
                        object.notice = "friendFileUploaded";
                }
                if (message.groupPoke != null && message.hasOwnProperty("groupPoke")) {
                    object.groupPoke = $root.kritor.event.GroupPokeNotice.toObject(message.groupPoke, options);
                    if (options.oneofs)
                        object.notice = "groupPoke";
                }
                if (message.groupCardChanged != null && message.hasOwnProperty("groupCardChanged")) {
                    object.groupCardChanged = $root.kritor.event.GroupCardChangedNotice.toObject(message.groupCardChanged, options);
                    if (options.oneofs)
                        object.notice = "groupCardChanged";
                }
                if (message.groupMemberUniqueTitleChanged != null && message.hasOwnProperty("groupMemberUniqueTitleChanged")) {
                    object.groupMemberUniqueTitleChanged = $root.kritor.event.GroupUniqueTitleChangedNotice.toObject(message.groupMemberUniqueTitleChanged, options);
                    if (options.oneofs)
                        object.notice = "groupMemberUniqueTitleChanged";
                }
                if (message.groupEssenceChanged != null && message.hasOwnProperty("groupEssenceChanged")) {
                    object.groupEssenceChanged = $root.kritor.event.GroupEssenceMessageNotice.toObject(message.groupEssenceChanged, options);
                    if (options.oneofs)
                        object.notice = "groupEssenceChanged";
                }
                if (message.groupRecall != null && message.hasOwnProperty("groupRecall")) {
                    object.groupRecall = $root.kritor.event.GroupRecallNotice.toObject(message.groupRecall, options);
                    if (options.oneofs)
                        object.notice = "groupRecall";
                }
                if (message.groupMemberIncrease != null && message.hasOwnProperty("groupMemberIncrease")) {
                    object.groupMemberIncrease = $root.kritor.event.GroupMemberIncreasedNotice.toObject(message.groupMemberIncrease, options);
                    if (options.oneofs)
                        object.notice = "groupMemberIncrease";
                }
                if (message.groupMemberDecrease != null && message.hasOwnProperty("groupMemberDecrease")) {
                    object.groupMemberDecrease = $root.kritor.event.GroupMemberDecreasedNotice.toObject(message.groupMemberDecrease, options);
                    if (options.oneofs)
                        object.notice = "groupMemberDecrease";
                }
                if (message.groupAdminChange != null && message.hasOwnProperty("groupAdminChange")) {
                    object.groupAdminChange = $root.kritor.event.GroupAdminChangedNotice.toObject(message.groupAdminChange, options);
                    if (options.oneofs)
                        object.notice = "groupAdminChange";
                }
                if (message.groupMemberBan != null && message.hasOwnProperty("groupMemberBan")) {
                    object.groupMemberBan = $root.kritor.event.GroupMemberBanNotice.toObject(message.groupMemberBan, options);
                    if (options.oneofs)
                        object.notice = "groupMemberBan";
                }
                if (message.groupSignIn != null && message.hasOwnProperty("groupSignIn")) {
                    object.groupSignIn = $root.kritor.event.GroupSignInNotice.toObject(message.groupSignIn, options);
                    if (options.oneofs)
                        object.notice = "groupSignIn";
                }
                if (message.groupWholeBan != null && message.hasOwnProperty("groupWholeBan")) {
                    object.groupWholeBan = $root.kritor.event.GroupWholeBanNotice.toObject(message.groupWholeBan, options);
                    if (options.oneofs)
                        object.notice = "groupWholeBan";
                }
                if (message.groupFileUploaded != null && message.hasOwnProperty("groupFileUploaded")) {
                    object.groupFileUploaded = $root.kritor.event.GroupFileUploadedNotice.toObject(message.groupFileUploaded, options);
                    if (options.oneofs)
                        object.notice = "groupFileUploaded";
                }
                return object;
            };

            /**
             * Converts this NoticeEvent to JSON.
             * @function toJSON
             * @memberof kritor.event.NoticeEvent
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NoticeEvent.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for NoticeEvent
             * @function getTypeUrl
             * @memberof kritor.event.NoticeEvent
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            NoticeEvent.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.NoticeEvent";
            };

            /**
             * NoticeType enum.
             * @name kritor.event.NoticeEvent.NoticeType
             * @enum {number}
             * @property {number} UNKNOWN=0 UNKNOWN value
             * @property {number} FRIEND_POKE=10 FRIEND_POKE value
             * @property {number} FRIEND_RECALL=11 FRIEND_RECALL value
             * @property {number} FRIEND_FILE_COME=12 FRIEND_FILE_COME value
             * @property {number} GROUP_POKE=20 GROUP_POKE value
             * @property {number} GROUP_CARD_CHANGED=21 GROUP_CARD_CHANGED value
             * @property {number} GROUP_MEMBER_UNIQUE_TITLE_CHANGED=22 GROUP_MEMBER_UNIQUE_TITLE_CHANGED value
             * @property {number} GROUP_ESSENCE_CHANGED=23 GROUP_ESSENCE_CHANGED value
             * @property {number} GROUP_RECALL=24 GROUP_RECALL value
             * @property {number} GROUP_MEMBER_INCREASE=25 GROUP_MEMBER_INCREASE value
             * @property {number} GROUP_MEMBER_DECREASE=26 GROUP_MEMBER_DECREASE value
             * @property {number} GROUP_ADMIN_CHANGED=27 GROUP_ADMIN_CHANGED value
             * @property {number} GROUP_MEMBER_BANNED=28 GROUP_MEMBER_BANNED value
             * @property {number} GROUP_SIGN=29 GROUP_SIGN value
             * @property {number} GROUP_WHOLE_BAN=30 GROUP_WHOLE_BAN value
             * @property {number} GROUP_FILE_COME=31 GROUP_FILE_COME value
             */
            NoticeEvent.NoticeType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNKNOWN"] = 0;
                values[valuesById[10] = "FRIEND_POKE"] = 10;
                values[valuesById[11] = "FRIEND_RECALL"] = 11;
                values[valuesById[12] = "FRIEND_FILE_COME"] = 12;
                values[valuesById[20] = "GROUP_POKE"] = 20;
                values[valuesById[21] = "GROUP_CARD_CHANGED"] = 21;
                values[valuesById[22] = "GROUP_MEMBER_UNIQUE_TITLE_CHANGED"] = 22;
                values[valuesById[23] = "GROUP_ESSENCE_CHANGED"] = 23;
                values[valuesById[24] = "GROUP_RECALL"] = 24;
                values[valuesById[25] = "GROUP_MEMBER_INCREASE"] = 25;
                values[valuesById[26] = "GROUP_MEMBER_DECREASE"] = 26;
                values[valuesById[27] = "GROUP_ADMIN_CHANGED"] = 27;
                values[valuesById[28] = "GROUP_MEMBER_BANNED"] = 28;
                values[valuesById[29] = "GROUP_SIGN"] = 29;
                values[valuesById[30] = "GROUP_WHOLE_BAN"] = 30;
                values[valuesById[31] = "GROUP_FILE_COME"] = 31;
                return values;
            })();

            return NoticeEvent;
        })();

        event.FriendPokeNotice = (function() {

            /**
             * Properties of a FriendPokeNotice.
             * @memberof kritor.event
             * @interface IFriendPokeNotice
             * @property {string|null} [operatorUid] FriendPokeNotice operatorUid
             * @property {number|Long|null} [operatorUin] FriendPokeNotice operatorUin
             * @property {string|null} [action] FriendPokeNotice action
             * @property {string|null} [suffix] FriendPokeNotice suffix
             * @property {string|null} [actionImage] FriendPokeNotice actionImage
             */

            /**
             * Constructs a new FriendPokeNotice.
             * @memberof kritor.event
             * @classdesc Represents a FriendPokeNotice.
             * @implements IFriendPokeNotice
             * @constructor
             * @param {kritor.event.IFriendPokeNotice=} [properties] Properties to set
             */
            function FriendPokeNotice(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FriendPokeNotice operatorUid.
             * @member {string} operatorUid
             * @memberof kritor.event.FriendPokeNotice
             * @instance
             */
            FriendPokeNotice.prototype.operatorUid = "";

            /**
             * FriendPokeNotice operatorUin.
             * @member {number|Long} operatorUin
             * @memberof kritor.event.FriendPokeNotice
             * @instance
             */
            FriendPokeNotice.prototype.operatorUin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * FriendPokeNotice action.
             * @member {string} action
             * @memberof kritor.event.FriendPokeNotice
             * @instance
             */
            FriendPokeNotice.prototype.action = "";

            /**
             * FriendPokeNotice suffix.
             * @member {string} suffix
             * @memberof kritor.event.FriendPokeNotice
             * @instance
             */
            FriendPokeNotice.prototype.suffix = "";

            /**
             * FriendPokeNotice actionImage.
             * @member {string} actionImage
             * @memberof kritor.event.FriendPokeNotice
             * @instance
             */
            FriendPokeNotice.prototype.actionImage = "";

            /**
             * Creates a new FriendPokeNotice instance using the specified properties.
             * @function create
             * @memberof kritor.event.FriendPokeNotice
             * @static
             * @param {kritor.event.IFriendPokeNotice=} [properties] Properties to set
             * @returns {kritor.event.FriendPokeNotice} FriendPokeNotice instance
             */
            FriendPokeNotice.create = function create(properties) {
                return new FriendPokeNotice(properties);
            };

            /**
             * Encodes the specified FriendPokeNotice message. Does not implicitly {@link kritor.event.FriendPokeNotice.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.FriendPokeNotice
             * @static
             * @param {kritor.event.IFriendPokeNotice} message FriendPokeNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FriendPokeNotice.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operatorUid != null && Object.hasOwnProperty.call(message, "operatorUid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.operatorUid);
                if (message.operatorUin != null && Object.hasOwnProperty.call(message, "operatorUin"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.operatorUin);
                if (message.action != null && Object.hasOwnProperty.call(message, "action"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.action);
                if (message.suffix != null && Object.hasOwnProperty.call(message, "suffix"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.suffix);
                if (message.actionImage != null && Object.hasOwnProperty.call(message, "actionImage"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.actionImage);
                return writer;
            };

            /**
             * Encodes the specified FriendPokeNotice message, length delimited. Does not implicitly {@link kritor.event.FriendPokeNotice.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.FriendPokeNotice
             * @static
             * @param {kritor.event.IFriendPokeNotice} message FriendPokeNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FriendPokeNotice.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FriendPokeNotice message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.FriendPokeNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.FriendPokeNotice} FriendPokeNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FriendPokeNotice.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.FriendPokeNotice();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.operatorUid = reader.string();
                            break;
                        }
                    case 2: {
                            message.operatorUin = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.action = reader.string();
                            break;
                        }
                    case 4: {
                            message.suffix = reader.string();
                            break;
                        }
                    case 5: {
                            message.actionImage = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FriendPokeNotice message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.FriendPokeNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.FriendPokeNotice} FriendPokeNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FriendPokeNotice.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FriendPokeNotice message.
             * @function verify
             * @memberof kritor.event.FriendPokeNotice
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FriendPokeNotice.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operatorUid != null && message.hasOwnProperty("operatorUid"))
                    if (!$util.isString(message.operatorUid))
                        return "operatorUid: string expected";
                if (message.operatorUin != null && message.hasOwnProperty("operatorUin"))
                    if (!$util.isInteger(message.operatorUin) && !(message.operatorUin && $util.isInteger(message.operatorUin.low) && $util.isInteger(message.operatorUin.high)))
                        return "operatorUin: integer|Long expected";
                if (message.action != null && message.hasOwnProperty("action"))
                    if (!$util.isString(message.action))
                        return "action: string expected";
                if (message.suffix != null && message.hasOwnProperty("suffix"))
                    if (!$util.isString(message.suffix))
                        return "suffix: string expected";
                if (message.actionImage != null && message.hasOwnProperty("actionImage"))
                    if (!$util.isString(message.actionImage))
                        return "actionImage: string expected";
                return null;
            };

            /**
             * Creates a FriendPokeNotice message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.FriendPokeNotice
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.FriendPokeNotice} FriendPokeNotice
             */
            FriendPokeNotice.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.FriendPokeNotice)
                    return object;
                let message = new $root.kritor.event.FriendPokeNotice();
                if (object.operatorUid != null)
                    message.operatorUid = String(object.operatorUid);
                if (object.operatorUin != null)
                    if ($util.Long)
                        (message.operatorUin = $util.Long.fromValue(object.operatorUin)).unsigned = true;
                    else if (typeof object.operatorUin === "string")
                        message.operatorUin = parseInt(object.operatorUin, 10);
                    else if (typeof object.operatorUin === "number")
                        message.operatorUin = object.operatorUin;
                    else if (typeof object.operatorUin === "object")
                        message.operatorUin = new $util.LongBits(object.operatorUin.low >>> 0, object.operatorUin.high >>> 0).toNumber(true);
                if (object.action != null)
                    message.action = String(object.action);
                if (object.suffix != null)
                    message.suffix = String(object.suffix);
                if (object.actionImage != null)
                    message.actionImage = String(object.actionImage);
                return message;
            };

            /**
             * Creates a plain object from a FriendPokeNotice message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.FriendPokeNotice
             * @static
             * @param {kritor.event.FriendPokeNotice} message FriendPokeNotice
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FriendPokeNotice.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.operatorUid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.operatorUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.operatorUin = options.longs === String ? "0" : 0;
                    object.action = "";
                    object.suffix = "";
                    object.actionImage = "";
                }
                if (message.operatorUid != null && message.hasOwnProperty("operatorUid"))
                    object.operatorUid = message.operatorUid;
                if (message.operatorUin != null && message.hasOwnProperty("operatorUin"))
                    if (typeof message.operatorUin === "number")
                        object.operatorUin = options.longs === String ? String(message.operatorUin) : message.operatorUin;
                    else
                        object.operatorUin = options.longs === String ? $util.Long.prototype.toString.call(message.operatorUin) : options.longs === Number ? new $util.LongBits(message.operatorUin.low >>> 0, message.operatorUin.high >>> 0).toNumber(true) : message.operatorUin;
                if (message.action != null && message.hasOwnProperty("action"))
                    object.action = message.action;
                if (message.suffix != null && message.hasOwnProperty("suffix"))
                    object.suffix = message.suffix;
                if (message.actionImage != null && message.hasOwnProperty("actionImage"))
                    object.actionImage = message.actionImage;
                return object;
            };

            /**
             * Converts this FriendPokeNotice to JSON.
             * @function toJSON
             * @memberof kritor.event.FriendPokeNotice
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FriendPokeNotice.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for FriendPokeNotice
             * @function getTypeUrl
             * @memberof kritor.event.FriendPokeNotice
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            FriendPokeNotice.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.FriendPokeNotice";
            };

            return FriendPokeNotice;
        })();

        event.FriendRecallNotice = (function() {

            /**
             * Properties of a FriendRecallNotice.
             * @memberof kritor.event
             * @interface IFriendRecallNotice
             * @property {string|null} [operatorUid] FriendRecallNotice operatorUid
             * @property {number|Long|null} [operatorUin] FriendRecallNotice operatorUin
             * @property {string|null} [messageId] FriendRecallNotice messageId
             * @property {string|null} [tipText] FriendRecallNotice tipText
             */

            /**
             * Constructs a new FriendRecallNotice.
             * @memberof kritor.event
             * @classdesc Represents a FriendRecallNotice.
             * @implements IFriendRecallNotice
             * @constructor
             * @param {kritor.event.IFriendRecallNotice=} [properties] Properties to set
             */
            function FriendRecallNotice(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FriendRecallNotice operatorUid.
             * @member {string} operatorUid
             * @memberof kritor.event.FriendRecallNotice
             * @instance
             */
            FriendRecallNotice.prototype.operatorUid = "";

            /**
             * FriendRecallNotice operatorUin.
             * @member {number|Long} operatorUin
             * @memberof kritor.event.FriendRecallNotice
             * @instance
             */
            FriendRecallNotice.prototype.operatorUin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * FriendRecallNotice messageId.
             * @member {string} messageId
             * @memberof kritor.event.FriendRecallNotice
             * @instance
             */
            FriendRecallNotice.prototype.messageId = "";

            /**
             * FriendRecallNotice tipText.
             * @member {string} tipText
             * @memberof kritor.event.FriendRecallNotice
             * @instance
             */
            FriendRecallNotice.prototype.tipText = "";

            /**
             * Creates a new FriendRecallNotice instance using the specified properties.
             * @function create
             * @memberof kritor.event.FriendRecallNotice
             * @static
             * @param {kritor.event.IFriendRecallNotice=} [properties] Properties to set
             * @returns {kritor.event.FriendRecallNotice} FriendRecallNotice instance
             */
            FriendRecallNotice.create = function create(properties) {
                return new FriendRecallNotice(properties);
            };

            /**
             * Encodes the specified FriendRecallNotice message. Does not implicitly {@link kritor.event.FriendRecallNotice.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.FriendRecallNotice
             * @static
             * @param {kritor.event.IFriendRecallNotice} message FriendRecallNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FriendRecallNotice.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operatorUid != null && Object.hasOwnProperty.call(message, "operatorUid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.operatorUid);
                if (message.operatorUin != null && Object.hasOwnProperty.call(message, "operatorUin"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.operatorUin);
                if (message.messageId != null && Object.hasOwnProperty.call(message, "messageId"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.messageId);
                if (message.tipText != null && Object.hasOwnProperty.call(message, "tipText"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.tipText);
                return writer;
            };

            /**
             * Encodes the specified FriendRecallNotice message, length delimited. Does not implicitly {@link kritor.event.FriendRecallNotice.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.FriendRecallNotice
             * @static
             * @param {kritor.event.IFriendRecallNotice} message FriendRecallNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FriendRecallNotice.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FriendRecallNotice message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.FriendRecallNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.FriendRecallNotice} FriendRecallNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FriendRecallNotice.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.FriendRecallNotice();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.operatorUid = reader.string();
                            break;
                        }
                    case 2: {
                            message.operatorUin = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.messageId = reader.string();
                            break;
                        }
                    case 4: {
                            message.tipText = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FriendRecallNotice message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.FriendRecallNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.FriendRecallNotice} FriendRecallNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FriendRecallNotice.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FriendRecallNotice message.
             * @function verify
             * @memberof kritor.event.FriendRecallNotice
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FriendRecallNotice.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operatorUid != null && message.hasOwnProperty("operatorUid"))
                    if (!$util.isString(message.operatorUid))
                        return "operatorUid: string expected";
                if (message.operatorUin != null && message.hasOwnProperty("operatorUin"))
                    if (!$util.isInteger(message.operatorUin) && !(message.operatorUin && $util.isInteger(message.operatorUin.low) && $util.isInteger(message.operatorUin.high)))
                        return "operatorUin: integer|Long expected";
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    if (!$util.isString(message.messageId))
                        return "messageId: string expected";
                if (message.tipText != null && message.hasOwnProperty("tipText"))
                    if (!$util.isString(message.tipText))
                        return "tipText: string expected";
                return null;
            };

            /**
             * Creates a FriendRecallNotice message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.FriendRecallNotice
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.FriendRecallNotice} FriendRecallNotice
             */
            FriendRecallNotice.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.FriendRecallNotice)
                    return object;
                let message = new $root.kritor.event.FriendRecallNotice();
                if (object.operatorUid != null)
                    message.operatorUid = String(object.operatorUid);
                if (object.operatorUin != null)
                    if ($util.Long)
                        (message.operatorUin = $util.Long.fromValue(object.operatorUin)).unsigned = true;
                    else if (typeof object.operatorUin === "string")
                        message.operatorUin = parseInt(object.operatorUin, 10);
                    else if (typeof object.operatorUin === "number")
                        message.operatorUin = object.operatorUin;
                    else if (typeof object.operatorUin === "object")
                        message.operatorUin = new $util.LongBits(object.operatorUin.low >>> 0, object.operatorUin.high >>> 0).toNumber(true);
                if (object.messageId != null)
                    message.messageId = String(object.messageId);
                if (object.tipText != null)
                    message.tipText = String(object.tipText);
                return message;
            };

            /**
             * Creates a plain object from a FriendRecallNotice message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.FriendRecallNotice
             * @static
             * @param {kritor.event.FriendRecallNotice} message FriendRecallNotice
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FriendRecallNotice.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.operatorUid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.operatorUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.operatorUin = options.longs === String ? "0" : 0;
                    object.messageId = "";
                    object.tipText = "";
                }
                if (message.operatorUid != null && message.hasOwnProperty("operatorUid"))
                    object.operatorUid = message.operatorUid;
                if (message.operatorUin != null && message.hasOwnProperty("operatorUin"))
                    if (typeof message.operatorUin === "number")
                        object.operatorUin = options.longs === String ? String(message.operatorUin) : message.operatorUin;
                    else
                        object.operatorUin = options.longs === String ? $util.Long.prototype.toString.call(message.operatorUin) : options.longs === Number ? new $util.LongBits(message.operatorUin.low >>> 0, message.operatorUin.high >>> 0).toNumber(true) : message.operatorUin;
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    object.messageId = message.messageId;
                if (message.tipText != null && message.hasOwnProperty("tipText"))
                    object.tipText = message.tipText;
                return object;
            };

            /**
             * Converts this FriendRecallNotice to JSON.
             * @function toJSON
             * @memberof kritor.event.FriendRecallNotice
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FriendRecallNotice.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for FriendRecallNotice
             * @function getTypeUrl
             * @memberof kritor.event.FriendRecallNotice
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            FriendRecallNotice.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.FriendRecallNotice";
            };

            return FriendRecallNotice;
        })();

        event.GroupUniqueTitleChangedNotice = (function() {

            /**
             * Properties of a GroupUniqueTitleChangedNotice.
             * @memberof kritor.event
             * @interface IGroupUniqueTitleChangedNotice
             * @property {number|Long|null} [target] GroupUniqueTitleChangedNotice target
             * @property {string|null} [title] GroupUniqueTitleChangedNotice title
             * @property {number|Long|null} [groupId] GroupUniqueTitleChangedNotice groupId
             */

            /**
             * Constructs a new GroupUniqueTitleChangedNotice.
             * @memberof kritor.event
             * @classdesc Represents a GroupUniqueTitleChangedNotice.
             * @implements IGroupUniqueTitleChangedNotice
             * @constructor
             * @param {kritor.event.IGroupUniqueTitleChangedNotice=} [properties] Properties to set
             */
            function GroupUniqueTitleChangedNotice(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupUniqueTitleChangedNotice target.
             * @member {number|Long} target
             * @memberof kritor.event.GroupUniqueTitleChangedNotice
             * @instance
             */
            GroupUniqueTitleChangedNotice.prototype.target = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupUniqueTitleChangedNotice title.
             * @member {string} title
             * @memberof kritor.event.GroupUniqueTitleChangedNotice
             * @instance
             */
            GroupUniqueTitleChangedNotice.prototype.title = "";

            /**
             * GroupUniqueTitleChangedNotice groupId.
             * @member {number|Long} groupId
             * @memberof kritor.event.GroupUniqueTitleChangedNotice
             * @instance
             */
            GroupUniqueTitleChangedNotice.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new GroupUniqueTitleChangedNotice instance using the specified properties.
             * @function create
             * @memberof kritor.event.GroupUniqueTitleChangedNotice
             * @static
             * @param {kritor.event.IGroupUniqueTitleChangedNotice=} [properties] Properties to set
             * @returns {kritor.event.GroupUniqueTitleChangedNotice} GroupUniqueTitleChangedNotice instance
             */
            GroupUniqueTitleChangedNotice.create = function create(properties) {
                return new GroupUniqueTitleChangedNotice(properties);
            };

            /**
             * Encodes the specified GroupUniqueTitleChangedNotice message. Does not implicitly {@link kritor.event.GroupUniqueTitleChangedNotice.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.GroupUniqueTitleChangedNotice
             * @static
             * @param {kritor.event.IGroupUniqueTitleChangedNotice} message GroupUniqueTitleChangedNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupUniqueTitleChangedNotice.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.target != null && Object.hasOwnProperty.call(message, "target"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.target);
                if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.title);
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.groupId);
                return writer;
            };

            /**
             * Encodes the specified GroupUniqueTitleChangedNotice message, length delimited. Does not implicitly {@link kritor.event.GroupUniqueTitleChangedNotice.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.GroupUniqueTitleChangedNotice
             * @static
             * @param {kritor.event.IGroupUniqueTitleChangedNotice} message GroupUniqueTitleChangedNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupUniqueTitleChangedNotice.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupUniqueTitleChangedNotice message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.GroupUniqueTitleChangedNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.GroupUniqueTitleChangedNotice} GroupUniqueTitleChangedNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupUniqueTitleChangedNotice.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.GroupUniqueTitleChangedNotice();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.target = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.title = reader.string();
                            break;
                        }
                    case 3: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupUniqueTitleChangedNotice message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.GroupUniqueTitleChangedNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.GroupUniqueTitleChangedNotice} GroupUniqueTitleChangedNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupUniqueTitleChangedNotice.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupUniqueTitleChangedNotice message.
             * @function verify
             * @memberof kritor.event.GroupUniqueTitleChangedNotice
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupUniqueTitleChangedNotice.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.target != null && message.hasOwnProperty("target"))
                    if (!$util.isInteger(message.target) && !(message.target && $util.isInteger(message.target.low) && $util.isInteger(message.target.high)))
                        return "target: integer|Long expected";
                if (message.title != null && message.hasOwnProperty("title"))
                    if (!$util.isString(message.title))
                        return "title: string expected";
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                return null;
            };

            /**
             * Creates a GroupUniqueTitleChangedNotice message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.GroupUniqueTitleChangedNotice
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.GroupUniqueTitleChangedNotice} GroupUniqueTitleChangedNotice
             */
            GroupUniqueTitleChangedNotice.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.GroupUniqueTitleChangedNotice)
                    return object;
                let message = new $root.kritor.event.GroupUniqueTitleChangedNotice();
                if (object.target != null)
                    if ($util.Long)
                        (message.target = $util.Long.fromValue(object.target)).unsigned = true;
                    else if (typeof object.target === "string")
                        message.target = parseInt(object.target, 10);
                    else if (typeof object.target === "number")
                        message.target = object.target;
                    else if (typeof object.target === "object")
                        message.target = new $util.LongBits(object.target.low >>> 0, object.target.high >>> 0).toNumber(true);
                if (object.title != null)
                    message.title = String(object.title);
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a GroupUniqueTitleChangedNotice message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.GroupUniqueTitleChangedNotice
             * @static
             * @param {kritor.event.GroupUniqueTitleChangedNotice} message GroupUniqueTitleChangedNotice
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupUniqueTitleChangedNotice.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.target = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.target = options.longs === String ? "0" : 0;
                    object.title = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                }
                if (message.target != null && message.hasOwnProperty("target"))
                    if (typeof message.target === "number")
                        object.target = options.longs === String ? String(message.target) : message.target;
                    else
                        object.target = options.longs === String ? $util.Long.prototype.toString.call(message.target) : options.longs === Number ? new $util.LongBits(message.target.low >>> 0, message.target.high >>> 0).toNumber(true) : message.target;
                if (message.title != null && message.hasOwnProperty("title"))
                    object.title = message.title;
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                return object;
            };

            /**
             * Converts this GroupUniqueTitleChangedNotice to JSON.
             * @function toJSON
             * @memberof kritor.event.GroupUniqueTitleChangedNotice
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupUniqueTitleChangedNotice.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GroupUniqueTitleChangedNotice
             * @function getTypeUrl
             * @memberof kritor.event.GroupUniqueTitleChangedNotice
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GroupUniqueTitleChangedNotice.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.GroupUniqueTitleChangedNotice";
            };

            return GroupUniqueTitleChangedNotice;
        })();

        event.GroupEssenceMessageNotice = (function() {

            /**
             * Properties of a GroupEssenceMessageNotice.
             * @memberof kritor.event
             * @interface IGroupEssenceMessageNotice
             * @property {number|Long|null} [groupId] GroupEssenceMessageNotice groupId
             * @property {string|null} [operatorUid] GroupEssenceMessageNotice operatorUid
             * @property {number|Long|null} [operatorUin] GroupEssenceMessageNotice operatorUin
             * @property {string|null} [targetUid] GroupEssenceMessageNotice targetUid
             * @property {number|Long|null} [targetUin] GroupEssenceMessageNotice targetUin
             * @property {string|null} [messageId] GroupEssenceMessageNotice messageId
             * @property {number|null} [subType] GroupEssenceMessageNotice subType
             */

            /**
             * Constructs a new GroupEssenceMessageNotice.
             * @memberof kritor.event
             * @classdesc Represents a GroupEssenceMessageNotice.
             * @implements IGroupEssenceMessageNotice
             * @constructor
             * @param {kritor.event.IGroupEssenceMessageNotice=} [properties] Properties to set
             */
            function GroupEssenceMessageNotice(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupEssenceMessageNotice groupId.
             * @member {number|Long} groupId
             * @memberof kritor.event.GroupEssenceMessageNotice
             * @instance
             */
            GroupEssenceMessageNotice.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupEssenceMessageNotice operatorUid.
             * @member {string} operatorUid
             * @memberof kritor.event.GroupEssenceMessageNotice
             * @instance
             */
            GroupEssenceMessageNotice.prototype.operatorUid = "";

            /**
             * GroupEssenceMessageNotice operatorUin.
             * @member {number|Long} operatorUin
             * @memberof kritor.event.GroupEssenceMessageNotice
             * @instance
             */
            GroupEssenceMessageNotice.prototype.operatorUin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupEssenceMessageNotice targetUid.
             * @member {string} targetUid
             * @memberof kritor.event.GroupEssenceMessageNotice
             * @instance
             */
            GroupEssenceMessageNotice.prototype.targetUid = "";

            /**
             * GroupEssenceMessageNotice targetUin.
             * @member {number|Long} targetUin
             * @memberof kritor.event.GroupEssenceMessageNotice
             * @instance
             */
            GroupEssenceMessageNotice.prototype.targetUin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupEssenceMessageNotice messageId.
             * @member {string} messageId
             * @memberof kritor.event.GroupEssenceMessageNotice
             * @instance
             */
            GroupEssenceMessageNotice.prototype.messageId = "";

            /**
             * GroupEssenceMessageNotice subType.
             * @member {number} subType
             * @memberof kritor.event.GroupEssenceMessageNotice
             * @instance
             */
            GroupEssenceMessageNotice.prototype.subType = 0;

            /**
             * Creates a new GroupEssenceMessageNotice instance using the specified properties.
             * @function create
             * @memberof kritor.event.GroupEssenceMessageNotice
             * @static
             * @param {kritor.event.IGroupEssenceMessageNotice=} [properties] Properties to set
             * @returns {kritor.event.GroupEssenceMessageNotice} GroupEssenceMessageNotice instance
             */
            GroupEssenceMessageNotice.create = function create(properties) {
                return new GroupEssenceMessageNotice(properties);
            };

            /**
             * Encodes the specified GroupEssenceMessageNotice message. Does not implicitly {@link kritor.event.GroupEssenceMessageNotice.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.GroupEssenceMessageNotice
             * @static
             * @param {kritor.event.IGroupEssenceMessageNotice} message GroupEssenceMessageNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupEssenceMessageNotice.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                if (message.operatorUid != null && Object.hasOwnProperty.call(message, "operatorUid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.operatorUid);
                if (message.operatorUin != null && Object.hasOwnProperty.call(message, "operatorUin"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.operatorUin);
                if (message.targetUid != null && Object.hasOwnProperty.call(message, "targetUid"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.targetUid);
                if (message.targetUin != null && Object.hasOwnProperty.call(message, "targetUin"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.targetUin);
                if (message.messageId != null && Object.hasOwnProperty.call(message, "messageId"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.messageId);
                if (message.subType != null && Object.hasOwnProperty.call(message, "subType"))
                    writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.subType);
                return writer;
            };

            /**
             * Encodes the specified GroupEssenceMessageNotice message, length delimited. Does not implicitly {@link kritor.event.GroupEssenceMessageNotice.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.GroupEssenceMessageNotice
             * @static
             * @param {kritor.event.IGroupEssenceMessageNotice} message GroupEssenceMessageNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupEssenceMessageNotice.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupEssenceMessageNotice message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.GroupEssenceMessageNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.GroupEssenceMessageNotice} GroupEssenceMessageNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupEssenceMessageNotice.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.GroupEssenceMessageNotice();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.operatorUid = reader.string();
                            break;
                        }
                    case 3: {
                            message.operatorUin = reader.uint64();
                            break;
                        }
                    case 4: {
                            message.targetUid = reader.string();
                            break;
                        }
                    case 5: {
                            message.targetUin = reader.uint64();
                            break;
                        }
                    case 6: {
                            message.messageId = reader.string();
                            break;
                        }
                    case 7: {
                            message.subType = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupEssenceMessageNotice message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.GroupEssenceMessageNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.GroupEssenceMessageNotice} GroupEssenceMessageNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupEssenceMessageNotice.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupEssenceMessageNotice message.
             * @function verify
             * @memberof kritor.event.GroupEssenceMessageNotice
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupEssenceMessageNotice.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                if (message.operatorUid != null && message.hasOwnProperty("operatorUid"))
                    if (!$util.isString(message.operatorUid))
                        return "operatorUid: string expected";
                if (message.operatorUin != null && message.hasOwnProperty("operatorUin"))
                    if (!$util.isInteger(message.operatorUin) && !(message.operatorUin && $util.isInteger(message.operatorUin.low) && $util.isInteger(message.operatorUin.high)))
                        return "operatorUin: integer|Long expected";
                if (message.targetUid != null && message.hasOwnProperty("targetUid"))
                    if (!$util.isString(message.targetUid))
                        return "targetUid: string expected";
                if (message.targetUin != null && message.hasOwnProperty("targetUin"))
                    if (!$util.isInteger(message.targetUin) && !(message.targetUin && $util.isInteger(message.targetUin.low) && $util.isInteger(message.targetUin.high)))
                        return "targetUin: integer|Long expected";
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    if (!$util.isString(message.messageId))
                        return "messageId: string expected";
                if (message.subType != null && message.hasOwnProperty("subType"))
                    if (!$util.isInteger(message.subType))
                        return "subType: integer expected";
                return null;
            };

            /**
             * Creates a GroupEssenceMessageNotice message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.GroupEssenceMessageNotice
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.GroupEssenceMessageNotice} GroupEssenceMessageNotice
             */
            GroupEssenceMessageNotice.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.GroupEssenceMessageNotice)
                    return object;
                let message = new $root.kritor.event.GroupEssenceMessageNotice();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                if (object.operatorUid != null)
                    message.operatorUid = String(object.operatorUid);
                if (object.operatorUin != null)
                    if ($util.Long)
                        (message.operatorUin = $util.Long.fromValue(object.operatorUin)).unsigned = true;
                    else if (typeof object.operatorUin === "string")
                        message.operatorUin = parseInt(object.operatorUin, 10);
                    else if (typeof object.operatorUin === "number")
                        message.operatorUin = object.operatorUin;
                    else if (typeof object.operatorUin === "object")
                        message.operatorUin = new $util.LongBits(object.operatorUin.low >>> 0, object.operatorUin.high >>> 0).toNumber(true);
                if (object.targetUid != null)
                    message.targetUid = String(object.targetUid);
                if (object.targetUin != null)
                    if ($util.Long)
                        (message.targetUin = $util.Long.fromValue(object.targetUin)).unsigned = true;
                    else if (typeof object.targetUin === "string")
                        message.targetUin = parseInt(object.targetUin, 10);
                    else if (typeof object.targetUin === "number")
                        message.targetUin = object.targetUin;
                    else if (typeof object.targetUin === "object")
                        message.targetUin = new $util.LongBits(object.targetUin.low >>> 0, object.targetUin.high >>> 0).toNumber(true);
                if (object.messageId != null)
                    message.messageId = String(object.messageId);
                if (object.subType != null)
                    message.subType = object.subType >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a GroupEssenceMessageNotice message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.GroupEssenceMessageNotice
             * @static
             * @param {kritor.event.GroupEssenceMessageNotice} message GroupEssenceMessageNotice
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupEssenceMessageNotice.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                    object.operatorUid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.operatorUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.operatorUin = options.longs === String ? "0" : 0;
                    object.targetUid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.targetUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.targetUin = options.longs === String ? "0" : 0;
                    object.messageId = "";
                    object.subType = 0;
                }
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                if (message.operatorUid != null && message.hasOwnProperty("operatorUid"))
                    object.operatorUid = message.operatorUid;
                if (message.operatorUin != null && message.hasOwnProperty("operatorUin"))
                    if (typeof message.operatorUin === "number")
                        object.operatorUin = options.longs === String ? String(message.operatorUin) : message.operatorUin;
                    else
                        object.operatorUin = options.longs === String ? $util.Long.prototype.toString.call(message.operatorUin) : options.longs === Number ? new $util.LongBits(message.operatorUin.low >>> 0, message.operatorUin.high >>> 0).toNumber(true) : message.operatorUin;
                if (message.targetUid != null && message.hasOwnProperty("targetUid"))
                    object.targetUid = message.targetUid;
                if (message.targetUin != null && message.hasOwnProperty("targetUin"))
                    if (typeof message.targetUin === "number")
                        object.targetUin = options.longs === String ? String(message.targetUin) : message.targetUin;
                    else
                        object.targetUin = options.longs === String ? $util.Long.prototype.toString.call(message.targetUin) : options.longs === Number ? new $util.LongBits(message.targetUin.low >>> 0, message.targetUin.high >>> 0).toNumber(true) : message.targetUin;
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    object.messageId = message.messageId;
                if (message.subType != null && message.hasOwnProperty("subType"))
                    object.subType = message.subType;
                return object;
            };

            /**
             * Converts this GroupEssenceMessageNotice to JSON.
             * @function toJSON
             * @memberof kritor.event.GroupEssenceMessageNotice
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupEssenceMessageNotice.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GroupEssenceMessageNotice
             * @function getTypeUrl
             * @memberof kritor.event.GroupEssenceMessageNotice
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GroupEssenceMessageNotice.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.GroupEssenceMessageNotice";
            };

            return GroupEssenceMessageNotice;
        })();

        event.GroupPokeNotice = (function() {

            /**
             * Properties of a GroupPokeNotice.
             * @memberof kritor.event
             * @interface IGroupPokeNotice
             * @property {number|Long|null} [groupId] GroupPokeNotice groupId
             * @property {string|null} [operatorUid] GroupPokeNotice operatorUid
             * @property {number|Long|null} [operatorUin] GroupPokeNotice operatorUin
             * @property {string|null} [targetUid] GroupPokeNotice targetUid
             * @property {number|Long|null} [targetUin] GroupPokeNotice targetUin
             * @property {string|null} [action] GroupPokeNotice action
             * @property {string|null} [suffix] GroupPokeNotice suffix
             * @property {string|null} [actionImage] GroupPokeNotice actionImage
             */

            /**
             * Constructs a new GroupPokeNotice.
             * @memberof kritor.event
             * @classdesc Represents a GroupPokeNotice.
             * @implements IGroupPokeNotice
             * @constructor
             * @param {kritor.event.IGroupPokeNotice=} [properties] Properties to set
             */
            function GroupPokeNotice(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupPokeNotice groupId.
             * @member {number|Long} groupId
             * @memberof kritor.event.GroupPokeNotice
             * @instance
             */
            GroupPokeNotice.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupPokeNotice operatorUid.
             * @member {string} operatorUid
             * @memberof kritor.event.GroupPokeNotice
             * @instance
             */
            GroupPokeNotice.prototype.operatorUid = "";

            /**
             * GroupPokeNotice operatorUin.
             * @member {number|Long} operatorUin
             * @memberof kritor.event.GroupPokeNotice
             * @instance
             */
            GroupPokeNotice.prototype.operatorUin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupPokeNotice targetUid.
             * @member {string} targetUid
             * @memberof kritor.event.GroupPokeNotice
             * @instance
             */
            GroupPokeNotice.prototype.targetUid = "";

            /**
             * GroupPokeNotice targetUin.
             * @member {number|Long} targetUin
             * @memberof kritor.event.GroupPokeNotice
             * @instance
             */
            GroupPokeNotice.prototype.targetUin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupPokeNotice action.
             * @member {string} action
             * @memberof kritor.event.GroupPokeNotice
             * @instance
             */
            GroupPokeNotice.prototype.action = "";

            /**
             * GroupPokeNotice suffix.
             * @member {string} suffix
             * @memberof kritor.event.GroupPokeNotice
             * @instance
             */
            GroupPokeNotice.prototype.suffix = "";

            /**
             * GroupPokeNotice actionImage.
             * @member {string} actionImage
             * @memberof kritor.event.GroupPokeNotice
             * @instance
             */
            GroupPokeNotice.prototype.actionImage = "";

            /**
             * Creates a new GroupPokeNotice instance using the specified properties.
             * @function create
             * @memberof kritor.event.GroupPokeNotice
             * @static
             * @param {kritor.event.IGroupPokeNotice=} [properties] Properties to set
             * @returns {kritor.event.GroupPokeNotice} GroupPokeNotice instance
             */
            GroupPokeNotice.create = function create(properties) {
                return new GroupPokeNotice(properties);
            };

            /**
             * Encodes the specified GroupPokeNotice message. Does not implicitly {@link kritor.event.GroupPokeNotice.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.GroupPokeNotice
             * @static
             * @param {kritor.event.IGroupPokeNotice} message GroupPokeNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupPokeNotice.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                if (message.operatorUid != null && Object.hasOwnProperty.call(message, "operatorUid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.operatorUid);
                if (message.operatorUin != null && Object.hasOwnProperty.call(message, "operatorUin"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.operatorUin);
                if (message.targetUid != null && Object.hasOwnProperty.call(message, "targetUid"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.targetUid);
                if (message.targetUin != null && Object.hasOwnProperty.call(message, "targetUin"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.targetUin);
                if (message.action != null && Object.hasOwnProperty.call(message, "action"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.action);
                if (message.suffix != null && Object.hasOwnProperty.call(message, "suffix"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.suffix);
                if (message.actionImage != null && Object.hasOwnProperty.call(message, "actionImage"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.actionImage);
                return writer;
            };

            /**
             * Encodes the specified GroupPokeNotice message, length delimited. Does not implicitly {@link kritor.event.GroupPokeNotice.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.GroupPokeNotice
             * @static
             * @param {kritor.event.IGroupPokeNotice} message GroupPokeNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupPokeNotice.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupPokeNotice message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.GroupPokeNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.GroupPokeNotice} GroupPokeNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupPokeNotice.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.GroupPokeNotice();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.operatorUid = reader.string();
                            break;
                        }
                    case 3: {
                            message.operatorUin = reader.uint64();
                            break;
                        }
                    case 4: {
                            message.targetUid = reader.string();
                            break;
                        }
                    case 5: {
                            message.targetUin = reader.uint64();
                            break;
                        }
                    case 6: {
                            message.action = reader.string();
                            break;
                        }
                    case 7: {
                            message.suffix = reader.string();
                            break;
                        }
                    case 8: {
                            message.actionImage = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupPokeNotice message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.GroupPokeNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.GroupPokeNotice} GroupPokeNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupPokeNotice.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupPokeNotice message.
             * @function verify
             * @memberof kritor.event.GroupPokeNotice
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupPokeNotice.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                if (message.operatorUid != null && message.hasOwnProperty("operatorUid"))
                    if (!$util.isString(message.operatorUid))
                        return "operatorUid: string expected";
                if (message.operatorUin != null && message.hasOwnProperty("operatorUin"))
                    if (!$util.isInteger(message.operatorUin) && !(message.operatorUin && $util.isInteger(message.operatorUin.low) && $util.isInteger(message.operatorUin.high)))
                        return "operatorUin: integer|Long expected";
                if (message.targetUid != null && message.hasOwnProperty("targetUid"))
                    if (!$util.isString(message.targetUid))
                        return "targetUid: string expected";
                if (message.targetUin != null && message.hasOwnProperty("targetUin"))
                    if (!$util.isInteger(message.targetUin) && !(message.targetUin && $util.isInteger(message.targetUin.low) && $util.isInteger(message.targetUin.high)))
                        return "targetUin: integer|Long expected";
                if (message.action != null && message.hasOwnProperty("action"))
                    if (!$util.isString(message.action))
                        return "action: string expected";
                if (message.suffix != null && message.hasOwnProperty("suffix"))
                    if (!$util.isString(message.suffix))
                        return "suffix: string expected";
                if (message.actionImage != null && message.hasOwnProperty("actionImage"))
                    if (!$util.isString(message.actionImage))
                        return "actionImage: string expected";
                return null;
            };

            /**
             * Creates a GroupPokeNotice message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.GroupPokeNotice
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.GroupPokeNotice} GroupPokeNotice
             */
            GroupPokeNotice.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.GroupPokeNotice)
                    return object;
                let message = new $root.kritor.event.GroupPokeNotice();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                if (object.operatorUid != null)
                    message.operatorUid = String(object.operatorUid);
                if (object.operatorUin != null)
                    if ($util.Long)
                        (message.operatorUin = $util.Long.fromValue(object.operatorUin)).unsigned = true;
                    else if (typeof object.operatorUin === "string")
                        message.operatorUin = parseInt(object.operatorUin, 10);
                    else if (typeof object.operatorUin === "number")
                        message.operatorUin = object.operatorUin;
                    else if (typeof object.operatorUin === "object")
                        message.operatorUin = new $util.LongBits(object.operatorUin.low >>> 0, object.operatorUin.high >>> 0).toNumber(true);
                if (object.targetUid != null)
                    message.targetUid = String(object.targetUid);
                if (object.targetUin != null)
                    if ($util.Long)
                        (message.targetUin = $util.Long.fromValue(object.targetUin)).unsigned = true;
                    else if (typeof object.targetUin === "string")
                        message.targetUin = parseInt(object.targetUin, 10);
                    else if (typeof object.targetUin === "number")
                        message.targetUin = object.targetUin;
                    else if (typeof object.targetUin === "object")
                        message.targetUin = new $util.LongBits(object.targetUin.low >>> 0, object.targetUin.high >>> 0).toNumber(true);
                if (object.action != null)
                    message.action = String(object.action);
                if (object.suffix != null)
                    message.suffix = String(object.suffix);
                if (object.actionImage != null)
                    message.actionImage = String(object.actionImage);
                return message;
            };

            /**
             * Creates a plain object from a GroupPokeNotice message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.GroupPokeNotice
             * @static
             * @param {kritor.event.GroupPokeNotice} message GroupPokeNotice
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupPokeNotice.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                    object.operatorUid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.operatorUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.operatorUin = options.longs === String ? "0" : 0;
                    object.targetUid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.targetUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.targetUin = options.longs === String ? "0" : 0;
                    object.action = "";
                    object.suffix = "";
                    object.actionImage = "";
                }
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                if (message.operatorUid != null && message.hasOwnProperty("operatorUid"))
                    object.operatorUid = message.operatorUid;
                if (message.operatorUin != null && message.hasOwnProperty("operatorUin"))
                    if (typeof message.operatorUin === "number")
                        object.operatorUin = options.longs === String ? String(message.operatorUin) : message.operatorUin;
                    else
                        object.operatorUin = options.longs === String ? $util.Long.prototype.toString.call(message.operatorUin) : options.longs === Number ? new $util.LongBits(message.operatorUin.low >>> 0, message.operatorUin.high >>> 0).toNumber(true) : message.operatorUin;
                if (message.targetUid != null && message.hasOwnProperty("targetUid"))
                    object.targetUid = message.targetUid;
                if (message.targetUin != null && message.hasOwnProperty("targetUin"))
                    if (typeof message.targetUin === "number")
                        object.targetUin = options.longs === String ? String(message.targetUin) : message.targetUin;
                    else
                        object.targetUin = options.longs === String ? $util.Long.prototype.toString.call(message.targetUin) : options.longs === Number ? new $util.LongBits(message.targetUin.low >>> 0, message.targetUin.high >>> 0).toNumber(true) : message.targetUin;
                if (message.action != null && message.hasOwnProperty("action"))
                    object.action = message.action;
                if (message.suffix != null && message.hasOwnProperty("suffix"))
                    object.suffix = message.suffix;
                if (message.actionImage != null && message.hasOwnProperty("actionImage"))
                    object.actionImage = message.actionImage;
                return object;
            };

            /**
             * Converts this GroupPokeNotice to JSON.
             * @function toJSON
             * @memberof kritor.event.GroupPokeNotice
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupPokeNotice.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GroupPokeNotice
             * @function getTypeUrl
             * @memberof kritor.event.GroupPokeNotice
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GroupPokeNotice.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.GroupPokeNotice";
            };

            return GroupPokeNotice;
        })();

        event.GroupCardChangedNotice = (function() {

            /**
             * Properties of a GroupCardChangedNotice.
             * @memberof kritor.event
             * @interface IGroupCardChangedNotice
             * @property {number|Long|null} [groupId] GroupCardChangedNotice groupId
             * @property {string|null} [operatorUid] GroupCardChangedNotice operatorUid
             * @property {number|Long|null} [operatorUin] GroupCardChangedNotice operatorUin
             * @property {string|null} [targetUid] GroupCardChangedNotice targetUid
             * @property {number|Long|null} [targetUin] GroupCardChangedNotice targetUin
             * @property {string|null} [newCard] GroupCardChangedNotice newCard
             */

            /**
             * Constructs a new GroupCardChangedNotice.
             * @memberof kritor.event
             * @classdesc Represents a GroupCardChangedNotice.
             * @implements IGroupCardChangedNotice
             * @constructor
             * @param {kritor.event.IGroupCardChangedNotice=} [properties] Properties to set
             */
            function GroupCardChangedNotice(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupCardChangedNotice groupId.
             * @member {number|Long} groupId
             * @memberof kritor.event.GroupCardChangedNotice
             * @instance
             */
            GroupCardChangedNotice.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupCardChangedNotice operatorUid.
             * @member {string} operatorUid
             * @memberof kritor.event.GroupCardChangedNotice
             * @instance
             */
            GroupCardChangedNotice.prototype.operatorUid = "";

            /**
             * GroupCardChangedNotice operatorUin.
             * @member {number|Long} operatorUin
             * @memberof kritor.event.GroupCardChangedNotice
             * @instance
             */
            GroupCardChangedNotice.prototype.operatorUin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupCardChangedNotice targetUid.
             * @member {string} targetUid
             * @memberof kritor.event.GroupCardChangedNotice
             * @instance
             */
            GroupCardChangedNotice.prototype.targetUid = "";

            /**
             * GroupCardChangedNotice targetUin.
             * @member {number|Long} targetUin
             * @memberof kritor.event.GroupCardChangedNotice
             * @instance
             */
            GroupCardChangedNotice.prototype.targetUin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupCardChangedNotice newCard.
             * @member {string} newCard
             * @memberof kritor.event.GroupCardChangedNotice
             * @instance
             */
            GroupCardChangedNotice.prototype.newCard = "";

            /**
             * Creates a new GroupCardChangedNotice instance using the specified properties.
             * @function create
             * @memberof kritor.event.GroupCardChangedNotice
             * @static
             * @param {kritor.event.IGroupCardChangedNotice=} [properties] Properties to set
             * @returns {kritor.event.GroupCardChangedNotice} GroupCardChangedNotice instance
             */
            GroupCardChangedNotice.create = function create(properties) {
                return new GroupCardChangedNotice(properties);
            };

            /**
             * Encodes the specified GroupCardChangedNotice message. Does not implicitly {@link kritor.event.GroupCardChangedNotice.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.GroupCardChangedNotice
             * @static
             * @param {kritor.event.IGroupCardChangedNotice} message GroupCardChangedNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupCardChangedNotice.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                if (message.operatorUid != null && Object.hasOwnProperty.call(message, "operatorUid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.operatorUid);
                if (message.operatorUin != null && Object.hasOwnProperty.call(message, "operatorUin"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.operatorUin);
                if (message.targetUid != null && Object.hasOwnProperty.call(message, "targetUid"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.targetUid);
                if (message.targetUin != null && Object.hasOwnProperty.call(message, "targetUin"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.targetUin);
                if (message.newCard != null && Object.hasOwnProperty.call(message, "newCard"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.newCard);
                return writer;
            };

            /**
             * Encodes the specified GroupCardChangedNotice message, length delimited. Does not implicitly {@link kritor.event.GroupCardChangedNotice.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.GroupCardChangedNotice
             * @static
             * @param {kritor.event.IGroupCardChangedNotice} message GroupCardChangedNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupCardChangedNotice.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupCardChangedNotice message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.GroupCardChangedNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.GroupCardChangedNotice} GroupCardChangedNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupCardChangedNotice.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.GroupCardChangedNotice();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.operatorUid = reader.string();
                            break;
                        }
                    case 3: {
                            message.operatorUin = reader.uint64();
                            break;
                        }
                    case 4: {
                            message.targetUid = reader.string();
                            break;
                        }
                    case 5: {
                            message.targetUin = reader.uint64();
                            break;
                        }
                    case 6: {
                            message.newCard = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupCardChangedNotice message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.GroupCardChangedNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.GroupCardChangedNotice} GroupCardChangedNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupCardChangedNotice.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupCardChangedNotice message.
             * @function verify
             * @memberof kritor.event.GroupCardChangedNotice
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupCardChangedNotice.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                if (message.operatorUid != null && message.hasOwnProperty("operatorUid"))
                    if (!$util.isString(message.operatorUid))
                        return "operatorUid: string expected";
                if (message.operatorUin != null && message.hasOwnProperty("operatorUin"))
                    if (!$util.isInteger(message.operatorUin) && !(message.operatorUin && $util.isInteger(message.operatorUin.low) && $util.isInteger(message.operatorUin.high)))
                        return "operatorUin: integer|Long expected";
                if (message.targetUid != null && message.hasOwnProperty("targetUid"))
                    if (!$util.isString(message.targetUid))
                        return "targetUid: string expected";
                if (message.targetUin != null && message.hasOwnProperty("targetUin"))
                    if (!$util.isInteger(message.targetUin) && !(message.targetUin && $util.isInteger(message.targetUin.low) && $util.isInteger(message.targetUin.high)))
                        return "targetUin: integer|Long expected";
                if (message.newCard != null && message.hasOwnProperty("newCard"))
                    if (!$util.isString(message.newCard))
                        return "newCard: string expected";
                return null;
            };

            /**
             * Creates a GroupCardChangedNotice message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.GroupCardChangedNotice
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.GroupCardChangedNotice} GroupCardChangedNotice
             */
            GroupCardChangedNotice.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.GroupCardChangedNotice)
                    return object;
                let message = new $root.kritor.event.GroupCardChangedNotice();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                if (object.operatorUid != null)
                    message.operatorUid = String(object.operatorUid);
                if (object.operatorUin != null)
                    if ($util.Long)
                        (message.operatorUin = $util.Long.fromValue(object.operatorUin)).unsigned = true;
                    else if (typeof object.operatorUin === "string")
                        message.operatorUin = parseInt(object.operatorUin, 10);
                    else if (typeof object.operatorUin === "number")
                        message.operatorUin = object.operatorUin;
                    else if (typeof object.operatorUin === "object")
                        message.operatorUin = new $util.LongBits(object.operatorUin.low >>> 0, object.operatorUin.high >>> 0).toNumber(true);
                if (object.targetUid != null)
                    message.targetUid = String(object.targetUid);
                if (object.targetUin != null)
                    if ($util.Long)
                        (message.targetUin = $util.Long.fromValue(object.targetUin)).unsigned = true;
                    else if (typeof object.targetUin === "string")
                        message.targetUin = parseInt(object.targetUin, 10);
                    else if (typeof object.targetUin === "number")
                        message.targetUin = object.targetUin;
                    else if (typeof object.targetUin === "object")
                        message.targetUin = new $util.LongBits(object.targetUin.low >>> 0, object.targetUin.high >>> 0).toNumber(true);
                if (object.newCard != null)
                    message.newCard = String(object.newCard);
                return message;
            };

            /**
             * Creates a plain object from a GroupCardChangedNotice message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.GroupCardChangedNotice
             * @static
             * @param {kritor.event.GroupCardChangedNotice} message GroupCardChangedNotice
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupCardChangedNotice.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                    object.operatorUid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.operatorUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.operatorUin = options.longs === String ? "0" : 0;
                    object.targetUid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.targetUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.targetUin = options.longs === String ? "0" : 0;
                    object.newCard = "";
                }
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                if (message.operatorUid != null && message.hasOwnProperty("operatorUid"))
                    object.operatorUid = message.operatorUid;
                if (message.operatorUin != null && message.hasOwnProperty("operatorUin"))
                    if (typeof message.operatorUin === "number")
                        object.operatorUin = options.longs === String ? String(message.operatorUin) : message.operatorUin;
                    else
                        object.operatorUin = options.longs === String ? $util.Long.prototype.toString.call(message.operatorUin) : options.longs === Number ? new $util.LongBits(message.operatorUin.low >>> 0, message.operatorUin.high >>> 0).toNumber(true) : message.operatorUin;
                if (message.targetUid != null && message.hasOwnProperty("targetUid"))
                    object.targetUid = message.targetUid;
                if (message.targetUin != null && message.hasOwnProperty("targetUin"))
                    if (typeof message.targetUin === "number")
                        object.targetUin = options.longs === String ? String(message.targetUin) : message.targetUin;
                    else
                        object.targetUin = options.longs === String ? $util.Long.prototype.toString.call(message.targetUin) : options.longs === Number ? new $util.LongBits(message.targetUin.low >>> 0, message.targetUin.high >>> 0).toNumber(true) : message.targetUin;
                if (message.newCard != null && message.hasOwnProperty("newCard"))
                    object.newCard = message.newCard;
                return object;
            };

            /**
             * Converts this GroupCardChangedNotice to JSON.
             * @function toJSON
             * @memberof kritor.event.GroupCardChangedNotice
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupCardChangedNotice.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GroupCardChangedNotice
             * @function getTypeUrl
             * @memberof kritor.event.GroupCardChangedNotice
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GroupCardChangedNotice.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.GroupCardChangedNotice";
            };

            return GroupCardChangedNotice;
        })();

        event.GroupMemberIncreasedNotice = (function() {

            /**
             * Properties of a GroupMemberIncreasedNotice.
             * @memberof kritor.event
             * @interface IGroupMemberIncreasedNotice
             * @property {number|Long|null} [groupId] GroupMemberIncreasedNotice groupId
             * @property {string|null} [operatorUid] GroupMemberIncreasedNotice operatorUid
             * @property {number|Long|null} [operatorUin] GroupMemberIncreasedNotice operatorUin
             * @property {string|null} [targetUid] GroupMemberIncreasedNotice targetUid
             * @property {number|Long|null} [targetUin] GroupMemberIncreasedNotice targetUin
             * @property {kritor.event.GroupMemberIncreasedNotice.GroupMemberIncreasedType|null} [type] GroupMemberIncreasedNotice type
             */

            /**
             * Constructs a new GroupMemberIncreasedNotice.
             * @memberof kritor.event
             * @classdesc Represents a GroupMemberIncreasedNotice.
             * @implements IGroupMemberIncreasedNotice
             * @constructor
             * @param {kritor.event.IGroupMemberIncreasedNotice=} [properties] Properties to set
             */
            function GroupMemberIncreasedNotice(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupMemberIncreasedNotice groupId.
             * @member {number|Long} groupId
             * @memberof kritor.event.GroupMemberIncreasedNotice
             * @instance
             */
            GroupMemberIncreasedNotice.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupMemberIncreasedNotice operatorUid.
             * @member {string} operatorUid
             * @memberof kritor.event.GroupMemberIncreasedNotice
             * @instance
             */
            GroupMemberIncreasedNotice.prototype.operatorUid = "";

            /**
             * GroupMemberIncreasedNotice operatorUin.
             * @member {number|Long} operatorUin
             * @memberof kritor.event.GroupMemberIncreasedNotice
             * @instance
             */
            GroupMemberIncreasedNotice.prototype.operatorUin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupMemberIncreasedNotice targetUid.
             * @member {string} targetUid
             * @memberof kritor.event.GroupMemberIncreasedNotice
             * @instance
             */
            GroupMemberIncreasedNotice.prototype.targetUid = "";

            /**
             * GroupMemberIncreasedNotice targetUin.
             * @member {number|Long} targetUin
             * @memberof kritor.event.GroupMemberIncreasedNotice
             * @instance
             */
            GroupMemberIncreasedNotice.prototype.targetUin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupMemberIncreasedNotice type.
             * @member {kritor.event.GroupMemberIncreasedNotice.GroupMemberIncreasedType} type
             * @memberof kritor.event.GroupMemberIncreasedNotice
             * @instance
             */
            GroupMemberIncreasedNotice.prototype.type = 0;

            /**
             * Creates a new GroupMemberIncreasedNotice instance using the specified properties.
             * @function create
             * @memberof kritor.event.GroupMemberIncreasedNotice
             * @static
             * @param {kritor.event.IGroupMemberIncreasedNotice=} [properties] Properties to set
             * @returns {kritor.event.GroupMemberIncreasedNotice} GroupMemberIncreasedNotice instance
             */
            GroupMemberIncreasedNotice.create = function create(properties) {
                return new GroupMemberIncreasedNotice(properties);
            };

            /**
             * Encodes the specified GroupMemberIncreasedNotice message. Does not implicitly {@link kritor.event.GroupMemberIncreasedNotice.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.GroupMemberIncreasedNotice
             * @static
             * @param {kritor.event.IGroupMemberIncreasedNotice} message GroupMemberIncreasedNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupMemberIncreasedNotice.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                if (message.operatorUid != null && Object.hasOwnProperty.call(message, "operatorUid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.operatorUid);
                if (message.operatorUin != null && Object.hasOwnProperty.call(message, "operatorUin"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.operatorUin);
                if (message.targetUid != null && Object.hasOwnProperty.call(message, "targetUid"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.targetUid);
                if (message.targetUin != null && Object.hasOwnProperty.call(message, "targetUin"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.targetUin);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.type);
                return writer;
            };

            /**
             * Encodes the specified GroupMemberIncreasedNotice message, length delimited. Does not implicitly {@link kritor.event.GroupMemberIncreasedNotice.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.GroupMemberIncreasedNotice
             * @static
             * @param {kritor.event.IGroupMemberIncreasedNotice} message GroupMemberIncreasedNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupMemberIncreasedNotice.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupMemberIncreasedNotice message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.GroupMemberIncreasedNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.GroupMemberIncreasedNotice} GroupMemberIncreasedNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupMemberIncreasedNotice.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.GroupMemberIncreasedNotice();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.operatorUid = reader.string();
                            break;
                        }
                    case 3: {
                            message.operatorUin = reader.uint64();
                            break;
                        }
                    case 4: {
                            message.targetUid = reader.string();
                            break;
                        }
                    case 5: {
                            message.targetUin = reader.uint64();
                            break;
                        }
                    case 6: {
                            message.type = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupMemberIncreasedNotice message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.GroupMemberIncreasedNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.GroupMemberIncreasedNotice} GroupMemberIncreasedNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupMemberIncreasedNotice.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupMemberIncreasedNotice message.
             * @function verify
             * @memberof kritor.event.GroupMemberIncreasedNotice
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupMemberIncreasedNotice.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                if (message.operatorUid != null && message.hasOwnProperty("operatorUid"))
                    if (!$util.isString(message.operatorUid))
                        return "operatorUid: string expected";
                if (message.operatorUin != null && message.hasOwnProperty("operatorUin"))
                    if (!$util.isInteger(message.operatorUin) && !(message.operatorUin && $util.isInteger(message.operatorUin.low) && $util.isInteger(message.operatorUin.high)))
                        return "operatorUin: integer|Long expected";
                if (message.targetUid != null && message.hasOwnProperty("targetUid"))
                    if (!$util.isString(message.targetUid))
                        return "targetUid: string expected";
                if (message.targetUin != null && message.hasOwnProperty("targetUin"))
                    if (!$util.isInteger(message.targetUin) && !(message.targetUin && $util.isInteger(message.targetUin.low) && $util.isInteger(message.targetUin.high)))
                        return "targetUin: integer|Long expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                return null;
            };

            /**
             * Creates a GroupMemberIncreasedNotice message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.GroupMemberIncreasedNotice
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.GroupMemberIncreasedNotice} GroupMemberIncreasedNotice
             */
            GroupMemberIncreasedNotice.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.GroupMemberIncreasedNotice)
                    return object;
                let message = new $root.kritor.event.GroupMemberIncreasedNotice();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                if (object.operatorUid != null)
                    message.operatorUid = String(object.operatorUid);
                if (object.operatorUin != null)
                    if ($util.Long)
                        (message.operatorUin = $util.Long.fromValue(object.operatorUin)).unsigned = true;
                    else if (typeof object.operatorUin === "string")
                        message.operatorUin = parseInt(object.operatorUin, 10);
                    else if (typeof object.operatorUin === "number")
                        message.operatorUin = object.operatorUin;
                    else if (typeof object.operatorUin === "object")
                        message.operatorUin = new $util.LongBits(object.operatorUin.low >>> 0, object.operatorUin.high >>> 0).toNumber(true);
                if (object.targetUid != null)
                    message.targetUid = String(object.targetUid);
                if (object.targetUin != null)
                    if ($util.Long)
                        (message.targetUin = $util.Long.fromValue(object.targetUin)).unsigned = true;
                    else if (typeof object.targetUin === "string")
                        message.targetUin = parseInt(object.targetUin, 10);
                    else if (typeof object.targetUin === "number")
                        message.targetUin = object.targetUin;
                    else if (typeof object.targetUin === "object")
                        message.targetUin = new $util.LongBits(object.targetUin.low >>> 0, object.targetUin.high >>> 0).toNumber(true);
                switch (object.type) {
                default:
                    if (typeof object.type === "number") {
                        message.type = object.type;
                        break;
                    }
                    break;
                case "APPROVE":
                case 0:
                    message.type = 0;
                    break;
                case "INVITE":
                case 1:
                    message.type = 1;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a GroupMemberIncreasedNotice message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.GroupMemberIncreasedNotice
             * @static
             * @param {kritor.event.GroupMemberIncreasedNotice} message GroupMemberIncreasedNotice
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupMemberIncreasedNotice.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                    object.operatorUid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.operatorUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.operatorUin = options.longs === String ? "0" : 0;
                    object.targetUid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.targetUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.targetUin = options.longs === String ? "0" : 0;
                    object.type = options.enums === String ? "APPROVE" : 0;
                }
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                if (message.operatorUid != null && message.hasOwnProperty("operatorUid"))
                    object.operatorUid = message.operatorUid;
                if (message.operatorUin != null && message.hasOwnProperty("operatorUin"))
                    if (typeof message.operatorUin === "number")
                        object.operatorUin = options.longs === String ? String(message.operatorUin) : message.operatorUin;
                    else
                        object.operatorUin = options.longs === String ? $util.Long.prototype.toString.call(message.operatorUin) : options.longs === Number ? new $util.LongBits(message.operatorUin.low >>> 0, message.operatorUin.high >>> 0).toNumber(true) : message.operatorUin;
                if (message.targetUid != null && message.hasOwnProperty("targetUid"))
                    object.targetUid = message.targetUid;
                if (message.targetUin != null && message.hasOwnProperty("targetUin"))
                    if (typeof message.targetUin === "number")
                        object.targetUin = options.longs === String ? String(message.targetUin) : message.targetUin;
                    else
                        object.targetUin = options.longs === String ? $util.Long.prototype.toString.call(message.targetUin) : options.longs === Number ? new $util.LongBits(message.targetUin.low >>> 0, message.targetUin.high >>> 0).toNumber(true) : message.targetUin;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.kritor.event.GroupMemberIncreasedNotice.GroupMemberIncreasedType[message.type] === undefined ? message.type : $root.kritor.event.GroupMemberIncreasedNotice.GroupMemberIncreasedType[message.type] : message.type;
                return object;
            };

            /**
             * Converts this GroupMemberIncreasedNotice to JSON.
             * @function toJSON
             * @memberof kritor.event.GroupMemberIncreasedNotice
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupMemberIncreasedNotice.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GroupMemberIncreasedNotice
             * @function getTypeUrl
             * @memberof kritor.event.GroupMemberIncreasedNotice
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GroupMemberIncreasedNotice.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.GroupMemberIncreasedNotice";
            };

            /**
             * GroupMemberIncreasedType enum.
             * @name kritor.event.GroupMemberIncreasedNotice.GroupMemberIncreasedType
             * @enum {number}
             * @property {number} APPROVE=0 APPROVE value
             * @property {number} INVITE=1 INVITE value
             */
            GroupMemberIncreasedNotice.GroupMemberIncreasedType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "APPROVE"] = 0;
                values[valuesById[1] = "INVITE"] = 1;
                return values;
            })();

            return GroupMemberIncreasedNotice;
        })();

        event.GroupMemberDecreasedNotice = (function() {

            /**
             * Properties of a GroupMemberDecreasedNotice.
             * @memberof kritor.event
             * @interface IGroupMemberDecreasedNotice
             * @property {number|Long|null} [groupId] GroupMemberDecreasedNotice groupId
             * @property {string|null} [operatorUid] GroupMemberDecreasedNotice operatorUid
             * @property {number|Long|null} [operatorUin] GroupMemberDecreasedNotice operatorUin
             * @property {string|null} [targetUid] GroupMemberDecreasedNotice targetUid
             * @property {number|Long|null} [targetUin] GroupMemberDecreasedNotice targetUin
             * @property {kritor.event.GroupMemberDecreasedNotice.GroupMemberDecreasedType|null} [type] GroupMemberDecreasedNotice type
             */

            /**
             * Constructs a new GroupMemberDecreasedNotice.
             * @memberof kritor.event
             * @classdesc Represents a GroupMemberDecreasedNotice.
             * @implements IGroupMemberDecreasedNotice
             * @constructor
             * @param {kritor.event.IGroupMemberDecreasedNotice=} [properties] Properties to set
             */
            function GroupMemberDecreasedNotice(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupMemberDecreasedNotice groupId.
             * @member {number|Long} groupId
             * @memberof kritor.event.GroupMemberDecreasedNotice
             * @instance
             */
            GroupMemberDecreasedNotice.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupMemberDecreasedNotice operatorUid.
             * @member {string|null|undefined} operatorUid
             * @memberof kritor.event.GroupMemberDecreasedNotice
             * @instance
             */
            GroupMemberDecreasedNotice.prototype.operatorUid = null;

            /**
             * GroupMemberDecreasedNotice operatorUin.
             * @member {number|Long|null|undefined} operatorUin
             * @memberof kritor.event.GroupMemberDecreasedNotice
             * @instance
             */
            GroupMemberDecreasedNotice.prototype.operatorUin = null;

            /**
             * GroupMemberDecreasedNotice targetUid.
             * @member {string|null|undefined} targetUid
             * @memberof kritor.event.GroupMemberDecreasedNotice
             * @instance
             */
            GroupMemberDecreasedNotice.prototype.targetUid = null;

            /**
             * GroupMemberDecreasedNotice targetUin.
             * @member {number|Long|null|undefined} targetUin
             * @memberof kritor.event.GroupMemberDecreasedNotice
             * @instance
             */
            GroupMemberDecreasedNotice.prototype.targetUin = null;

            /**
             * GroupMemberDecreasedNotice type.
             * @member {kritor.event.GroupMemberDecreasedNotice.GroupMemberDecreasedType} type
             * @memberof kritor.event.GroupMemberDecreasedNotice
             * @instance
             */
            GroupMemberDecreasedNotice.prototype.type = 0;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * GroupMemberDecreasedNotice _operatorUid.
             * @member {"operatorUid"|undefined} _operatorUid
             * @memberof kritor.event.GroupMemberDecreasedNotice
             * @instance
             */
            Object.defineProperty(GroupMemberDecreasedNotice.prototype, "_operatorUid", {
                get: $util.oneOfGetter($oneOfFields = ["operatorUid"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * GroupMemberDecreasedNotice _operatorUin.
             * @member {"operatorUin"|undefined} _operatorUin
             * @memberof kritor.event.GroupMemberDecreasedNotice
             * @instance
             */
            Object.defineProperty(GroupMemberDecreasedNotice.prototype, "_operatorUin", {
                get: $util.oneOfGetter($oneOfFields = ["operatorUin"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * GroupMemberDecreasedNotice _targetUid.
             * @member {"targetUid"|undefined} _targetUid
             * @memberof kritor.event.GroupMemberDecreasedNotice
             * @instance
             */
            Object.defineProperty(GroupMemberDecreasedNotice.prototype, "_targetUid", {
                get: $util.oneOfGetter($oneOfFields = ["targetUid"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * GroupMemberDecreasedNotice _targetUin.
             * @member {"targetUin"|undefined} _targetUin
             * @memberof kritor.event.GroupMemberDecreasedNotice
             * @instance
             */
            Object.defineProperty(GroupMemberDecreasedNotice.prototype, "_targetUin", {
                get: $util.oneOfGetter($oneOfFields = ["targetUin"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new GroupMemberDecreasedNotice instance using the specified properties.
             * @function create
             * @memberof kritor.event.GroupMemberDecreasedNotice
             * @static
             * @param {kritor.event.IGroupMemberDecreasedNotice=} [properties] Properties to set
             * @returns {kritor.event.GroupMemberDecreasedNotice} GroupMemberDecreasedNotice instance
             */
            GroupMemberDecreasedNotice.create = function create(properties) {
                return new GroupMemberDecreasedNotice(properties);
            };

            /**
             * Encodes the specified GroupMemberDecreasedNotice message. Does not implicitly {@link kritor.event.GroupMemberDecreasedNotice.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.GroupMemberDecreasedNotice
             * @static
             * @param {kritor.event.IGroupMemberDecreasedNotice} message GroupMemberDecreasedNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupMemberDecreasedNotice.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                if (message.operatorUid != null && Object.hasOwnProperty.call(message, "operatorUid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.operatorUid);
                if (message.operatorUin != null && Object.hasOwnProperty.call(message, "operatorUin"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.operatorUin);
                if (message.targetUid != null && Object.hasOwnProperty.call(message, "targetUid"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.targetUid);
                if (message.targetUin != null && Object.hasOwnProperty.call(message, "targetUin"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.targetUin);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.type);
                return writer;
            };

            /**
             * Encodes the specified GroupMemberDecreasedNotice message, length delimited. Does not implicitly {@link kritor.event.GroupMemberDecreasedNotice.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.GroupMemberDecreasedNotice
             * @static
             * @param {kritor.event.IGroupMemberDecreasedNotice} message GroupMemberDecreasedNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupMemberDecreasedNotice.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupMemberDecreasedNotice message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.GroupMemberDecreasedNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.GroupMemberDecreasedNotice} GroupMemberDecreasedNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupMemberDecreasedNotice.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.GroupMemberDecreasedNotice();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.operatorUid = reader.string();
                            break;
                        }
                    case 3: {
                            message.operatorUin = reader.uint64();
                            break;
                        }
                    case 4: {
                            message.targetUid = reader.string();
                            break;
                        }
                    case 5: {
                            message.targetUin = reader.uint64();
                            break;
                        }
                    case 6: {
                            message.type = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupMemberDecreasedNotice message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.GroupMemberDecreasedNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.GroupMemberDecreasedNotice} GroupMemberDecreasedNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupMemberDecreasedNotice.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupMemberDecreasedNotice message.
             * @function verify
             * @memberof kritor.event.GroupMemberDecreasedNotice
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupMemberDecreasedNotice.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                if (message.operatorUid != null && message.hasOwnProperty("operatorUid")) {
                    properties._operatorUid = 1;
                    if (!$util.isString(message.operatorUid))
                        return "operatorUid: string expected";
                }
                if (message.operatorUin != null && message.hasOwnProperty("operatorUin")) {
                    properties._operatorUin = 1;
                    if (!$util.isInteger(message.operatorUin) && !(message.operatorUin && $util.isInteger(message.operatorUin.low) && $util.isInteger(message.operatorUin.high)))
                        return "operatorUin: integer|Long expected";
                }
                if (message.targetUid != null && message.hasOwnProperty("targetUid")) {
                    properties._targetUid = 1;
                    if (!$util.isString(message.targetUid))
                        return "targetUid: string expected";
                }
                if (message.targetUin != null && message.hasOwnProperty("targetUin")) {
                    properties._targetUin = 1;
                    if (!$util.isInteger(message.targetUin) && !(message.targetUin && $util.isInteger(message.targetUin.low) && $util.isInteger(message.targetUin.high)))
                        return "targetUin: integer|Long expected";
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                return null;
            };

            /**
             * Creates a GroupMemberDecreasedNotice message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.GroupMemberDecreasedNotice
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.GroupMemberDecreasedNotice} GroupMemberDecreasedNotice
             */
            GroupMemberDecreasedNotice.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.GroupMemberDecreasedNotice)
                    return object;
                let message = new $root.kritor.event.GroupMemberDecreasedNotice();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                if (object.operatorUid != null)
                    message.operatorUid = String(object.operatorUid);
                if (object.operatorUin != null)
                    if ($util.Long)
                        (message.operatorUin = $util.Long.fromValue(object.operatorUin)).unsigned = true;
                    else if (typeof object.operatorUin === "string")
                        message.operatorUin = parseInt(object.operatorUin, 10);
                    else if (typeof object.operatorUin === "number")
                        message.operatorUin = object.operatorUin;
                    else if (typeof object.operatorUin === "object")
                        message.operatorUin = new $util.LongBits(object.operatorUin.low >>> 0, object.operatorUin.high >>> 0).toNumber(true);
                if (object.targetUid != null)
                    message.targetUid = String(object.targetUid);
                if (object.targetUin != null)
                    if ($util.Long)
                        (message.targetUin = $util.Long.fromValue(object.targetUin)).unsigned = true;
                    else if (typeof object.targetUin === "string")
                        message.targetUin = parseInt(object.targetUin, 10);
                    else if (typeof object.targetUin === "number")
                        message.targetUin = object.targetUin;
                    else if (typeof object.targetUin === "object")
                        message.targetUin = new $util.LongBits(object.targetUin.low >>> 0, object.targetUin.high >>> 0).toNumber(true);
                switch (object.type) {
                default:
                    if (typeof object.type === "number") {
                        message.type = object.type;
                        break;
                    }
                    break;
                case "LEAVE":
                case 0:
                    message.type = 0;
                    break;
                case "KICK":
                case 1:
                    message.type = 1;
                    break;
                case "KICK_ME":
                case 2:
                    message.type = 2;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a GroupMemberDecreasedNotice message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.GroupMemberDecreasedNotice
             * @static
             * @param {kritor.event.GroupMemberDecreasedNotice} message GroupMemberDecreasedNotice
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupMemberDecreasedNotice.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                    object.type = options.enums === String ? "LEAVE" : 0;
                }
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                if (message.operatorUid != null && message.hasOwnProperty("operatorUid")) {
                    object.operatorUid = message.operatorUid;
                    if (options.oneofs)
                        object._operatorUid = "operatorUid";
                }
                if (message.operatorUin != null && message.hasOwnProperty("operatorUin")) {
                    if (typeof message.operatorUin === "number")
                        object.operatorUin = options.longs === String ? String(message.operatorUin) : message.operatorUin;
                    else
                        object.operatorUin = options.longs === String ? $util.Long.prototype.toString.call(message.operatorUin) : options.longs === Number ? new $util.LongBits(message.operatorUin.low >>> 0, message.operatorUin.high >>> 0).toNumber(true) : message.operatorUin;
                    if (options.oneofs)
                        object._operatorUin = "operatorUin";
                }
                if (message.targetUid != null && message.hasOwnProperty("targetUid")) {
                    object.targetUid = message.targetUid;
                    if (options.oneofs)
                        object._targetUid = "targetUid";
                }
                if (message.targetUin != null && message.hasOwnProperty("targetUin")) {
                    if (typeof message.targetUin === "number")
                        object.targetUin = options.longs === String ? String(message.targetUin) : message.targetUin;
                    else
                        object.targetUin = options.longs === String ? $util.Long.prototype.toString.call(message.targetUin) : options.longs === Number ? new $util.LongBits(message.targetUin.low >>> 0, message.targetUin.high >>> 0).toNumber(true) : message.targetUin;
                    if (options.oneofs)
                        object._targetUin = "targetUin";
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.kritor.event.GroupMemberDecreasedNotice.GroupMemberDecreasedType[message.type] === undefined ? message.type : $root.kritor.event.GroupMemberDecreasedNotice.GroupMemberDecreasedType[message.type] : message.type;
                return object;
            };

            /**
             * Converts this GroupMemberDecreasedNotice to JSON.
             * @function toJSON
             * @memberof kritor.event.GroupMemberDecreasedNotice
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupMemberDecreasedNotice.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GroupMemberDecreasedNotice
             * @function getTypeUrl
             * @memberof kritor.event.GroupMemberDecreasedNotice
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GroupMemberDecreasedNotice.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.GroupMemberDecreasedNotice";
            };

            /**
             * GroupMemberDecreasedType enum.
             * @name kritor.event.GroupMemberDecreasedNotice.GroupMemberDecreasedType
             * @enum {number}
             * @property {number} LEAVE=0 LEAVE value
             * @property {number} KICK=1 KICK value
             * @property {number} KICK_ME=2 KICK_ME value
             */
            GroupMemberDecreasedNotice.GroupMemberDecreasedType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "LEAVE"] = 0;
                values[valuesById[1] = "KICK"] = 1;
                values[valuesById[2] = "KICK_ME"] = 2;
                return values;
            })();

            return GroupMemberDecreasedNotice;
        })();

        event.GroupAdminChangedNotice = (function() {

            /**
             * Properties of a GroupAdminChangedNotice.
             * @memberof kritor.event
             * @interface IGroupAdminChangedNotice
             * @property {number|Long|null} [groupId] GroupAdminChangedNotice groupId
             * @property {string|null} [targetUid] GroupAdminChangedNotice targetUid
             * @property {number|Long|null} [targetUin] GroupAdminChangedNotice targetUin
             * @property {boolean|null} [isAdmin] GroupAdminChangedNotice isAdmin
             */

            /**
             * Constructs a new GroupAdminChangedNotice.
             * @memberof kritor.event
             * @classdesc Represents a GroupAdminChangedNotice.
             * @implements IGroupAdminChangedNotice
             * @constructor
             * @param {kritor.event.IGroupAdminChangedNotice=} [properties] Properties to set
             */
            function GroupAdminChangedNotice(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupAdminChangedNotice groupId.
             * @member {number|Long} groupId
             * @memberof kritor.event.GroupAdminChangedNotice
             * @instance
             */
            GroupAdminChangedNotice.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupAdminChangedNotice targetUid.
             * @member {string} targetUid
             * @memberof kritor.event.GroupAdminChangedNotice
             * @instance
             */
            GroupAdminChangedNotice.prototype.targetUid = "";

            /**
             * GroupAdminChangedNotice targetUin.
             * @member {number|Long} targetUin
             * @memberof kritor.event.GroupAdminChangedNotice
             * @instance
             */
            GroupAdminChangedNotice.prototype.targetUin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupAdminChangedNotice isAdmin.
             * @member {boolean} isAdmin
             * @memberof kritor.event.GroupAdminChangedNotice
             * @instance
             */
            GroupAdminChangedNotice.prototype.isAdmin = false;

            /**
             * Creates a new GroupAdminChangedNotice instance using the specified properties.
             * @function create
             * @memberof kritor.event.GroupAdminChangedNotice
             * @static
             * @param {kritor.event.IGroupAdminChangedNotice=} [properties] Properties to set
             * @returns {kritor.event.GroupAdminChangedNotice} GroupAdminChangedNotice instance
             */
            GroupAdminChangedNotice.create = function create(properties) {
                return new GroupAdminChangedNotice(properties);
            };

            /**
             * Encodes the specified GroupAdminChangedNotice message. Does not implicitly {@link kritor.event.GroupAdminChangedNotice.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.GroupAdminChangedNotice
             * @static
             * @param {kritor.event.IGroupAdminChangedNotice} message GroupAdminChangedNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupAdminChangedNotice.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                if (message.targetUid != null && Object.hasOwnProperty.call(message, "targetUid"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.targetUid);
                if (message.targetUin != null && Object.hasOwnProperty.call(message, "targetUin"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.targetUin);
                if (message.isAdmin != null && Object.hasOwnProperty.call(message, "isAdmin"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.isAdmin);
                return writer;
            };

            /**
             * Encodes the specified GroupAdminChangedNotice message, length delimited. Does not implicitly {@link kritor.event.GroupAdminChangedNotice.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.GroupAdminChangedNotice
             * @static
             * @param {kritor.event.IGroupAdminChangedNotice} message GroupAdminChangedNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupAdminChangedNotice.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupAdminChangedNotice message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.GroupAdminChangedNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.GroupAdminChangedNotice} GroupAdminChangedNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupAdminChangedNotice.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.GroupAdminChangedNotice();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    case 4: {
                            message.targetUid = reader.string();
                            break;
                        }
                    case 5: {
                            message.targetUin = reader.uint64();
                            break;
                        }
                    case 6: {
                            message.isAdmin = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupAdminChangedNotice message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.GroupAdminChangedNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.GroupAdminChangedNotice} GroupAdminChangedNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupAdminChangedNotice.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupAdminChangedNotice message.
             * @function verify
             * @memberof kritor.event.GroupAdminChangedNotice
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupAdminChangedNotice.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                if (message.targetUid != null && message.hasOwnProperty("targetUid"))
                    if (!$util.isString(message.targetUid))
                        return "targetUid: string expected";
                if (message.targetUin != null && message.hasOwnProperty("targetUin"))
                    if (!$util.isInteger(message.targetUin) && !(message.targetUin && $util.isInteger(message.targetUin.low) && $util.isInteger(message.targetUin.high)))
                        return "targetUin: integer|Long expected";
                if (message.isAdmin != null && message.hasOwnProperty("isAdmin"))
                    if (typeof message.isAdmin !== "boolean")
                        return "isAdmin: boolean expected";
                return null;
            };

            /**
             * Creates a GroupAdminChangedNotice message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.GroupAdminChangedNotice
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.GroupAdminChangedNotice} GroupAdminChangedNotice
             */
            GroupAdminChangedNotice.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.GroupAdminChangedNotice)
                    return object;
                let message = new $root.kritor.event.GroupAdminChangedNotice();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                if (object.targetUid != null)
                    message.targetUid = String(object.targetUid);
                if (object.targetUin != null)
                    if ($util.Long)
                        (message.targetUin = $util.Long.fromValue(object.targetUin)).unsigned = true;
                    else if (typeof object.targetUin === "string")
                        message.targetUin = parseInt(object.targetUin, 10);
                    else if (typeof object.targetUin === "number")
                        message.targetUin = object.targetUin;
                    else if (typeof object.targetUin === "object")
                        message.targetUin = new $util.LongBits(object.targetUin.low >>> 0, object.targetUin.high >>> 0).toNumber(true);
                if (object.isAdmin != null)
                    message.isAdmin = Boolean(object.isAdmin);
                return message;
            };

            /**
             * Creates a plain object from a GroupAdminChangedNotice message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.GroupAdminChangedNotice
             * @static
             * @param {kritor.event.GroupAdminChangedNotice} message GroupAdminChangedNotice
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupAdminChangedNotice.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                    object.targetUid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.targetUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.targetUin = options.longs === String ? "0" : 0;
                    object.isAdmin = false;
                }
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                if (message.targetUid != null && message.hasOwnProperty("targetUid"))
                    object.targetUid = message.targetUid;
                if (message.targetUin != null && message.hasOwnProperty("targetUin"))
                    if (typeof message.targetUin === "number")
                        object.targetUin = options.longs === String ? String(message.targetUin) : message.targetUin;
                    else
                        object.targetUin = options.longs === String ? $util.Long.prototype.toString.call(message.targetUin) : options.longs === Number ? new $util.LongBits(message.targetUin.low >>> 0, message.targetUin.high >>> 0).toNumber(true) : message.targetUin;
                if (message.isAdmin != null && message.hasOwnProperty("isAdmin"))
                    object.isAdmin = message.isAdmin;
                return object;
            };

            /**
             * Converts this GroupAdminChangedNotice to JSON.
             * @function toJSON
             * @memberof kritor.event.GroupAdminChangedNotice
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupAdminChangedNotice.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GroupAdminChangedNotice
             * @function getTypeUrl
             * @memberof kritor.event.GroupAdminChangedNotice
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GroupAdminChangedNotice.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.GroupAdminChangedNotice";
            };

            return GroupAdminChangedNotice;
        })();

        event.GroupMemberBanNotice = (function() {

            /**
             * Properties of a GroupMemberBanNotice.
             * @memberof kritor.event
             * @interface IGroupMemberBanNotice
             * @property {number|Long|null} [groupId] GroupMemberBanNotice groupId
             * @property {string|null} [operatorUid] GroupMemberBanNotice operatorUid
             * @property {number|Long|null} [operatorUin] GroupMemberBanNotice operatorUin
             * @property {string|null} [targetUid] GroupMemberBanNotice targetUid
             * @property {number|Long|null} [targetUin] GroupMemberBanNotice targetUin
             * @property {number|null} [duration] GroupMemberBanNotice duration
             * @property {kritor.event.GroupMemberBanNotice.GroupMemberBanType|null} [type] GroupMemberBanNotice type
             */

            /**
             * Constructs a new GroupMemberBanNotice.
             * @memberof kritor.event
             * @classdesc Represents a GroupMemberBanNotice.
             * @implements IGroupMemberBanNotice
             * @constructor
             * @param {kritor.event.IGroupMemberBanNotice=} [properties] Properties to set
             */
            function GroupMemberBanNotice(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupMemberBanNotice groupId.
             * @member {number|Long} groupId
             * @memberof kritor.event.GroupMemberBanNotice
             * @instance
             */
            GroupMemberBanNotice.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupMemberBanNotice operatorUid.
             * @member {string} operatorUid
             * @memberof kritor.event.GroupMemberBanNotice
             * @instance
             */
            GroupMemberBanNotice.prototype.operatorUid = "";

            /**
             * GroupMemberBanNotice operatorUin.
             * @member {number|Long} operatorUin
             * @memberof kritor.event.GroupMemberBanNotice
             * @instance
             */
            GroupMemberBanNotice.prototype.operatorUin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupMemberBanNotice targetUid.
             * @member {string} targetUid
             * @memberof kritor.event.GroupMemberBanNotice
             * @instance
             */
            GroupMemberBanNotice.prototype.targetUid = "";

            /**
             * GroupMemberBanNotice targetUin.
             * @member {number|Long} targetUin
             * @memberof kritor.event.GroupMemberBanNotice
             * @instance
             */
            GroupMemberBanNotice.prototype.targetUin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupMemberBanNotice duration.
             * @member {number} duration
             * @memberof kritor.event.GroupMemberBanNotice
             * @instance
             */
            GroupMemberBanNotice.prototype.duration = 0;

            /**
             * GroupMemberBanNotice type.
             * @member {kritor.event.GroupMemberBanNotice.GroupMemberBanType} type
             * @memberof kritor.event.GroupMemberBanNotice
             * @instance
             */
            GroupMemberBanNotice.prototype.type = 0;

            /**
             * Creates a new GroupMemberBanNotice instance using the specified properties.
             * @function create
             * @memberof kritor.event.GroupMemberBanNotice
             * @static
             * @param {kritor.event.IGroupMemberBanNotice=} [properties] Properties to set
             * @returns {kritor.event.GroupMemberBanNotice} GroupMemberBanNotice instance
             */
            GroupMemberBanNotice.create = function create(properties) {
                return new GroupMemberBanNotice(properties);
            };

            /**
             * Encodes the specified GroupMemberBanNotice message. Does not implicitly {@link kritor.event.GroupMemberBanNotice.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.GroupMemberBanNotice
             * @static
             * @param {kritor.event.IGroupMemberBanNotice} message GroupMemberBanNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupMemberBanNotice.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                if (message.operatorUid != null && Object.hasOwnProperty.call(message, "operatorUid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.operatorUid);
                if (message.operatorUin != null && Object.hasOwnProperty.call(message, "operatorUin"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.operatorUin);
                if (message.targetUid != null && Object.hasOwnProperty.call(message, "targetUid"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.targetUid);
                if (message.targetUin != null && Object.hasOwnProperty.call(message, "targetUin"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.targetUin);
                if (message.duration != null && Object.hasOwnProperty.call(message, "duration"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.duration);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 7, wireType 0 =*/56).int32(message.type);
                return writer;
            };

            /**
             * Encodes the specified GroupMemberBanNotice message, length delimited. Does not implicitly {@link kritor.event.GroupMemberBanNotice.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.GroupMemberBanNotice
             * @static
             * @param {kritor.event.IGroupMemberBanNotice} message GroupMemberBanNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupMemberBanNotice.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupMemberBanNotice message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.GroupMemberBanNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.GroupMemberBanNotice} GroupMemberBanNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupMemberBanNotice.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.GroupMemberBanNotice();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.operatorUid = reader.string();
                            break;
                        }
                    case 3: {
                            message.operatorUin = reader.uint64();
                            break;
                        }
                    case 4: {
                            message.targetUid = reader.string();
                            break;
                        }
                    case 5: {
                            message.targetUin = reader.uint64();
                            break;
                        }
                    case 6: {
                            message.duration = reader.int32();
                            break;
                        }
                    case 7: {
                            message.type = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupMemberBanNotice message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.GroupMemberBanNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.GroupMemberBanNotice} GroupMemberBanNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupMemberBanNotice.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupMemberBanNotice message.
             * @function verify
             * @memberof kritor.event.GroupMemberBanNotice
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupMemberBanNotice.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                if (message.operatorUid != null && message.hasOwnProperty("operatorUid"))
                    if (!$util.isString(message.operatorUid))
                        return "operatorUid: string expected";
                if (message.operatorUin != null && message.hasOwnProperty("operatorUin"))
                    if (!$util.isInteger(message.operatorUin) && !(message.operatorUin && $util.isInteger(message.operatorUin.low) && $util.isInteger(message.operatorUin.high)))
                        return "operatorUin: integer|Long expected";
                if (message.targetUid != null && message.hasOwnProperty("targetUid"))
                    if (!$util.isString(message.targetUid))
                        return "targetUid: string expected";
                if (message.targetUin != null && message.hasOwnProperty("targetUin"))
                    if (!$util.isInteger(message.targetUin) && !(message.targetUin && $util.isInteger(message.targetUin.low) && $util.isInteger(message.targetUin.high)))
                        return "targetUin: integer|Long expected";
                if (message.duration != null && message.hasOwnProperty("duration"))
                    if (!$util.isInteger(message.duration))
                        return "duration: integer expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                return null;
            };

            /**
             * Creates a GroupMemberBanNotice message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.GroupMemberBanNotice
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.GroupMemberBanNotice} GroupMemberBanNotice
             */
            GroupMemberBanNotice.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.GroupMemberBanNotice)
                    return object;
                let message = new $root.kritor.event.GroupMemberBanNotice();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                if (object.operatorUid != null)
                    message.operatorUid = String(object.operatorUid);
                if (object.operatorUin != null)
                    if ($util.Long)
                        (message.operatorUin = $util.Long.fromValue(object.operatorUin)).unsigned = true;
                    else if (typeof object.operatorUin === "string")
                        message.operatorUin = parseInt(object.operatorUin, 10);
                    else if (typeof object.operatorUin === "number")
                        message.operatorUin = object.operatorUin;
                    else if (typeof object.operatorUin === "object")
                        message.operatorUin = new $util.LongBits(object.operatorUin.low >>> 0, object.operatorUin.high >>> 0).toNumber(true);
                if (object.targetUid != null)
                    message.targetUid = String(object.targetUid);
                if (object.targetUin != null)
                    if ($util.Long)
                        (message.targetUin = $util.Long.fromValue(object.targetUin)).unsigned = true;
                    else if (typeof object.targetUin === "string")
                        message.targetUin = parseInt(object.targetUin, 10);
                    else if (typeof object.targetUin === "number")
                        message.targetUin = object.targetUin;
                    else if (typeof object.targetUin === "object")
                        message.targetUin = new $util.LongBits(object.targetUin.low >>> 0, object.targetUin.high >>> 0).toNumber(true);
                if (object.duration != null)
                    message.duration = object.duration | 0;
                switch (object.type) {
                default:
                    if (typeof object.type === "number") {
                        message.type = object.type;
                        break;
                    }
                    break;
                case "LIFT_BAN":
                case 0:
                    message.type = 0;
                    break;
                case "BAN":
                case 1:
                    message.type = 1;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a GroupMemberBanNotice message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.GroupMemberBanNotice
             * @static
             * @param {kritor.event.GroupMemberBanNotice} message GroupMemberBanNotice
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupMemberBanNotice.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                    object.operatorUid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.operatorUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.operatorUin = options.longs === String ? "0" : 0;
                    object.targetUid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.targetUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.targetUin = options.longs === String ? "0" : 0;
                    object.duration = 0;
                    object.type = options.enums === String ? "LIFT_BAN" : 0;
                }
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                if (message.operatorUid != null && message.hasOwnProperty("operatorUid"))
                    object.operatorUid = message.operatorUid;
                if (message.operatorUin != null && message.hasOwnProperty("operatorUin"))
                    if (typeof message.operatorUin === "number")
                        object.operatorUin = options.longs === String ? String(message.operatorUin) : message.operatorUin;
                    else
                        object.operatorUin = options.longs === String ? $util.Long.prototype.toString.call(message.operatorUin) : options.longs === Number ? new $util.LongBits(message.operatorUin.low >>> 0, message.operatorUin.high >>> 0).toNumber(true) : message.operatorUin;
                if (message.targetUid != null && message.hasOwnProperty("targetUid"))
                    object.targetUid = message.targetUid;
                if (message.targetUin != null && message.hasOwnProperty("targetUin"))
                    if (typeof message.targetUin === "number")
                        object.targetUin = options.longs === String ? String(message.targetUin) : message.targetUin;
                    else
                        object.targetUin = options.longs === String ? $util.Long.prototype.toString.call(message.targetUin) : options.longs === Number ? new $util.LongBits(message.targetUin.low >>> 0, message.targetUin.high >>> 0).toNumber(true) : message.targetUin;
                if (message.duration != null && message.hasOwnProperty("duration"))
                    object.duration = message.duration;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.kritor.event.GroupMemberBanNotice.GroupMemberBanType[message.type] === undefined ? message.type : $root.kritor.event.GroupMemberBanNotice.GroupMemberBanType[message.type] : message.type;
                return object;
            };

            /**
             * Converts this GroupMemberBanNotice to JSON.
             * @function toJSON
             * @memberof kritor.event.GroupMemberBanNotice
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupMemberBanNotice.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GroupMemberBanNotice
             * @function getTypeUrl
             * @memberof kritor.event.GroupMemberBanNotice
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GroupMemberBanNotice.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.GroupMemberBanNotice";
            };

            /**
             * GroupMemberBanType enum.
             * @name kritor.event.GroupMemberBanNotice.GroupMemberBanType
             * @enum {number}
             * @property {number} LIFT_BAN=0 LIFT_BAN value
             * @property {number} BAN=1 BAN value
             */
            GroupMemberBanNotice.GroupMemberBanType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "LIFT_BAN"] = 0;
                values[valuesById[1] = "BAN"] = 1;
                return values;
            })();

            return GroupMemberBanNotice;
        })();

        event.GroupRecallNotice = (function() {

            /**
             * Properties of a GroupRecallNotice.
             * @memberof kritor.event
             * @interface IGroupRecallNotice
             * @property {number|Long|null} [groupId] GroupRecallNotice groupId
             * @property {string|null} [messageId] GroupRecallNotice messageId
             * @property {string|null} [tipText] GroupRecallNotice tipText
             * @property {string|null} [operatorUid] GroupRecallNotice operatorUid
             * @property {number|Long|null} [operatorUin] GroupRecallNotice operatorUin
             * @property {string|null} [targetUid] GroupRecallNotice targetUid
             * @property {number|Long|null} [targetUin] GroupRecallNotice targetUin
             * @property {number|Long|null} [messageSeq] GroupRecallNotice messageSeq
             */

            /**
             * Constructs a new GroupRecallNotice.
             * @memberof kritor.event
             * @classdesc Represents a GroupRecallNotice.
             * @implements IGroupRecallNotice
             * @constructor
             * @param {kritor.event.IGroupRecallNotice=} [properties] Properties to set
             */
            function GroupRecallNotice(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupRecallNotice groupId.
             * @member {number|Long} groupId
             * @memberof kritor.event.GroupRecallNotice
             * @instance
             */
            GroupRecallNotice.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupRecallNotice messageId.
             * @member {string} messageId
             * @memberof kritor.event.GroupRecallNotice
             * @instance
             */
            GroupRecallNotice.prototype.messageId = "";

            /**
             * GroupRecallNotice tipText.
             * @member {string} tipText
             * @memberof kritor.event.GroupRecallNotice
             * @instance
             */
            GroupRecallNotice.prototype.tipText = "";

            /**
             * GroupRecallNotice operatorUid.
             * @member {string} operatorUid
             * @memberof kritor.event.GroupRecallNotice
             * @instance
             */
            GroupRecallNotice.prototype.operatorUid = "";

            /**
             * GroupRecallNotice operatorUin.
             * @member {number|Long} operatorUin
             * @memberof kritor.event.GroupRecallNotice
             * @instance
             */
            GroupRecallNotice.prototype.operatorUin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupRecallNotice targetUid.
             * @member {string} targetUid
             * @memberof kritor.event.GroupRecallNotice
             * @instance
             */
            GroupRecallNotice.prototype.targetUid = "";

            /**
             * GroupRecallNotice targetUin.
             * @member {number|Long} targetUin
             * @memberof kritor.event.GroupRecallNotice
             * @instance
             */
            GroupRecallNotice.prototype.targetUin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupRecallNotice messageSeq.
             * @member {number|Long} messageSeq
             * @memberof kritor.event.GroupRecallNotice
             * @instance
             */
            GroupRecallNotice.prototype.messageSeq = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new GroupRecallNotice instance using the specified properties.
             * @function create
             * @memberof kritor.event.GroupRecallNotice
             * @static
             * @param {kritor.event.IGroupRecallNotice=} [properties] Properties to set
             * @returns {kritor.event.GroupRecallNotice} GroupRecallNotice instance
             */
            GroupRecallNotice.create = function create(properties) {
                return new GroupRecallNotice(properties);
            };

            /**
             * Encodes the specified GroupRecallNotice message. Does not implicitly {@link kritor.event.GroupRecallNotice.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.GroupRecallNotice
             * @static
             * @param {kritor.event.IGroupRecallNotice} message GroupRecallNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupRecallNotice.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                if (message.messageId != null && Object.hasOwnProperty.call(message, "messageId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.messageId);
                if (message.tipText != null && Object.hasOwnProperty.call(message, "tipText"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.tipText);
                if (message.operatorUid != null && Object.hasOwnProperty.call(message, "operatorUid"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.operatorUid);
                if (message.operatorUin != null && Object.hasOwnProperty.call(message, "operatorUin"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.operatorUin);
                if (message.targetUid != null && Object.hasOwnProperty.call(message, "targetUid"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.targetUid);
                if (message.targetUin != null && Object.hasOwnProperty.call(message, "targetUin"))
                    writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.targetUin);
                if (message.messageSeq != null && Object.hasOwnProperty.call(message, "messageSeq"))
                    writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.messageSeq);
                return writer;
            };

            /**
             * Encodes the specified GroupRecallNotice message, length delimited. Does not implicitly {@link kritor.event.GroupRecallNotice.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.GroupRecallNotice
             * @static
             * @param {kritor.event.IGroupRecallNotice} message GroupRecallNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupRecallNotice.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupRecallNotice message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.GroupRecallNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.GroupRecallNotice} GroupRecallNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupRecallNotice.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.GroupRecallNotice();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.messageId = reader.string();
                            break;
                        }
                    case 3: {
                            message.tipText = reader.string();
                            break;
                        }
                    case 4: {
                            message.operatorUid = reader.string();
                            break;
                        }
                    case 5: {
                            message.operatorUin = reader.uint64();
                            break;
                        }
                    case 6: {
                            message.targetUid = reader.string();
                            break;
                        }
                    case 7: {
                            message.targetUin = reader.uint64();
                            break;
                        }
                    case 8: {
                            message.messageSeq = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupRecallNotice message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.GroupRecallNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.GroupRecallNotice} GroupRecallNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupRecallNotice.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupRecallNotice message.
             * @function verify
             * @memberof kritor.event.GroupRecallNotice
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupRecallNotice.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    if (!$util.isString(message.messageId))
                        return "messageId: string expected";
                if (message.tipText != null && message.hasOwnProperty("tipText"))
                    if (!$util.isString(message.tipText))
                        return "tipText: string expected";
                if (message.operatorUid != null && message.hasOwnProperty("operatorUid"))
                    if (!$util.isString(message.operatorUid))
                        return "operatorUid: string expected";
                if (message.operatorUin != null && message.hasOwnProperty("operatorUin"))
                    if (!$util.isInteger(message.operatorUin) && !(message.operatorUin && $util.isInteger(message.operatorUin.low) && $util.isInteger(message.operatorUin.high)))
                        return "operatorUin: integer|Long expected";
                if (message.targetUid != null && message.hasOwnProperty("targetUid"))
                    if (!$util.isString(message.targetUid))
                        return "targetUid: string expected";
                if (message.targetUin != null && message.hasOwnProperty("targetUin"))
                    if (!$util.isInteger(message.targetUin) && !(message.targetUin && $util.isInteger(message.targetUin.low) && $util.isInteger(message.targetUin.high)))
                        return "targetUin: integer|Long expected";
                if (message.messageSeq != null && message.hasOwnProperty("messageSeq"))
                    if (!$util.isInteger(message.messageSeq) && !(message.messageSeq && $util.isInteger(message.messageSeq.low) && $util.isInteger(message.messageSeq.high)))
                        return "messageSeq: integer|Long expected";
                return null;
            };

            /**
             * Creates a GroupRecallNotice message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.GroupRecallNotice
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.GroupRecallNotice} GroupRecallNotice
             */
            GroupRecallNotice.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.GroupRecallNotice)
                    return object;
                let message = new $root.kritor.event.GroupRecallNotice();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                if (object.messageId != null)
                    message.messageId = String(object.messageId);
                if (object.tipText != null)
                    message.tipText = String(object.tipText);
                if (object.operatorUid != null)
                    message.operatorUid = String(object.operatorUid);
                if (object.operatorUin != null)
                    if ($util.Long)
                        (message.operatorUin = $util.Long.fromValue(object.operatorUin)).unsigned = true;
                    else if (typeof object.operatorUin === "string")
                        message.operatorUin = parseInt(object.operatorUin, 10);
                    else if (typeof object.operatorUin === "number")
                        message.operatorUin = object.operatorUin;
                    else if (typeof object.operatorUin === "object")
                        message.operatorUin = new $util.LongBits(object.operatorUin.low >>> 0, object.operatorUin.high >>> 0).toNumber(true);
                if (object.targetUid != null)
                    message.targetUid = String(object.targetUid);
                if (object.targetUin != null)
                    if ($util.Long)
                        (message.targetUin = $util.Long.fromValue(object.targetUin)).unsigned = true;
                    else if (typeof object.targetUin === "string")
                        message.targetUin = parseInt(object.targetUin, 10);
                    else if (typeof object.targetUin === "number")
                        message.targetUin = object.targetUin;
                    else if (typeof object.targetUin === "object")
                        message.targetUin = new $util.LongBits(object.targetUin.low >>> 0, object.targetUin.high >>> 0).toNumber(true);
                if (object.messageSeq != null)
                    if ($util.Long)
                        (message.messageSeq = $util.Long.fromValue(object.messageSeq)).unsigned = true;
                    else if (typeof object.messageSeq === "string")
                        message.messageSeq = parseInt(object.messageSeq, 10);
                    else if (typeof object.messageSeq === "number")
                        message.messageSeq = object.messageSeq;
                    else if (typeof object.messageSeq === "object")
                        message.messageSeq = new $util.LongBits(object.messageSeq.low >>> 0, object.messageSeq.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a GroupRecallNotice message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.GroupRecallNotice
             * @static
             * @param {kritor.event.GroupRecallNotice} message GroupRecallNotice
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupRecallNotice.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                    object.messageId = "";
                    object.tipText = "";
                    object.operatorUid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.operatorUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.operatorUin = options.longs === String ? "0" : 0;
                    object.targetUid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.targetUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.targetUin = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.messageSeq = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.messageSeq = options.longs === String ? "0" : 0;
                }
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    object.messageId = message.messageId;
                if (message.tipText != null && message.hasOwnProperty("tipText"))
                    object.tipText = message.tipText;
                if (message.operatorUid != null && message.hasOwnProperty("operatorUid"))
                    object.operatorUid = message.operatorUid;
                if (message.operatorUin != null && message.hasOwnProperty("operatorUin"))
                    if (typeof message.operatorUin === "number")
                        object.operatorUin = options.longs === String ? String(message.operatorUin) : message.operatorUin;
                    else
                        object.operatorUin = options.longs === String ? $util.Long.prototype.toString.call(message.operatorUin) : options.longs === Number ? new $util.LongBits(message.operatorUin.low >>> 0, message.operatorUin.high >>> 0).toNumber(true) : message.operatorUin;
                if (message.targetUid != null && message.hasOwnProperty("targetUid"))
                    object.targetUid = message.targetUid;
                if (message.targetUin != null && message.hasOwnProperty("targetUin"))
                    if (typeof message.targetUin === "number")
                        object.targetUin = options.longs === String ? String(message.targetUin) : message.targetUin;
                    else
                        object.targetUin = options.longs === String ? $util.Long.prototype.toString.call(message.targetUin) : options.longs === Number ? new $util.LongBits(message.targetUin.low >>> 0, message.targetUin.high >>> 0).toNumber(true) : message.targetUin;
                if (message.messageSeq != null && message.hasOwnProperty("messageSeq"))
                    if (typeof message.messageSeq === "number")
                        object.messageSeq = options.longs === String ? String(message.messageSeq) : message.messageSeq;
                    else
                        object.messageSeq = options.longs === String ? $util.Long.prototype.toString.call(message.messageSeq) : options.longs === Number ? new $util.LongBits(message.messageSeq.low >>> 0, message.messageSeq.high >>> 0).toNumber(true) : message.messageSeq;
                return object;
            };

            /**
             * Converts this GroupRecallNotice to JSON.
             * @function toJSON
             * @memberof kritor.event.GroupRecallNotice
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupRecallNotice.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GroupRecallNotice
             * @function getTypeUrl
             * @memberof kritor.event.GroupRecallNotice
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GroupRecallNotice.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.GroupRecallNotice";
            };

            return GroupRecallNotice;
        })();

        event.GroupSignInNotice = (function() {

            /**
             * Properties of a GroupSignInNotice.
             * @memberof kritor.event
             * @interface IGroupSignInNotice
             * @property {number|Long|null} [groupId] GroupSignInNotice groupId
             * @property {string|null} [targetUid] GroupSignInNotice targetUid
             * @property {number|Long|null} [targetUin] GroupSignInNotice targetUin
             * @property {string|null} [action] GroupSignInNotice action
             * @property {string|null} [suffix] GroupSignInNotice suffix
             * @property {string|null} [rankImage] GroupSignInNotice rankImage
             */

            /**
             * Constructs a new GroupSignInNotice.
             * @memberof kritor.event
             * @classdesc Represents a GroupSignInNotice.
             * @implements IGroupSignInNotice
             * @constructor
             * @param {kritor.event.IGroupSignInNotice=} [properties] Properties to set
             */
            function GroupSignInNotice(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupSignInNotice groupId.
             * @member {number|Long} groupId
             * @memberof kritor.event.GroupSignInNotice
             * @instance
             */
            GroupSignInNotice.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupSignInNotice targetUid.
             * @member {string} targetUid
             * @memberof kritor.event.GroupSignInNotice
             * @instance
             */
            GroupSignInNotice.prototype.targetUid = "";

            /**
             * GroupSignInNotice targetUin.
             * @member {number|Long} targetUin
             * @memberof kritor.event.GroupSignInNotice
             * @instance
             */
            GroupSignInNotice.prototype.targetUin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupSignInNotice action.
             * @member {string} action
             * @memberof kritor.event.GroupSignInNotice
             * @instance
             */
            GroupSignInNotice.prototype.action = "";

            /**
             * GroupSignInNotice suffix.
             * @member {string} suffix
             * @memberof kritor.event.GroupSignInNotice
             * @instance
             */
            GroupSignInNotice.prototype.suffix = "";

            /**
             * GroupSignInNotice rankImage.
             * @member {string} rankImage
             * @memberof kritor.event.GroupSignInNotice
             * @instance
             */
            GroupSignInNotice.prototype.rankImage = "";

            /**
             * Creates a new GroupSignInNotice instance using the specified properties.
             * @function create
             * @memberof kritor.event.GroupSignInNotice
             * @static
             * @param {kritor.event.IGroupSignInNotice=} [properties] Properties to set
             * @returns {kritor.event.GroupSignInNotice} GroupSignInNotice instance
             */
            GroupSignInNotice.create = function create(properties) {
                return new GroupSignInNotice(properties);
            };

            /**
             * Encodes the specified GroupSignInNotice message. Does not implicitly {@link kritor.event.GroupSignInNotice.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.GroupSignInNotice
             * @static
             * @param {kritor.event.IGroupSignInNotice} message GroupSignInNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupSignInNotice.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                if (message.targetUid != null && Object.hasOwnProperty.call(message, "targetUid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.targetUid);
                if (message.targetUin != null && Object.hasOwnProperty.call(message, "targetUin"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.targetUin);
                if (message.action != null && Object.hasOwnProperty.call(message, "action"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.action);
                if (message.suffix != null && Object.hasOwnProperty.call(message, "suffix"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.suffix);
                if (message.rankImage != null && Object.hasOwnProperty.call(message, "rankImage"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.rankImage);
                return writer;
            };

            /**
             * Encodes the specified GroupSignInNotice message, length delimited. Does not implicitly {@link kritor.event.GroupSignInNotice.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.GroupSignInNotice
             * @static
             * @param {kritor.event.IGroupSignInNotice} message GroupSignInNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupSignInNotice.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupSignInNotice message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.GroupSignInNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.GroupSignInNotice} GroupSignInNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupSignInNotice.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.GroupSignInNotice();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.targetUid = reader.string();
                            break;
                        }
                    case 3: {
                            message.targetUin = reader.uint64();
                            break;
                        }
                    case 4: {
                            message.action = reader.string();
                            break;
                        }
                    case 5: {
                            message.suffix = reader.string();
                            break;
                        }
                    case 6: {
                            message.rankImage = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupSignInNotice message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.GroupSignInNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.GroupSignInNotice} GroupSignInNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupSignInNotice.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupSignInNotice message.
             * @function verify
             * @memberof kritor.event.GroupSignInNotice
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupSignInNotice.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                if (message.targetUid != null && message.hasOwnProperty("targetUid"))
                    if (!$util.isString(message.targetUid))
                        return "targetUid: string expected";
                if (message.targetUin != null && message.hasOwnProperty("targetUin"))
                    if (!$util.isInteger(message.targetUin) && !(message.targetUin && $util.isInteger(message.targetUin.low) && $util.isInteger(message.targetUin.high)))
                        return "targetUin: integer|Long expected";
                if (message.action != null && message.hasOwnProperty("action"))
                    if (!$util.isString(message.action))
                        return "action: string expected";
                if (message.suffix != null && message.hasOwnProperty("suffix"))
                    if (!$util.isString(message.suffix))
                        return "suffix: string expected";
                if (message.rankImage != null && message.hasOwnProperty("rankImage"))
                    if (!$util.isString(message.rankImage))
                        return "rankImage: string expected";
                return null;
            };

            /**
             * Creates a GroupSignInNotice message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.GroupSignInNotice
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.GroupSignInNotice} GroupSignInNotice
             */
            GroupSignInNotice.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.GroupSignInNotice)
                    return object;
                let message = new $root.kritor.event.GroupSignInNotice();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                if (object.targetUid != null)
                    message.targetUid = String(object.targetUid);
                if (object.targetUin != null)
                    if ($util.Long)
                        (message.targetUin = $util.Long.fromValue(object.targetUin)).unsigned = true;
                    else if (typeof object.targetUin === "string")
                        message.targetUin = parseInt(object.targetUin, 10);
                    else if (typeof object.targetUin === "number")
                        message.targetUin = object.targetUin;
                    else if (typeof object.targetUin === "object")
                        message.targetUin = new $util.LongBits(object.targetUin.low >>> 0, object.targetUin.high >>> 0).toNumber(true);
                if (object.action != null)
                    message.action = String(object.action);
                if (object.suffix != null)
                    message.suffix = String(object.suffix);
                if (object.rankImage != null)
                    message.rankImage = String(object.rankImage);
                return message;
            };

            /**
             * Creates a plain object from a GroupSignInNotice message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.GroupSignInNotice
             * @static
             * @param {kritor.event.GroupSignInNotice} message GroupSignInNotice
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupSignInNotice.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                    object.targetUid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.targetUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.targetUin = options.longs === String ? "0" : 0;
                    object.action = "";
                    object.suffix = "";
                    object.rankImage = "";
                }
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                if (message.targetUid != null && message.hasOwnProperty("targetUid"))
                    object.targetUid = message.targetUid;
                if (message.targetUin != null && message.hasOwnProperty("targetUin"))
                    if (typeof message.targetUin === "number")
                        object.targetUin = options.longs === String ? String(message.targetUin) : message.targetUin;
                    else
                        object.targetUin = options.longs === String ? $util.Long.prototype.toString.call(message.targetUin) : options.longs === Number ? new $util.LongBits(message.targetUin.low >>> 0, message.targetUin.high >>> 0).toNumber(true) : message.targetUin;
                if (message.action != null && message.hasOwnProperty("action"))
                    object.action = message.action;
                if (message.suffix != null && message.hasOwnProperty("suffix"))
                    object.suffix = message.suffix;
                if (message.rankImage != null && message.hasOwnProperty("rankImage"))
                    object.rankImage = message.rankImage;
                return object;
            };

            /**
             * Converts this GroupSignInNotice to JSON.
             * @function toJSON
             * @memberof kritor.event.GroupSignInNotice
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupSignInNotice.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GroupSignInNotice
             * @function getTypeUrl
             * @memberof kritor.event.GroupSignInNotice
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GroupSignInNotice.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.GroupSignInNotice";
            };

            return GroupSignInNotice;
        })();

        event.GroupWholeBanNotice = (function() {

            /**
             * Properties of a GroupWholeBanNotice.
             * @memberof kritor.event
             * @interface IGroupWholeBanNotice
             * @property {number|Long|null} [groupId] GroupWholeBanNotice groupId
             * @property {string|null} [operatorUid] GroupWholeBanNotice operatorUid
             * @property {number|Long|null} [operatorUin] GroupWholeBanNotice operatorUin
             * @property {boolean|null} [isBan] GroupWholeBanNotice isBan
             */

            /**
             * Constructs a new GroupWholeBanNotice.
             * @memberof kritor.event
             * @classdesc Represents a GroupWholeBanNotice.
             * @implements IGroupWholeBanNotice
             * @constructor
             * @param {kritor.event.IGroupWholeBanNotice=} [properties] Properties to set
             */
            function GroupWholeBanNotice(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupWholeBanNotice groupId.
             * @member {number|Long} groupId
             * @memberof kritor.event.GroupWholeBanNotice
             * @instance
             */
            GroupWholeBanNotice.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupWholeBanNotice operatorUid.
             * @member {string} operatorUid
             * @memberof kritor.event.GroupWholeBanNotice
             * @instance
             */
            GroupWholeBanNotice.prototype.operatorUid = "";

            /**
             * GroupWholeBanNotice operatorUin.
             * @member {number|Long} operatorUin
             * @memberof kritor.event.GroupWholeBanNotice
             * @instance
             */
            GroupWholeBanNotice.prototype.operatorUin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupWholeBanNotice isBan.
             * @member {boolean} isBan
             * @memberof kritor.event.GroupWholeBanNotice
             * @instance
             */
            GroupWholeBanNotice.prototype.isBan = false;

            /**
             * Creates a new GroupWholeBanNotice instance using the specified properties.
             * @function create
             * @memberof kritor.event.GroupWholeBanNotice
             * @static
             * @param {kritor.event.IGroupWholeBanNotice=} [properties] Properties to set
             * @returns {kritor.event.GroupWholeBanNotice} GroupWholeBanNotice instance
             */
            GroupWholeBanNotice.create = function create(properties) {
                return new GroupWholeBanNotice(properties);
            };

            /**
             * Encodes the specified GroupWholeBanNotice message. Does not implicitly {@link kritor.event.GroupWholeBanNotice.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.GroupWholeBanNotice
             * @static
             * @param {kritor.event.IGroupWholeBanNotice} message GroupWholeBanNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupWholeBanNotice.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                if (message.operatorUid != null && Object.hasOwnProperty.call(message, "operatorUid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.operatorUid);
                if (message.operatorUin != null && Object.hasOwnProperty.call(message, "operatorUin"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.operatorUin);
                if (message.isBan != null && Object.hasOwnProperty.call(message, "isBan"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.isBan);
                return writer;
            };

            /**
             * Encodes the specified GroupWholeBanNotice message, length delimited. Does not implicitly {@link kritor.event.GroupWholeBanNotice.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.GroupWholeBanNotice
             * @static
             * @param {kritor.event.IGroupWholeBanNotice} message GroupWholeBanNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupWholeBanNotice.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupWholeBanNotice message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.GroupWholeBanNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.GroupWholeBanNotice} GroupWholeBanNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupWholeBanNotice.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.GroupWholeBanNotice();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.operatorUid = reader.string();
                            break;
                        }
                    case 3: {
                            message.operatorUin = reader.uint64();
                            break;
                        }
                    case 4: {
                            message.isBan = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupWholeBanNotice message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.GroupWholeBanNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.GroupWholeBanNotice} GroupWholeBanNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupWholeBanNotice.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupWholeBanNotice message.
             * @function verify
             * @memberof kritor.event.GroupWholeBanNotice
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupWholeBanNotice.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                if (message.operatorUid != null && message.hasOwnProperty("operatorUid"))
                    if (!$util.isString(message.operatorUid))
                        return "operatorUid: string expected";
                if (message.operatorUin != null && message.hasOwnProperty("operatorUin"))
                    if (!$util.isInteger(message.operatorUin) && !(message.operatorUin && $util.isInteger(message.operatorUin.low) && $util.isInteger(message.operatorUin.high)))
                        return "operatorUin: integer|Long expected";
                if (message.isBan != null && message.hasOwnProperty("isBan"))
                    if (typeof message.isBan !== "boolean")
                        return "isBan: boolean expected";
                return null;
            };

            /**
             * Creates a GroupWholeBanNotice message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.GroupWholeBanNotice
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.GroupWholeBanNotice} GroupWholeBanNotice
             */
            GroupWholeBanNotice.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.GroupWholeBanNotice)
                    return object;
                let message = new $root.kritor.event.GroupWholeBanNotice();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                if (object.operatorUid != null)
                    message.operatorUid = String(object.operatorUid);
                if (object.operatorUin != null)
                    if ($util.Long)
                        (message.operatorUin = $util.Long.fromValue(object.operatorUin)).unsigned = true;
                    else if (typeof object.operatorUin === "string")
                        message.operatorUin = parseInt(object.operatorUin, 10);
                    else if (typeof object.operatorUin === "number")
                        message.operatorUin = object.operatorUin;
                    else if (typeof object.operatorUin === "object")
                        message.operatorUin = new $util.LongBits(object.operatorUin.low >>> 0, object.operatorUin.high >>> 0).toNumber(true);
                if (object.isBan != null)
                    message.isBan = Boolean(object.isBan);
                return message;
            };

            /**
             * Creates a plain object from a GroupWholeBanNotice message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.GroupWholeBanNotice
             * @static
             * @param {kritor.event.GroupWholeBanNotice} message GroupWholeBanNotice
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupWholeBanNotice.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                    object.operatorUid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.operatorUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.operatorUin = options.longs === String ? "0" : 0;
                    object.isBan = false;
                }
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                if (message.operatorUid != null && message.hasOwnProperty("operatorUid"))
                    object.operatorUid = message.operatorUid;
                if (message.operatorUin != null && message.hasOwnProperty("operatorUin"))
                    if (typeof message.operatorUin === "number")
                        object.operatorUin = options.longs === String ? String(message.operatorUin) : message.operatorUin;
                    else
                        object.operatorUin = options.longs === String ? $util.Long.prototype.toString.call(message.operatorUin) : options.longs === Number ? new $util.LongBits(message.operatorUin.low >>> 0, message.operatorUin.high >>> 0).toNumber(true) : message.operatorUin;
                if (message.isBan != null && message.hasOwnProperty("isBan"))
                    object.isBan = message.isBan;
                return object;
            };

            /**
             * Converts this GroupWholeBanNotice to JSON.
             * @function toJSON
             * @memberof kritor.event.GroupWholeBanNotice
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupWholeBanNotice.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GroupWholeBanNotice
             * @function getTypeUrl
             * @memberof kritor.event.GroupWholeBanNotice
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GroupWholeBanNotice.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.GroupWholeBanNotice";
            };

            return GroupWholeBanNotice;
        })();

        event.FriendFileUploadedNotice = (function() {

            /**
             * Properties of a FriendFileUploadedNotice.
             * @memberof kritor.event
             * @interface IFriendFileUploadedNotice
             * @property {string|null} [operatorUid] FriendFileUploadedNotice operatorUid
             * @property {number|Long|null} [operatorUin] FriendFileUploadedNotice operatorUin
             * @property {string|null} [fileId] FriendFileUploadedNotice fileId
             * @property {string|null} [fileSubId] FriendFileUploadedNotice fileSubId
             * @property {string|null} [fileName] FriendFileUploadedNotice fileName
             * @property {number|Long|null} [fileSize] FriendFileUploadedNotice fileSize
             * @property {number|null} [expireTime] FriendFileUploadedNotice expireTime
             * @property {string|null} [url] FriendFileUploadedNotice url
             */

            /**
             * Constructs a new FriendFileUploadedNotice.
             * @memberof kritor.event
             * @classdesc Represents a FriendFileUploadedNotice.
             * @implements IFriendFileUploadedNotice
             * @constructor
             * @param {kritor.event.IFriendFileUploadedNotice=} [properties] Properties to set
             */
            function FriendFileUploadedNotice(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FriendFileUploadedNotice operatorUid.
             * @member {string} operatorUid
             * @memberof kritor.event.FriendFileUploadedNotice
             * @instance
             */
            FriendFileUploadedNotice.prototype.operatorUid = "";

            /**
             * FriendFileUploadedNotice operatorUin.
             * @member {number|Long} operatorUin
             * @memberof kritor.event.FriendFileUploadedNotice
             * @instance
             */
            FriendFileUploadedNotice.prototype.operatorUin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * FriendFileUploadedNotice fileId.
             * @member {string} fileId
             * @memberof kritor.event.FriendFileUploadedNotice
             * @instance
             */
            FriendFileUploadedNotice.prototype.fileId = "";

            /**
             * FriendFileUploadedNotice fileSubId.
             * @member {string} fileSubId
             * @memberof kritor.event.FriendFileUploadedNotice
             * @instance
             */
            FriendFileUploadedNotice.prototype.fileSubId = "";

            /**
             * FriendFileUploadedNotice fileName.
             * @member {string} fileName
             * @memberof kritor.event.FriendFileUploadedNotice
             * @instance
             */
            FriendFileUploadedNotice.prototype.fileName = "";

            /**
             * FriendFileUploadedNotice fileSize.
             * @member {number|Long} fileSize
             * @memberof kritor.event.FriendFileUploadedNotice
             * @instance
             */
            FriendFileUploadedNotice.prototype.fileSize = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * FriendFileUploadedNotice expireTime.
             * @member {number} expireTime
             * @memberof kritor.event.FriendFileUploadedNotice
             * @instance
             */
            FriendFileUploadedNotice.prototype.expireTime = 0;

            /**
             * FriendFileUploadedNotice url.
             * @member {string} url
             * @memberof kritor.event.FriendFileUploadedNotice
             * @instance
             */
            FriendFileUploadedNotice.prototype.url = "";

            /**
             * Creates a new FriendFileUploadedNotice instance using the specified properties.
             * @function create
             * @memberof kritor.event.FriendFileUploadedNotice
             * @static
             * @param {kritor.event.IFriendFileUploadedNotice=} [properties] Properties to set
             * @returns {kritor.event.FriendFileUploadedNotice} FriendFileUploadedNotice instance
             */
            FriendFileUploadedNotice.create = function create(properties) {
                return new FriendFileUploadedNotice(properties);
            };

            /**
             * Encodes the specified FriendFileUploadedNotice message. Does not implicitly {@link kritor.event.FriendFileUploadedNotice.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.FriendFileUploadedNotice
             * @static
             * @param {kritor.event.IFriendFileUploadedNotice} message FriendFileUploadedNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FriendFileUploadedNotice.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operatorUid != null && Object.hasOwnProperty.call(message, "operatorUid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.operatorUid);
                if (message.operatorUin != null && Object.hasOwnProperty.call(message, "operatorUin"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.operatorUin);
                if (message.fileId != null && Object.hasOwnProperty.call(message, "fileId"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.fileId);
                if (message.fileSubId != null && Object.hasOwnProperty.call(message, "fileSubId"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.fileSubId);
                if (message.fileName != null && Object.hasOwnProperty.call(message, "fileName"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.fileName);
                if (message.fileSize != null && Object.hasOwnProperty.call(message, "fileSize"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.fileSize);
                if (message.expireTime != null && Object.hasOwnProperty.call(message, "expireTime"))
                    writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.expireTime);
                if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.url);
                return writer;
            };

            /**
             * Encodes the specified FriendFileUploadedNotice message, length delimited. Does not implicitly {@link kritor.event.FriendFileUploadedNotice.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.FriendFileUploadedNotice
             * @static
             * @param {kritor.event.IFriendFileUploadedNotice} message FriendFileUploadedNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FriendFileUploadedNotice.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FriendFileUploadedNotice message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.FriendFileUploadedNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.FriendFileUploadedNotice} FriendFileUploadedNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FriendFileUploadedNotice.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.FriendFileUploadedNotice();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.operatorUid = reader.string();
                            break;
                        }
                    case 2: {
                            message.operatorUin = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.fileId = reader.string();
                            break;
                        }
                    case 4: {
                            message.fileSubId = reader.string();
                            break;
                        }
                    case 5: {
                            message.fileName = reader.string();
                            break;
                        }
                    case 6: {
                            message.fileSize = reader.uint64();
                            break;
                        }
                    case 7: {
                            message.expireTime = reader.uint32();
                            break;
                        }
                    case 8: {
                            message.url = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FriendFileUploadedNotice message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.FriendFileUploadedNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.FriendFileUploadedNotice} FriendFileUploadedNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FriendFileUploadedNotice.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FriendFileUploadedNotice message.
             * @function verify
             * @memberof kritor.event.FriendFileUploadedNotice
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FriendFileUploadedNotice.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operatorUid != null && message.hasOwnProperty("operatorUid"))
                    if (!$util.isString(message.operatorUid))
                        return "operatorUid: string expected";
                if (message.operatorUin != null && message.hasOwnProperty("operatorUin"))
                    if (!$util.isInteger(message.operatorUin) && !(message.operatorUin && $util.isInteger(message.operatorUin.low) && $util.isInteger(message.operatorUin.high)))
                        return "operatorUin: integer|Long expected";
                if (message.fileId != null && message.hasOwnProperty("fileId"))
                    if (!$util.isString(message.fileId))
                        return "fileId: string expected";
                if (message.fileSubId != null && message.hasOwnProperty("fileSubId"))
                    if (!$util.isString(message.fileSubId))
                        return "fileSubId: string expected";
                if (message.fileName != null && message.hasOwnProperty("fileName"))
                    if (!$util.isString(message.fileName))
                        return "fileName: string expected";
                if (message.fileSize != null && message.hasOwnProperty("fileSize"))
                    if (!$util.isInteger(message.fileSize) && !(message.fileSize && $util.isInteger(message.fileSize.low) && $util.isInteger(message.fileSize.high)))
                        return "fileSize: integer|Long expected";
                if (message.expireTime != null && message.hasOwnProperty("expireTime"))
                    if (!$util.isInteger(message.expireTime))
                        return "expireTime: integer expected";
                if (message.url != null && message.hasOwnProperty("url"))
                    if (!$util.isString(message.url))
                        return "url: string expected";
                return null;
            };

            /**
             * Creates a FriendFileUploadedNotice message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.FriendFileUploadedNotice
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.FriendFileUploadedNotice} FriendFileUploadedNotice
             */
            FriendFileUploadedNotice.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.FriendFileUploadedNotice)
                    return object;
                let message = new $root.kritor.event.FriendFileUploadedNotice();
                if (object.operatorUid != null)
                    message.operatorUid = String(object.operatorUid);
                if (object.operatorUin != null)
                    if ($util.Long)
                        (message.operatorUin = $util.Long.fromValue(object.operatorUin)).unsigned = true;
                    else if (typeof object.operatorUin === "string")
                        message.operatorUin = parseInt(object.operatorUin, 10);
                    else if (typeof object.operatorUin === "number")
                        message.operatorUin = object.operatorUin;
                    else if (typeof object.operatorUin === "object")
                        message.operatorUin = new $util.LongBits(object.operatorUin.low >>> 0, object.operatorUin.high >>> 0).toNumber(true);
                if (object.fileId != null)
                    message.fileId = String(object.fileId);
                if (object.fileSubId != null)
                    message.fileSubId = String(object.fileSubId);
                if (object.fileName != null)
                    message.fileName = String(object.fileName);
                if (object.fileSize != null)
                    if ($util.Long)
                        (message.fileSize = $util.Long.fromValue(object.fileSize)).unsigned = true;
                    else if (typeof object.fileSize === "string")
                        message.fileSize = parseInt(object.fileSize, 10);
                    else if (typeof object.fileSize === "number")
                        message.fileSize = object.fileSize;
                    else if (typeof object.fileSize === "object")
                        message.fileSize = new $util.LongBits(object.fileSize.low >>> 0, object.fileSize.high >>> 0).toNumber(true);
                if (object.expireTime != null)
                    message.expireTime = object.expireTime >>> 0;
                if (object.url != null)
                    message.url = String(object.url);
                return message;
            };

            /**
             * Creates a plain object from a FriendFileUploadedNotice message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.FriendFileUploadedNotice
             * @static
             * @param {kritor.event.FriendFileUploadedNotice} message FriendFileUploadedNotice
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FriendFileUploadedNotice.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.operatorUid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.operatorUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.operatorUin = options.longs === String ? "0" : 0;
                    object.fileId = "";
                    object.fileSubId = "";
                    object.fileName = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.fileSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.fileSize = options.longs === String ? "0" : 0;
                    object.expireTime = 0;
                    object.url = "";
                }
                if (message.operatorUid != null && message.hasOwnProperty("operatorUid"))
                    object.operatorUid = message.operatorUid;
                if (message.operatorUin != null && message.hasOwnProperty("operatorUin"))
                    if (typeof message.operatorUin === "number")
                        object.operatorUin = options.longs === String ? String(message.operatorUin) : message.operatorUin;
                    else
                        object.operatorUin = options.longs === String ? $util.Long.prototype.toString.call(message.operatorUin) : options.longs === Number ? new $util.LongBits(message.operatorUin.low >>> 0, message.operatorUin.high >>> 0).toNumber(true) : message.operatorUin;
                if (message.fileId != null && message.hasOwnProperty("fileId"))
                    object.fileId = message.fileId;
                if (message.fileSubId != null && message.hasOwnProperty("fileSubId"))
                    object.fileSubId = message.fileSubId;
                if (message.fileName != null && message.hasOwnProperty("fileName"))
                    object.fileName = message.fileName;
                if (message.fileSize != null && message.hasOwnProperty("fileSize"))
                    if (typeof message.fileSize === "number")
                        object.fileSize = options.longs === String ? String(message.fileSize) : message.fileSize;
                    else
                        object.fileSize = options.longs === String ? $util.Long.prototype.toString.call(message.fileSize) : options.longs === Number ? new $util.LongBits(message.fileSize.low >>> 0, message.fileSize.high >>> 0).toNumber(true) : message.fileSize;
                if (message.expireTime != null && message.hasOwnProperty("expireTime"))
                    object.expireTime = message.expireTime;
                if (message.url != null && message.hasOwnProperty("url"))
                    object.url = message.url;
                return object;
            };

            /**
             * Converts this FriendFileUploadedNotice to JSON.
             * @function toJSON
             * @memberof kritor.event.FriendFileUploadedNotice
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FriendFileUploadedNotice.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for FriendFileUploadedNotice
             * @function getTypeUrl
             * @memberof kritor.event.FriendFileUploadedNotice
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            FriendFileUploadedNotice.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.FriendFileUploadedNotice";
            };

            return FriendFileUploadedNotice;
        })();

        event.GroupFileUploadedNotice = (function() {

            /**
             * Properties of a GroupFileUploadedNotice.
             * @memberof kritor.event
             * @interface IGroupFileUploadedNotice
             * @property {number|Long|null} [groupId] GroupFileUploadedNotice groupId
             * @property {string|null} [operatorUid] GroupFileUploadedNotice operatorUid
             * @property {number|Long|null} [operatorUin] GroupFileUploadedNotice operatorUin
             * @property {string|null} [fileId] GroupFileUploadedNotice fileId
             * @property {string|null} [fileSubId] GroupFileUploadedNotice fileSubId
             * @property {string|null} [fileName] GroupFileUploadedNotice fileName
             * @property {number|Long|null} [fileSize] GroupFileUploadedNotice fileSize
             * @property {number|null} [expireTime] GroupFileUploadedNotice expireTime
             * @property {number|null} [biz] GroupFileUploadedNotice biz
             * @property {string|null} [url] GroupFileUploadedNotice url
             */

            /**
             * Constructs a new GroupFileUploadedNotice.
             * @memberof kritor.event
             * @classdesc Represents a GroupFileUploadedNotice.
             * @implements IGroupFileUploadedNotice
             * @constructor
             * @param {kritor.event.IGroupFileUploadedNotice=} [properties] Properties to set
             */
            function GroupFileUploadedNotice(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupFileUploadedNotice groupId.
             * @member {number|Long} groupId
             * @memberof kritor.event.GroupFileUploadedNotice
             * @instance
             */
            GroupFileUploadedNotice.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupFileUploadedNotice operatorUid.
             * @member {string} operatorUid
             * @memberof kritor.event.GroupFileUploadedNotice
             * @instance
             */
            GroupFileUploadedNotice.prototype.operatorUid = "";

            /**
             * GroupFileUploadedNotice operatorUin.
             * @member {number|Long} operatorUin
             * @memberof kritor.event.GroupFileUploadedNotice
             * @instance
             */
            GroupFileUploadedNotice.prototype.operatorUin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupFileUploadedNotice fileId.
             * @member {string} fileId
             * @memberof kritor.event.GroupFileUploadedNotice
             * @instance
             */
            GroupFileUploadedNotice.prototype.fileId = "";

            /**
             * GroupFileUploadedNotice fileSubId.
             * @member {string} fileSubId
             * @memberof kritor.event.GroupFileUploadedNotice
             * @instance
             */
            GroupFileUploadedNotice.prototype.fileSubId = "";

            /**
             * GroupFileUploadedNotice fileName.
             * @member {string} fileName
             * @memberof kritor.event.GroupFileUploadedNotice
             * @instance
             */
            GroupFileUploadedNotice.prototype.fileName = "";

            /**
             * GroupFileUploadedNotice fileSize.
             * @member {number|Long} fileSize
             * @memberof kritor.event.GroupFileUploadedNotice
             * @instance
             */
            GroupFileUploadedNotice.prototype.fileSize = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupFileUploadedNotice expireTime.
             * @member {number} expireTime
             * @memberof kritor.event.GroupFileUploadedNotice
             * @instance
             */
            GroupFileUploadedNotice.prototype.expireTime = 0;

            /**
             * GroupFileUploadedNotice biz.
             * @member {number} biz
             * @memberof kritor.event.GroupFileUploadedNotice
             * @instance
             */
            GroupFileUploadedNotice.prototype.biz = 0;

            /**
             * GroupFileUploadedNotice url.
             * @member {string} url
             * @memberof kritor.event.GroupFileUploadedNotice
             * @instance
             */
            GroupFileUploadedNotice.prototype.url = "";

            /**
             * Creates a new GroupFileUploadedNotice instance using the specified properties.
             * @function create
             * @memberof kritor.event.GroupFileUploadedNotice
             * @static
             * @param {kritor.event.IGroupFileUploadedNotice=} [properties] Properties to set
             * @returns {kritor.event.GroupFileUploadedNotice} GroupFileUploadedNotice instance
             */
            GroupFileUploadedNotice.create = function create(properties) {
                return new GroupFileUploadedNotice(properties);
            };

            /**
             * Encodes the specified GroupFileUploadedNotice message. Does not implicitly {@link kritor.event.GroupFileUploadedNotice.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.GroupFileUploadedNotice
             * @static
             * @param {kritor.event.IGroupFileUploadedNotice} message GroupFileUploadedNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupFileUploadedNotice.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                if (message.operatorUid != null && Object.hasOwnProperty.call(message, "operatorUid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.operatorUid);
                if (message.operatorUin != null && Object.hasOwnProperty.call(message, "operatorUin"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.operatorUin);
                if (message.fileId != null && Object.hasOwnProperty.call(message, "fileId"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.fileId);
                if (message.fileSubId != null && Object.hasOwnProperty.call(message, "fileSubId"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.fileSubId);
                if (message.fileName != null && Object.hasOwnProperty.call(message, "fileName"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.fileName);
                if (message.fileSize != null && Object.hasOwnProperty.call(message, "fileSize"))
                    writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.fileSize);
                if (message.expireTime != null && Object.hasOwnProperty.call(message, "expireTime"))
                    writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.expireTime);
                if (message.biz != null && Object.hasOwnProperty.call(message, "biz"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.biz);
                if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                    writer.uint32(/* id 10, wireType 2 =*/82).string(message.url);
                return writer;
            };

            /**
             * Encodes the specified GroupFileUploadedNotice message, length delimited. Does not implicitly {@link kritor.event.GroupFileUploadedNotice.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.GroupFileUploadedNotice
             * @static
             * @param {kritor.event.IGroupFileUploadedNotice} message GroupFileUploadedNotice message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupFileUploadedNotice.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupFileUploadedNotice message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.GroupFileUploadedNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.GroupFileUploadedNotice} GroupFileUploadedNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupFileUploadedNotice.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.GroupFileUploadedNotice();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.operatorUid = reader.string();
                            break;
                        }
                    case 3: {
                            message.operatorUin = reader.uint64();
                            break;
                        }
                    case 4: {
                            message.fileId = reader.string();
                            break;
                        }
                    case 5: {
                            message.fileSubId = reader.string();
                            break;
                        }
                    case 6: {
                            message.fileName = reader.string();
                            break;
                        }
                    case 7: {
                            message.fileSize = reader.uint64();
                            break;
                        }
                    case 8: {
                            message.expireTime = reader.uint32();
                            break;
                        }
                    case 9: {
                            message.biz = reader.int32();
                            break;
                        }
                    case 10: {
                            message.url = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupFileUploadedNotice message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.GroupFileUploadedNotice
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.GroupFileUploadedNotice} GroupFileUploadedNotice
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupFileUploadedNotice.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupFileUploadedNotice message.
             * @function verify
             * @memberof kritor.event.GroupFileUploadedNotice
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupFileUploadedNotice.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                if (message.operatorUid != null && message.hasOwnProperty("operatorUid"))
                    if (!$util.isString(message.operatorUid))
                        return "operatorUid: string expected";
                if (message.operatorUin != null && message.hasOwnProperty("operatorUin"))
                    if (!$util.isInteger(message.operatorUin) && !(message.operatorUin && $util.isInteger(message.operatorUin.low) && $util.isInteger(message.operatorUin.high)))
                        return "operatorUin: integer|Long expected";
                if (message.fileId != null && message.hasOwnProperty("fileId"))
                    if (!$util.isString(message.fileId))
                        return "fileId: string expected";
                if (message.fileSubId != null && message.hasOwnProperty("fileSubId"))
                    if (!$util.isString(message.fileSubId))
                        return "fileSubId: string expected";
                if (message.fileName != null && message.hasOwnProperty("fileName"))
                    if (!$util.isString(message.fileName))
                        return "fileName: string expected";
                if (message.fileSize != null && message.hasOwnProperty("fileSize"))
                    if (!$util.isInteger(message.fileSize) && !(message.fileSize && $util.isInteger(message.fileSize.low) && $util.isInteger(message.fileSize.high)))
                        return "fileSize: integer|Long expected";
                if (message.expireTime != null && message.hasOwnProperty("expireTime"))
                    if (!$util.isInteger(message.expireTime))
                        return "expireTime: integer expected";
                if (message.biz != null && message.hasOwnProperty("biz"))
                    if (!$util.isInteger(message.biz))
                        return "biz: integer expected";
                if (message.url != null && message.hasOwnProperty("url"))
                    if (!$util.isString(message.url))
                        return "url: string expected";
                return null;
            };

            /**
             * Creates a GroupFileUploadedNotice message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.GroupFileUploadedNotice
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.GroupFileUploadedNotice} GroupFileUploadedNotice
             */
            GroupFileUploadedNotice.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.GroupFileUploadedNotice)
                    return object;
                let message = new $root.kritor.event.GroupFileUploadedNotice();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                if (object.operatorUid != null)
                    message.operatorUid = String(object.operatorUid);
                if (object.operatorUin != null)
                    if ($util.Long)
                        (message.operatorUin = $util.Long.fromValue(object.operatorUin)).unsigned = true;
                    else if (typeof object.operatorUin === "string")
                        message.operatorUin = parseInt(object.operatorUin, 10);
                    else if (typeof object.operatorUin === "number")
                        message.operatorUin = object.operatorUin;
                    else if (typeof object.operatorUin === "object")
                        message.operatorUin = new $util.LongBits(object.operatorUin.low >>> 0, object.operatorUin.high >>> 0).toNumber(true);
                if (object.fileId != null)
                    message.fileId = String(object.fileId);
                if (object.fileSubId != null)
                    message.fileSubId = String(object.fileSubId);
                if (object.fileName != null)
                    message.fileName = String(object.fileName);
                if (object.fileSize != null)
                    if ($util.Long)
                        (message.fileSize = $util.Long.fromValue(object.fileSize)).unsigned = true;
                    else if (typeof object.fileSize === "string")
                        message.fileSize = parseInt(object.fileSize, 10);
                    else if (typeof object.fileSize === "number")
                        message.fileSize = object.fileSize;
                    else if (typeof object.fileSize === "object")
                        message.fileSize = new $util.LongBits(object.fileSize.low >>> 0, object.fileSize.high >>> 0).toNumber(true);
                if (object.expireTime != null)
                    message.expireTime = object.expireTime >>> 0;
                if (object.biz != null)
                    message.biz = object.biz | 0;
                if (object.url != null)
                    message.url = String(object.url);
                return message;
            };

            /**
             * Creates a plain object from a GroupFileUploadedNotice message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.GroupFileUploadedNotice
             * @static
             * @param {kritor.event.GroupFileUploadedNotice} message GroupFileUploadedNotice
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupFileUploadedNotice.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                    object.operatorUid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.operatorUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.operatorUin = options.longs === String ? "0" : 0;
                    object.fileId = "";
                    object.fileSubId = "";
                    object.fileName = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.fileSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.fileSize = options.longs === String ? "0" : 0;
                    object.expireTime = 0;
                    object.biz = 0;
                    object.url = "";
                }
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                if (message.operatorUid != null && message.hasOwnProperty("operatorUid"))
                    object.operatorUid = message.operatorUid;
                if (message.operatorUin != null && message.hasOwnProperty("operatorUin"))
                    if (typeof message.operatorUin === "number")
                        object.operatorUin = options.longs === String ? String(message.operatorUin) : message.operatorUin;
                    else
                        object.operatorUin = options.longs === String ? $util.Long.prototype.toString.call(message.operatorUin) : options.longs === Number ? new $util.LongBits(message.operatorUin.low >>> 0, message.operatorUin.high >>> 0).toNumber(true) : message.operatorUin;
                if (message.fileId != null && message.hasOwnProperty("fileId"))
                    object.fileId = message.fileId;
                if (message.fileSubId != null && message.hasOwnProperty("fileSubId"))
                    object.fileSubId = message.fileSubId;
                if (message.fileName != null && message.hasOwnProperty("fileName"))
                    object.fileName = message.fileName;
                if (message.fileSize != null && message.hasOwnProperty("fileSize"))
                    if (typeof message.fileSize === "number")
                        object.fileSize = options.longs === String ? String(message.fileSize) : message.fileSize;
                    else
                        object.fileSize = options.longs === String ? $util.Long.prototype.toString.call(message.fileSize) : options.longs === Number ? new $util.LongBits(message.fileSize.low >>> 0, message.fileSize.high >>> 0).toNumber(true) : message.fileSize;
                if (message.expireTime != null && message.hasOwnProperty("expireTime"))
                    object.expireTime = message.expireTime;
                if (message.biz != null && message.hasOwnProperty("biz"))
                    object.biz = message.biz;
                if (message.url != null && message.hasOwnProperty("url"))
                    object.url = message.url;
                return object;
            };

            /**
             * Converts this GroupFileUploadedNotice to JSON.
             * @function toJSON
             * @memberof kritor.event.GroupFileUploadedNotice
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupFileUploadedNotice.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GroupFileUploadedNotice
             * @function getTypeUrl
             * @memberof kritor.event.GroupFileUploadedNotice
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GroupFileUploadedNotice.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.GroupFileUploadedNotice";
            };

            return GroupFileUploadedNotice;
        })();

        event.RequestsEvent = (function() {

            /**
             * Properties of a RequestsEvent.
             * @memberof kritor.event
             * @interface IRequestsEvent
             * @property {kritor.event.RequestsEvent.RequestType|null} [type] RequestsEvent type
             * @property {number|null} [time] RequestsEvent time
             * @property {kritor.event.IFriendApplyRequest|null} [friendApply] RequestsEvent friendApply
             * @property {kritor.event.IGroupApplyRequest|null} [groupApply] RequestsEvent groupApply
             * @property {kritor.event.IInvitedJoinGroupRequest|null} [invitedGroup] RequestsEvent invitedGroup
             */

            /**
             * Constructs a new RequestsEvent.
             * @memberof kritor.event
             * @classdesc Represents a RequestsEvent.
             * @implements IRequestsEvent
             * @constructor
             * @param {kritor.event.IRequestsEvent=} [properties] Properties to set
             */
            function RequestsEvent(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RequestsEvent type.
             * @member {kritor.event.RequestsEvent.RequestType} type
             * @memberof kritor.event.RequestsEvent
             * @instance
             */
            RequestsEvent.prototype.type = 0;

            /**
             * RequestsEvent time.
             * @member {number} time
             * @memberof kritor.event.RequestsEvent
             * @instance
             */
            RequestsEvent.prototype.time = 0;

            /**
             * RequestsEvent friendApply.
             * @member {kritor.event.IFriendApplyRequest|null|undefined} friendApply
             * @memberof kritor.event.RequestsEvent
             * @instance
             */
            RequestsEvent.prototype.friendApply = null;

            /**
             * RequestsEvent groupApply.
             * @member {kritor.event.IGroupApplyRequest|null|undefined} groupApply
             * @memberof kritor.event.RequestsEvent
             * @instance
             */
            RequestsEvent.prototype.groupApply = null;

            /**
             * RequestsEvent invitedGroup.
             * @member {kritor.event.IInvitedJoinGroupRequest|null|undefined} invitedGroup
             * @memberof kritor.event.RequestsEvent
             * @instance
             */
            RequestsEvent.prototype.invitedGroup = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * RequestsEvent request.
             * @member {"friendApply"|"groupApply"|"invitedGroup"|undefined} request
             * @memberof kritor.event.RequestsEvent
             * @instance
             */
            Object.defineProperty(RequestsEvent.prototype, "request", {
                get: $util.oneOfGetter($oneOfFields = ["friendApply", "groupApply", "invitedGroup"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new RequestsEvent instance using the specified properties.
             * @function create
             * @memberof kritor.event.RequestsEvent
             * @static
             * @param {kritor.event.IRequestsEvent=} [properties] Properties to set
             * @returns {kritor.event.RequestsEvent} RequestsEvent instance
             */
            RequestsEvent.create = function create(properties) {
                return new RequestsEvent(properties);
            };

            /**
             * Encodes the specified RequestsEvent message. Does not implicitly {@link kritor.event.RequestsEvent.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.RequestsEvent
             * @static
             * @param {kritor.event.IRequestsEvent} message RequestsEvent message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RequestsEvent.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.time);
                if (message.friendApply != null && Object.hasOwnProperty.call(message, "friendApply"))
                    $root.kritor.event.FriendApplyRequest.encode(message.friendApply, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.groupApply != null && Object.hasOwnProperty.call(message, "groupApply"))
                    $root.kritor.event.GroupApplyRequest.encode(message.groupApply, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.invitedGroup != null && Object.hasOwnProperty.call(message, "invitedGroup"))
                    $root.kritor.event.InvitedJoinGroupRequest.encode(message.invitedGroup, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RequestsEvent message, length delimited. Does not implicitly {@link kritor.event.RequestsEvent.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.RequestsEvent
             * @static
             * @param {kritor.event.IRequestsEvent} message RequestsEvent message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RequestsEvent.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RequestsEvent message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.RequestsEvent
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.RequestsEvent} RequestsEvent
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RequestsEvent.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.RequestsEvent();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.type = reader.int32();
                            break;
                        }
                    case 2: {
                            message.time = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.friendApply = $root.kritor.event.FriendApplyRequest.decode(reader, reader.uint32());
                            break;
                        }
                    case 4: {
                            message.groupApply = $root.kritor.event.GroupApplyRequest.decode(reader, reader.uint32());
                            break;
                        }
                    case 5: {
                            message.invitedGroup = $root.kritor.event.InvitedJoinGroupRequest.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RequestsEvent message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.RequestsEvent
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.RequestsEvent} RequestsEvent
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RequestsEvent.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RequestsEvent message.
             * @function verify
             * @memberof kritor.event.RequestsEvent
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RequestsEvent.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.time != null && message.hasOwnProperty("time"))
                    if (!$util.isInteger(message.time))
                        return "time: integer expected";
                if (message.friendApply != null && message.hasOwnProperty("friendApply")) {
                    properties.request = 1;
                    {
                        let error = $root.kritor.event.FriendApplyRequest.verify(message.friendApply);
                        if (error)
                            return "friendApply." + error;
                    }
                }
                if (message.groupApply != null && message.hasOwnProperty("groupApply")) {
                    if (properties.request === 1)
                        return "request: multiple values";
                    properties.request = 1;
                    {
                        let error = $root.kritor.event.GroupApplyRequest.verify(message.groupApply);
                        if (error)
                            return "groupApply." + error;
                    }
                }
                if (message.invitedGroup != null && message.hasOwnProperty("invitedGroup")) {
                    if (properties.request === 1)
                        return "request: multiple values";
                    properties.request = 1;
                    {
                        let error = $root.kritor.event.InvitedJoinGroupRequest.verify(message.invitedGroup);
                        if (error)
                            return "invitedGroup." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a RequestsEvent message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.RequestsEvent
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.RequestsEvent} RequestsEvent
             */
            RequestsEvent.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.RequestsEvent)
                    return object;
                let message = new $root.kritor.event.RequestsEvent();
                switch (object.type) {
                default:
                    if (typeof object.type === "number") {
                        message.type = object.type;
                        break;
                    }
                    break;
                case "FRIEND_APPLY":
                case 0:
                    message.type = 0;
                    break;
                case "GROUP_APPLY":
                case 1:
                    message.type = 1;
                    break;
                case "INVITED_GROUP":
                case 2:
                    message.type = 2;
                    break;
                }
                if (object.time != null)
                    message.time = object.time >>> 0;
                if (object.friendApply != null) {
                    if (typeof object.friendApply !== "object")
                        throw TypeError(".kritor.event.RequestsEvent.friendApply: object expected");
                    message.friendApply = $root.kritor.event.FriendApplyRequest.fromObject(object.friendApply);
                }
                if (object.groupApply != null) {
                    if (typeof object.groupApply !== "object")
                        throw TypeError(".kritor.event.RequestsEvent.groupApply: object expected");
                    message.groupApply = $root.kritor.event.GroupApplyRequest.fromObject(object.groupApply);
                }
                if (object.invitedGroup != null) {
                    if (typeof object.invitedGroup !== "object")
                        throw TypeError(".kritor.event.RequestsEvent.invitedGroup: object expected");
                    message.invitedGroup = $root.kritor.event.InvitedJoinGroupRequest.fromObject(object.invitedGroup);
                }
                return message;
            };

            /**
             * Creates a plain object from a RequestsEvent message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.RequestsEvent
             * @static
             * @param {kritor.event.RequestsEvent} message RequestsEvent
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RequestsEvent.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.type = options.enums === String ? "FRIEND_APPLY" : 0;
                    object.time = 0;
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.kritor.event.RequestsEvent.RequestType[message.type] === undefined ? message.type : $root.kritor.event.RequestsEvent.RequestType[message.type] : message.type;
                if (message.time != null && message.hasOwnProperty("time"))
                    object.time = message.time;
                if (message.friendApply != null && message.hasOwnProperty("friendApply")) {
                    object.friendApply = $root.kritor.event.FriendApplyRequest.toObject(message.friendApply, options);
                    if (options.oneofs)
                        object.request = "friendApply";
                }
                if (message.groupApply != null && message.hasOwnProperty("groupApply")) {
                    object.groupApply = $root.kritor.event.GroupApplyRequest.toObject(message.groupApply, options);
                    if (options.oneofs)
                        object.request = "groupApply";
                }
                if (message.invitedGroup != null && message.hasOwnProperty("invitedGroup")) {
                    object.invitedGroup = $root.kritor.event.InvitedJoinGroupRequest.toObject(message.invitedGroup, options);
                    if (options.oneofs)
                        object.request = "invitedGroup";
                }
                return object;
            };

            /**
             * Converts this RequestsEvent to JSON.
             * @function toJSON
             * @memberof kritor.event.RequestsEvent
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RequestsEvent.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for RequestsEvent
             * @function getTypeUrl
             * @memberof kritor.event.RequestsEvent
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            RequestsEvent.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.RequestsEvent";
            };

            /**
             * RequestType enum.
             * @name kritor.event.RequestsEvent.RequestType
             * @enum {number}
             * @property {number} FRIEND_APPLY=0 FRIEND_APPLY value
             * @property {number} GROUP_APPLY=1 GROUP_APPLY value
             * @property {number} INVITED_GROUP=2 INVITED_GROUP value
             */
            RequestsEvent.RequestType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "FRIEND_APPLY"] = 0;
                values[valuesById[1] = "GROUP_APPLY"] = 1;
                values[valuesById[2] = "INVITED_GROUP"] = 2;
                return values;
            })();

            return RequestsEvent;
        })();

        event.FriendApplyRequest = (function() {

            /**
             * Properties of a FriendApplyRequest.
             * @memberof kritor.event
             * @interface IFriendApplyRequest
             * @property {string|null} [applierUid] FriendApplyRequest applierUid
             * @property {number|Long|null} [applierUin] FriendApplyRequest applierUin
             * @property {string|null} [flag] FriendApplyRequest flag
             * @property {string|null} [message] FriendApplyRequest message
             */

            /**
             * Constructs a new FriendApplyRequest.
             * @memberof kritor.event
             * @classdesc Represents a FriendApplyRequest.
             * @implements IFriendApplyRequest
             * @constructor
             * @param {kritor.event.IFriendApplyRequest=} [properties] Properties to set
             */
            function FriendApplyRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FriendApplyRequest applierUid.
             * @member {string} applierUid
             * @memberof kritor.event.FriendApplyRequest
             * @instance
             */
            FriendApplyRequest.prototype.applierUid = "";

            /**
             * FriendApplyRequest applierUin.
             * @member {number|Long} applierUin
             * @memberof kritor.event.FriendApplyRequest
             * @instance
             */
            FriendApplyRequest.prototype.applierUin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * FriendApplyRequest flag.
             * @member {string} flag
             * @memberof kritor.event.FriendApplyRequest
             * @instance
             */
            FriendApplyRequest.prototype.flag = "";

            /**
             * FriendApplyRequest message.
             * @member {string} message
             * @memberof kritor.event.FriendApplyRequest
             * @instance
             */
            FriendApplyRequest.prototype.message = "";

            /**
             * Creates a new FriendApplyRequest instance using the specified properties.
             * @function create
             * @memberof kritor.event.FriendApplyRequest
             * @static
             * @param {kritor.event.IFriendApplyRequest=} [properties] Properties to set
             * @returns {kritor.event.FriendApplyRequest} FriendApplyRequest instance
             */
            FriendApplyRequest.create = function create(properties) {
                return new FriendApplyRequest(properties);
            };

            /**
             * Encodes the specified FriendApplyRequest message. Does not implicitly {@link kritor.event.FriendApplyRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.FriendApplyRequest
             * @static
             * @param {kritor.event.IFriendApplyRequest} message FriendApplyRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FriendApplyRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.applierUid != null && Object.hasOwnProperty.call(message, "applierUid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.applierUid);
                if (message.applierUin != null && Object.hasOwnProperty.call(message, "applierUin"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.applierUin);
                if (message.flag != null && Object.hasOwnProperty.call(message, "flag"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.flag);
                if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.message);
                return writer;
            };

            /**
             * Encodes the specified FriendApplyRequest message, length delimited. Does not implicitly {@link kritor.event.FriendApplyRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.FriendApplyRequest
             * @static
             * @param {kritor.event.IFriendApplyRequest} message FriendApplyRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FriendApplyRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FriendApplyRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.FriendApplyRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.FriendApplyRequest} FriendApplyRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FriendApplyRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.FriendApplyRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.applierUid = reader.string();
                            break;
                        }
                    case 2: {
                            message.applierUin = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.flag = reader.string();
                            break;
                        }
                    case 4: {
                            message.message = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FriendApplyRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.FriendApplyRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.FriendApplyRequest} FriendApplyRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FriendApplyRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FriendApplyRequest message.
             * @function verify
             * @memberof kritor.event.FriendApplyRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FriendApplyRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.applierUid != null && message.hasOwnProperty("applierUid"))
                    if (!$util.isString(message.applierUid))
                        return "applierUid: string expected";
                if (message.applierUin != null && message.hasOwnProperty("applierUin"))
                    if (!$util.isInteger(message.applierUin) && !(message.applierUin && $util.isInteger(message.applierUin.low) && $util.isInteger(message.applierUin.high)))
                        return "applierUin: integer|Long expected";
                if (message.flag != null && message.hasOwnProperty("flag"))
                    if (!$util.isString(message.flag))
                        return "flag: string expected";
                if (message.message != null && message.hasOwnProperty("message"))
                    if (!$util.isString(message.message))
                        return "message: string expected";
                return null;
            };

            /**
             * Creates a FriendApplyRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.FriendApplyRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.FriendApplyRequest} FriendApplyRequest
             */
            FriendApplyRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.FriendApplyRequest)
                    return object;
                let message = new $root.kritor.event.FriendApplyRequest();
                if (object.applierUid != null)
                    message.applierUid = String(object.applierUid);
                if (object.applierUin != null)
                    if ($util.Long)
                        (message.applierUin = $util.Long.fromValue(object.applierUin)).unsigned = true;
                    else if (typeof object.applierUin === "string")
                        message.applierUin = parseInt(object.applierUin, 10);
                    else if (typeof object.applierUin === "number")
                        message.applierUin = object.applierUin;
                    else if (typeof object.applierUin === "object")
                        message.applierUin = new $util.LongBits(object.applierUin.low >>> 0, object.applierUin.high >>> 0).toNumber(true);
                if (object.flag != null)
                    message.flag = String(object.flag);
                if (object.message != null)
                    message.message = String(object.message);
                return message;
            };

            /**
             * Creates a plain object from a FriendApplyRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.FriendApplyRequest
             * @static
             * @param {kritor.event.FriendApplyRequest} message FriendApplyRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FriendApplyRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.applierUid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.applierUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.applierUin = options.longs === String ? "0" : 0;
                    object.flag = "";
                    object.message = "";
                }
                if (message.applierUid != null && message.hasOwnProperty("applierUid"))
                    object.applierUid = message.applierUid;
                if (message.applierUin != null && message.hasOwnProperty("applierUin"))
                    if (typeof message.applierUin === "number")
                        object.applierUin = options.longs === String ? String(message.applierUin) : message.applierUin;
                    else
                        object.applierUin = options.longs === String ? $util.Long.prototype.toString.call(message.applierUin) : options.longs === Number ? new $util.LongBits(message.applierUin.low >>> 0, message.applierUin.high >>> 0).toNumber(true) : message.applierUin;
                if (message.flag != null && message.hasOwnProperty("flag"))
                    object.flag = message.flag;
                if (message.message != null && message.hasOwnProperty("message"))
                    object.message = message.message;
                return object;
            };

            /**
             * Converts this FriendApplyRequest to JSON.
             * @function toJSON
             * @memberof kritor.event.FriendApplyRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FriendApplyRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for FriendApplyRequest
             * @function getTypeUrl
             * @memberof kritor.event.FriendApplyRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            FriendApplyRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.FriendApplyRequest";
            };

            return FriendApplyRequest;
        })();

        event.GroupApplyRequest = (function() {

            /**
             * Properties of a GroupApplyRequest.
             * @memberof kritor.event
             * @interface IGroupApplyRequest
             * @property {number|Long|null} [groupId] GroupApplyRequest groupId
             * @property {string|null} [applierUid] GroupApplyRequest applierUid
             * @property {number|Long|null} [applierUin] GroupApplyRequest applierUin
             * @property {string|null} [inviterUid] GroupApplyRequest inviterUid
             * @property {number|Long|null} [inviterUin] GroupApplyRequest inviterUin
             * @property {string|null} [reason] GroupApplyRequest reason
             * @property {string|null} [flag] GroupApplyRequest flag
             */

            /**
             * Constructs a new GroupApplyRequest.
             * @memberof kritor.event
             * @classdesc Represents a GroupApplyRequest.
             * @implements IGroupApplyRequest
             * @constructor
             * @param {kritor.event.IGroupApplyRequest=} [properties] Properties to set
             */
            function GroupApplyRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupApplyRequest groupId.
             * @member {number|Long} groupId
             * @memberof kritor.event.GroupApplyRequest
             * @instance
             */
            GroupApplyRequest.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupApplyRequest applierUid.
             * @member {string} applierUid
             * @memberof kritor.event.GroupApplyRequest
             * @instance
             */
            GroupApplyRequest.prototype.applierUid = "";

            /**
             * GroupApplyRequest applierUin.
             * @member {number|Long} applierUin
             * @memberof kritor.event.GroupApplyRequest
             * @instance
             */
            GroupApplyRequest.prototype.applierUin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupApplyRequest inviterUid.
             * @member {string} inviterUid
             * @memberof kritor.event.GroupApplyRequest
             * @instance
             */
            GroupApplyRequest.prototype.inviterUid = "";

            /**
             * GroupApplyRequest inviterUin.
             * @member {number|Long} inviterUin
             * @memberof kritor.event.GroupApplyRequest
             * @instance
             */
            GroupApplyRequest.prototype.inviterUin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupApplyRequest reason.
             * @member {string} reason
             * @memberof kritor.event.GroupApplyRequest
             * @instance
             */
            GroupApplyRequest.prototype.reason = "";

            /**
             * GroupApplyRequest flag.
             * @member {string} flag
             * @memberof kritor.event.GroupApplyRequest
             * @instance
             */
            GroupApplyRequest.prototype.flag = "";

            /**
             * Creates a new GroupApplyRequest instance using the specified properties.
             * @function create
             * @memberof kritor.event.GroupApplyRequest
             * @static
             * @param {kritor.event.IGroupApplyRequest=} [properties] Properties to set
             * @returns {kritor.event.GroupApplyRequest} GroupApplyRequest instance
             */
            GroupApplyRequest.create = function create(properties) {
                return new GroupApplyRequest(properties);
            };

            /**
             * Encodes the specified GroupApplyRequest message. Does not implicitly {@link kritor.event.GroupApplyRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.GroupApplyRequest
             * @static
             * @param {kritor.event.IGroupApplyRequest} message GroupApplyRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupApplyRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                if (message.applierUid != null && Object.hasOwnProperty.call(message, "applierUid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.applierUid);
                if (message.applierUin != null && Object.hasOwnProperty.call(message, "applierUin"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.applierUin);
                if (message.inviterUid != null && Object.hasOwnProperty.call(message, "inviterUid"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.inviterUid);
                if (message.inviterUin != null && Object.hasOwnProperty.call(message, "inviterUin"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.inviterUin);
                if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.reason);
                if (message.flag != null && Object.hasOwnProperty.call(message, "flag"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.flag);
                return writer;
            };

            /**
             * Encodes the specified GroupApplyRequest message, length delimited. Does not implicitly {@link kritor.event.GroupApplyRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.GroupApplyRequest
             * @static
             * @param {kritor.event.IGroupApplyRequest} message GroupApplyRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupApplyRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupApplyRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.GroupApplyRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.GroupApplyRequest} GroupApplyRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupApplyRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.GroupApplyRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.applierUid = reader.string();
                            break;
                        }
                    case 3: {
                            message.applierUin = reader.uint64();
                            break;
                        }
                    case 4: {
                            message.inviterUid = reader.string();
                            break;
                        }
                    case 5: {
                            message.inviterUin = reader.uint64();
                            break;
                        }
                    case 6: {
                            message.reason = reader.string();
                            break;
                        }
                    case 7: {
                            message.flag = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupApplyRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.GroupApplyRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.GroupApplyRequest} GroupApplyRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupApplyRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupApplyRequest message.
             * @function verify
             * @memberof kritor.event.GroupApplyRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupApplyRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                if (message.applierUid != null && message.hasOwnProperty("applierUid"))
                    if (!$util.isString(message.applierUid))
                        return "applierUid: string expected";
                if (message.applierUin != null && message.hasOwnProperty("applierUin"))
                    if (!$util.isInteger(message.applierUin) && !(message.applierUin && $util.isInteger(message.applierUin.low) && $util.isInteger(message.applierUin.high)))
                        return "applierUin: integer|Long expected";
                if (message.inviterUid != null && message.hasOwnProperty("inviterUid"))
                    if (!$util.isString(message.inviterUid))
                        return "inviterUid: string expected";
                if (message.inviterUin != null && message.hasOwnProperty("inviterUin"))
                    if (!$util.isInteger(message.inviterUin) && !(message.inviterUin && $util.isInteger(message.inviterUin.low) && $util.isInteger(message.inviterUin.high)))
                        return "inviterUin: integer|Long expected";
                if (message.reason != null && message.hasOwnProperty("reason"))
                    if (!$util.isString(message.reason))
                        return "reason: string expected";
                if (message.flag != null && message.hasOwnProperty("flag"))
                    if (!$util.isString(message.flag))
                        return "flag: string expected";
                return null;
            };

            /**
             * Creates a GroupApplyRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.GroupApplyRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.GroupApplyRequest} GroupApplyRequest
             */
            GroupApplyRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.GroupApplyRequest)
                    return object;
                let message = new $root.kritor.event.GroupApplyRequest();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                if (object.applierUid != null)
                    message.applierUid = String(object.applierUid);
                if (object.applierUin != null)
                    if ($util.Long)
                        (message.applierUin = $util.Long.fromValue(object.applierUin)).unsigned = true;
                    else if (typeof object.applierUin === "string")
                        message.applierUin = parseInt(object.applierUin, 10);
                    else if (typeof object.applierUin === "number")
                        message.applierUin = object.applierUin;
                    else if (typeof object.applierUin === "object")
                        message.applierUin = new $util.LongBits(object.applierUin.low >>> 0, object.applierUin.high >>> 0).toNumber(true);
                if (object.inviterUid != null)
                    message.inviterUid = String(object.inviterUid);
                if (object.inviterUin != null)
                    if ($util.Long)
                        (message.inviterUin = $util.Long.fromValue(object.inviterUin)).unsigned = true;
                    else if (typeof object.inviterUin === "string")
                        message.inviterUin = parseInt(object.inviterUin, 10);
                    else if (typeof object.inviterUin === "number")
                        message.inviterUin = object.inviterUin;
                    else if (typeof object.inviterUin === "object")
                        message.inviterUin = new $util.LongBits(object.inviterUin.low >>> 0, object.inviterUin.high >>> 0).toNumber(true);
                if (object.reason != null)
                    message.reason = String(object.reason);
                if (object.flag != null)
                    message.flag = String(object.flag);
                return message;
            };

            /**
             * Creates a plain object from a GroupApplyRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.GroupApplyRequest
             * @static
             * @param {kritor.event.GroupApplyRequest} message GroupApplyRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupApplyRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                    object.applierUid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.applierUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.applierUin = options.longs === String ? "0" : 0;
                    object.inviterUid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.inviterUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.inviterUin = options.longs === String ? "0" : 0;
                    object.reason = "";
                    object.flag = "";
                }
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                if (message.applierUid != null && message.hasOwnProperty("applierUid"))
                    object.applierUid = message.applierUid;
                if (message.applierUin != null && message.hasOwnProperty("applierUin"))
                    if (typeof message.applierUin === "number")
                        object.applierUin = options.longs === String ? String(message.applierUin) : message.applierUin;
                    else
                        object.applierUin = options.longs === String ? $util.Long.prototype.toString.call(message.applierUin) : options.longs === Number ? new $util.LongBits(message.applierUin.low >>> 0, message.applierUin.high >>> 0).toNumber(true) : message.applierUin;
                if (message.inviterUid != null && message.hasOwnProperty("inviterUid"))
                    object.inviterUid = message.inviterUid;
                if (message.inviterUin != null && message.hasOwnProperty("inviterUin"))
                    if (typeof message.inviterUin === "number")
                        object.inviterUin = options.longs === String ? String(message.inviterUin) : message.inviterUin;
                    else
                        object.inviterUin = options.longs === String ? $util.Long.prototype.toString.call(message.inviterUin) : options.longs === Number ? new $util.LongBits(message.inviterUin.low >>> 0, message.inviterUin.high >>> 0).toNumber(true) : message.inviterUin;
                if (message.reason != null && message.hasOwnProperty("reason"))
                    object.reason = message.reason;
                if (message.flag != null && message.hasOwnProperty("flag"))
                    object.flag = message.flag;
                return object;
            };

            /**
             * Converts this GroupApplyRequest to JSON.
             * @function toJSON
             * @memberof kritor.event.GroupApplyRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupApplyRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GroupApplyRequest
             * @function getTypeUrl
             * @memberof kritor.event.GroupApplyRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GroupApplyRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.GroupApplyRequest";
            };

            return GroupApplyRequest;
        })();

        event.InvitedJoinGroupRequest = (function() {

            /**
             * Properties of an InvitedJoinGroupRequest.
             * @memberof kritor.event
             * @interface IInvitedJoinGroupRequest
             * @property {number|Long|null} [groupId] InvitedJoinGroupRequest groupId
             * @property {string|null} [inviterUid] InvitedJoinGroupRequest inviterUid
             * @property {number|Long|null} [inviterUin] InvitedJoinGroupRequest inviterUin
             * @property {string|null} [flag] InvitedJoinGroupRequest flag
             */

            /**
             * Constructs a new InvitedJoinGroupRequest.
             * @memberof kritor.event
             * @classdesc Represents an InvitedJoinGroupRequest.
             * @implements IInvitedJoinGroupRequest
             * @constructor
             * @param {kritor.event.IInvitedJoinGroupRequest=} [properties] Properties to set
             */
            function InvitedJoinGroupRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * InvitedJoinGroupRequest groupId.
             * @member {number|Long} groupId
             * @memberof kritor.event.InvitedJoinGroupRequest
             * @instance
             */
            InvitedJoinGroupRequest.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * InvitedJoinGroupRequest inviterUid.
             * @member {string} inviterUid
             * @memberof kritor.event.InvitedJoinGroupRequest
             * @instance
             */
            InvitedJoinGroupRequest.prototype.inviterUid = "";

            /**
             * InvitedJoinGroupRequest inviterUin.
             * @member {number|Long} inviterUin
             * @memberof kritor.event.InvitedJoinGroupRequest
             * @instance
             */
            InvitedJoinGroupRequest.prototype.inviterUin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * InvitedJoinGroupRequest flag.
             * @member {string} flag
             * @memberof kritor.event.InvitedJoinGroupRequest
             * @instance
             */
            InvitedJoinGroupRequest.prototype.flag = "";

            /**
             * Creates a new InvitedJoinGroupRequest instance using the specified properties.
             * @function create
             * @memberof kritor.event.InvitedJoinGroupRequest
             * @static
             * @param {kritor.event.IInvitedJoinGroupRequest=} [properties] Properties to set
             * @returns {kritor.event.InvitedJoinGroupRequest} InvitedJoinGroupRequest instance
             */
            InvitedJoinGroupRequest.create = function create(properties) {
                return new InvitedJoinGroupRequest(properties);
            };

            /**
             * Encodes the specified InvitedJoinGroupRequest message. Does not implicitly {@link kritor.event.InvitedJoinGroupRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.event.InvitedJoinGroupRequest
             * @static
             * @param {kritor.event.IInvitedJoinGroupRequest} message InvitedJoinGroupRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            InvitedJoinGroupRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                if (message.inviterUid != null && Object.hasOwnProperty.call(message, "inviterUid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.inviterUid);
                if (message.inviterUin != null && Object.hasOwnProperty.call(message, "inviterUin"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.inviterUin);
                if (message.flag != null && Object.hasOwnProperty.call(message, "flag"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.flag);
                return writer;
            };

            /**
             * Encodes the specified InvitedJoinGroupRequest message, length delimited. Does not implicitly {@link kritor.event.InvitedJoinGroupRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.event.InvitedJoinGroupRequest
             * @static
             * @param {kritor.event.IInvitedJoinGroupRequest} message InvitedJoinGroupRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            InvitedJoinGroupRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an InvitedJoinGroupRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.event.InvitedJoinGroupRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.event.InvitedJoinGroupRequest} InvitedJoinGroupRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            InvitedJoinGroupRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.event.InvitedJoinGroupRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.inviterUid = reader.string();
                            break;
                        }
                    case 3: {
                            message.inviterUin = reader.uint64();
                            break;
                        }
                    case 4: {
                            message.flag = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an InvitedJoinGroupRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.event.InvitedJoinGroupRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.event.InvitedJoinGroupRequest} InvitedJoinGroupRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            InvitedJoinGroupRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an InvitedJoinGroupRequest message.
             * @function verify
             * @memberof kritor.event.InvitedJoinGroupRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            InvitedJoinGroupRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                if (message.inviterUid != null && message.hasOwnProperty("inviterUid"))
                    if (!$util.isString(message.inviterUid))
                        return "inviterUid: string expected";
                if (message.inviterUin != null && message.hasOwnProperty("inviterUin"))
                    if (!$util.isInteger(message.inviterUin) && !(message.inviterUin && $util.isInteger(message.inviterUin.low) && $util.isInteger(message.inviterUin.high)))
                        return "inviterUin: integer|Long expected";
                if (message.flag != null && message.hasOwnProperty("flag"))
                    if (!$util.isString(message.flag))
                        return "flag: string expected";
                return null;
            };

            /**
             * Creates an InvitedJoinGroupRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.event.InvitedJoinGroupRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.event.InvitedJoinGroupRequest} InvitedJoinGroupRequest
             */
            InvitedJoinGroupRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.event.InvitedJoinGroupRequest)
                    return object;
                let message = new $root.kritor.event.InvitedJoinGroupRequest();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                if (object.inviterUid != null)
                    message.inviterUid = String(object.inviterUid);
                if (object.inviterUin != null)
                    if ($util.Long)
                        (message.inviterUin = $util.Long.fromValue(object.inviterUin)).unsigned = true;
                    else if (typeof object.inviterUin === "string")
                        message.inviterUin = parseInt(object.inviterUin, 10);
                    else if (typeof object.inviterUin === "number")
                        message.inviterUin = object.inviterUin;
                    else if (typeof object.inviterUin === "object")
                        message.inviterUin = new $util.LongBits(object.inviterUin.low >>> 0, object.inviterUin.high >>> 0).toNumber(true);
                if (object.flag != null)
                    message.flag = String(object.flag);
                return message;
            };

            /**
             * Creates a plain object from an InvitedJoinGroupRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.event.InvitedJoinGroupRequest
             * @static
             * @param {kritor.event.InvitedJoinGroupRequest} message InvitedJoinGroupRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            InvitedJoinGroupRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                    object.inviterUid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.inviterUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.inviterUin = options.longs === String ? "0" : 0;
                    object.flag = "";
                }
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                if (message.inviterUid != null && message.hasOwnProperty("inviterUid"))
                    object.inviterUid = message.inviterUid;
                if (message.inviterUin != null && message.hasOwnProperty("inviterUin"))
                    if (typeof message.inviterUin === "number")
                        object.inviterUin = options.longs === String ? String(message.inviterUin) : message.inviterUin;
                    else
                        object.inviterUin = options.longs === String ? $util.Long.prototype.toString.call(message.inviterUin) : options.longs === Number ? new $util.LongBits(message.inviterUin.low >>> 0, message.inviterUin.high >>> 0).toNumber(true) : message.inviterUin;
                if (message.flag != null && message.hasOwnProperty("flag"))
                    object.flag = message.flag;
                return object;
            };

            /**
             * Converts this InvitedJoinGroupRequest to JSON.
             * @function toJSON
             * @memberof kritor.event.InvitedJoinGroupRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            InvitedJoinGroupRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for InvitedJoinGroupRequest
             * @function getTypeUrl
             * @memberof kritor.event.InvitedJoinGroupRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            InvitedJoinGroupRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.event.InvitedJoinGroupRequest";
            };

            return InvitedJoinGroupRequest;
        })();

        return event;
    })();

    kritor.file = (function() {

        /**
         * Namespace file.
         * @memberof kritor
         * @namespace
         */
        const file = {};

        file.File = (function() {

            /**
             * Properties of a File.
             * @memberof kritor.file
             * @interface IFile
             * @property {string|null} [fileId] File fileId
             * @property {string|null} [fileName] File fileName
             * @property {number|Long|null} [fileSize] File fileSize
             * @property {number|null} [busId] File busId
             * @property {number|null} [uploadTime] File uploadTime
             * @property {number|null} [deadTime] File deadTime
             * @property {number|null} [modifyTime] File modifyTime
             * @property {number|null} [downloadTimes] File downloadTimes
             * @property {number|Long|null} [uploader] File uploader
             * @property {string|null} [uploaderName] File uploaderName
             * @property {string|null} [sha] File sha
             * @property {string|null} [sha3] File sha3
             * @property {string|null} [md5] File md5
             */

            /**
             * Constructs a new File.
             * @memberof kritor.file
             * @classdesc Represents a File.
             * @implements IFile
             * @constructor
             * @param {kritor.file.IFile=} [properties] Properties to set
             */
            function File(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * File fileId.
             * @member {string} fileId
             * @memberof kritor.file.File
             * @instance
             */
            File.prototype.fileId = "";

            /**
             * File fileName.
             * @member {string} fileName
             * @memberof kritor.file.File
             * @instance
             */
            File.prototype.fileName = "";

            /**
             * File fileSize.
             * @member {number|Long} fileSize
             * @memberof kritor.file.File
             * @instance
             */
            File.prototype.fileSize = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * File busId.
             * @member {number} busId
             * @memberof kritor.file.File
             * @instance
             */
            File.prototype.busId = 0;

            /**
             * File uploadTime.
             * @member {number} uploadTime
             * @memberof kritor.file.File
             * @instance
             */
            File.prototype.uploadTime = 0;

            /**
             * File deadTime.
             * @member {number} deadTime
             * @memberof kritor.file.File
             * @instance
             */
            File.prototype.deadTime = 0;

            /**
             * File modifyTime.
             * @member {number} modifyTime
             * @memberof kritor.file.File
             * @instance
             */
            File.prototype.modifyTime = 0;

            /**
             * File downloadTimes.
             * @member {number} downloadTimes
             * @memberof kritor.file.File
             * @instance
             */
            File.prototype.downloadTimes = 0;

            /**
             * File uploader.
             * @member {number|Long} uploader
             * @memberof kritor.file.File
             * @instance
             */
            File.prototype.uploader = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * File uploaderName.
             * @member {string} uploaderName
             * @memberof kritor.file.File
             * @instance
             */
            File.prototype.uploaderName = "";

            /**
             * File sha.
             * @member {string} sha
             * @memberof kritor.file.File
             * @instance
             */
            File.prototype.sha = "";

            /**
             * File sha3.
             * @member {string} sha3
             * @memberof kritor.file.File
             * @instance
             */
            File.prototype.sha3 = "";

            /**
             * File md5.
             * @member {string} md5
             * @memberof kritor.file.File
             * @instance
             */
            File.prototype.md5 = "";

            /**
             * Creates a new File instance using the specified properties.
             * @function create
             * @memberof kritor.file.File
             * @static
             * @param {kritor.file.IFile=} [properties] Properties to set
             * @returns {kritor.file.File} File instance
             */
            File.create = function create(properties) {
                return new File(properties);
            };

            /**
             * Encodes the specified File message. Does not implicitly {@link kritor.file.File.verify|verify} messages.
             * @function encode
             * @memberof kritor.file.File
             * @static
             * @param {kritor.file.IFile} message File message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            File.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.fileId != null && Object.hasOwnProperty.call(message, "fileId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.fileId);
                if (message.fileName != null && Object.hasOwnProperty.call(message, "fileName"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.fileName);
                if (message.fileSize != null && Object.hasOwnProperty.call(message, "fileSize"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.fileSize);
                if (message.busId != null && Object.hasOwnProperty.call(message, "busId"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.busId);
                if (message.uploadTime != null && Object.hasOwnProperty.call(message, "uploadTime"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.uploadTime);
                if (message.deadTime != null && Object.hasOwnProperty.call(message, "deadTime"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.deadTime);
                if (message.modifyTime != null && Object.hasOwnProperty.call(message, "modifyTime"))
                    writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.modifyTime);
                if (message.downloadTimes != null && Object.hasOwnProperty.call(message, "downloadTimes"))
                    writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.downloadTimes);
                if (message.uploader != null && Object.hasOwnProperty.call(message, "uploader"))
                    writer.uint32(/* id 9, wireType 0 =*/72).uint64(message.uploader);
                if (message.uploaderName != null && Object.hasOwnProperty.call(message, "uploaderName"))
                    writer.uint32(/* id 10, wireType 2 =*/82).string(message.uploaderName);
                if (message.sha != null && Object.hasOwnProperty.call(message, "sha"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.sha);
                if (message.sha3 != null && Object.hasOwnProperty.call(message, "sha3"))
                    writer.uint32(/* id 12, wireType 2 =*/98).string(message.sha3);
                if (message.md5 != null && Object.hasOwnProperty.call(message, "md5"))
                    writer.uint32(/* id 13, wireType 2 =*/106).string(message.md5);
                return writer;
            };

            /**
             * Encodes the specified File message, length delimited. Does not implicitly {@link kritor.file.File.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.file.File
             * @static
             * @param {kritor.file.IFile} message File message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            File.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a File message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.file.File
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.file.File} File
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            File.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.file.File();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.fileId = reader.string();
                            break;
                        }
                    case 2: {
                            message.fileName = reader.string();
                            break;
                        }
                    case 3: {
                            message.fileSize = reader.uint64();
                            break;
                        }
                    case 4: {
                            message.busId = reader.int32();
                            break;
                        }
                    case 5: {
                            message.uploadTime = reader.uint32();
                            break;
                        }
                    case 6: {
                            message.deadTime = reader.uint32();
                            break;
                        }
                    case 7: {
                            message.modifyTime = reader.uint32();
                            break;
                        }
                    case 8: {
                            message.downloadTimes = reader.uint32();
                            break;
                        }
                    case 9: {
                            message.uploader = reader.uint64();
                            break;
                        }
                    case 10: {
                            message.uploaderName = reader.string();
                            break;
                        }
                    case 11: {
                            message.sha = reader.string();
                            break;
                        }
                    case 12: {
                            message.sha3 = reader.string();
                            break;
                        }
                    case 13: {
                            message.md5 = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a File message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.file.File
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.file.File} File
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            File.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a File message.
             * @function verify
             * @memberof kritor.file.File
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            File.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.fileId != null && message.hasOwnProperty("fileId"))
                    if (!$util.isString(message.fileId))
                        return "fileId: string expected";
                if (message.fileName != null && message.hasOwnProperty("fileName"))
                    if (!$util.isString(message.fileName))
                        return "fileName: string expected";
                if (message.fileSize != null && message.hasOwnProperty("fileSize"))
                    if (!$util.isInteger(message.fileSize) && !(message.fileSize && $util.isInteger(message.fileSize.low) && $util.isInteger(message.fileSize.high)))
                        return "fileSize: integer|Long expected";
                if (message.busId != null && message.hasOwnProperty("busId"))
                    if (!$util.isInteger(message.busId))
                        return "busId: integer expected";
                if (message.uploadTime != null && message.hasOwnProperty("uploadTime"))
                    if (!$util.isInteger(message.uploadTime))
                        return "uploadTime: integer expected";
                if (message.deadTime != null && message.hasOwnProperty("deadTime"))
                    if (!$util.isInteger(message.deadTime))
                        return "deadTime: integer expected";
                if (message.modifyTime != null && message.hasOwnProperty("modifyTime"))
                    if (!$util.isInteger(message.modifyTime))
                        return "modifyTime: integer expected";
                if (message.downloadTimes != null && message.hasOwnProperty("downloadTimes"))
                    if (!$util.isInteger(message.downloadTimes))
                        return "downloadTimes: integer expected";
                if (message.uploader != null && message.hasOwnProperty("uploader"))
                    if (!$util.isInteger(message.uploader) && !(message.uploader && $util.isInteger(message.uploader.low) && $util.isInteger(message.uploader.high)))
                        return "uploader: integer|Long expected";
                if (message.uploaderName != null && message.hasOwnProperty("uploaderName"))
                    if (!$util.isString(message.uploaderName))
                        return "uploaderName: string expected";
                if (message.sha != null && message.hasOwnProperty("sha"))
                    if (!$util.isString(message.sha))
                        return "sha: string expected";
                if (message.sha3 != null && message.hasOwnProperty("sha3"))
                    if (!$util.isString(message.sha3))
                        return "sha3: string expected";
                if (message.md5 != null && message.hasOwnProperty("md5"))
                    if (!$util.isString(message.md5))
                        return "md5: string expected";
                return null;
            };

            /**
             * Creates a File message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.file.File
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.file.File} File
             */
            File.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.file.File)
                    return object;
                let message = new $root.kritor.file.File();
                if (object.fileId != null)
                    message.fileId = String(object.fileId);
                if (object.fileName != null)
                    message.fileName = String(object.fileName);
                if (object.fileSize != null)
                    if ($util.Long)
                        (message.fileSize = $util.Long.fromValue(object.fileSize)).unsigned = true;
                    else if (typeof object.fileSize === "string")
                        message.fileSize = parseInt(object.fileSize, 10);
                    else if (typeof object.fileSize === "number")
                        message.fileSize = object.fileSize;
                    else if (typeof object.fileSize === "object")
                        message.fileSize = new $util.LongBits(object.fileSize.low >>> 0, object.fileSize.high >>> 0).toNumber(true);
                if (object.busId != null)
                    message.busId = object.busId | 0;
                if (object.uploadTime != null)
                    message.uploadTime = object.uploadTime >>> 0;
                if (object.deadTime != null)
                    message.deadTime = object.deadTime >>> 0;
                if (object.modifyTime != null)
                    message.modifyTime = object.modifyTime >>> 0;
                if (object.downloadTimes != null)
                    message.downloadTimes = object.downloadTimes >>> 0;
                if (object.uploader != null)
                    if ($util.Long)
                        (message.uploader = $util.Long.fromValue(object.uploader)).unsigned = true;
                    else if (typeof object.uploader === "string")
                        message.uploader = parseInt(object.uploader, 10);
                    else if (typeof object.uploader === "number")
                        message.uploader = object.uploader;
                    else if (typeof object.uploader === "object")
                        message.uploader = new $util.LongBits(object.uploader.low >>> 0, object.uploader.high >>> 0).toNumber(true);
                if (object.uploaderName != null)
                    message.uploaderName = String(object.uploaderName);
                if (object.sha != null)
                    message.sha = String(object.sha);
                if (object.sha3 != null)
                    message.sha3 = String(object.sha3);
                if (object.md5 != null)
                    message.md5 = String(object.md5);
                return message;
            };

            /**
             * Creates a plain object from a File message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.file.File
             * @static
             * @param {kritor.file.File} message File
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            File.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.fileId = "";
                    object.fileName = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.fileSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.fileSize = options.longs === String ? "0" : 0;
                    object.busId = 0;
                    object.uploadTime = 0;
                    object.deadTime = 0;
                    object.modifyTime = 0;
                    object.downloadTimes = 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.uploader = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.uploader = options.longs === String ? "0" : 0;
                    object.uploaderName = "";
                    object.sha = "";
                    object.sha3 = "";
                    object.md5 = "";
                }
                if (message.fileId != null && message.hasOwnProperty("fileId"))
                    object.fileId = message.fileId;
                if (message.fileName != null && message.hasOwnProperty("fileName"))
                    object.fileName = message.fileName;
                if (message.fileSize != null && message.hasOwnProperty("fileSize"))
                    if (typeof message.fileSize === "number")
                        object.fileSize = options.longs === String ? String(message.fileSize) : message.fileSize;
                    else
                        object.fileSize = options.longs === String ? $util.Long.prototype.toString.call(message.fileSize) : options.longs === Number ? new $util.LongBits(message.fileSize.low >>> 0, message.fileSize.high >>> 0).toNumber(true) : message.fileSize;
                if (message.busId != null && message.hasOwnProperty("busId"))
                    object.busId = message.busId;
                if (message.uploadTime != null && message.hasOwnProperty("uploadTime"))
                    object.uploadTime = message.uploadTime;
                if (message.deadTime != null && message.hasOwnProperty("deadTime"))
                    object.deadTime = message.deadTime;
                if (message.modifyTime != null && message.hasOwnProperty("modifyTime"))
                    object.modifyTime = message.modifyTime;
                if (message.downloadTimes != null && message.hasOwnProperty("downloadTimes"))
                    object.downloadTimes = message.downloadTimes;
                if (message.uploader != null && message.hasOwnProperty("uploader"))
                    if (typeof message.uploader === "number")
                        object.uploader = options.longs === String ? String(message.uploader) : message.uploader;
                    else
                        object.uploader = options.longs === String ? $util.Long.prototype.toString.call(message.uploader) : options.longs === Number ? new $util.LongBits(message.uploader.low >>> 0, message.uploader.high >>> 0).toNumber(true) : message.uploader;
                if (message.uploaderName != null && message.hasOwnProperty("uploaderName"))
                    object.uploaderName = message.uploaderName;
                if (message.sha != null && message.hasOwnProperty("sha"))
                    object.sha = message.sha;
                if (message.sha3 != null && message.hasOwnProperty("sha3"))
                    object.sha3 = message.sha3;
                if (message.md5 != null && message.hasOwnProperty("md5"))
                    object.md5 = message.md5;
                return object;
            };

            /**
             * Converts this File to JSON.
             * @function toJSON
             * @memberof kritor.file.File
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            File.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for File
             * @function getTypeUrl
             * @memberof kritor.file.File
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            File.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.file.File";
            };

            return File;
        })();

        file.Folder = (function() {

            /**
             * Properties of a Folder.
             * @memberof kritor.file
             * @interface IFolder
             * @property {string|null} [folderId] Folder folderId
             * @property {string|null} [folderName] Folder folderName
             * @property {number|null} [totalFileCount] Folder totalFileCount
             * @property {number|null} [createTime] Folder createTime
             * @property {number|Long|null} [creator] Folder creator
             * @property {string|null} [creatorName] Folder creatorName
             */

            /**
             * Constructs a new Folder.
             * @memberof kritor.file
             * @classdesc Represents a Folder.
             * @implements IFolder
             * @constructor
             * @param {kritor.file.IFolder=} [properties] Properties to set
             */
            function Folder(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Folder folderId.
             * @member {string} folderId
             * @memberof kritor.file.Folder
             * @instance
             */
            Folder.prototype.folderId = "";

            /**
             * Folder folderName.
             * @member {string} folderName
             * @memberof kritor.file.Folder
             * @instance
             */
            Folder.prototype.folderName = "";

            /**
             * Folder totalFileCount.
             * @member {number} totalFileCount
             * @memberof kritor.file.Folder
             * @instance
             */
            Folder.prototype.totalFileCount = 0;

            /**
             * Folder createTime.
             * @member {number} createTime
             * @memberof kritor.file.Folder
             * @instance
             */
            Folder.prototype.createTime = 0;

            /**
             * Folder creator.
             * @member {number|Long} creator
             * @memberof kritor.file.Folder
             * @instance
             */
            Folder.prototype.creator = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Folder creatorName.
             * @member {string} creatorName
             * @memberof kritor.file.Folder
             * @instance
             */
            Folder.prototype.creatorName = "";

            /**
             * Creates a new Folder instance using the specified properties.
             * @function create
             * @memberof kritor.file.Folder
             * @static
             * @param {kritor.file.IFolder=} [properties] Properties to set
             * @returns {kritor.file.Folder} Folder instance
             */
            Folder.create = function create(properties) {
                return new Folder(properties);
            };

            /**
             * Encodes the specified Folder message. Does not implicitly {@link kritor.file.Folder.verify|verify} messages.
             * @function encode
             * @memberof kritor.file.Folder
             * @static
             * @param {kritor.file.IFolder} message Folder message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Folder.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.folderId != null && Object.hasOwnProperty.call(message, "folderId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.folderId);
                if (message.folderName != null && Object.hasOwnProperty.call(message, "folderName"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.folderName);
                if (message.totalFileCount != null && Object.hasOwnProperty.call(message, "totalFileCount"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.totalFileCount);
                if (message.createTime != null && Object.hasOwnProperty.call(message, "createTime"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.createTime);
                if (message.creator != null && Object.hasOwnProperty.call(message, "creator"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.creator);
                if (message.creatorName != null && Object.hasOwnProperty.call(message, "creatorName"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.creatorName);
                return writer;
            };

            /**
             * Encodes the specified Folder message, length delimited. Does not implicitly {@link kritor.file.Folder.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.file.Folder
             * @static
             * @param {kritor.file.IFolder} message Folder message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Folder.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Folder message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.file.Folder
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.file.Folder} Folder
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Folder.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.file.Folder();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.folderId = reader.string();
                            break;
                        }
                    case 2: {
                            message.folderName = reader.string();
                            break;
                        }
                    case 3: {
                            message.totalFileCount = reader.uint32();
                            break;
                        }
                    case 4: {
                            message.createTime = reader.uint32();
                            break;
                        }
                    case 5: {
                            message.creator = reader.uint64();
                            break;
                        }
                    case 6: {
                            message.creatorName = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Folder message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.file.Folder
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.file.Folder} Folder
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Folder.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Folder message.
             * @function verify
             * @memberof kritor.file.Folder
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Folder.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.folderId != null && message.hasOwnProperty("folderId"))
                    if (!$util.isString(message.folderId))
                        return "folderId: string expected";
                if (message.folderName != null && message.hasOwnProperty("folderName"))
                    if (!$util.isString(message.folderName))
                        return "folderName: string expected";
                if (message.totalFileCount != null && message.hasOwnProperty("totalFileCount"))
                    if (!$util.isInteger(message.totalFileCount))
                        return "totalFileCount: integer expected";
                if (message.createTime != null && message.hasOwnProperty("createTime"))
                    if (!$util.isInteger(message.createTime))
                        return "createTime: integer expected";
                if (message.creator != null && message.hasOwnProperty("creator"))
                    if (!$util.isInteger(message.creator) && !(message.creator && $util.isInteger(message.creator.low) && $util.isInteger(message.creator.high)))
                        return "creator: integer|Long expected";
                if (message.creatorName != null && message.hasOwnProperty("creatorName"))
                    if (!$util.isString(message.creatorName))
                        return "creatorName: string expected";
                return null;
            };

            /**
             * Creates a Folder message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.file.Folder
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.file.Folder} Folder
             */
            Folder.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.file.Folder)
                    return object;
                let message = new $root.kritor.file.Folder();
                if (object.folderId != null)
                    message.folderId = String(object.folderId);
                if (object.folderName != null)
                    message.folderName = String(object.folderName);
                if (object.totalFileCount != null)
                    message.totalFileCount = object.totalFileCount >>> 0;
                if (object.createTime != null)
                    message.createTime = object.createTime >>> 0;
                if (object.creator != null)
                    if ($util.Long)
                        (message.creator = $util.Long.fromValue(object.creator)).unsigned = true;
                    else if (typeof object.creator === "string")
                        message.creator = parseInt(object.creator, 10);
                    else if (typeof object.creator === "number")
                        message.creator = object.creator;
                    else if (typeof object.creator === "object")
                        message.creator = new $util.LongBits(object.creator.low >>> 0, object.creator.high >>> 0).toNumber(true);
                if (object.creatorName != null)
                    message.creatorName = String(object.creatorName);
                return message;
            };

            /**
             * Creates a plain object from a Folder message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.file.Folder
             * @static
             * @param {kritor.file.Folder} message Folder
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Folder.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.folderId = "";
                    object.folderName = "";
                    object.totalFileCount = 0;
                    object.createTime = 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.creator = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.creator = options.longs === String ? "0" : 0;
                    object.creatorName = "";
                }
                if (message.folderId != null && message.hasOwnProperty("folderId"))
                    object.folderId = message.folderId;
                if (message.folderName != null && message.hasOwnProperty("folderName"))
                    object.folderName = message.folderName;
                if (message.totalFileCount != null && message.hasOwnProperty("totalFileCount"))
                    object.totalFileCount = message.totalFileCount;
                if (message.createTime != null && message.hasOwnProperty("createTime"))
                    object.createTime = message.createTime;
                if (message.creator != null && message.hasOwnProperty("creator"))
                    if (typeof message.creator === "number")
                        object.creator = options.longs === String ? String(message.creator) : message.creator;
                    else
                        object.creator = options.longs === String ? $util.Long.prototype.toString.call(message.creator) : options.longs === Number ? new $util.LongBits(message.creator.low >>> 0, message.creator.high >>> 0).toNumber(true) : message.creator;
                if (message.creatorName != null && message.hasOwnProperty("creatorName"))
                    object.creatorName = message.creatorName;
                return object;
            };

            /**
             * Converts this Folder to JSON.
             * @function toJSON
             * @memberof kritor.file.Folder
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Folder.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Folder
             * @function getTypeUrl
             * @memberof kritor.file.Folder
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Folder.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.file.Folder";
            };

            return Folder;
        })();

        file.GroupFileService = (function() {

            /**
             * Constructs a new GroupFileService service.
             * @memberof kritor.file
             * @classdesc Represents a GroupFileService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function GroupFileService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (GroupFileService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = GroupFileService;

            /**
             * Creates new GroupFileService service using the specified rpc implementation.
             * @function create
             * @memberof kritor.file.GroupFileService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {GroupFileService} RPC service. Useful where requests and/or responses are streamed.
             */
            GroupFileService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link kritor.file.GroupFileService#createFolder}.
             * @memberof kritor.file.GroupFileService
             * @typedef CreateFolderCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.file.CreateFolderResponse} [response] CreateFolderResponse
             */

            /**
             * Calls CreateFolder.
             * @function createFolder
             * @memberof kritor.file.GroupFileService
             * @instance
             * @param {kritor.file.ICreateFolderRequest} request CreateFolderRequest message or plain object
             * @param {kritor.file.GroupFileService.CreateFolderCallback} callback Node-style callback called with the error, if any, and CreateFolderResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GroupFileService.prototype.createFolder = function createFolder(request, callback) {
                return this.rpcCall(createFolder, $root.kritor.file.CreateFolderRequest, $root.kritor.file.CreateFolderResponse, request, callback);
            }, "name", { value: "CreateFolder" });

            /**
             * Calls CreateFolder.
             * @function createFolder
             * @memberof kritor.file.GroupFileService
             * @instance
             * @param {kritor.file.ICreateFolderRequest} request CreateFolderRequest message or plain object
             * @returns {Promise<kritor.file.CreateFolderResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.file.GroupFileService#renameFolder}.
             * @memberof kritor.file.GroupFileService
             * @typedef RenameFolderCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.file.RenameFolderResponse} [response] RenameFolderResponse
             */

            /**
             * Calls RenameFolder.
             * @function renameFolder
             * @memberof kritor.file.GroupFileService
             * @instance
             * @param {kritor.file.IRenameFolderRequest} request RenameFolderRequest message or plain object
             * @param {kritor.file.GroupFileService.RenameFolderCallback} callback Node-style callback called with the error, if any, and RenameFolderResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GroupFileService.prototype.renameFolder = function renameFolder(request, callback) {
                return this.rpcCall(renameFolder, $root.kritor.file.RenameFolderRequest, $root.kritor.file.RenameFolderResponse, request, callback);
            }, "name", { value: "RenameFolder" });

            /**
             * Calls RenameFolder.
             * @function renameFolder
             * @memberof kritor.file.GroupFileService
             * @instance
             * @param {kritor.file.IRenameFolderRequest} request RenameFolderRequest message or plain object
             * @returns {Promise<kritor.file.RenameFolderResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.file.GroupFileService#deleteFolder}.
             * @memberof kritor.file.GroupFileService
             * @typedef DeleteFolderCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.file.DeleteFolderResponse} [response] DeleteFolderResponse
             */

            /**
             * Calls DeleteFolder.
             * @function deleteFolder
             * @memberof kritor.file.GroupFileService
             * @instance
             * @param {kritor.file.IDeleteFolderRequest} request DeleteFolderRequest message or plain object
             * @param {kritor.file.GroupFileService.DeleteFolderCallback} callback Node-style callback called with the error, if any, and DeleteFolderResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GroupFileService.prototype.deleteFolder = function deleteFolder(request, callback) {
                return this.rpcCall(deleteFolder, $root.kritor.file.DeleteFolderRequest, $root.kritor.file.DeleteFolderResponse, request, callback);
            }, "name", { value: "DeleteFolder" });

            /**
             * Calls DeleteFolder.
             * @function deleteFolder
             * @memberof kritor.file.GroupFileService
             * @instance
             * @param {kritor.file.IDeleteFolderRequest} request DeleteFolderRequest message or plain object
             * @returns {Promise<kritor.file.DeleteFolderResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.file.GroupFileService#uploadFile}.
             * @memberof kritor.file.GroupFileService
             * @typedef UploadFileCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.file.UploadFileResponse} [response] UploadFileResponse
             */

            /**
             * Calls UploadFile.
             * @function uploadFile
             * @memberof kritor.file.GroupFileService
             * @instance
             * @param {kritor.file.IUploadFileRequest} request UploadFileRequest message or plain object
             * @param {kritor.file.GroupFileService.UploadFileCallback} callback Node-style callback called with the error, if any, and UploadFileResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GroupFileService.prototype.uploadFile = function uploadFile(request, callback) {
                return this.rpcCall(uploadFile, $root.kritor.file.UploadFileRequest, $root.kritor.file.UploadFileResponse, request, callback);
            }, "name", { value: "UploadFile" });

            /**
             * Calls UploadFile.
             * @function uploadFile
             * @memberof kritor.file.GroupFileService
             * @instance
             * @param {kritor.file.IUploadFileRequest} request UploadFileRequest message or plain object
             * @returns {Promise<kritor.file.UploadFileResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.file.GroupFileService#deleteFile}.
             * @memberof kritor.file.GroupFileService
             * @typedef DeleteFileCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.file.DeleteFileResponse} [response] DeleteFileResponse
             */

            /**
             * Calls DeleteFile.
             * @function deleteFile
             * @memberof kritor.file.GroupFileService
             * @instance
             * @param {kritor.file.IDeleteFileRequest} request DeleteFileRequest message or plain object
             * @param {kritor.file.GroupFileService.DeleteFileCallback} callback Node-style callback called with the error, if any, and DeleteFileResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GroupFileService.prototype.deleteFile = function deleteFile(request, callback) {
                return this.rpcCall(deleteFile, $root.kritor.file.DeleteFileRequest, $root.kritor.file.DeleteFileResponse, request, callback);
            }, "name", { value: "DeleteFile" });

            /**
             * Calls DeleteFile.
             * @function deleteFile
             * @memberof kritor.file.GroupFileService
             * @instance
             * @param {kritor.file.IDeleteFileRequest} request DeleteFileRequest message or plain object
             * @returns {Promise<kritor.file.DeleteFileResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.file.GroupFileService#getFileSystemInfo}.
             * @memberof kritor.file.GroupFileService
             * @typedef GetFileSystemInfoCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.file.GetFileSystemInfoResponse} [response] GetFileSystemInfoResponse
             */

            /**
             * Calls GetFileSystemInfo.
             * @function getFileSystemInfo
             * @memberof kritor.file.GroupFileService
             * @instance
             * @param {kritor.file.IGetFileSystemInfoRequest} request GetFileSystemInfoRequest message or plain object
             * @param {kritor.file.GroupFileService.GetFileSystemInfoCallback} callback Node-style callback called with the error, if any, and GetFileSystemInfoResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GroupFileService.prototype.getFileSystemInfo = function getFileSystemInfo(request, callback) {
                return this.rpcCall(getFileSystemInfo, $root.kritor.file.GetFileSystemInfoRequest, $root.kritor.file.GetFileSystemInfoResponse, request, callback);
            }, "name", { value: "GetFileSystemInfo" });

            /**
             * Calls GetFileSystemInfo.
             * @function getFileSystemInfo
             * @memberof kritor.file.GroupFileService
             * @instance
             * @param {kritor.file.IGetFileSystemInfoRequest} request GetFileSystemInfoRequest message or plain object
             * @returns {Promise<kritor.file.GetFileSystemInfoResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.file.GroupFileService#getFileList}.
             * @memberof kritor.file.GroupFileService
             * @typedef GetFileListCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.file.GetFileListResponse} [response] GetFileListResponse
             */

            /**
             * Calls GetFileList.
             * @function getFileList
             * @memberof kritor.file.GroupFileService
             * @instance
             * @param {kritor.file.IGetFileListRequest} request GetFileListRequest message or plain object
             * @param {kritor.file.GroupFileService.GetFileListCallback} callback Node-style callback called with the error, if any, and GetFileListResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GroupFileService.prototype.getFileList = function getFileList(request, callback) {
                return this.rpcCall(getFileList, $root.kritor.file.GetFileListRequest, $root.kritor.file.GetFileListResponse, request, callback);
            }, "name", { value: "GetFileList" });

            /**
             * Calls GetFileList.
             * @function getFileList
             * @memberof kritor.file.GroupFileService
             * @instance
             * @param {kritor.file.IGetFileListRequest} request GetFileListRequest message or plain object
             * @returns {Promise<kritor.file.GetFileListResponse>} Promise
             * @variation 2
             */

            return GroupFileService;
        })();

        file.CreateFolderRequest = (function() {

            /**
             * Properties of a CreateFolderRequest.
             * @memberof kritor.file
             * @interface ICreateFolderRequest
             * @property {number|Long|null} [groupId] CreateFolderRequest groupId
             * @property {string|null} [name] CreateFolderRequest name
             */

            /**
             * Constructs a new CreateFolderRequest.
             * @memberof kritor.file
             * @classdesc Represents a CreateFolderRequest.
             * @implements ICreateFolderRequest
             * @constructor
             * @param {kritor.file.ICreateFolderRequest=} [properties] Properties to set
             */
            function CreateFolderRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CreateFolderRequest groupId.
             * @member {number|Long} groupId
             * @memberof kritor.file.CreateFolderRequest
             * @instance
             */
            CreateFolderRequest.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * CreateFolderRequest name.
             * @member {string} name
             * @memberof kritor.file.CreateFolderRequest
             * @instance
             */
            CreateFolderRequest.prototype.name = "";

            /**
             * Creates a new CreateFolderRequest instance using the specified properties.
             * @function create
             * @memberof kritor.file.CreateFolderRequest
             * @static
             * @param {kritor.file.ICreateFolderRequest=} [properties] Properties to set
             * @returns {kritor.file.CreateFolderRequest} CreateFolderRequest instance
             */
            CreateFolderRequest.create = function create(properties) {
                return new CreateFolderRequest(properties);
            };

            /**
             * Encodes the specified CreateFolderRequest message. Does not implicitly {@link kritor.file.CreateFolderRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.file.CreateFolderRequest
             * @static
             * @param {kritor.file.ICreateFolderRequest} message CreateFolderRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateFolderRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                return writer;
            };

            /**
             * Encodes the specified CreateFolderRequest message, length delimited. Does not implicitly {@link kritor.file.CreateFolderRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.file.CreateFolderRequest
             * @static
             * @param {kritor.file.ICreateFolderRequest} message CreateFolderRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateFolderRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CreateFolderRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.file.CreateFolderRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.file.CreateFolderRequest} CreateFolderRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateFolderRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.file.CreateFolderRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.name = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CreateFolderRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.file.CreateFolderRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.file.CreateFolderRequest} CreateFolderRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateFolderRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CreateFolderRequest message.
             * @function verify
             * @memberof kritor.file.CreateFolderRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CreateFolderRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                return null;
            };

            /**
             * Creates a CreateFolderRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.file.CreateFolderRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.file.CreateFolderRequest} CreateFolderRequest
             */
            CreateFolderRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.file.CreateFolderRequest)
                    return object;
                let message = new $root.kritor.file.CreateFolderRequest();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                if (object.name != null)
                    message.name = String(object.name);
                return message;
            };

            /**
             * Creates a plain object from a CreateFolderRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.file.CreateFolderRequest
             * @static
             * @param {kritor.file.CreateFolderRequest} message CreateFolderRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CreateFolderRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                    object.name = "";
                }
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                return object;
            };

            /**
             * Converts this CreateFolderRequest to JSON.
             * @function toJSON
             * @memberof kritor.file.CreateFolderRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CreateFolderRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for CreateFolderRequest
             * @function getTypeUrl
             * @memberof kritor.file.CreateFolderRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            CreateFolderRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.file.CreateFolderRequest";
            };

            return CreateFolderRequest;
        })();

        file.CreateFolderResponse = (function() {

            /**
             * Properties of a CreateFolderResponse.
             * @memberof kritor.file
             * @interface ICreateFolderResponse
             * @property {string|null} [id] CreateFolderResponse id
             * @property {number|Long|null} [usedSpace] CreateFolderResponse usedSpace
             */

            /**
             * Constructs a new CreateFolderResponse.
             * @memberof kritor.file
             * @classdesc Represents a CreateFolderResponse.
             * @implements ICreateFolderResponse
             * @constructor
             * @param {kritor.file.ICreateFolderResponse=} [properties] Properties to set
             */
            function CreateFolderResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CreateFolderResponse id.
             * @member {string} id
             * @memberof kritor.file.CreateFolderResponse
             * @instance
             */
            CreateFolderResponse.prototype.id = "";

            /**
             * CreateFolderResponse usedSpace.
             * @member {number|Long} usedSpace
             * @memberof kritor.file.CreateFolderResponse
             * @instance
             */
            CreateFolderResponse.prototype.usedSpace = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new CreateFolderResponse instance using the specified properties.
             * @function create
             * @memberof kritor.file.CreateFolderResponse
             * @static
             * @param {kritor.file.ICreateFolderResponse=} [properties] Properties to set
             * @returns {kritor.file.CreateFolderResponse} CreateFolderResponse instance
             */
            CreateFolderResponse.create = function create(properties) {
                return new CreateFolderResponse(properties);
            };

            /**
             * Encodes the specified CreateFolderResponse message. Does not implicitly {@link kritor.file.CreateFolderResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.file.CreateFolderResponse
             * @static
             * @param {kritor.file.ICreateFolderResponse} message CreateFolderResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateFolderResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.usedSpace != null && Object.hasOwnProperty.call(message, "usedSpace"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.usedSpace);
                return writer;
            };

            /**
             * Encodes the specified CreateFolderResponse message, length delimited. Does not implicitly {@link kritor.file.CreateFolderResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.file.CreateFolderResponse
             * @static
             * @param {kritor.file.ICreateFolderResponse} message CreateFolderResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateFolderResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CreateFolderResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.file.CreateFolderResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.file.CreateFolderResponse} CreateFolderResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateFolderResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.file.CreateFolderResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.id = reader.string();
                            break;
                        }
                    case 2: {
                            message.usedSpace = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CreateFolderResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.file.CreateFolderResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.file.CreateFolderResponse} CreateFolderResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateFolderResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CreateFolderResponse message.
             * @function verify
             * @memberof kritor.file.CreateFolderResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CreateFolderResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.usedSpace != null && message.hasOwnProperty("usedSpace"))
                    if (!$util.isInteger(message.usedSpace) && !(message.usedSpace && $util.isInteger(message.usedSpace.low) && $util.isInteger(message.usedSpace.high)))
                        return "usedSpace: integer|Long expected";
                return null;
            };

            /**
             * Creates a CreateFolderResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.file.CreateFolderResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.file.CreateFolderResponse} CreateFolderResponse
             */
            CreateFolderResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.file.CreateFolderResponse)
                    return object;
                let message = new $root.kritor.file.CreateFolderResponse();
                if (object.id != null)
                    message.id = String(object.id);
                if (object.usedSpace != null)
                    if ($util.Long)
                        (message.usedSpace = $util.Long.fromValue(object.usedSpace)).unsigned = true;
                    else if (typeof object.usedSpace === "string")
                        message.usedSpace = parseInt(object.usedSpace, 10);
                    else if (typeof object.usedSpace === "number")
                        message.usedSpace = object.usedSpace;
                    else if (typeof object.usedSpace === "object")
                        message.usedSpace = new $util.LongBits(object.usedSpace.low >>> 0, object.usedSpace.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a CreateFolderResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.file.CreateFolderResponse
             * @static
             * @param {kritor.file.CreateFolderResponse} message CreateFolderResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CreateFolderResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.id = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.usedSpace = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.usedSpace = options.longs === String ? "0" : 0;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.usedSpace != null && message.hasOwnProperty("usedSpace"))
                    if (typeof message.usedSpace === "number")
                        object.usedSpace = options.longs === String ? String(message.usedSpace) : message.usedSpace;
                    else
                        object.usedSpace = options.longs === String ? $util.Long.prototype.toString.call(message.usedSpace) : options.longs === Number ? new $util.LongBits(message.usedSpace.low >>> 0, message.usedSpace.high >>> 0).toNumber(true) : message.usedSpace;
                return object;
            };

            /**
             * Converts this CreateFolderResponse to JSON.
             * @function toJSON
             * @memberof kritor.file.CreateFolderResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CreateFolderResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for CreateFolderResponse
             * @function getTypeUrl
             * @memberof kritor.file.CreateFolderResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            CreateFolderResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.file.CreateFolderResponse";
            };

            return CreateFolderResponse;
        })();

        file.RenameFolderRequest = (function() {

            /**
             * Properties of a RenameFolderRequest.
             * @memberof kritor.file
             * @interface IRenameFolderRequest
             * @property {number|Long|null} [groupId] RenameFolderRequest groupId
             * @property {string|null} [folderId] RenameFolderRequest folderId
             * @property {string|null} [name] RenameFolderRequest name
             */

            /**
             * Constructs a new RenameFolderRequest.
             * @memberof kritor.file
             * @classdesc Represents a RenameFolderRequest.
             * @implements IRenameFolderRequest
             * @constructor
             * @param {kritor.file.IRenameFolderRequest=} [properties] Properties to set
             */
            function RenameFolderRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RenameFolderRequest groupId.
             * @member {number|Long} groupId
             * @memberof kritor.file.RenameFolderRequest
             * @instance
             */
            RenameFolderRequest.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * RenameFolderRequest folderId.
             * @member {string} folderId
             * @memberof kritor.file.RenameFolderRequest
             * @instance
             */
            RenameFolderRequest.prototype.folderId = "";

            /**
             * RenameFolderRequest name.
             * @member {string} name
             * @memberof kritor.file.RenameFolderRequest
             * @instance
             */
            RenameFolderRequest.prototype.name = "";

            /**
             * Creates a new RenameFolderRequest instance using the specified properties.
             * @function create
             * @memberof kritor.file.RenameFolderRequest
             * @static
             * @param {kritor.file.IRenameFolderRequest=} [properties] Properties to set
             * @returns {kritor.file.RenameFolderRequest} RenameFolderRequest instance
             */
            RenameFolderRequest.create = function create(properties) {
                return new RenameFolderRequest(properties);
            };

            /**
             * Encodes the specified RenameFolderRequest message. Does not implicitly {@link kritor.file.RenameFolderRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.file.RenameFolderRequest
             * @static
             * @param {kritor.file.IRenameFolderRequest} message RenameFolderRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RenameFolderRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                if (message.folderId != null && Object.hasOwnProperty.call(message, "folderId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.folderId);
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
                return writer;
            };

            /**
             * Encodes the specified RenameFolderRequest message, length delimited. Does not implicitly {@link kritor.file.RenameFolderRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.file.RenameFolderRequest
             * @static
             * @param {kritor.file.IRenameFolderRequest} message RenameFolderRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RenameFolderRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RenameFolderRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.file.RenameFolderRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.file.RenameFolderRequest} RenameFolderRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RenameFolderRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.file.RenameFolderRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.folderId = reader.string();
                            break;
                        }
                    case 3: {
                            message.name = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RenameFolderRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.file.RenameFolderRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.file.RenameFolderRequest} RenameFolderRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RenameFolderRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RenameFolderRequest message.
             * @function verify
             * @memberof kritor.file.RenameFolderRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RenameFolderRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                if (message.folderId != null && message.hasOwnProperty("folderId"))
                    if (!$util.isString(message.folderId))
                        return "folderId: string expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                return null;
            };

            /**
             * Creates a RenameFolderRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.file.RenameFolderRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.file.RenameFolderRequest} RenameFolderRequest
             */
            RenameFolderRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.file.RenameFolderRequest)
                    return object;
                let message = new $root.kritor.file.RenameFolderRequest();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                if (object.folderId != null)
                    message.folderId = String(object.folderId);
                if (object.name != null)
                    message.name = String(object.name);
                return message;
            };

            /**
             * Creates a plain object from a RenameFolderRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.file.RenameFolderRequest
             * @static
             * @param {kritor.file.RenameFolderRequest} message RenameFolderRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RenameFolderRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                    object.folderId = "";
                    object.name = "";
                }
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                if (message.folderId != null && message.hasOwnProperty("folderId"))
                    object.folderId = message.folderId;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                return object;
            };

            /**
             * Converts this RenameFolderRequest to JSON.
             * @function toJSON
             * @memberof kritor.file.RenameFolderRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RenameFolderRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for RenameFolderRequest
             * @function getTypeUrl
             * @memberof kritor.file.RenameFolderRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            RenameFolderRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.file.RenameFolderRequest";
            };

            return RenameFolderRequest;
        })();

        file.RenameFolderResponse = (function() {

            /**
             * Properties of a RenameFolderResponse.
             * @memberof kritor.file
             * @interface IRenameFolderResponse
             */

            /**
             * Constructs a new RenameFolderResponse.
             * @memberof kritor.file
             * @classdesc Represents a RenameFolderResponse.
             * @implements IRenameFolderResponse
             * @constructor
             * @param {kritor.file.IRenameFolderResponse=} [properties] Properties to set
             */
            function RenameFolderResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new RenameFolderResponse instance using the specified properties.
             * @function create
             * @memberof kritor.file.RenameFolderResponse
             * @static
             * @param {kritor.file.IRenameFolderResponse=} [properties] Properties to set
             * @returns {kritor.file.RenameFolderResponse} RenameFolderResponse instance
             */
            RenameFolderResponse.create = function create(properties) {
                return new RenameFolderResponse(properties);
            };

            /**
             * Encodes the specified RenameFolderResponse message. Does not implicitly {@link kritor.file.RenameFolderResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.file.RenameFolderResponse
             * @static
             * @param {kritor.file.IRenameFolderResponse} message RenameFolderResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RenameFolderResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified RenameFolderResponse message, length delimited. Does not implicitly {@link kritor.file.RenameFolderResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.file.RenameFolderResponse
             * @static
             * @param {kritor.file.IRenameFolderResponse} message RenameFolderResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RenameFolderResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RenameFolderResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.file.RenameFolderResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.file.RenameFolderResponse} RenameFolderResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RenameFolderResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.file.RenameFolderResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RenameFolderResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.file.RenameFolderResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.file.RenameFolderResponse} RenameFolderResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RenameFolderResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RenameFolderResponse message.
             * @function verify
             * @memberof kritor.file.RenameFolderResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RenameFolderResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a RenameFolderResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.file.RenameFolderResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.file.RenameFolderResponse} RenameFolderResponse
             */
            RenameFolderResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.file.RenameFolderResponse)
                    return object;
                return new $root.kritor.file.RenameFolderResponse();
            };

            /**
             * Creates a plain object from a RenameFolderResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.file.RenameFolderResponse
             * @static
             * @param {kritor.file.RenameFolderResponse} message RenameFolderResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RenameFolderResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this RenameFolderResponse to JSON.
             * @function toJSON
             * @memberof kritor.file.RenameFolderResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RenameFolderResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for RenameFolderResponse
             * @function getTypeUrl
             * @memberof kritor.file.RenameFolderResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            RenameFolderResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.file.RenameFolderResponse";
            };

            return RenameFolderResponse;
        })();

        file.DeleteFolderRequest = (function() {

            /**
             * Properties of a DeleteFolderRequest.
             * @memberof kritor.file
             * @interface IDeleteFolderRequest
             * @property {number|Long|null} [groupId] DeleteFolderRequest groupId
             * @property {string|null} [folderId] DeleteFolderRequest folderId
             */

            /**
             * Constructs a new DeleteFolderRequest.
             * @memberof kritor.file
             * @classdesc Represents a DeleteFolderRequest.
             * @implements IDeleteFolderRequest
             * @constructor
             * @param {kritor.file.IDeleteFolderRequest=} [properties] Properties to set
             */
            function DeleteFolderRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DeleteFolderRequest groupId.
             * @member {number|Long} groupId
             * @memberof kritor.file.DeleteFolderRequest
             * @instance
             */
            DeleteFolderRequest.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * DeleteFolderRequest folderId.
             * @member {string} folderId
             * @memberof kritor.file.DeleteFolderRequest
             * @instance
             */
            DeleteFolderRequest.prototype.folderId = "";

            /**
             * Creates a new DeleteFolderRequest instance using the specified properties.
             * @function create
             * @memberof kritor.file.DeleteFolderRequest
             * @static
             * @param {kritor.file.IDeleteFolderRequest=} [properties] Properties to set
             * @returns {kritor.file.DeleteFolderRequest} DeleteFolderRequest instance
             */
            DeleteFolderRequest.create = function create(properties) {
                return new DeleteFolderRequest(properties);
            };

            /**
             * Encodes the specified DeleteFolderRequest message. Does not implicitly {@link kritor.file.DeleteFolderRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.file.DeleteFolderRequest
             * @static
             * @param {kritor.file.IDeleteFolderRequest} message DeleteFolderRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteFolderRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                if (message.folderId != null && Object.hasOwnProperty.call(message, "folderId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.folderId);
                return writer;
            };

            /**
             * Encodes the specified DeleteFolderRequest message, length delimited. Does not implicitly {@link kritor.file.DeleteFolderRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.file.DeleteFolderRequest
             * @static
             * @param {kritor.file.IDeleteFolderRequest} message DeleteFolderRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteFolderRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeleteFolderRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.file.DeleteFolderRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.file.DeleteFolderRequest} DeleteFolderRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteFolderRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.file.DeleteFolderRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.folderId = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DeleteFolderRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.file.DeleteFolderRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.file.DeleteFolderRequest} DeleteFolderRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteFolderRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeleteFolderRequest message.
             * @function verify
             * @memberof kritor.file.DeleteFolderRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeleteFolderRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                if (message.folderId != null && message.hasOwnProperty("folderId"))
                    if (!$util.isString(message.folderId))
                        return "folderId: string expected";
                return null;
            };

            /**
             * Creates a DeleteFolderRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.file.DeleteFolderRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.file.DeleteFolderRequest} DeleteFolderRequest
             */
            DeleteFolderRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.file.DeleteFolderRequest)
                    return object;
                let message = new $root.kritor.file.DeleteFolderRequest();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                if (object.folderId != null)
                    message.folderId = String(object.folderId);
                return message;
            };

            /**
             * Creates a plain object from a DeleteFolderRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.file.DeleteFolderRequest
             * @static
             * @param {kritor.file.DeleteFolderRequest} message DeleteFolderRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeleteFolderRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                    object.folderId = "";
                }
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                if (message.folderId != null && message.hasOwnProperty("folderId"))
                    object.folderId = message.folderId;
                return object;
            };

            /**
             * Converts this DeleteFolderRequest to JSON.
             * @function toJSON
             * @memberof kritor.file.DeleteFolderRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeleteFolderRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DeleteFolderRequest
             * @function getTypeUrl
             * @memberof kritor.file.DeleteFolderRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DeleteFolderRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.file.DeleteFolderRequest";
            };

            return DeleteFolderRequest;
        })();

        file.DeleteFolderResponse = (function() {

            /**
             * Properties of a DeleteFolderResponse.
             * @memberof kritor.file
             * @interface IDeleteFolderResponse
             */

            /**
             * Constructs a new DeleteFolderResponse.
             * @memberof kritor.file
             * @classdesc Represents a DeleteFolderResponse.
             * @implements IDeleteFolderResponse
             * @constructor
             * @param {kritor.file.IDeleteFolderResponse=} [properties] Properties to set
             */
            function DeleteFolderResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new DeleteFolderResponse instance using the specified properties.
             * @function create
             * @memberof kritor.file.DeleteFolderResponse
             * @static
             * @param {kritor.file.IDeleteFolderResponse=} [properties] Properties to set
             * @returns {kritor.file.DeleteFolderResponse} DeleteFolderResponse instance
             */
            DeleteFolderResponse.create = function create(properties) {
                return new DeleteFolderResponse(properties);
            };

            /**
             * Encodes the specified DeleteFolderResponse message. Does not implicitly {@link kritor.file.DeleteFolderResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.file.DeleteFolderResponse
             * @static
             * @param {kritor.file.IDeleteFolderResponse} message DeleteFolderResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteFolderResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified DeleteFolderResponse message, length delimited. Does not implicitly {@link kritor.file.DeleteFolderResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.file.DeleteFolderResponse
             * @static
             * @param {kritor.file.IDeleteFolderResponse} message DeleteFolderResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteFolderResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeleteFolderResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.file.DeleteFolderResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.file.DeleteFolderResponse} DeleteFolderResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteFolderResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.file.DeleteFolderResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DeleteFolderResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.file.DeleteFolderResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.file.DeleteFolderResponse} DeleteFolderResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteFolderResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeleteFolderResponse message.
             * @function verify
             * @memberof kritor.file.DeleteFolderResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeleteFolderResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a DeleteFolderResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.file.DeleteFolderResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.file.DeleteFolderResponse} DeleteFolderResponse
             */
            DeleteFolderResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.file.DeleteFolderResponse)
                    return object;
                return new $root.kritor.file.DeleteFolderResponse();
            };

            /**
             * Creates a plain object from a DeleteFolderResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.file.DeleteFolderResponse
             * @static
             * @param {kritor.file.DeleteFolderResponse} message DeleteFolderResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeleteFolderResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this DeleteFolderResponse to JSON.
             * @function toJSON
             * @memberof kritor.file.DeleteFolderResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeleteFolderResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DeleteFolderResponse
             * @function getTypeUrl
             * @memberof kritor.file.DeleteFolderResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DeleteFolderResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.file.DeleteFolderResponse";
            };

            return DeleteFolderResponse;
        })();

        file.UploadFileRequest = (function() {

            /**
             * Properties of an UploadFileRequest.
             * @memberof kritor.file
             * @interface IUploadFileRequest
             * @property {number|Long|null} [groupId] UploadFileRequest groupId
             * @property {Uint8Array|null} [file] UploadFileRequest file
             * @property {string|null} [fileName] UploadFileRequest fileName
             * @property {string|null} [filePath] UploadFileRequest filePath
             * @property {string|null} [fileUrl] UploadFileRequest fileUrl
             */

            /**
             * Constructs a new UploadFileRequest.
             * @memberof kritor.file
             * @classdesc Represents an UploadFileRequest.
             * @implements IUploadFileRequest
             * @constructor
             * @param {kritor.file.IUploadFileRequest=} [properties] Properties to set
             */
            function UploadFileRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * UploadFileRequest groupId.
             * @member {number|Long} groupId
             * @memberof kritor.file.UploadFileRequest
             * @instance
             */
            UploadFileRequest.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * UploadFileRequest file.
             * @member {Uint8Array|null|undefined} file
             * @memberof kritor.file.UploadFileRequest
             * @instance
             */
            UploadFileRequest.prototype.file = null;

            /**
             * UploadFileRequest fileName.
             * @member {string|null|undefined} fileName
             * @memberof kritor.file.UploadFileRequest
             * @instance
             */
            UploadFileRequest.prototype.fileName = null;

            /**
             * UploadFileRequest filePath.
             * @member {string|null|undefined} filePath
             * @memberof kritor.file.UploadFileRequest
             * @instance
             */
            UploadFileRequest.prototype.filePath = null;

            /**
             * UploadFileRequest fileUrl.
             * @member {string|null|undefined} fileUrl
             * @memberof kritor.file.UploadFileRequest
             * @instance
             */
            UploadFileRequest.prototype.fileUrl = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * UploadFileRequest data.
             * @member {"file"|"fileName"|"filePath"|"fileUrl"|undefined} data
             * @memberof kritor.file.UploadFileRequest
             * @instance
             */
            Object.defineProperty(UploadFileRequest.prototype, "data", {
                get: $util.oneOfGetter($oneOfFields = ["file", "fileName", "filePath", "fileUrl"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new UploadFileRequest instance using the specified properties.
             * @function create
             * @memberof kritor.file.UploadFileRequest
             * @static
             * @param {kritor.file.IUploadFileRequest=} [properties] Properties to set
             * @returns {kritor.file.UploadFileRequest} UploadFileRequest instance
             */
            UploadFileRequest.create = function create(properties) {
                return new UploadFileRequest(properties);
            };

            /**
             * Encodes the specified UploadFileRequest message. Does not implicitly {@link kritor.file.UploadFileRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.file.UploadFileRequest
             * @static
             * @param {kritor.file.IUploadFileRequest} message UploadFileRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UploadFileRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                if (message.file != null && Object.hasOwnProperty.call(message, "file"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.file);
                if (message.fileName != null && Object.hasOwnProperty.call(message, "fileName"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.fileName);
                if (message.filePath != null && Object.hasOwnProperty.call(message, "filePath"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.filePath);
                if (message.fileUrl != null && Object.hasOwnProperty.call(message, "fileUrl"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.fileUrl);
                return writer;
            };

            /**
             * Encodes the specified UploadFileRequest message, length delimited. Does not implicitly {@link kritor.file.UploadFileRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.file.UploadFileRequest
             * @static
             * @param {kritor.file.IUploadFileRequest} message UploadFileRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UploadFileRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an UploadFileRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.file.UploadFileRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.file.UploadFileRequest} UploadFileRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UploadFileRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.file.UploadFileRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.file = reader.bytes();
                            break;
                        }
                    case 3: {
                            message.fileName = reader.string();
                            break;
                        }
                    case 4: {
                            message.filePath = reader.string();
                            break;
                        }
                    case 5: {
                            message.fileUrl = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an UploadFileRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.file.UploadFileRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.file.UploadFileRequest} UploadFileRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UploadFileRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an UploadFileRequest message.
             * @function verify
             * @memberof kritor.file.UploadFileRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UploadFileRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                if (message.file != null && message.hasOwnProperty("file")) {
                    properties.data = 1;
                    if (!(message.file && typeof message.file.length === "number" || $util.isString(message.file)))
                        return "file: buffer expected";
                }
                if (message.fileName != null && message.hasOwnProperty("fileName")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    if (!$util.isString(message.fileName))
                        return "fileName: string expected";
                }
                if (message.filePath != null && message.hasOwnProperty("filePath")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    if (!$util.isString(message.filePath))
                        return "filePath: string expected";
                }
                if (message.fileUrl != null && message.hasOwnProperty("fileUrl")) {
                    if (properties.data === 1)
                        return "data: multiple values";
                    properties.data = 1;
                    if (!$util.isString(message.fileUrl))
                        return "fileUrl: string expected";
                }
                return null;
            };

            /**
             * Creates an UploadFileRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.file.UploadFileRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.file.UploadFileRequest} UploadFileRequest
             */
            UploadFileRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.file.UploadFileRequest)
                    return object;
                let message = new $root.kritor.file.UploadFileRequest();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                if (object.file != null)
                    if (typeof object.file === "string")
                        $util.base64.decode(object.file, message.file = $util.newBuffer($util.base64.length(object.file)), 0);
                    else if (object.file.length >= 0)
                        message.file = object.file;
                if (object.fileName != null)
                    message.fileName = String(object.fileName);
                if (object.filePath != null)
                    message.filePath = String(object.filePath);
                if (object.fileUrl != null)
                    message.fileUrl = String(object.fileUrl);
                return message;
            };

            /**
             * Creates a plain object from an UploadFileRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.file.UploadFileRequest
             * @static
             * @param {kritor.file.UploadFileRequest} message UploadFileRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UploadFileRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                if (message.file != null && message.hasOwnProperty("file")) {
                    object.file = options.bytes === String ? $util.base64.encode(message.file, 0, message.file.length) : options.bytes === Array ? Array.prototype.slice.call(message.file) : message.file;
                    if (options.oneofs)
                        object.data = "file";
                }
                if (message.fileName != null && message.hasOwnProperty("fileName")) {
                    object.fileName = message.fileName;
                    if (options.oneofs)
                        object.data = "fileName";
                }
                if (message.filePath != null && message.hasOwnProperty("filePath")) {
                    object.filePath = message.filePath;
                    if (options.oneofs)
                        object.data = "filePath";
                }
                if (message.fileUrl != null && message.hasOwnProperty("fileUrl")) {
                    object.fileUrl = message.fileUrl;
                    if (options.oneofs)
                        object.data = "fileUrl";
                }
                return object;
            };

            /**
             * Converts this UploadFileRequest to JSON.
             * @function toJSON
             * @memberof kritor.file.UploadFileRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UploadFileRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for UploadFileRequest
             * @function getTypeUrl
             * @memberof kritor.file.UploadFileRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            UploadFileRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.file.UploadFileRequest";
            };

            return UploadFileRequest;
        })();

        file.UploadFileResponse = (function() {

            /**
             * Properties of an UploadFileResponse.
             * @memberof kritor.file
             * @interface IUploadFileResponse
             */

            /**
             * Constructs a new UploadFileResponse.
             * @memberof kritor.file
             * @classdesc Represents an UploadFileResponse.
             * @implements IUploadFileResponse
             * @constructor
             * @param {kritor.file.IUploadFileResponse=} [properties] Properties to set
             */
            function UploadFileResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new UploadFileResponse instance using the specified properties.
             * @function create
             * @memberof kritor.file.UploadFileResponse
             * @static
             * @param {kritor.file.IUploadFileResponse=} [properties] Properties to set
             * @returns {kritor.file.UploadFileResponse} UploadFileResponse instance
             */
            UploadFileResponse.create = function create(properties) {
                return new UploadFileResponse(properties);
            };

            /**
             * Encodes the specified UploadFileResponse message. Does not implicitly {@link kritor.file.UploadFileResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.file.UploadFileResponse
             * @static
             * @param {kritor.file.IUploadFileResponse} message UploadFileResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UploadFileResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified UploadFileResponse message, length delimited. Does not implicitly {@link kritor.file.UploadFileResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.file.UploadFileResponse
             * @static
             * @param {kritor.file.IUploadFileResponse} message UploadFileResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UploadFileResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an UploadFileResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.file.UploadFileResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.file.UploadFileResponse} UploadFileResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UploadFileResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.file.UploadFileResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an UploadFileResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.file.UploadFileResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.file.UploadFileResponse} UploadFileResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UploadFileResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an UploadFileResponse message.
             * @function verify
             * @memberof kritor.file.UploadFileResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UploadFileResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates an UploadFileResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.file.UploadFileResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.file.UploadFileResponse} UploadFileResponse
             */
            UploadFileResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.file.UploadFileResponse)
                    return object;
                return new $root.kritor.file.UploadFileResponse();
            };

            /**
             * Creates a plain object from an UploadFileResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.file.UploadFileResponse
             * @static
             * @param {kritor.file.UploadFileResponse} message UploadFileResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UploadFileResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this UploadFileResponse to JSON.
             * @function toJSON
             * @memberof kritor.file.UploadFileResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UploadFileResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for UploadFileResponse
             * @function getTypeUrl
             * @memberof kritor.file.UploadFileResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            UploadFileResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.file.UploadFileResponse";
            };

            return UploadFileResponse;
        })();

        file.DeleteFileRequest = (function() {

            /**
             * Properties of a DeleteFileRequest.
             * @memberof kritor.file
             * @interface IDeleteFileRequest
             * @property {number|Long|null} [groupId] DeleteFileRequest groupId
             * @property {string|null} [fileId] DeleteFileRequest fileId
             * @property {number|null} [busId] DeleteFileRequest busId
             */

            /**
             * Constructs a new DeleteFileRequest.
             * @memberof kritor.file
             * @classdesc Represents a DeleteFileRequest.
             * @implements IDeleteFileRequest
             * @constructor
             * @param {kritor.file.IDeleteFileRequest=} [properties] Properties to set
             */
            function DeleteFileRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DeleteFileRequest groupId.
             * @member {number|Long} groupId
             * @memberof kritor.file.DeleteFileRequest
             * @instance
             */
            DeleteFileRequest.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * DeleteFileRequest fileId.
             * @member {string} fileId
             * @memberof kritor.file.DeleteFileRequest
             * @instance
             */
            DeleteFileRequest.prototype.fileId = "";

            /**
             * DeleteFileRequest busId.
             * @member {number} busId
             * @memberof kritor.file.DeleteFileRequest
             * @instance
             */
            DeleteFileRequest.prototype.busId = 0;

            /**
             * Creates a new DeleteFileRequest instance using the specified properties.
             * @function create
             * @memberof kritor.file.DeleteFileRequest
             * @static
             * @param {kritor.file.IDeleteFileRequest=} [properties] Properties to set
             * @returns {kritor.file.DeleteFileRequest} DeleteFileRequest instance
             */
            DeleteFileRequest.create = function create(properties) {
                return new DeleteFileRequest(properties);
            };

            /**
             * Encodes the specified DeleteFileRequest message. Does not implicitly {@link kritor.file.DeleteFileRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.file.DeleteFileRequest
             * @static
             * @param {kritor.file.IDeleteFileRequest} message DeleteFileRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteFileRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                if (message.fileId != null && Object.hasOwnProperty.call(message, "fileId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.fileId);
                if (message.busId != null && Object.hasOwnProperty.call(message, "busId"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.busId);
                return writer;
            };

            /**
             * Encodes the specified DeleteFileRequest message, length delimited. Does not implicitly {@link kritor.file.DeleteFileRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.file.DeleteFileRequest
             * @static
             * @param {kritor.file.IDeleteFileRequest} message DeleteFileRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteFileRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeleteFileRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.file.DeleteFileRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.file.DeleteFileRequest} DeleteFileRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteFileRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.file.DeleteFileRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.fileId = reader.string();
                            break;
                        }
                    case 3: {
                            message.busId = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DeleteFileRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.file.DeleteFileRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.file.DeleteFileRequest} DeleteFileRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteFileRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeleteFileRequest message.
             * @function verify
             * @memberof kritor.file.DeleteFileRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeleteFileRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                if (message.fileId != null && message.hasOwnProperty("fileId"))
                    if (!$util.isString(message.fileId))
                        return "fileId: string expected";
                if (message.busId != null && message.hasOwnProperty("busId"))
                    if (!$util.isInteger(message.busId))
                        return "busId: integer expected";
                return null;
            };

            /**
             * Creates a DeleteFileRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.file.DeleteFileRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.file.DeleteFileRequest} DeleteFileRequest
             */
            DeleteFileRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.file.DeleteFileRequest)
                    return object;
                let message = new $root.kritor.file.DeleteFileRequest();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                if (object.fileId != null)
                    message.fileId = String(object.fileId);
                if (object.busId != null)
                    message.busId = object.busId | 0;
                return message;
            };

            /**
             * Creates a plain object from a DeleteFileRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.file.DeleteFileRequest
             * @static
             * @param {kritor.file.DeleteFileRequest} message DeleteFileRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeleteFileRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                    object.fileId = "";
                    object.busId = 0;
                }
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                if (message.fileId != null && message.hasOwnProperty("fileId"))
                    object.fileId = message.fileId;
                if (message.busId != null && message.hasOwnProperty("busId"))
                    object.busId = message.busId;
                return object;
            };

            /**
             * Converts this DeleteFileRequest to JSON.
             * @function toJSON
             * @memberof kritor.file.DeleteFileRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeleteFileRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DeleteFileRequest
             * @function getTypeUrl
             * @memberof kritor.file.DeleteFileRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DeleteFileRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.file.DeleteFileRequest";
            };

            return DeleteFileRequest;
        })();

        file.DeleteFileResponse = (function() {

            /**
             * Properties of a DeleteFileResponse.
             * @memberof kritor.file
             * @interface IDeleteFileResponse
             */

            /**
             * Constructs a new DeleteFileResponse.
             * @memberof kritor.file
             * @classdesc Represents a DeleteFileResponse.
             * @implements IDeleteFileResponse
             * @constructor
             * @param {kritor.file.IDeleteFileResponse=} [properties] Properties to set
             */
            function DeleteFileResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new DeleteFileResponse instance using the specified properties.
             * @function create
             * @memberof kritor.file.DeleteFileResponse
             * @static
             * @param {kritor.file.IDeleteFileResponse=} [properties] Properties to set
             * @returns {kritor.file.DeleteFileResponse} DeleteFileResponse instance
             */
            DeleteFileResponse.create = function create(properties) {
                return new DeleteFileResponse(properties);
            };

            /**
             * Encodes the specified DeleteFileResponse message. Does not implicitly {@link kritor.file.DeleteFileResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.file.DeleteFileResponse
             * @static
             * @param {kritor.file.IDeleteFileResponse} message DeleteFileResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteFileResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified DeleteFileResponse message, length delimited. Does not implicitly {@link kritor.file.DeleteFileResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.file.DeleteFileResponse
             * @static
             * @param {kritor.file.IDeleteFileResponse} message DeleteFileResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteFileResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeleteFileResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.file.DeleteFileResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.file.DeleteFileResponse} DeleteFileResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteFileResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.file.DeleteFileResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DeleteFileResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.file.DeleteFileResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.file.DeleteFileResponse} DeleteFileResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteFileResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeleteFileResponse message.
             * @function verify
             * @memberof kritor.file.DeleteFileResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeleteFileResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a DeleteFileResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.file.DeleteFileResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.file.DeleteFileResponse} DeleteFileResponse
             */
            DeleteFileResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.file.DeleteFileResponse)
                    return object;
                return new $root.kritor.file.DeleteFileResponse();
            };

            /**
             * Creates a plain object from a DeleteFileResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.file.DeleteFileResponse
             * @static
             * @param {kritor.file.DeleteFileResponse} message DeleteFileResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeleteFileResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this DeleteFileResponse to JSON.
             * @function toJSON
             * @memberof kritor.file.DeleteFileResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeleteFileResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DeleteFileResponse
             * @function getTypeUrl
             * @memberof kritor.file.DeleteFileResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DeleteFileResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.file.DeleteFileResponse";
            };

            return DeleteFileResponse;
        })();

        file.GetFileSystemInfoRequest = (function() {

            /**
             * Properties of a GetFileSystemInfoRequest.
             * @memberof kritor.file
             * @interface IGetFileSystemInfoRequest
             * @property {number|Long|null} [groupId] GetFileSystemInfoRequest groupId
             */

            /**
             * Constructs a new GetFileSystemInfoRequest.
             * @memberof kritor.file
             * @classdesc Represents a GetFileSystemInfoRequest.
             * @implements IGetFileSystemInfoRequest
             * @constructor
             * @param {kritor.file.IGetFileSystemInfoRequest=} [properties] Properties to set
             */
            function GetFileSystemInfoRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetFileSystemInfoRequest groupId.
             * @member {number|Long} groupId
             * @memberof kritor.file.GetFileSystemInfoRequest
             * @instance
             */
            GetFileSystemInfoRequest.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new GetFileSystemInfoRequest instance using the specified properties.
             * @function create
             * @memberof kritor.file.GetFileSystemInfoRequest
             * @static
             * @param {kritor.file.IGetFileSystemInfoRequest=} [properties] Properties to set
             * @returns {kritor.file.GetFileSystemInfoRequest} GetFileSystemInfoRequest instance
             */
            GetFileSystemInfoRequest.create = function create(properties) {
                return new GetFileSystemInfoRequest(properties);
            };

            /**
             * Encodes the specified GetFileSystemInfoRequest message. Does not implicitly {@link kritor.file.GetFileSystemInfoRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.file.GetFileSystemInfoRequest
             * @static
             * @param {kritor.file.IGetFileSystemInfoRequest} message GetFileSystemInfoRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetFileSystemInfoRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                return writer;
            };

            /**
             * Encodes the specified GetFileSystemInfoRequest message, length delimited. Does not implicitly {@link kritor.file.GetFileSystemInfoRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.file.GetFileSystemInfoRequest
             * @static
             * @param {kritor.file.IGetFileSystemInfoRequest} message GetFileSystemInfoRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetFileSystemInfoRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetFileSystemInfoRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.file.GetFileSystemInfoRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.file.GetFileSystemInfoRequest} GetFileSystemInfoRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetFileSystemInfoRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.file.GetFileSystemInfoRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetFileSystemInfoRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.file.GetFileSystemInfoRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.file.GetFileSystemInfoRequest} GetFileSystemInfoRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetFileSystemInfoRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetFileSystemInfoRequest message.
             * @function verify
             * @memberof kritor.file.GetFileSystemInfoRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetFileSystemInfoRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                return null;
            };

            /**
             * Creates a GetFileSystemInfoRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.file.GetFileSystemInfoRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.file.GetFileSystemInfoRequest} GetFileSystemInfoRequest
             */
            GetFileSystemInfoRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.file.GetFileSystemInfoRequest)
                    return object;
                let message = new $root.kritor.file.GetFileSystemInfoRequest();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a GetFileSystemInfoRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.file.GetFileSystemInfoRequest
             * @static
             * @param {kritor.file.GetFileSystemInfoRequest} message GetFileSystemInfoRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetFileSystemInfoRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                return object;
            };

            /**
             * Converts this GetFileSystemInfoRequest to JSON.
             * @function toJSON
             * @memberof kritor.file.GetFileSystemInfoRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetFileSystemInfoRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetFileSystemInfoRequest
             * @function getTypeUrl
             * @memberof kritor.file.GetFileSystemInfoRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetFileSystemInfoRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.file.GetFileSystemInfoRequest";
            };

            return GetFileSystemInfoRequest;
        })();

        file.GetFileSystemInfoResponse = (function() {

            /**
             * Properties of a GetFileSystemInfoResponse.
             * @memberof kritor.file
             * @interface IGetFileSystemInfoResponse
             * @property {number|null} [fileCount] GetFileSystemInfoResponse fileCount
             * @property {number|null} [totalCount] GetFileSystemInfoResponse totalCount
             * @property {number|null} [usedSpace] GetFileSystemInfoResponse usedSpace
             * @property {number|null} [totalSpace] GetFileSystemInfoResponse totalSpace
             */

            /**
             * Constructs a new GetFileSystemInfoResponse.
             * @memberof kritor.file
             * @classdesc Represents a GetFileSystemInfoResponse.
             * @implements IGetFileSystemInfoResponse
             * @constructor
             * @param {kritor.file.IGetFileSystemInfoResponse=} [properties] Properties to set
             */
            function GetFileSystemInfoResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetFileSystemInfoResponse fileCount.
             * @member {number} fileCount
             * @memberof kritor.file.GetFileSystemInfoResponse
             * @instance
             */
            GetFileSystemInfoResponse.prototype.fileCount = 0;

            /**
             * GetFileSystemInfoResponse totalCount.
             * @member {number} totalCount
             * @memberof kritor.file.GetFileSystemInfoResponse
             * @instance
             */
            GetFileSystemInfoResponse.prototype.totalCount = 0;

            /**
             * GetFileSystemInfoResponse usedSpace.
             * @member {number} usedSpace
             * @memberof kritor.file.GetFileSystemInfoResponse
             * @instance
             */
            GetFileSystemInfoResponse.prototype.usedSpace = 0;

            /**
             * GetFileSystemInfoResponse totalSpace.
             * @member {number} totalSpace
             * @memberof kritor.file.GetFileSystemInfoResponse
             * @instance
             */
            GetFileSystemInfoResponse.prototype.totalSpace = 0;

            /**
             * Creates a new GetFileSystemInfoResponse instance using the specified properties.
             * @function create
             * @memberof kritor.file.GetFileSystemInfoResponse
             * @static
             * @param {kritor.file.IGetFileSystemInfoResponse=} [properties] Properties to set
             * @returns {kritor.file.GetFileSystemInfoResponse} GetFileSystemInfoResponse instance
             */
            GetFileSystemInfoResponse.create = function create(properties) {
                return new GetFileSystemInfoResponse(properties);
            };

            /**
             * Encodes the specified GetFileSystemInfoResponse message. Does not implicitly {@link kritor.file.GetFileSystemInfoResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.file.GetFileSystemInfoResponse
             * @static
             * @param {kritor.file.IGetFileSystemInfoResponse} message GetFileSystemInfoResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetFileSystemInfoResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.fileCount != null && Object.hasOwnProperty.call(message, "fileCount"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.fileCount);
                if (message.totalCount != null && Object.hasOwnProperty.call(message, "totalCount"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.totalCount);
                if (message.usedSpace != null && Object.hasOwnProperty.call(message, "usedSpace"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.usedSpace);
                if (message.totalSpace != null && Object.hasOwnProperty.call(message, "totalSpace"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.totalSpace);
                return writer;
            };

            /**
             * Encodes the specified GetFileSystemInfoResponse message, length delimited. Does not implicitly {@link kritor.file.GetFileSystemInfoResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.file.GetFileSystemInfoResponse
             * @static
             * @param {kritor.file.IGetFileSystemInfoResponse} message GetFileSystemInfoResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetFileSystemInfoResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetFileSystemInfoResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.file.GetFileSystemInfoResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.file.GetFileSystemInfoResponse} GetFileSystemInfoResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetFileSystemInfoResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.file.GetFileSystemInfoResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.fileCount = reader.uint32();
                            break;
                        }
                    case 2: {
                            message.totalCount = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.usedSpace = reader.uint32();
                            break;
                        }
                    case 4: {
                            message.totalSpace = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetFileSystemInfoResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.file.GetFileSystemInfoResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.file.GetFileSystemInfoResponse} GetFileSystemInfoResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetFileSystemInfoResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetFileSystemInfoResponse message.
             * @function verify
             * @memberof kritor.file.GetFileSystemInfoResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetFileSystemInfoResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.fileCount != null && message.hasOwnProperty("fileCount"))
                    if (!$util.isInteger(message.fileCount))
                        return "fileCount: integer expected";
                if (message.totalCount != null && message.hasOwnProperty("totalCount"))
                    if (!$util.isInteger(message.totalCount))
                        return "totalCount: integer expected";
                if (message.usedSpace != null && message.hasOwnProperty("usedSpace"))
                    if (!$util.isInteger(message.usedSpace))
                        return "usedSpace: integer expected";
                if (message.totalSpace != null && message.hasOwnProperty("totalSpace"))
                    if (!$util.isInteger(message.totalSpace))
                        return "totalSpace: integer expected";
                return null;
            };

            /**
             * Creates a GetFileSystemInfoResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.file.GetFileSystemInfoResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.file.GetFileSystemInfoResponse} GetFileSystemInfoResponse
             */
            GetFileSystemInfoResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.file.GetFileSystemInfoResponse)
                    return object;
                let message = new $root.kritor.file.GetFileSystemInfoResponse();
                if (object.fileCount != null)
                    message.fileCount = object.fileCount >>> 0;
                if (object.totalCount != null)
                    message.totalCount = object.totalCount >>> 0;
                if (object.usedSpace != null)
                    message.usedSpace = object.usedSpace >>> 0;
                if (object.totalSpace != null)
                    message.totalSpace = object.totalSpace >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a GetFileSystemInfoResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.file.GetFileSystemInfoResponse
             * @static
             * @param {kritor.file.GetFileSystemInfoResponse} message GetFileSystemInfoResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetFileSystemInfoResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.fileCount = 0;
                    object.totalCount = 0;
                    object.usedSpace = 0;
                    object.totalSpace = 0;
                }
                if (message.fileCount != null && message.hasOwnProperty("fileCount"))
                    object.fileCount = message.fileCount;
                if (message.totalCount != null && message.hasOwnProperty("totalCount"))
                    object.totalCount = message.totalCount;
                if (message.usedSpace != null && message.hasOwnProperty("usedSpace"))
                    object.usedSpace = message.usedSpace;
                if (message.totalSpace != null && message.hasOwnProperty("totalSpace"))
                    object.totalSpace = message.totalSpace;
                return object;
            };

            /**
             * Converts this GetFileSystemInfoResponse to JSON.
             * @function toJSON
             * @memberof kritor.file.GetFileSystemInfoResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetFileSystemInfoResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetFileSystemInfoResponse
             * @function getTypeUrl
             * @memberof kritor.file.GetFileSystemInfoResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetFileSystemInfoResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.file.GetFileSystemInfoResponse";
            };

            return GetFileSystemInfoResponse;
        })();

        file.GetFileListRequest = (function() {

            /**
             * Properties of a GetFileListRequest.
             * @memberof kritor.file
             * @interface IGetFileListRequest
             * @property {number|Long|null} [groupId] GetFileListRequest groupId
             * @property {string|null} [folderId] GetFileListRequest folderId
             */

            /**
             * Constructs a new GetFileListRequest.
             * @memberof kritor.file
             * @classdesc Represents a GetFileListRequest.
             * @implements IGetFileListRequest
             * @constructor
             * @param {kritor.file.IGetFileListRequest=} [properties] Properties to set
             */
            function GetFileListRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetFileListRequest groupId.
             * @member {number|Long} groupId
             * @memberof kritor.file.GetFileListRequest
             * @instance
             */
            GetFileListRequest.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GetFileListRequest folderId.
             * @member {string|null|undefined} folderId
             * @memberof kritor.file.GetFileListRequest
             * @instance
             */
            GetFileListRequest.prototype.folderId = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * GetFileListRequest _folderId.
             * @member {"folderId"|undefined} _folderId
             * @memberof kritor.file.GetFileListRequest
             * @instance
             */
            Object.defineProperty(GetFileListRequest.prototype, "_folderId", {
                get: $util.oneOfGetter($oneOfFields = ["folderId"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new GetFileListRequest instance using the specified properties.
             * @function create
             * @memberof kritor.file.GetFileListRequest
             * @static
             * @param {kritor.file.IGetFileListRequest=} [properties] Properties to set
             * @returns {kritor.file.GetFileListRequest} GetFileListRequest instance
             */
            GetFileListRequest.create = function create(properties) {
                return new GetFileListRequest(properties);
            };

            /**
             * Encodes the specified GetFileListRequest message. Does not implicitly {@link kritor.file.GetFileListRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.file.GetFileListRequest
             * @static
             * @param {kritor.file.IGetFileListRequest} message GetFileListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetFileListRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                if (message.folderId != null && Object.hasOwnProperty.call(message, "folderId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.folderId);
                return writer;
            };

            /**
             * Encodes the specified GetFileListRequest message, length delimited. Does not implicitly {@link kritor.file.GetFileListRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.file.GetFileListRequest
             * @static
             * @param {kritor.file.IGetFileListRequest} message GetFileListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetFileListRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetFileListRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.file.GetFileListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.file.GetFileListRequest} GetFileListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetFileListRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.file.GetFileListRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.folderId = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetFileListRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.file.GetFileListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.file.GetFileListRequest} GetFileListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetFileListRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetFileListRequest message.
             * @function verify
             * @memberof kritor.file.GetFileListRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetFileListRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                if (message.folderId != null && message.hasOwnProperty("folderId")) {
                    properties._folderId = 1;
                    if (!$util.isString(message.folderId))
                        return "folderId: string expected";
                }
                return null;
            };

            /**
             * Creates a GetFileListRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.file.GetFileListRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.file.GetFileListRequest} GetFileListRequest
             */
            GetFileListRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.file.GetFileListRequest)
                    return object;
                let message = new $root.kritor.file.GetFileListRequest();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                if (object.folderId != null)
                    message.folderId = String(object.folderId);
                return message;
            };

            /**
             * Creates a plain object from a GetFileListRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.file.GetFileListRequest
             * @static
             * @param {kritor.file.GetFileListRequest} message GetFileListRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetFileListRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                if (message.folderId != null && message.hasOwnProperty("folderId")) {
                    object.folderId = message.folderId;
                    if (options.oneofs)
                        object._folderId = "folderId";
                }
                return object;
            };

            /**
             * Converts this GetFileListRequest to JSON.
             * @function toJSON
             * @memberof kritor.file.GetFileListRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetFileListRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetFileListRequest
             * @function getTypeUrl
             * @memberof kritor.file.GetFileListRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetFileListRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.file.GetFileListRequest";
            };

            return GetFileListRequest;
        })();

        file.GetFileListResponse = (function() {

            /**
             * Properties of a GetFileListResponse.
             * @memberof kritor.file
             * @interface IGetFileListResponse
             * @property {Array.<kritor.file.IFile>|null} [files] GetFileListResponse files
             * @property {Array.<kritor.file.IFolder>|null} [folders] GetFileListResponse folders
             */

            /**
             * Constructs a new GetFileListResponse.
             * @memberof kritor.file
             * @classdesc Represents a GetFileListResponse.
             * @implements IGetFileListResponse
             * @constructor
             * @param {kritor.file.IGetFileListResponse=} [properties] Properties to set
             */
            function GetFileListResponse(properties) {
                this.files = [];
                this.folders = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetFileListResponse files.
             * @member {Array.<kritor.file.IFile>} files
             * @memberof kritor.file.GetFileListResponse
             * @instance
             */
            GetFileListResponse.prototype.files = $util.emptyArray;

            /**
             * GetFileListResponse folders.
             * @member {Array.<kritor.file.IFolder>} folders
             * @memberof kritor.file.GetFileListResponse
             * @instance
             */
            GetFileListResponse.prototype.folders = $util.emptyArray;

            /**
             * Creates a new GetFileListResponse instance using the specified properties.
             * @function create
             * @memberof kritor.file.GetFileListResponse
             * @static
             * @param {kritor.file.IGetFileListResponse=} [properties] Properties to set
             * @returns {kritor.file.GetFileListResponse} GetFileListResponse instance
             */
            GetFileListResponse.create = function create(properties) {
                return new GetFileListResponse(properties);
            };

            /**
             * Encodes the specified GetFileListResponse message. Does not implicitly {@link kritor.file.GetFileListResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.file.GetFileListResponse
             * @static
             * @param {kritor.file.IGetFileListResponse} message GetFileListResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetFileListResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.files != null && message.files.length)
                    for (let i = 0; i < message.files.length; ++i)
                        $root.kritor.file.File.encode(message.files[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.folders != null && message.folders.length)
                    for (let i = 0; i < message.folders.length; ++i)
                        $root.kritor.file.Folder.encode(message.folders[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetFileListResponse message, length delimited. Does not implicitly {@link kritor.file.GetFileListResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.file.GetFileListResponse
             * @static
             * @param {kritor.file.IGetFileListResponse} message GetFileListResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetFileListResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetFileListResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.file.GetFileListResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.file.GetFileListResponse} GetFileListResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetFileListResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.file.GetFileListResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.files && message.files.length))
                                message.files = [];
                            message.files.push($root.kritor.file.File.decode(reader, reader.uint32()));
                            break;
                        }
                    case 2: {
                            if (!(message.folders && message.folders.length))
                                message.folders = [];
                            message.folders.push($root.kritor.file.Folder.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetFileListResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.file.GetFileListResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.file.GetFileListResponse} GetFileListResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetFileListResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetFileListResponse message.
             * @function verify
             * @memberof kritor.file.GetFileListResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetFileListResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.files != null && message.hasOwnProperty("files")) {
                    if (!Array.isArray(message.files))
                        return "files: array expected";
                    for (let i = 0; i < message.files.length; ++i) {
                        let error = $root.kritor.file.File.verify(message.files[i]);
                        if (error)
                            return "files." + error;
                    }
                }
                if (message.folders != null && message.hasOwnProperty("folders")) {
                    if (!Array.isArray(message.folders))
                        return "folders: array expected";
                    for (let i = 0; i < message.folders.length; ++i) {
                        let error = $root.kritor.file.Folder.verify(message.folders[i]);
                        if (error)
                            return "folders." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a GetFileListResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.file.GetFileListResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.file.GetFileListResponse} GetFileListResponse
             */
            GetFileListResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.file.GetFileListResponse)
                    return object;
                let message = new $root.kritor.file.GetFileListResponse();
                if (object.files) {
                    if (!Array.isArray(object.files))
                        throw TypeError(".kritor.file.GetFileListResponse.files: array expected");
                    message.files = [];
                    for (let i = 0; i < object.files.length; ++i) {
                        if (typeof object.files[i] !== "object")
                            throw TypeError(".kritor.file.GetFileListResponse.files: object expected");
                        message.files[i] = $root.kritor.file.File.fromObject(object.files[i]);
                    }
                }
                if (object.folders) {
                    if (!Array.isArray(object.folders))
                        throw TypeError(".kritor.file.GetFileListResponse.folders: array expected");
                    message.folders = [];
                    for (let i = 0; i < object.folders.length; ++i) {
                        if (typeof object.folders[i] !== "object")
                            throw TypeError(".kritor.file.GetFileListResponse.folders: object expected");
                        message.folders[i] = $root.kritor.file.Folder.fromObject(object.folders[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a GetFileListResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.file.GetFileListResponse
             * @static
             * @param {kritor.file.GetFileListResponse} message GetFileListResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetFileListResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.files = [];
                    object.folders = [];
                }
                if (message.files && message.files.length) {
                    object.files = [];
                    for (let j = 0; j < message.files.length; ++j)
                        object.files[j] = $root.kritor.file.File.toObject(message.files[j], options);
                }
                if (message.folders && message.folders.length) {
                    object.folders = [];
                    for (let j = 0; j < message.folders.length; ++j)
                        object.folders[j] = $root.kritor.file.Folder.toObject(message.folders[j], options);
                }
                return object;
            };

            /**
             * Converts this GetFileListResponse to JSON.
             * @function toJSON
             * @memberof kritor.file.GetFileListResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetFileListResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetFileListResponse
             * @function getTypeUrl
             * @memberof kritor.file.GetFileListResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetFileListResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.file.GetFileListResponse";
            };

            return GetFileListResponse;
        })();

        return file;
    })();

    kritor.friend = (function() {

        /**
         * Namespace friend.
         * @memberof kritor
         * @namespace
         */
        const friend = {};

        friend.FriendInfo = (function() {

            /**
             * Properties of a FriendInfo.
             * @memberof kritor.friend
             * @interface IFriendInfo
             * @property {string|null} [uid] FriendInfo uid
             * @property {number|Long|null} [uin] FriendInfo uin
             * @property {string|null} [qid] FriendInfo qid
             * @property {string|null} [nick] FriendInfo nick
             * @property {string|null} [remark] FriendInfo remark
             * @property {number|null} [level] FriendInfo level
             * @property {number|null} [age] FriendInfo age
             * @property {number|null} [voteCnt] FriendInfo voteCnt
             * @property {number|null} [gender] FriendInfo gender
             * @property {number|null} [groupId] FriendInfo groupId
             * @property {kritor.friend.IExtInfo|null} [ext] FriendInfo ext
             */

            /**
             * Constructs a new FriendInfo.
             * @memberof kritor.friend
             * @classdesc Represents a FriendInfo.
             * @implements IFriendInfo
             * @constructor
             * @param {kritor.friend.IFriendInfo=} [properties] Properties to set
             */
            function FriendInfo(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FriendInfo uid.
             * @member {string} uid
             * @memberof kritor.friend.FriendInfo
             * @instance
             */
            FriendInfo.prototype.uid = "";

            /**
             * FriendInfo uin.
             * @member {number|Long} uin
             * @memberof kritor.friend.FriendInfo
             * @instance
             */
            FriendInfo.prototype.uin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * FriendInfo qid.
             * @member {string} qid
             * @memberof kritor.friend.FriendInfo
             * @instance
             */
            FriendInfo.prototype.qid = "";

            /**
             * FriendInfo nick.
             * @member {string} nick
             * @memberof kritor.friend.FriendInfo
             * @instance
             */
            FriendInfo.prototype.nick = "";

            /**
             * FriendInfo remark.
             * @member {string} remark
             * @memberof kritor.friend.FriendInfo
             * @instance
             */
            FriendInfo.prototype.remark = "";

            /**
             * FriendInfo level.
             * @member {number} level
             * @memberof kritor.friend.FriendInfo
             * @instance
             */
            FriendInfo.prototype.level = 0;

            /**
             * FriendInfo age.
             * @member {number} age
             * @memberof kritor.friend.FriendInfo
             * @instance
             */
            FriendInfo.prototype.age = 0;

            /**
             * FriendInfo voteCnt.
             * @member {number} voteCnt
             * @memberof kritor.friend.FriendInfo
             * @instance
             */
            FriendInfo.prototype.voteCnt = 0;

            /**
             * FriendInfo gender.
             * @member {number} gender
             * @memberof kritor.friend.FriendInfo
             * @instance
             */
            FriendInfo.prototype.gender = 0;

            /**
             * FriendInfo groupId.
             * @member {number} groupId
             * @memberof kritor.friend.FriendInfo
             * @instance
             */
            FriendInfo.prototype.groupId = 0;

            /**
             * FriendInfo ext.
             * @member {kritor.friend.IExtInfo|null|undefined} ext
             * @memberof kritor.friend.FriendInfo
             * @instance
             */
            FriendInfo.prototype.ext = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * FriendInfo _ext.
             * @member {"ext"|undefined} _ext
             * @memberof kritor.friend.FriendInfo
             * @instance
             */
            Object.defineProperty(FriendInfo.prototype, "_ext", {
                get: $util.oneOfGetter($oneOfFields = ["ext"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new FriendInfo instance using the specified properties.
             * @function create
             * @memberof kritor.friend.FriendInfo
             * @static
             * @param {kritor.friend.IFriendInfo=} [properties] Properties to set
             * @returns {kritor.friend.FriendInfo} FriendInfo instance
             */
            FriendInfo.create = function create(properties) {
                return new FriendInfo(properties);
            };

            /**
             * Encodes the specified FriendInfo message. Does not implicitly {@link kritor.friend.FriendInfo.verify|verify} messages.
             * @function encode
             * @memberof kritor.friend.FriendInfo
             * @static
             * @param {kritor.friend.IFriendInfo} message FriendInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FriendInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.uid);
                if (message.uin != null && Object.hasOwnProperty.call(message, "uin"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.uin);
                if (message.qid != null && Object.hasOwnProperty.call(message, "qid"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.qid);
                if (message.nick != null && Object.hasOwnProperty.call(message, "nick"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.nick);
                if (message.remark != null && Object.hasOwnProperty.call(message, "remark"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.remark);
                if (message.level != null && Object.hasOwnProperty.call(message, "level"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.level);
                if (message.age != null && Object.hasOwnProperty.call(message, "age"))
                    writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.age);
                if (message.voteCnt != null && Object.hasOwnProperty.call(message, "voteCnt"))
                    writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.voteCnt);
                if (message.gender != null && Object.hasOwnProperty.call(message, "gender"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.gender);
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 10, wireType 0 =*/80).int32(message.groupId);
                if (message.ext != null && Object.hasOwnProperty.call(message, "ext"))
                    $root.kritor.friend.ExtInfo.encode(message.ext, writer.uint32(/* id 99, wireType 2 =*/794).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified FriendInfo message, length delimited. Does not implicitly {@link kritor.friend.FriendInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.friend.FriendInfo
             * @static
             * @param {kritor.friend.IFriendInfo} message FriendInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FriendInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FriendInfo message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.friend.FriendInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.friend.FriendInfo} FriendInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FriendInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.friend.FriendInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.uid = reader.string();
                            break;
                        }
                    case 2: {
                            message.uin = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.qid = reader.string();
                            break;
                        }
                    case 4: {
                            message.nick = reader.string();
                            break;
                        }
                    case 5: {
                            message.remark = reader.string();
                            break;
                        }
                    case 6: {
                            message.level = reader.uint32();
                            break;
                        }
                    case 7: {
                            message.age = reader.uint32();
                            break;
                        }
                    case 8: {
                            message.voteCnt = reader.uint32();
                            break;
                        }
                    case 9: {
                            message.gender = reader.int32();
                            break;
                        }
                    case 10: {
                            message.groupId = reader.int32();
                            break;
                        }
                    case 99: {
                            message.ext = $root.kritor.friend.ExtInfo.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FriendInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.friend.FriendInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.friend.FriendInfo} FriendInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FriendInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FriendInfo message.
             * @function verify
             * @memberof kritor.friend.FriendInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FriendInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.uid != null && message.hasOwnProperty("uid"))
                    if (!$util.isString(message.uid))
                        return "uid: string expected";
                if (message.uin != null && message.hasOwnProperty("uin"))
                    if (!$util.isInteger(message.uin) && !(message.uin && $util.isInteger(message.uin.low) && $util.isInteger(message.uin.high)))
                        return "uin: integer|Long expected";
                if (message.qid != null && message.hasOwnProperty("qid"))
                    if (!$util.isString(message.qid))
                        return "qid: string expected";
                if (message.nick != null && message.hasOwnProperty("nick"))
                    if (!$util.isString(message.nick))
                        return "nick: string expected";
                if (message.remark != null && message.hasOwnProperty("remark"))
                    if (!$util.isString(message.remark))
                        return "remark: string expected";
                if (message.level != null && message.hasOwnProperty("level"))
                    if (!$util.isInteger(message.level))
                        return "level: integer expected";
                if (message.age != null && message.hasOwnProperty("age"))
                    if (!$util.isInteger(message.age))
                        return "age: integer expected";
                if (message.voteCnt != null && message.hasOwnProperty("voteCnt"))
                    if (!$util.isInteger(message.voteCnt))
                        return "voteCnt: integer expected";
                if (message.gender != null && message.hasOwnProperty("gender"))
                    if (!$util.isInteger(message.gender))
                        return "gender: integer expected";
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId))
                        return "groupId: integer expected";
                if (message.ext != null && message.hasOwnProperty("ext")) {
                    properties._ext = 1;
                    {
                        let error = $root.kritor.friend.ExtInfo.verify(message.ext);
                        if (error)
                            return "ext." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a FriendInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.friend.FriendInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.friend.FriendInfo} FriendInfo
             */
            FriendInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.friend.FriendInfo)
                    return object;
                let message = new $root.kritor.friend.FriendInfo();
                if (object.uid != null)
                    message.uid = String(object.uid);
                if (object.uin != null)
                    if ($util.Long)
                        (message.uin = $util.Long.fromValue(object.uin)).unsigned = true;
                    else if (typeof object.uin === "string")
                        message.uin = parseInt(object.uin, 10);
                    else if (typeof object.uin === "number")
                        message.uin = object.uin;
                    else if (typeof object.uin === "object")
                        message.uin = new $util.LongBits(object.uin.low >>> 0, object.uin.high >>> 0).toNumber(true);
                if (object.qid != null)
                    message.qid = String(object.qid);
                if (object.nick != null)
                    message.nick = String(object.nick);
                if (object.remark != null)
                    message.remark = String(object.remark);
                if (object.level != null)
                    message.level = object.level >>> 0;
                if (object.age != null)
                    message.age = object.age >>> 0;
                if (object.voteCnt != null)
                    message.voteCnt = object.voteCnt >>> 0;
                if (object.gender != null)
                    message.gender = object.gender | 0;
                if (object.groupId != null)
                    message.groupId = object.groupId | 0;
                if (object.ext != null) {
                    if (typeof object.ext !== "object")
                        throw TypeError(".kritor.friend.FriendInfo.ext: object expected");
                    message.ext = $root.kritor.friend.ExtInfo.fromObject(object.ext);
                }
                return message;
            };

            /**
             * Creates a plain object from a FriendInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.friend.FriendInfo
             * @static
             * @param {kritor.friend.FriendInfo} message FriendInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FriendInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.uid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.uin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.uin = options.longs === String ? "0" : 0;
                    object.qid = "";
                    object.nick = "";
                    object.remark = "";
                    object.level = 0;
                    object.age = 0;
                    object.voteCnt = 0;
                    object.gender = 0;
                    object.groupId = 0;
                }
                if (message.uid != null && message.hasOwnProperty("uid"))
                    object.uid = message.uid;
                if (message.uin != null && message.hasOwnProperty("uin"))
                    if (typeof message.uin === "number")
                        object.uin = options.longs === String ? String(message.uin) : message.uin;
                    else
                        object.uin = options.longs === String ? $util.Long.prototype.toString.call(message.uin) : options.longs === Number ? new $util.LongBits(message.uin.low >>> 0, message.uin.high >>> 0).toNumber(true) : message.uin;
                if (message.qid != null && message.hasOwnProperty("qid"))
                    object.qid = message.qid;
                if (message.nick != null && message.hasOwnProperty("nick"))
                    object.nick = message.nick;
                if (message.remark != null && message.hasOwnProperty("remark"))
                    object.remark = message.remark;
                if (message.level != null && message.hasOwnProperty("level"))
                    object.level = message.level;
                if (message.age != null && message.hasOwnProperty("age"))
                    object.age = message.age;
                if (message.voteCnt != null && message.hasOwnProperty("voteCnt"))
                    object.voteCnt = message.voteCnt;
                if (message.gender != null && message.hasOwnProperty("gender"))
                    object.gender = message.gender;
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    object.groupId = message.groupId;
                if (message.ext != null && message.hasOwnProperty("ext")) {
                    object.ext = $root.kritor.friend.ExtInfo.toObject(message.ext, options);
                    if (options.oneofs)
                        object._ext = "ext";
                }
                return object;
            };

            /**
             * Converts this FriendInfo to JSON.
             * @function toJSON
             * @memberof kritor.friend.FriendInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FriendInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for FriendInfo
             * @function getTypeUrl
             * @memberof kritor.friend.FriendInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            FriendInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.friend.FriendInfo";
            };

            return FriendInfo;
        })();

        friend.ProfileCard = (function() {

            /**
             * Properties of a ProfileCard.
             * @memberof kritor.friend
             * @interface IProfileCard
             * @property {string|null} [uid] ProfileCard uid
             * @property {number|Long|null} [uin] ProfileCard uin
             * @property {string|null} [qid] ProfileCard qid
             * @property {string|null} [nick] ProfileCard nick
             * @property {string|null} [remark] ProfileCard remark
             * @property {number|null} [level] ProfileCard level
             * @property {number|Long|null} [birthday] ProfileCard birthday
             * @property {number|null} [loginDay] ProfileCard loginDay
             * @property {number|null} [voteCnt] ProfileCard voteCnt
             * @property {boolean|null} [isSchoolVerified] ProfileCard isSchoolVerified
             * @property {kritor.friend.IExtInfo|null} [ext] ProfileCard ext
             */

            /**
             * Constructs a new ProfileCard.
             * @memberof kritor.friend
             * @classdesc Represents a ProfileCard.
             * @implements IProfileCard
             * @constructor
             * @param {kritor.friend.IProfileCard=} [properties] Properties to set
             */
            function ProfileCard(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ProfileCard uid.
             * @member {string} uid
             * @memberof kritor.friend.ProfileCard
             * @instance
             */
            ProfileCard.prototype.uid = "";

            /**
             * ProfileCard uin.
             * @member {number|Long} uin
             * @memberof kritor.friend.ProfileCard
             * @instance
             */
            ProfileCard.prototype.uin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * ProfileCard qid.
             * @member {string} qid
             * @memberof kritor.friend.ProfileCard
             * @instance
             */
            ProfileCard.prototype.qid = "";

            /**
             * ProfileCard nick.
             * @member {string} nick
             * @memberof kritor.friend.ProfileCard
             * @instance
             */
            ProfileCard.prototype.nick = "";

            /**
             * ProfileCard remark.
             * @member {string|null|undefined} remark
             * @memberof kritor.friend.ProfileCard
             * @instance
             */
            ProfileCard.prototype.remark = null;

            /**
             * ProfileCard level.
             * @member {number} level
             * @memberof kritor.friend.ProfileCard
             * @instance
             */
            ProfileCard.prototype.level = 0;

            /**
             * ProfileCard birthday.
             * @member {number|Long|null|undefined} birthday
             * @memberof kritor.friend.ProfileCard
             * @instance
             */
            ProfileCard.prototype.birthday = null;

            /**
             * ProfileCard loginDay.
             * @member {number} loginDay
             * @memberof kritor.friend.ProfileCard
             * @instance
             */
            ProfileCard.prototype.loginDay = 0;

            /**
             * ProfileCard voteCnt.
             * @member {number} voteCnt
             * @memberof kritor.friend.ProfileCard
             * @instance
             */
            ProfileCard.prototype.voteCnt = 0;

            /**
             * ProfileCard isSchoolVerified.
             * @member {boolean|null|undefined} isSchoolVerified
             * @memberof kritor.friend.ProfileCard
             * @instance
             */
            ProfileCard.prototype.isSchoolVerified = null;

            /**
             * ProfileCard ext.
             * @member {kritor.friend.IExtInfo|null|undefined} ext
             * @memberof kritor.friend.ProfileCard
             * @instance
             */
            ProfileCard.prototype.ext = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * ProfileCard _remark.
             * @member {"remark"|undefined} _remark
             * @memberof kritor.friend.ProfileCard
             * @instance
             */
            Object.defineProperty(ProfileCard.prototype, "_remark", {
                get: $util.oneOfGetter($oneOfFields = ["remark"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * ProfileCard _birthday.
             * @member {"birthday"|undefined} _birthday
             * @memberof kritor.friend.ProfileCard
             * @instance
             */
            Object.defineProperty(ProfileCard.prototype, "_birthday", {
                get: $util.oneOfGetter($oneOfFields = ["birthday"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * ProfileCard _isSchoolVerified.
             * @member {"isSchoolVerified"|undefined} _isSchoolVerified
             * @memberof kritor.friend.ProfileCard
             * @instance
             */
            Object.defineProperty(ProfileCard.prototype, "_isSchoolVerified", {
                get: $util.oneOfGetter($oneOfFields = ["isSchoolVerified"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * ProfileCard _ext.
             * @member {"ext"|undefined} _ext
             * @memberof kritor.friend.ProfileCard
             * @instance
             */
            Object.defineProperty(ProfileCard.prototype, "_ext", {
                get: $util.oneOfGetter($oneOfFields = ["ext"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new ProfileCard instance using the specified properties.
             * @function create
             * @memberof kritor.friend.ProfileCard
             * @static
             * @param {kritor.friend.IProfileCard=} [properties] Properties to set
             * @returns {kritor.friend.ProfileCard} ProfileCard instance
             */
            ProfileCard.create = function create(properties) {
                return new ProfileCard(properties);
            };

            /**
             * Encodes the specified ProfileCard message. Does not implicitly {@link kritor.friend.ProfileCard.verify|verify} messages.
             * @function encode
             * @memberof kritor.friend.ProfileCard
             * @static
             * @param {kritor.friend.IProfileCard} message ProfileCard message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProfileCard.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.uid);
                if (message.uin != null && Object.hasOwnProperty.call(message, "uin"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.uin);
                if (message.qid != null && Object.hasOwnProperty.call(message, "qid"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.qid);
                if (message.nick != null && Object.hasOwnProperty.call(message, "nick"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.nick);
                if (message.remark != null && Object.hasOwnProperty.call(message, "remark"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.remark);
                if (message.level != null && Object.hasOwnProperty.call(message, "level"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.level);
                if (message.birthday != null && Object.hasOwnProperty.call(message, "birthday"))
                    writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.birthday);
                if (message.loginDay != null && Object.hasOwnProperty.call(message, "loginDay"))
                    writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.loginDay);
                if (message.voteCnt != null && Object.hasOwnProperty.call(message, "voteCnt"))
                    writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.voteCnt);
                if (message.isSchoolVerified != null && Object.hasOwnProperty.call(message, "isSchoolVerified"))
                    writer.uint32(/* id 51, wireType 0 =*/408).bool(message.isSchoolVerified);
                if (message.ext != null && Object.hasOwnProperty.call(message, "ext"))
                    $root.kritor.friend.ExtInfo.encode(message.ext, writer.uint32(/* id 99, wireType 2 =*/794).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ProfileCard message, length delimited. Does not implicitly {@link kritor.friend.ProfileCard.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.friend.ProfileCard
             * @static
             * @param {kritor.friend.IProfileCard} message ProfileCard message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProfileCard.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ProfileCard message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.friend.ProfileCard
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.friend.ProfileCard} ProfileCard
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProfileCard.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.friend.ProfileCard();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.uid = reader.string();
                            break;
                        }
                    case 2: {
                            message.uin = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.qid = reader.string();
                            break;
                        }
                    case 4: {
                            message.nick = reader.string();
                            break;
                        }
                    case 5: {
                            message.remark = reader.string();
                            break;
                        }
                    case 6: {
                            message.level = reader.uint32();
                            break;
                        }
                    case 7: {
                            message.birthday = reader.uint64();
                            break;
                        }
                    case 8: {
                            message.loginDay = reader.uint32();
                            break;
                        }
                    case 9: {
                            message.voteCnt = reader.uint32();
                            break;
                        }
                    case 51: {
                            message.isSchoolVerified = reader.bool();
                            break;
                        }
                    case 99: {
                            message.ext = $root.kritor.friend.ExtInfo.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ProfileCard message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.friend.ProfileCard
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.friend.ProfileCard} ProfileCard
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProfileCard.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ProfileCard message.
             * @function verify
             * @memberof kritor.friend.ProfileCard
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ProfileCard.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.uid != null && message.hasOwnProperty("uid"))
                    if (!$util.isString(message.uid))
                        return "uid: string expected";
                if (message.uin != null && message.hasOwnProperty("uin"))
                    if (!$util.isInteger(message.uin) && !(message.uin && $util.isInteger(message.uin.low) && $util.isInteger(message.uin.high)))
                        return "uin: integer|Long expected";
                if (message.qid != null && message.hasOwnProperty("qid"))
                    if (!$util.isString(message.qid))
                        return "qid: string expected";
                if (message.nick != null && message.hasOwnProperty("nick"))
                    if (!$util.isString(message.nick))
                        return "nick: string expected";
                if (message.remark != null && message.hasOwnProperty("remark")) {
                    properties._remark = 1;
                    if (!$util.isString(message.remark))
                        return "remark: string expected";
                }
                if (message.level != null && message.hasOwnProperty("level"))
                    if (!$util.isInteger(message.level))
                        return "level: integer expected";
                if (message.birthday != null && message.hasOwnProperty("birthday")) {
                    properties._birthday = 1;
                    if (!$util.isInteger(message.birthday) && !(message.birthday && $util.isInteger(message.birthday.low) && $util.isInteger(message.birthday.high)))
                        return "birthday: integer|Long expected";
                }
                if (message.loginDay != null && message.hasOwnProperty("loginDay"))
                    if (!$util.isInteger(message.loginDay))
                        return "loginDay: integer expected";
                if (message.voteCnt != null && message.hasOwnProperty("voteCnt"))
                    if (!$util.isInteger(message.voteCnt))
                        return "voteCnt: integer expected";
                if (message.isSchoolVerified != null && message.hasOwnProperty("isSchoolVerified")) {
                    properties._isSchoolVerified = 1;
                    if (typeof message.isSchoolVerified !== "boolean")
                        return "isSchoolVerified: boolean expected";
                }
                if (message.ext != null && message.hasOwnProperty("ext")) {
                    properties._ext = 1;
                    {
                        let error = $root.kritor.friend.ExtInfo.verify(message.ext);
                        if (error)
                            return "ext." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a ProfileCard message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.friend.ProfileCard
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.friend.ProfileCard} ProfileCard
             */
            ProfileCard.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.friend.ProfileCard)
                    return object;
                let message = new $root.kritor.friend.ProfileCard();
                if (object.uid != null)
                    message.uid = String(object.uid);
                if (object.uin != null)
                    if ($util.Long)
                        (message.uin = $util.Long.fromValue(object.uin)).unsigned = true;
                    else if (typeof object.uin === "string")
                        message.uin = parseInt(object.uin, 10);
                    else if (typeof object.uin === "number")
                        message.uin = object.uin;
                    else if (typeof object.uin === "object")
                        message.uin = new $util.LongBits(object.uin.low >>> 0, object.uin.high >>> 0).toNumber(true);
                if (object.qid != null)
                    message.qid = String(object.qid);
                if (object.nick != null)
                    message.nick = String(object.nick);
                if (object.remark != null)
                    message.remark = String(object.remark);
                if (object.level != null)
                    message.level = object.level >>> 0;
                if (object.birthday != null)
                    if ($util.Long)
                        (message.birthday = $util.Long.fromValue(object.birthday)).unsigned = true;
                    else if (typeof object.birthday === "string")
                        message.birthday = parseInt(object.birthday, 10);
                    else if (typeof object.birthday === "number")
                        message.birthday = object.birthday;
                    else if (typeof object.birthday === "object")
                        message.birthday = new $util.LongBits(object.birthday.low >>> 0, object.birthday.high >>> 0).toNumber(true);
                if (object.loginDay != null)
                    message.loginDay = object.loginDay >>> 0;
                if (object.voteCnt != null)
                    message.voteCnt = object.voteCnt >>> 0;
                if (object.isSchoolVerified != null)
                    message.isSchoolVerified = Boolean(object.isSchoolVerified);
                if (object.ext != null) {
                    if (typeof object.ext !== "object")
                        throw TypeError(".kritor.friend.ProfileCard.ext: object expected");
                    message.ext = $root.kritor.friend.ExtInfo.fromObject(object.ext);
                }
                return message;
            };

            /**
             * Creates a plain object from a ProfileCard message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.friend.ProfileCard
             * @static
             * @param {kritor.friend.ProfileCard} message ProfileCard
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ProfileCard.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.uid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.uin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.uin = options.longs === String ? "0" : 0;
                    object.qid = "";
                    object.nick = "";
                    object.level = 0;
                    object.loginDay = 0;
                    object.voteCnt = 0;
                }
                if (message.uid != null && message.hasOwnProperty("uid"))
                    object.uid = message.uid;
                if (message.uin != null && message.hasOwnProperty("uin"))
                    if (typeof message.uin === "number")
                        object.uin = options.longs === String ? String(message.uin) : message.uin;
                    else
                        object.uin = options.longs === String ? $util.Long.prototype.toString.call(message.uin) : options.longs === Number ? new $util.LongBits(message.uin.low >>> 0, message.uin.high >>> 0).toNumber(true) : message.uin;
                if (message.qid != null && message.hasOwnProperty("qid"))
                    object.qid = message.qid;
                if (message.nick != null && message.hasOwnProperty("nick"))
                    object.nick = message.nick;
                if (message.remark != null && message.hasOwnProperty("remark")) {
                    object.remark = message.remark;
                    if (options.oneofs)
                        object._remark = "remark";
                }
                if (message.level != null && message.hasOwnProperty("level"))
                    object.level = message.level;
                if (message.birthday != null && message.hasOwnProperty("birthday")) {
                    if (typeof message.birthday === "number")
                        object.birthday = options.longs === String ? String(message.birthday) : message.birthday;
                    else
                        object.birthday = options.longs === String ? $util.Long.prototype.toString.call(message.birthday) : options.longs === Number ? new $util.LongBits(message.birthday.low >>> 0, message.birthday.high >>> 0).toNumber(true) : message.birthday;
                    if (options.oneofs)
                        object._birthday = "birthday";
                }
                if (message.loginDay != null && message.hasOwnProperty("loginDay"))
                    object.loginDay = message.loginDay;
                if (message.voteCnt != null && message.hasOwnProperty("voteCnt"))
                    object.voteCnt = message.voteCnt;
                if (message.isSchoolVerified != null && message.hasOwnProperty("isSchoolVerified")) {
                    object.isSchoolVerified = message.isSchoolVerified;
                    if (options.oneofs)
                        object._isSchoolVerified = "isSchoolVerified";
                }
                if (message.ext != null && message.hasOwnProperty("ext")) {
                    object.ext = $root.kritor.friend.ExtInfo.toObject(message.ext, options);
                    if (options.oneofs)
                        object._ext = "ext";
                }
                return object;
            };

            /**
             * Converts this ProfileCard to JSON.
             * @function toJSON
             * @memberof kritor.friend.ProfileCard
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ProfileCard.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ProfileCard
             * @function getTypeUrl
             * @memberof kritor.friend.ProfileCard
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ProfileCard.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.friend.ProfileCard";
            };

            return ProfileCard;
        })();

        friend.ExtInfo = (function() {

            /**
             * Properties of an ExtInfo.
             * @memberof kritor.friend
             * @interface IExtInfo
             * @property {boolean|null} [bigVip] ExtInfo bigVip
             * @property {boolean|null} [hollywoodVip] ExtInfo hollywoodVip
             * @property {boolean|null} [qqVip] ExtInfo qqVip
             * @property {boolean|null} [superVip] ExtInfo superVip
             * @property {boolean|null} [voted] ExtInfo voted
             */

            /**
             * Constructs a new ExtInfo.
             * @memberof kritor.friend
             * @classdesc Represents an ExtInfo.
             * @implements IExtInfo
             * @constructor
             * @param {kritor.friend.IExtInfo=} [properties] Properties to set
             */
            function ExtInfo(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExtInfo bigVip.
             * @member {boolean|null|undefined} bigVip
             * @memberof kritor.friend.ExtInfo
             * @instance
             */
            ExtInfo.prototype.bigVip = null;

            /**
             * ExtInfo hollywoodVip.
             * @member {boolean|null|undefined} hollywoodVip
             * @memberof kritor.friend.ExtInfo
             * @instance
             */
            ExtInfo.prototype.hollywoodVip = null;

            /**
             * ExtInfo qqVip.
             * @member {boolean|null|undefined} qqVip
             * @memberof kritor.friend.ExtInfo
             * @instance
             */
            ExtInfo.prototype.qqVip = null;

            /**
             * ExtInfo superVip.
             * @member {boolean|null|undefined} superVip
             * @memberof kritor.friend.ExtInfo
             * @instance
             */
            ExtInfo.prototype.superVip = null;

            /**
             * ExtInfo voted.
             * @member {boolean|null|undefined} voted
             * @memberof kritor.friend.ExtInfo
             * @instance
             */
            ExtInfo.prototype.voted = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * ExtInfo _bigVip.
             * @member {"bigVip"|undefined} _bigVip
             * @memberof kritor.friend.ExtInfo
             * @instance
             */
            Object.defineProperty(ExtInfo.prototype, "_bigVip", {
                get: $util.oneOfGetter($oneOfFields = ["bigVip"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * ExtInfo _hollywoodVip.
             * @member {"hollywoodVip"|undefined} _hollywoodVip
             * @memberof kritor.friend.ExtInfo
             * @instance
             */
            Object.defineProperty(ExtInfo.prototype, "_hollywoodVip", {
                get: $util.oneOfGetter($oneOfFields = ["hollywoodVip"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * ExtInfo _qqVip.
             * @member {"qqVip"|undefined} _qqVip
             * @memberof kritor.friend.ExtInfo
             * @instance
             */
            Object.defineProperty(ExtInfo.prototype, "_qqVip", {
                get: $util.oneOfGetter($oneOfFields = ["qqVip"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * ExtInfo _superVip.
             * @member {"superVip"|undefined} _superVip
             * @memberof kritor.friend.ExtInfo
             * @instance
             */
            Object.defineProperty(ExtInfo.prototype, "_superVip", {
                get: $util.oneOfGetter($oneOfFields = ["superVip"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * ExtInfo _voted.
             * @member {"voted"|undefined} _voted
             * @memberof kritor.friend.ExtInfo
             * @instance
             */
            Object.defineProperty(ExtInfo.prototype, "_voted", {
                get: $util.oneOfGetter($oneOfFields = ["voted"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new ExtInfo instance using the specified properties.
             * @function create
             * @memberof kritor.friend.ExtInfo
             * @static
             * @param {kritor.friend.IExtInfo=} [properties] Properties to set
             * @returns {kritor.friend.ExtInfo} ExtInfo instance
             */
            ExtInfo.create = function create(properties) {
                return new ExtInfo(properties);
            };

            /**
             * Encodes the specified ExtInfo message. Does not implicitly {@link kritor.friend.ExtInfo.verify|verify} messages.
             * @function encode
             * @memberof kritor.friend.ExtInfo
             * @static
             * @param {kritor.friend.IExtInfo} message ExtInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExtInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.bigVip != null && Object.hasOwnProperty.call(message, "bigVip"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.bigVip);
                if (message.hollywoodVip != null && Object.hasOwnProperty.call(message, "hollywoodVip"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.hollywoodVip);
                if (message.qqVip != null && Object.hasOwnProperty.call(message, "qqVip"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.qqVip);
                if (message.superVip != null && Object.hasOwnProperty.call(message, "superVip"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.superVip);
                if (message.voted != null && Object.hasOwnProperty.call(message, "voted"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.voted);
                return writer;
            };

            /**
             * Encodes the specified ExtInfo message, length delimited. Does not implicitly {@link kritor.friend.ExtInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.friend.ExtInfo
             * @static
             * @param {kritor.friend.IExtInfo} message ExtInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ExtInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ExtInfo message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.friend.ExtInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.friend.ExtInfo} ExtInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExtInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.friend.ExtInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.bigVip = reader.bool();
                            break;
                        }
                    case 2: {
                            message.hollywoodVip = reader.bool();
                            break;
                        }
                    case 3: {
                            message.qqVip = reader.bool();
                            break;
                        }
                    case 4: {
                            message.superVip = reader.bool();
                            break;
                        }
                    case 5: {
                            message.voted = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ExtInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.friend.ExtInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.friend.ExtInfo} ExtInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ExtInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ExtInfo message.
             * @function verify
             * @memberof kritor.friend.ExtInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExtInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.bigVip != null && message.hasOwnProperty("bigVip")) {
                    properties._bigVip = 1;
                    if (typeof message.bigVip !== "boolean")
                        return "bigVip: boolean expected";
                }
                if (message.hollywoodVip != null && message.hasOwnProperty("hollywoodVip")) {
                    properties._hollywoodVip = 1;
                    if (typeof message.hollywoodVip !== "boolean")
                        return "hollywoodVip: boolean expected";
                }
                if (message.qqVip != null && message.hasOwnProperty("qqVip")) {
                    properties._qqVip = 1;
                    if (typeof message.qqVip !== "boolean")
                        return "qqVip: boolean expected";
                }
                if (message.superVip != null && message.hasOwnProperty("superVip")) {
                    properties._superVip = 1;
                    if (typeof message.superVip !== "boolean")
                        return "superVip: boolean expected";
                }
                if (message.voted != null && message.hasOwnProperty("voted")) {
                    properties._voted = 1;
                    if (typeof message.voted !== "boolean")
                        return "voted: boolean expected";
                }
                return null;
            };

            /**
             * Creates an ExtInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.friend.ExtInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.friend.ExtInfo} ExtInfo
             */
            ExtInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.friend.ExtInfo)
                    return object;
                let message = new $root.kritor.friend.ExtInfo();
                if (object.bigVip != null)
                    message.bigVip = Boolean(object.bigVip);
                if (object.hollywoodVip != null)
                    message.hollywoodVip = Boolean(object.hollywoodVip);
                if (object.qqVip != null)
                    message.qqVip = Boolean(object.qqVip);
                if (object.superVip != null)
                    message.superVip = Boolean(object.superVip);
                if (object.voted != null)
                    message.voted = Boolean(object.voted);
                return message;
            };

            /**
             * Creates a plain object from an ExtInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.friend.ExtInfo
             * @static
             * @param {kritor.friend.ExtInfo} message ExtInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExtInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (message.bigVip != null && message.hasOwnProperty("bigVip")) {
                    object.bigVip = message.bigVip;
                    if (options.oneofs)
                        object._bigVip = "bigVip";
                }
                if (message.hollywoodVip != null && message.hasOwnProperty("hollywoodVip")) {
                    object.hollywoodVip = message.hollywoodVip;
                    if (options.oneofs)
                        object._hollywoodVip = "hollywoodVip";
                }
                if (message.qqVip != null && message.hasOwnProperty("qqVip")) {
                    object.qqVip = message.qqVip;
                    if (options.oneofs)
                        object._qqVip = "qqVip";
                }
                if (message.superVip != null && message.hasOwnProperty("superVip")) {
                    object.superVip = message.superVip;
                    if (options.oneofs)
                        object._superVip = "superVip";
                }
                if (message.voted != null && message.hasOwnProperty("voted")) {
                    object.voted = message.voted;
                    if (options.oneofs)
                        object._voted = "voted";
                }
                return object;
            };

            /**
             * Converts this ExtInfo to JSON.
             * @function toJSON
             * @memberof kritor.friend.ExtInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExtInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ExtInfo
             * @function getTypeUrl
             * @memberof kritor.friend.ExtInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ExtInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.friend.ExtInfo";
            };

            return ExtInfo;
        })();

        friend.FriendService = (function() {

            /**
             * Constructs a new FriendService service.
             * @memberof kritor.friend
             * @classdesc Represents a FriendService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function FriendService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (FriendService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = FriendService;

            /**
             * Creates new FriendService service using the specified rpc implementation.
             * @function create
             * @memberof kritor.friend.FriendService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {FriendService} RPC service. Useful where requests and/or responses are streamed.
             */
            FriendService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link kritor.friend.FriendService#getFriendList}.
             * @memberof kritor.friend.FriendService
             * @typedef GetFriendListCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.friend.GetFriendListResponse} [response] GetFriendListResponse
             */

            /**
             * Calls GetFriendList.
             * @function getFriendList
             * @memberof kritor.friend.FriendService
             * @instance
             * @param {kritor.friend.IGetFriendListRequest} request GetFriendListRequest message or plain object
             * @param {kritor.friend.FriendService.GetFriendListCallback} callback Node-style callback called with the error, if any, and GetFriendListResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(FriendService.prototype.getFriendList = function getFriendList(request, callback) {
                return this.rpcCall(getFriendList, $root.kritor.friend.GetFriendListRequest, $root.kritor.friend.GetFriendListResponse, request, callback);
            }, "name", { value: "GetFriendList" });

            /**
             * Calls GetFriendList.
             * @function getFriendList
             * @memberof kritor.friend.FriendService
             * @instance
             * @param {kritor.friend.IGetFriendListRequest} request GetFriendListRequest message or plain object
             * @returns {Promise<kritor.friend.GetFriendListResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.friend.FriendService#getFriendProfileCard}.
             * @memberof kritor.friend.FriendService
             * @typedef GetFriendProfileCardCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.friend.GetFriendProfileCardResponse} [response] GetFriendProfileCardResponse
             */

            /**
             * Calls GetFriendProfileCard.
             * @function getFriendProfileCard
             * @memberof kritor.friend.FriendService
             * @instance
             * @param {kritor.friend.IGetFriendProfileCardRequest} request GetFriendProfileCardRequest message or plain object
             * @param {kritor.friend.FriendService.GetFriendProfileCardCallback} callback Node-style callback called with the error, if any, and GetFriendProfileCardResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(FriendService.prototype.getFriendProfileCard = function getFriendProfileCard(request, callback) {
                return this.rpcCall(getFriendProfileCard, $root.kritor.friend.GetFriendProfileCardRequest, $root.kritor.friend.GetFriendProfileCardResponse, request, callback);
            }, "name", { value: "GetFriendProfileCard" });

            /**
             * Calls GetFriendProfileCard.
             * @function getFriendProfileCard
             * @memberof kritor.friend.FriendService
             * @instance
             * @param {kritor.friend.IGetFriendProfileCardRequest} request GetFriendProfileCardRequest message or plain object
             * @returns {Promise<kritor.friend.GetFriendProfileCardResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.friend.FriendService#getStrangerProfileCard}.
             * @memberof kritor.friend.FriendService
             * @typedef GetStrangerProfileCardCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.friend.GetStrangerProfileCardResponse} [response] GetStrangerProfileCardResponse
             */

            /**
             * Calls GetStrangerProfileCard.
             * @function getStrangerProfileCard
             * @memberof kritor.friend.FriendService
             * @instance
             * @param {kritor.friend.IGetStrangerProfileCardRequest} request GetStrangerProfileCardRequest message or plain object
             * @param {kritor.friend.FriendService.GetStrangerProfileCardCallback} callback Node-style callback called with the error, if any, and GetStrangerProfileCardResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(FriendService.prototype.getStrangerProfileCard = function getStrangerProfileCard(request, callback) {
                return this.rpcCall(getStrangerProfileCard, $root.kritor.friend.GetStrangerProfileCardRequest, $root.kritor.friend.GetStrangerProfileCardResponse, request, callback);
            }, "name", { value: "GetStrangerProfileCard" });

            /**
             * Calls GetStrangerProfileCard.
             * @function getStrangerProfileCard
             * @memberof kritor.friend.FriendService
             * @instance
             * @param {kritor.friend.IGetStrangerProfileCardRequest} request GetStrangerProfileCardRequest message or plain object
             * @returns {Promise<kritor.friend.GetStrangerProfileCardResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.friend.FriendService#setProfileCard}.
             * @memberof kritor.friend.FriendService
             * @typedef SetProfileCardCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.friend.SetProfileCardResponse} [response] SetProfileCardResponse
             */

            /**
             * Calls SetProfileCard.
             * @function setProfileCard
             * @memberof kritor.friend.FriendService
             * @instance
             * @param {kritor.friend.ISetProfileCardRequest} request SetProfileCardRequest message or plain object
             * @param {kritor.friend.FriendService.SetProfileCardCallback} callback Node-style callback called with the error, if any, and SetProfileCardResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(FriendService.prototype.setProfileCard = function setProfileCard(request, callback) {
                return this.rpcCall(setProfileCard, $root.kritor.friend.SetProfileCardRequest, $root.kritor.friend.SetProfileCardResponse, request, callback);
            }, "name", { value: "SetProfileCard" });

            /**
             * Calls SetProfileCard.
             * @function setProfileCard
             * @memberof kritor.friend.FriendService
             * @instance
             * @param {kritor.friend.ISetProfileCardRequest} request SetProfileCardRequest message or plain object
             * @returns {Promise<kritor.friend.SetProfileCardResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.friend.FriendService#isBlackListUser}.
             * @memberof kritor.friend.FriendService
             * @typedef IsBlackListUserCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.friend.IsBlackListUserResponse} [response] IsBlackListUserResponse
             */

            /**
             * Calls IsBlackListUser.
             * @function isBlackListUser
             * @memberof kritor.friend.FriendService
             * @instance
             * @param {kritor.friend.IIsBlackListUserRequest} request IsBlackListUserRequest message or plain object
             * @param {kritor.friend.FriendService.IsBlackListUserCallback} callback Node-style callback called with the error, if any, and IsBlackListUserResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(FriendService.prototype.isBlackListUser = function isBlackListUser(request, callback) {
                return this.rpcCall(isBlackListUser, $root.kritor.friend.IsBlackListUserRequest, $root.kritor.friend.IsBlackListUserResponse, request, callback);
            }, "name", { value: "IsBlackListUser" });

            /**
             * Calls IsBlackListUser.
             * @function isBlackListUser
             * @memberof kritor.friend.FriendService
             * @instance
             * @param {kritor.friend.IIsBlackListUserRequest} request IsBlackListUserRequest message or plain object
             * @returns {Promise<kritor.friend.IsBlackListUserResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.friend.FriendService#voteUser}.
             * @memberof kritor.friend.FriendService
             * @typedef VoteUserCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.friend.VoteUserResponse} [response] VoteUserResponse
             */

            /**
             * Calls VoteUser.
             * @function voteUser
             * @memberof kritor.friend.FriendService
             * @instance
             * @param {kritor.friend.IVoteUserRequest} request VoteUserRequest message or plain object
             * @param {kritor.friend.FriendService.VoteUserCallback} callback Node-style callback called with the error, if any, and VoteUserResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(FriendService.prototype.voteUser = function voteUser(request, callback) {
                return this.rpcCall(voteUser, $root.kritor.friend.VoteUserRequest, $root.kritor.friend.VoteUserResponse, request, callback);
            }, "name", { value: "VoteUser" });

            /**
             * Calls VoteUser.
             * @function voteUser
             * @memberof kritor.friend.FriendService
             * @instance
             * @param {kritor.friend.IVoteUserRequest} request VoteUserRequest message or plain object
             * @returns {Promise<kritor.friend.VoteUserResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.friend.FriendService#getUidByUin}.
             * @memberof kritor.friend.FriendService
             * @typedef GetUidByUinCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.friend.GetUidByUinResponse} [response] GetUidByUinResponse
             */

            /**
             * Calls GetUidByUin.
             * @function getUidByUin
             * @memberof kritor.friend.FriendService
             * @instance
             * @param {kritor.friend.IGetUidByUinRequest} request GetUidByUinRequest message or plain object
             * @param {kritor.friend.FriendService.GetUidByUinCallback} callback Node-style callback called with the error, if any, and GetUidByUinResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(FriendService.prototype.getUidByUin = function getUidByUin(request, callback) {
                return this.rpcCall(getUidByUin, $root.kritor.friend.GetUidByUinRequest, $root.kritor.friend.GetUidByUinResponse, request, callback);
            }, "name", { value: "GetUidByUin" });

            /**
             * Calls GetUidByUin.
             * @function getUidByUin
             * @memberof kritor.friend.FriendService
             * @instance
             * @param {kritor.friend.IGetUidByUinRequest} request GetUidByUinRequest message or plain object
             * @returns {Promise<kritor.friend.GetUidByUinResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.friend.FriendService#getUinByUid}.
             * @memberof kritor.friend.FriendService
             * @typedef GetUinByUidCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.friend.GetUinByUidResponse} [response] GetUinByUidResponse
             */

            /**
             * Calls GetUinByUid.
             * @function getUinByUid
             * @memberof kritor.friend.FriendService
             * @instance
             * @param {kritor.friend.IGetUinByUidRequest} request GetUinByUidRequest message or plain object
             * @param {kritor.friend.FriendService.GetUinByUidCallback} callback Node-style callback called with the error, if any, and GetUinByUidResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(FriendService.prototype.getUinByUid = function getUinByUid(request, callback) {
                return this.rpcCall(getUinByUid, $root.kritor.friend.GetUinByUidRequest, $root.kritor.friend.GetUinByUidResponse, request, callback);
            }, "name", { value: "GetUinByUid" });

            /**
             * Calls GetUinByUid.
             * @function getUinByUid
             * @memberof kritor.friend.FriendService
             * @instance
             * @param {kritor.friend.IGetUinByUidRequest} request GetUinByUidRequest message or plain object
             * @returns {Promise<kritor.friend.GetUinByUidResponse>} Promise
             * @variation 2
             */

            return FriendService;
        })();

        friend.GetFriendListRequest = (function() {

            /**
             * Properties of a GetFriendListRequest.
             * @memberof kritor.friend
             * @interface IGetFriendListRequest
             * @property {boolean|null} [refresh] GetFriendListRequest refresh
             */

            /**
             * Constructs a new GetFriendListRequest.
             * @memberof kritor.friend
             * @classdesc Represents a GetFriendListRequest.
             * @implements IGetFriendListRequest
             * @constructor
             * @param {kritor.friend.IGetFriendListRequest=} [properties] Properties to set
             */
            function GetFriendListRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetFriendListRequest refresh.
             * @member {boolean|null|undefined} refresh
             * @memberof kritor.friend.GetFriendListRequest
             * @instance
             */
            GetFriendListRequest.prototype.refresh = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * GetFriendListRequest _refresh.
             * @member {"refresh"|undefined} _refresh
             * @memberof kritor.friend.GetFriendListRequest
             * @instance
             */
            Object.defineProperty(GetFriendListRequest.prototype, "_refresh", {
                get: $util.oneOfGetter($oneOfFields = ["refresh"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new GetFriendListRequest instance using the specified properties.
             * @function create
             * @memberof kritor.friend.GetFriendListRequest
             * @static
             * @param {kritor.friend.IGetFriendListRequest=} [properties] Properties to set
             * @returns {kritor.friend.GetFriendListRequest} GetFriendListRequest instance
             */
            GetFriendListRequest.create = function create(properties) {
                return new GetFriendListRequest(properties);
            };

            /**
             * Encodes the specified GetFriendListRequest message. Does not implicitly {@link kritor.friend.GetFriendListRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.friend.GetFriendListRequest
             * @static
             * @param {kritor.friend.IGetFriendListRequest} message GetFriendListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetFriendListRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.refresh != null && Object.hasOwnProperty.call(message, "refresh"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.refresh);
                return writer;
            };

            /**
             * Encodes the specified GetFriendListRequest message, length delimited. Does not implicitly {@link kritor.friend.GetFriendListRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.friend.GetFriendListRequest
             * @static
             * @param {kritor.friend.IGetFriendListRequest} message GetFriendListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetFriendListRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetFriendListRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.friend.GetFriendListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.friend.GetFriendListRequest} GetFriendListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetFriendListRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.friend.GetFriendListRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.refresh = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetFriendListRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.friend.GetFriendListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.friend.GetFriendListRequest} GetFriendListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetFriendListRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetFriendListRequest message.
             * @function verify
             * @memberof kritor.friend.GetFriendListRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetFriendListRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.refresh != null && message.hasOwnProperty("refresh")) {
                    properties._refresh = 1;
                    if (typeof message.refresh !== "boolean")
                        return "refresh: boolean expected";
                }
                return null;
            };

            /**
             * Creates a GetFriendListRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.friend.GetFriendListRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.friend.GetFriendListRequest} GetFriendListRequest
             */
            GetFriendListRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.friend.GetFriendListRequest)
                    return object;
                let message = new $root.kritor.friend.GetFriendListRequest();
                if (object.refresh != null)
                    message.refresh = Boolean(object.refresh);
                return message;
            };

            /**
             * Creates a plain object from a GetFriendListRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.friend.GetFriendListRequest
             * @static
             * @param {kritor.friend.GetFriendListRequest} message GetFriendListRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetFriendListRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (message.refresh != null && message.hasOwnProperty("refresh")) {
                    object.refresh = message.refresh;
                    if (options.oneofs)
                        object._refresh = "refresh";
                }
                return object;
            };

            /**
             * Converts this GetFriendListRequest to JSON.
             * @function toJSON
             * @memberof kritor.friend.GetFriendListRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetFriendListRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetFriendListRequest
             * @function getTypeUrl
             * @memberof kritor.friend.GetFriendListRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetFriendListRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.friend.GetFriendListRequest";
            };

            return GetFriendListRequest;
        })();

        friend.GetFriendListResponse = (function() {

            /**
             * Properties of a GetFriendListResponse.
             * @memberof kritor.friend
             * @interface IGetFriendListResponse
             * @property {Array.<kritor.friend.IFriendInfo>|null} [friendsInfo] GetFriendListResponse friendsInfo
             */

            /**
             * Constructs a new GetFriendListResponse.
             * @memberof kritor.friend
             * @classdesc Represents a GetFriendListResponse.
             * @implements IGetFriendListResponse
             * @constructor
             * @param {kritor.friend.IGetFriendListResponse=} [properties] Properties to set
             */
            function GetFriendListResponse(properties) {
                this.friendsInfo = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetFriendListResponse friendsInfo.
             * @member {Array.<kritor.friend.IFriendInfo>} friendsInfo
             * @memberof kritor.friend.GetFriendListResponse
             * @instance
             */
            GetFriendListResponse.prototype.friendsInfo = $util.emptyArray;

            /**
             * Creates a new GetFriendListResponse instance using the specified properties.
             * @function create
             * @memberof kritor.friend.GetFriendListResponse
             * @static
             * @param {kritor.friend.IGetFriendListResponse=} [properties] Properties to set
             * @returns {kritor.friend.GetFriendListResponse} GetFriendListResponse instance
             */
            GetFriendListResponse.create = function create(properties) {
                return new GetFriendListResponse(properties);
            };

            /**
             * Encodes the specified GetFriendListResponse message. Does not implicitly {@link kritor.friend.GetFriendListResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.friend.GetFriendListResponse
             * @static
             * @param {kritor.friend.IGetFriendListResponse} message GetFriendListResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetFriendListResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.friendsInfo != null && message.friendsInfo.length)
                    for (let i = 0; i < message.friendsInfo.length; ++i)
                        $root.kritor.friend.FriendInfo.encode(message.friendsInfo[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetFriendListResponse message, length delimited. Does not implicitly {@link kritor.friend.GetFriendListResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.friend.GetFriendListResponse
             * @static
             * @param {kritor.friend.IGetFriendListResponse} message GetFriendListResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetFriendListResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetFriendListResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.friend.GetFriendListResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.friend.GetFriendListResponse} GetFriendListResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetFriendListResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.friend.GetFriendListResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.friendsInfo && message.friendsInfo.length))
                                message.friendsInfo = [];
                            message.friendsInfo.push($root.kritor.friend.FriendInfo.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetFriendListResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.friend.GetFriendListResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.friend.GetFriendListResponse} GetFriendListResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetFriendListResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetFriendListResponse message.
             * @function verify
             * @memberof kritor.friend.GetFriendListResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetFriendListResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.friendsInfo != null && message.hasOwnProperty("friendsInfo")) {
                    if (!Array.isArray(message.friendsInfo))
                        return "friendsInfo: array expected";
                    for (let i = 0; i < message.friendsInfo.length; ++i) {
                        let error = $root.kritor.friend.FriendInfo.verify(message.friendsInfo[i]);
                        if (error)
                            return "friendsInfo." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a GetFriendListResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.friend.GetFriendListResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.friend.GetFriendListResponse} GetFriendListResponse
             */
            GetFriendListResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.friend.GetFriendListResponse)
                    return object;
                let message = new $root.kritor.friend.GetFriendListResponse();
                if (object.friendsInfo) {
                    if (!Array.isArray(object.friendsInfo))
                        throw TypeError(".kritor.friend.GetFriendListResponse.friendsInfo: array expected");
                    message.friendsInfo = [];
                    for (let i = 0; i < object.friendsInfo.length; ++i) {
                        if (typeof object.friendsInfo[i] !== "object")
                            throw TypeError(".kritor.friend.GetFriendListResponse.friendsInfo: object expected");
                        message.friendsInfo[i] = $root.kritor.friend.FriendInfo.fromObject(object.friendsInfo[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a GetFriendListResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.friend.GetFriendListResponse
             * @static
             * @param {kritor.friend.GetFriendListResponse} message GetFriendListResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetFriendListResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.friendsInfo = [];
                if (message.friendsInfo && message.friendsInfo.length) {
                    object.friendsInfo = [];
                    for (let j = 0; j < message.friendsInfo.length; ++j)
                        object.friendsInfo[j] = $root.kritor.friend.FriendInfo.toObject(message.friendsInfo[j], options);
                }
                return object;
            };

            /**
             * Converts this GetFriendListResponse to JSON.
             * @function toJSON
             * @memberof kritor.friend.GetFriendListResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetFriendListResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetFriendListResponse
             * @function getTypeUrl
             * @memberof kritor.friend.GetFriendListResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetFriendListResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.friend.GetFriendListResponse";
            };

            return GetFriendListResponse;
        })();

        friend.GetFriendProfileCardRequest = (function() {

            /**
             * Properties of a GetFriendProfileCardRequest.
             * @memberof kritor.friend
             * @interface IGetFriendProfileCardRequest
             * @property {Array.<string>|null} [targetUids] GetFriendProfileCardRequest targetUids
             * @property {Array.<number|Long>|null} [targetUins] GetFriendProfileCardRequest targetUins
             */

            /**
             * Constructs a new GetFriendProfileCardRequest.
             * @memberof kritor.friend
             * @classdesc Represents a GetFriendProfileCardRequest.
             * @implements IGetFriendProfileCardRequest
             * @constructor
             * @param {kritor.friend.IGetFriendProfileCardRequest=} [properties] Properties to set
             */
            function GetFriendProfileCardRequest(properties) {
                this.targetUids = [];
                this.targetUins = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetFriendProfileCardRequest targetUids.
             * @member {Array.<string>} targetUids
             * @memberof kritor.friend.GetFriendProfileCardRequest
             * @instance
             */
            GetFriendProfileCardRequest.prototype.targetUids = $util.emptyArray;

            /**
             * GetFriendProfileCardRequest targetUins.
             * @member {Array.<number|Long>} targetUins
             * @memberof kritor.friend.GetFriendProfileCardRequest
             * @instance
             */
            GetFriendProfileCardRequest.prototype.targetUins = $util.emptyArray;

            /**
             * Creates a new GetFriendProfileCardRequest instance using the specified properties.
             * @function create
             * @memberof kritor.friend.GetFriendProfileCardRequest
             * @static
             * @param {kritor.friend.IGetFriendProfileCardRequest=} [properties] Properties to set
             * @returns {kritor.friend.GetFriendProfileCardRequest} GetFriendProfileCardRequest instance
             */
            GetFriendProfileCardRequest.create = function create(properties) {
                return new GetFriendProfileCardRequest(properties);
            };

            /**
             * Encodes the specified GetFriendProfileCardRequest message. Does not implicitly {@link kritor.friend.GetFriendProfileCardRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.friend.GetFriendProfileCardRequest
             * @static
             * @param {kritor.friend.IGetFriendProfileCardRequest} message GetFriendProfileCardRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetFriendProfileCardRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.targetUids != null && message.targetUids.length)
                    for (let i = 0; i < message.targetUids.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.targetUids[i]);
                if (message.targetUins != null && message.targetUins.length) {
                    writer.uint32(/* id 2, wireType 2 =*/18).fork();
                    for (let i = 0; i < message.targetUins.length; ++i)
                        writer.uint64(message.targetUins[i]);
                    writer.ldelim();
                }
                return writer;
            };

            /**
             * Encodes the specified GetFriendProfileCardRequest message, length delimited. Does not implicitly {@link kritor.friend.GetFriendProfileCardRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.friend.GetFriendProfileCardRequest
             * @static
             * @param {kritor.friend.IGetFriendProfileCardRequest} message GetFriendProfileCardRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetFriendProfileCardRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetFriendProfileCardRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.friend.GetFriendProfileCardRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.friend.GetFriendProfileCardRequest} GetFriendProfileCardRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetFriendProfileCardRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.friend.GetFriendProfileCardRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.targetUids && message.targetUids.length))
                                message.targetUids = [];
                            message.targetUids.push(reader.string());
                            break;
                        }
                    case 2: {
                            if (!(message.targetUins && message.targetUins.length))
                                message.targetUins = [];
                            if ((tag & 7) === 2) {
                                let end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.targetUins.push(reader.uint64());
                            } else
                                message.targetUins.push(reader.uint64());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetFriendProfileCardRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.friend.GetFriendProfileCardRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.friend.GetFriendProfileCardRequest} GetFriendProfileCardRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetFriendProfileCardRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetFriendProfileCardRequest message.
             * @function verify
             * @memberof kritor.friend.GetFriendProfileCardRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetFriendProfileCardRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.targetUids != null && message.hasOwnProperty("targetUids")) {
                    if (!Array.isArray(message.targetUids))
                        return "targetUids: array expected";
                    for (let i = 0; i < message.targetUids.length; ++i)
                        if (!$util.isString(message.targetUids[i]))
                            return "targetUids: string[] expected";
                }
                if (message.targetUins != null && message.hasOwnProperty("targetUins")) {
                    if (!Array.isArray(message.targetUins))
                        return "targetUins: array expected";
                    for (let i = 0; i < message.targetUins.length; ++i)
                        if (!$util.isInteger(message.targetUins[i]) && !(message.targetUins[i] && $util.isInteger(message.targetUins[i].low) && $util.isInteger(message.targetUins[i].high)))
                            return "targetUins: integer|Long[] expected";
                }
                return null;
            };

            /**
             * Creates a GetFriendProfileCardRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.friend.GetFriendProfileCardRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.friend.GetFriendProfileCardRequest} GetFriendProfileCardRequest
             */
            GetFriendProfileCardRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.friend.GetFriendProfileCardRequest)
                    return object;
                let message = new $root.kritor.friend.GetFriendProfileCardRequest();
                if (object.targetUids) {
                    if (!Array.isArray(object.targetUids))
                        throw TypeError(".kritor.friend.GetFriendProfileCardRequest.targetUids: array expected");
                    message.targetUids = [];
                    for (let i = 0; i < object.targetUids.length; ++i)
                        message.targetUids[i] = String(object.targetUids[i]);
                }
                if (object.targetUins) {
                    if (!Array.isArray(object.targetUins))
                        throw TypeError(".kritor.friend.GetFriendProfileCardRequest.targetUins: array expected");
                    message.targetUins = [];
                    for (let i = 0; i < object.targetUins.length; ++i)
                        if ($util.Long)
                            (message.targetUins[i] = $util.Long.fromValue(object.targetUins[i])).unsigned = true;
                        else if (typeof object.targetUins[i] === "string")
                            message.targetUins[i] = parseInt(object.targetUins[i], 10);
                        else if (typeof object.targetUins[i] === "number")
                            message.targetUins[i] = object.targetUins[i];
                        else if (typeof object.targetUins[i] === "object")
                            message.targetUins[i] = new $util.LongBits(object.targetUins[i].low >>> 0, object.targetUins[i].high >>> 0).toNumber(true);
                }
                return message;
            };

            /**
             * Creates a plain object from a GetFriendProfileCardRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.friend.GetFriendProfileCardRequest
             * @static
             * @param {kritor.friend.GetFriendProfileCardRequest} message GetFriendProfileCardRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetFriendProfileCardRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.targetUids = [];
                    object.targetUins = [];
                }
                if (message.targetUids && message.targetUids.length) {
                    object.targetUids = [];
                    for (let j = 0; j < message.targetUids.length; ++j)
                        object.targetUids[j] = message.targetUids[j];
                }
                if (message.targetUins && message.targetUins.length) {
                    object.targetUins = [];
                    for (let j = 0; j < message.targetUins.length; ++j)
                        if (typeof message.targetUins[j] === "number")
                            object.targetUins[j] = options.longs === String ? String(message.targetUins[j]) : message.targetUins[j];
                        else
                            object.targetUins[j] = options.longs === String ? $util.Long.prototype.toString.call(message.targetUins[j]) : options.longs === Number ? new $util.LongBits(message.targetUins[j].low >>> 0, message.targetUins[j].high >>> 0).toNumber(true) : message.targetUins[j];
                }
                return object;
            };

            /**
             * Converts this GetFriendProfileCardRequest to JSON.
             * @function toJSON
             * @memberof kritor.friend.GetFriendProfileCardRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetFriendProfileCardRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetFriendProfileCardRequest
             * @function getTypeUrl
             * @memberof kritor.friend.GetFriendProfileCardRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetFriendProfileCardRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.friend.GetFriendProfileCardRequest";
            };

            return GetFriendProfileCardRequest;
        })();

        friend.GetFriendProfileCardResponse = (function() {

            /**
             * Properties of a GetFriendProfileCardResponse.
             * @memberof kritor.friend
             * @interface IGetFriendProfileCardResponse
             * @property {Array.<kritor.friend.IProfileCard>|null} [friendsProfileCard] GetFriendProfileCardResponse friendsProfileCard
             */

            /**
             * Constructs a new GetFriendProfileCardResponse.
             * @memberof kritor.friend
             * @classdesc Represents a GetFriendProfileCardResponse.
             * @implements IGetFriendProfileCardResponse
             * @constructor
             * @param {kritor.friend.IGetFriendProfileCardResponse=} [properties] Properties to set
             */
            function GetFriendProfileCardResponse(properties) {
                this.friendsProfileCard = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetFriendProfileCardResponse friendsProfileCard.
             * @member {Array.<kritor.friend.IProfileCard>} friendsProfileCard
             * @memberof kritor.friend.GetFriendProfileCardResponse
             * @instance
             */
            GetFriendProfileCardResponse.prototype.friendsProfileCard = $util.emptyArray;

            /**
             * Creates a new GetFriendProfileCardResponse instance using the specified properties.
             * @function create
             * @memberof kritor.friend.GetFriendProfileCardResponse
             * @static
             * @param {kritor.friend.IGetFriendProfileCardResponse=} [properties] Properties to set
             * @returns {kritor.friend.GetFriendProfileCardResponse} GetFriendProfileCardResponse instance
             */
            GetFriendProfileCardResponse.create = function create(properties) {
                return new GetFriendProfileCardResponse(properties);
            };

            /**
             * Encodes the specified GetFriendProfileCardResponse message. Does not implicitly {@link kritor.friend.GetFriendProfileCardResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.friend.GetFriendProfileCardResponse
             * @static
             * @param {kritor.friend.IGetFriendProfileCardResponse} message GetFriendProfileCardResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetFriendProfileCardResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.friendsProfileCard != null && message.friendsProfileCard.length)
                    for (let i = 0; i < message.friendsProfileCard.length; ++i)
                        $root.kritor.friend.ProfileCard.encode(message.friendsProfileCard[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetFriendProfileCardResponse message, length delimited. Does not implicitly {@link kritor.friend.GetFriendProfileCardResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.friend.GetFriendProfileCardResponse
             * @static
             * @param {kritor.friend.IGetFriendProfileCardResponse} message GetFriendProfileCardResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetFriendProfileCardResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetFriendProfileCardResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.friend.GetFriendProfileCardResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.friend.GetFriendProfileCardResponse} GetFriendProfileCardResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetFriendProfileCardResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.friend.GetFriendProfileCardResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.friendsProfileCard && message.friendsProfileCard.length))
                                message.friendsProfileCard = [];
                            message.friendsProfileCard.push($root.kritor.friend.ProfileCard.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetFriendProfileCardResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.friend.GetFriendProfileCardResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.friend.GetFriendProfileCardResponse} GetFriendProfileCardResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetFriendProfileCardResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetFriendProfileCardResponse message.
             * @function verify
             * @memberof kritor.friend.GetFriendProfileCardResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetFriendProfileCardResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.friendsProfileCard != null && message.hasOwnProperty("friendsProfileCard")) {
                    if (!Array.isArray(message.friendsProfileCard))
                        return "friendsProfileCard: array expected";
                    for (let i = 0; i < message.friendsProfileCard.length; ++i) {
                        let error = $root.kritor.friend.ProfileCard.verify(message.friendsProfileCard[i]);
                        if (error)
                            return "friendsProfileCard." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a GetFriendProfileCardResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.friend.GetFriendProfileCardResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.friend.GetFriendProfileCardResponse} GetFriendProfileCardResponse
             */
            GetFriendProfileCardResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.friend.GetFriendProfileCardResponse)
                    return object;
                let message = new $root.kritor.friend.GetFriendProfileCardResponse();
                if (object.friendsProfileCard) {
                    if (!Array.isArray(object.friendsProfileCard))
                        throw TypeError(".kritor.friend.GetFriendProfileCardResponse.friendsProfileCard: array expected");
                    message.friendsProfileCard = [];
                    for (let i = 0; i < object.friendsProfileCard.length; ++i) {
                        if (typeof object.friendsProfileCard[i] !== "object")
                            throw TypeError(".kritor.friend.GetFriendProfileCardResponse.friendsProfileCard: object expected");
                        message.friendsProfileCard[i] = $root.kritor.friend.ProfileCard.fromObject(object.friendsProfileCard[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a GetFriendProfileCardResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.friend.GetFriendProfileCardResponse
             * @static
             * @param {kritor.friend.GetFriendProfileCardResponse} message GetFriendProfileCardResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetFriendProfileCardResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.friendsProfileCard = [];
                if (message.friendsProfileCard && message.friendsProfileCard.length) {
                    object.friendsProfileCard = [];
                    for (let j = 0; j < message.friendsProfileCard.length; ++j)
                        object.friendsProfileCard[j] = $root.kritor.friend.ProfileCard.toObject(message.friendsProfileCard[j], options);
                }
                return object;
            };

            /**
             * Converts this GetFriendProfileCardResponse to JSON.
             * @function toJSON
             * @memberof kritor.friend.GetFriendProfileCardResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetFriendProfileCardResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetFriendProfileCardResponse
             * @function getTypeUrl
             * @memberof kritor.friend.GetFriendProfileCardResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetFriendProfileCardResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.friend.GetFriendProfileCardResponse";
            };

            return GetFriendProfileCardResponse;
        })();

        friend.GetStrangerProfileCardRequest = (function() {

            /**
             * Properties of a GetStrangerProfileCardRequest.
             * @memberof kritor.friend
             * @interface IGetStrangerProfileCardRequest
             * @property {Array.<string>|null} [targetUids] GetStrangerProfileCardRequest targetUids
             * @property {Array.<number|Long>|null} [targetUins] GetStrangerProfileCardRequest targetUins
             */

            /**
             * Constructs a new GetStrangerProfileCardRequest.
             * @memberof kritor.friend
             * @classdesc Represents a GetStrangerProfileCardRequest.
             * @implements IGetStrangerProfileCardRequest
             * @constructor
             * @param {kritor.friend.IGetStrangerProfileCardRequest=} [properties] Properties to set
             */
            function GetStrangerProfileCardRequest(properties) {
                this.targetUids = [];
                this.targetUins = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetStrangerProfileCardRequest targetUids.
             * @member {Array.<string>} targetUids
             * @memberof kritor.friend.GetStrangerProfileCardRequest
             * @instance
             */
            GetStrangerProfileCardRequest.prototype.targetUids = $util.emptyArray;

            /**
             * GetStrangerProfileCardRequest targetUins.
             * @member {Array.<number|Long>} targetUins
             * @memberof kritor.friend.GetStrangerProfileCardRequest
             * @instance
             */
            GetStrangerProfileCardRequest.prototype.targetUins = $util.emptyArray;

            /**
             * Creates a new GetStrangerProfileCardRequest instance using the specified properties.
             * @function create
             * @memberof kritor.friend.GetStrangerProfileCardRequest
             * @static
             * @param {kritor.friend.IGetStrangerProfileCardRequest=} [properties] Properties to set
             * @returns {kritor.friend.GetStrangerProfileCardRequest} GetStrangerProfileCardRequest instance
             */
            GetStrangerProfileCardRequest.create = function create(properties) {
                return new GetStrangerProfileCardRequest(properties);
            };

            /**
             * Encodes the specified GetStrangerProfileCardRequest message. Does not implicitly {@link kritor.friend.GetStrangerProfileCardRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.friend.GetStrangerProfileCardRequest
             * @static
             * @param {kritor.friend.IGetStrangerProfileCardRequest} message GetStrangerProfileCardRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetStrangerProfileCardRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.targetUids != null && message.targetUids.length)
                    for (let i = 0; i < message.targetUids.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.targetUids[i]);
                if (message.targetUins != null && message.targetUins.length) {
                    writer.uint32(/* id 2, wireType 2 =*/18).fork();
                    for (let i = 0; i < message.targetUins.length; ++i)
                        writer.uint64(message.targetUins[i]);
                    writer.ldelim();
                }
                return writer;
            };

            /**
             * Encodes the specified GetStrangerProfileCardRequest message, length delimited. Does not implicitly {@link kritor.friend.GetStrangerProfileCardRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.friend.GetStrangerProfileCardRequest
             * @static
             * @param {kritor.friend.IGetStrangerProfileCardRequest} message GetStrangerProfileCardRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetStrangerProfileCardRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetStrangerProfileCardRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.friend.GetStrangerProfileCardRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.friend.GetStrangerProfileCardRequest} GetStrangerProfileCardRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetStrangerProfileCardRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.friend.GetStrangerProfileCardRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.targetUids && message.targetUids.length))
                                message.targetUids = [];
                            message.targetUids.push(reader.string());
                            break;
                        }
                    case 2: {
                            if (!(message.targetUins && message.targetUins.length))
                                message.targetUins = [];
                            if ((tag & 7) === 2) {
                                let end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.targetUins.push(reader.uint64());
                            } else
                                message.targetUins.push(reader.uint64());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetStrangerProfileCardRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.friend.GetStrangerProfileCardRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.friend.GetStrangerProfileCardRequest} GetStrangerProfileCardRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetStrangerProfileCardRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetStrangerProfileCardRequest message.
             * @function verify
             * @memberof kritor.friend.GetStrangerProfileCardRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetStrangerProfileCardRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.targetUids != null && message.hasOwnProperty("targetUids")) {
                    if (!Array.isArray(message.targetUids))
                        return "targetUids: array expected";
                    for (let i = 0; i < message.targetUids.length; ++i)
                        if (!$util.isString(message.targetUids[i]))
                            return "targetUids: string[] expected";
                }
                if (message.targetUins != null && message.hasOwnProperty("targetUins")) {
                    if (!Array.isArray(message.targetUins))
                        return "targetUins: array expected";
                    for (let i = 0; i < message.targetUins.length; ++i)
                        if (!$util.isInteger(message.targetUins[i]) && !(message.targetUins[i] && $util.isInteger(message.targetUins[i].low) && $util.isInteger(message.targetUins[i].high)))
                            return "targetUins: integer|Long[] expected";
                }
                return null;
            };

            /**
             * Creates a GetStrangerProfileCardRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.friend.GetStrangerProfileCardRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.friend.GetStrangerProfileCardRequest} GetStrangerProfileCardRequest
             */
            GetStrangerProfileCardRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.friend.GetStrangerProfileCardRequest)
                    return object;
                let message = new $root.kritor.friend.GetStrangerProfileCardRequest();
                if (object.targetUids) {
                    if (!Array.isArray(object.targetUids))
                        throw TypeError(".kritor.friend.GetStrangerProfileCardRequest.targetUids: array expected");
                    message.targetUids = [];
                    for (let i = 0; i < object.targetUids.length; ++i)
                        message.targetUids[i] = String(object.targetUids[i]);
                }
                if (object.targetUins) {
                    if (!Array.isArray(object.targetUins))
                        throw TypeError(".kritor.friend.GetStrangerProfileCardRequest.targetUins: array expected");
                    message.targetUins = [];
                    for (let i = 0; i < object.targetUins.length; ++i)
                        if ($util.Long)
                            (message.targetUins[i] = $util.Long.fromValue(object.targetUins[i])).unsigned = true;
                        else if (typeof object.targetUins[i] === "string")
                            message.targetUins[i] = parseInt(object.targetUins[i], 10);
                        else if (typeof object.targetUins[i] === "number")
                            message.targetUins[i] = object.targetUins[i];
                        else if (typeof object.targetUins[i] === "object")
                            message.targetUins[i] = new $util.LongBits(object.targetUins[i].low >>> 0, object.targetUins[i].high >>> 0).toNumber(true);
                }
                return message;
            };

            /**
             * Creates a plain object from a GetStrangerProfileCardRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.friend.GetStrangerProfileCardRequest
             * @static
             * @param {kritor.friend.GetStrangerProfileCardRequest} message GetStrangerProfileCardRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetStrangerProfileCardRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.targetUids = [];
                    object.targetUins = [];
                }
                if (message.targetUids && message.targetUids.length) {
                    object.targetUids = [];
                    for (let j = 0; j < message.targetUids.length; ++j)
                        object.targetUids[j] = message.targetUids[j];
                }
                if (message.targetUins && message.targetUins.length) {
                    object.targetUins = [];
                    for (let j = 0; j < message.targetUins.length; ++j)
                        if (typeof message.targetUins[j] === "number")
                            object.targetUins[j] = options.longs === String ? String(message.targetUins[j]) : message.targetUins[j];
                        else
                            object.targetUins[j] = options.longs === String ? $util.Long.prototype.toString.call(message.targetUins[j]) : options.longs === Number ? new $util.LongBits(message.targetUins[j].low >>> 0, message.targetUins[j].high >>> 0).toNumber(true) : message.targetUins[j];
                }
                return object;
            };

            /**
             * Converts this GetStrangerProfileCardRequest to JSON.
             * @function toJSON
             * @memberof kritor.friend.GetStrangerProfileCardRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetStrangerProfileCardRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetStrangerProfileCardRequest
             * @function getTypeUrl
             * @memberof kritor.friend.GetStrangerProfileCardRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetStrangerProfileCardRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.friend.GetStrangerProfileCardRequest";
            };

            return GetStrangerProfileCardRequest;
        })();

        friend.GetStrangerProfileCardResponse = (function() {

            /**
             * Properties of a GetStrangerProfileCardResponse.
             * @memberof kritor.friend
             * @interface IGetStrangerProfileCardResponse
             * @property {Array.<kritor.friend.IProfileCard>|null} [strangersProfileCard] GetStrangerProfileCardResponse strangersProfileCard
             */

            /**
             * Constructs a new GetStrangerProfileCardResponse.
             * @memberof kritor.friend
             * @classdesc Represents a GetStrangerProfileCardResponse.
             * @implements IGetStrangerProfileCardResponse
             * @constructor
             * @param {kritor.friend.IGetStrangerProfileCardResponse=} [properties] Properties to set
             */
            function GetStrangerProfileCardResponse(properties) {
                this.strangersProfileCard = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetStrangerProfileCardResponse strangersProfileCard.
             * @member {Array.<kritor.friend.IProfileCard>} strangersProfileCard
             * @memberof kritor.friend.GetStrangerProfileCardResponse
             * @instance
             */
            GetStrangerProfileCardResponse.prototype.strangersProfileCard = $util.emptyArray;

            /**
             * Creates a new GetStrangerProfileCardResponse instance using the specified properties.
             * @function create
             * @memberof kritor.friend.GetStrangerProfileCardResponse
             * @static
             * @param {kritor.friend.IGetStrangerProfileCardResponse=} [properties] Properties to set
             * @returns {kritor.friend.GetStrangerProfileCardResponse} GetStrangerProfileCardResponse instance
             */
            GetStrangerProfileCardResponse.create = function create(properties) {
                return new GetStrangerProfileCardResponse(properties);
            };

            /**
             * Encodes the specified GetStrangerProfileCardResponse message. Does not implicitly {@link kritor.friend.GetStrangerProfileCardResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.friend.GetStrangerProfileCardResponse
             * @static
             * @param {kritor.friend.IGetStrangerProfileCardResponse} message GetStrangerProfileCardResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetStrangerProfileCardResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.strangersProfileCard != null && message.strangersProfileCard.length)
                    for (let i = 0; i < message.strangersProfileCard.length; ++i)
                        $root.kritor.friend.ProfileCard.encode(message.strangersProfileCard[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetStrangerProfileCardResponse message, length delimited. Does not implicitly {@link kritor.friend.GetStrangerProfileCardResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.friend.GetStrangerProfileCardResponse
             * @static
             * @param {kritor.friend.IGetStrangerProfileCardResponse} message GetStrangerProfileCardResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetStrangerProfileCardResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetStrangerProfileCardResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.friend.GetStrangerProfileCardResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.friend.GetStrangerProfileCardResponse} GetStrangerProfileCardResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetStrangerProfileCardResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.friend.GetStrangerProfileCardResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.strangersProfileCard && message.strangersProfileCard.length))
                                message.strangersProfileCard = [];
                            message.strangersProfileCard.push($root.kritor.friend.ProfileCard.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetStrangerProfileCardResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.friend.GetStrangerProfileCardResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.friend.GetStrangerProfileCardResponse} GetStrangerProfileCardResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetStrangerProfileCardResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetStrangerProfileCardResponse message.
             * @function verify
             * @memberof kritor.friend.GetStrangerProfileCardResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetStrangerProfileCardResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.strangersProfileCard != null && message.hasOwnProperty("strangersProfileCard")) {
                    if (!Array.isArray(message.strangersProfileCard))
                        return "strangersProfileCard: array expected";
                    for (let i = 0; i < message.strangersProfileCard.length; ++i) {
                        let error = $root.kritor.friend.ProfileCard.verify(message.strangersProfileCard[i]);
                        if (error)
                            return "strangersProfileCard." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a GetStrangerProfileCardResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.friend.GetStrangerProfileCardResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.friend.GetStrangerProfileCardResponse} GetStrangerProfileCardResponse
             */
            GetStrangerProfileCardResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.friend.GetStrangerProfileCardResponse)
                    return object;
                let message = new $root.kritor.friend.GetStrangerProfileCardResponse();
                if (object.strangersProfileCard) {
                    if (!Array.isArray(object.strangersProfileCard))
                        throw TypeError(".kritor.friend.GetStrangerProfileCardResponse.strangersProfileCard: array expected");
                    message.strangersProfileCard = [];
                    for (let i = 0; i < object.strangersProfileCard.length; ++i) {
                        if (typeof object.strangersProfileCard[i] !== "object")
                            throw TypeError(".kritor.friend.GetStrangerProfileCardResponse.strangersProfileCard: object expected");
                        message.strangersProfileCard[i] = $root.kritor.friend.ProfileCard.fromObject(object.strangersProfileCard[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a GetStrangerProfileCardResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.friend.GetStrangerProfileCardResponse
             * @static
             * @param {kritor.friend.GetStrangerProfileCardResponse} message GetStrangerProfileCardResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetStrangerProfileCardResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.strangersProfileCard = [];
                if (message.strangersProfileCard && message.strangersProfileCard.length) {
                    object.strangersProfileCard = [];
                    for (let j = 0; j < message.strangersProfileCard.length; ++j)
                        object.strangersProfileCard[j] = $root.kritor.friend.ProfileCard.toObject(message.strangersProfileCard[j], options);
                }
                return object;
            };

            /**
             * Converts this GetStrangerProfileCardResponse to JSON.
             * @function toJSON
             * @memberof kritor.friend.GetStrangerProfileCardResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetStrangerProfileCardResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetStrangerProfileCardResponse
             * @function getTypeUrl
             * @memberof kritor.friend.GetStrangerProfileCardResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetStrangerProfileCardResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.friend.GetStrangerProfileCardResponse";
            };

            return GetStrangerProfileCardResponse;
        })();

        friend.SetProfileCardRequest = (function() {

            /**
             * Properties of a SetProfileCardRequest.
             * @memberof kritor.friend
             * @interface ISetProfileCardRequest
             * @property {string|null} [nickName] SetProfileCardRequest nickName
             * @property {string|null} [company] SetProfileCardRequest company
             * @property {string|null} [email] SetProfileCardRequest email
             * @property {string|null} [college] SetProfileCardRequest college
             * @property {string|null} [personalNote] SetProfileCardRequest personalNote
             * @property {number|null} [birthday] SetProfileCardRequest birthday
             * @property {number|null} [age] SetProfileCardRequest age
             */

            /**
             * Constructs a new SetProfileCardRequest.
             * @memberof kritor.friend
             * @classdesc Represents a SetProfileCardRequest.
             * @implements ISetProfileCardRequest
             * @constructor
             * @param {kritor.friend.ISetProfileCardRequest=} [properties] Properties to set
             */
            function SetProfileCardRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SetProfileCardRequest nickName.
             * @member {string|null|undefined} nickName
             * @memberof kritor.friend.SetProfileCardRequest
             * @instance
             */
            SetProfileCardRequest.prototype.nickName = null;

            /**
             * SetProfileCardRequest company.
             * @member {string|null|undefined} company
             * @memberof kritor.friend.SetProfileCardRequest
             * @instance
             */
            SetProfileCardRequest.prototype.company = null;

            /**
             * SetProfileCardRequest email.
             * @member {string|null|undefined} email
             * @memberof kritor.friend.SetProfileCardRequest
             * @instance
             */
            SetProfileCardRequest.prototype.email = null;

            /**
             * SetProfileCardRequest college.
             * @member {string|null|undefined} college
             * @memberof kritor.friend.SetProfileCardRequest
             * @instance
             */
            SetProfileCardRequest.prototype.college = null;

            /**
             * SetProfileCardRequest personalNote.
             * @member {string|null|undefined} personalNote
             * @memberof kritor.friend.SetProfileCardRequest
             * @instance
             */
            SetProfileCardRequest.prototype.personalNote = null;

            /**
             * SetProfileCardRequest birthday.
             * @member {number|null|undefined} birthday
             * @memberof kritor.friend.SetProfileCardRequest
             * @instance
             */
            SetProfileCardRequest.prototype.birthday = null;

            /**
             * SetProfileCardRequest age.
             * @member {number|null|undefined} age
             * @memberof kritor.friend.SetProfileCardRequest
             * @instance
             */
            SetProfileCardRequest.prototype.age = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * SetProfileCardRequest _nickName.
             * @member {"nickName"|undefined} _nickName
             * @memberof kritor.friend.SetProfileCardRequest
             * @instance
             */
            Object.defineProperty(SetProfileCardRequest.prototype, "_nickName", {
                get: $util.oneOfGetter($oneOfFields = ["nickName"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * SetProfileCardRequest _company.
             * @member {"company"|undefined} _company
             * @memberof kritor.friend.SetProfileCardRequest
             * @instance
             */
            Object.defineProperty(SetProfileCardRequest.prototype, "_company", {
                get: $util.oneOfGetter($oneOfFields = ["company"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * SetProfileCardRequest _email.
             * @member {"email"|undefined} _email
             * @memberof kritor.friend.SetProfileCardRequest
             * @instance
             */
            Object.defineProperty(SetProfileCardRequest.prototype, "_email", {
                get: $util.oneOfGetter($oneOfFields = ["email"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * SetProfileCardRequest _college.
             * @member {"college"|undefined} _college
             * @memberof kritor.friend.SetProfileCardRequest
             * @instance
             */
            Object.defineProperty(SetProfileCardRequest.prototype, "_college", {
                get: $util.oneOfGetter($oneOfFields = ["college"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * SetProfileCardRequest _personalNote.
             * @member {"personalNote"|undefined} _personalNote
             * @memberof kritor.friend.SetProfileCardRequest
             * @instance
             */
            Object.defineProperty(SetProfileCardRequest.prototype, "_personalNote", {
                get: $util.oneOfGetter($oneOfFields = ["personalNote"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * SetProfileCardRequest _birthday.
             * @member {"birthday"|undefined} _birthday
             * @memberof kritor.friend.SetProfileCardRequest
             * @instance
             */
            Object.defineProperty(SetProfileCardRequest.prototype, "_birthday", {
                get: $util.oneOfGetter($oneOfFields = ["birthday"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * SetProfileCardRequest _age.
             * @member {"age"|undefined} _age
             * @memberof kritor.friend.SetProfileCardRequest
             * @instance
             */
            Object.defineProperty(SetProfileCardRequest.prototype, "_age", {
                get: $util.oneOfGetter($oneOfFields = ["age"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new SetProfileCardRequest instance using the specified properties.
             * @function create
             * @memberof kritor.friend.SetProfileCardRequest
             * @static
             * @param {kritor.friend.ISetProfileCardRequest=} [properties] Properties to set
             * @returns {kritor.friend.SetProfileCardRequest} SetProfileCardRequest instance
             */
            SetProfileCardRequest.create = function create(properties) {
                return new SetProfileCardRequest(properties);
            };

            /**
             * Encodes the specified SetProfileCardRequest message. Does not implicitly {@link kritor.friend.SetProfileCardRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.friend.SetProfileCardRequest
             * @static
             * @param {kritor.friend.ISetProfileCardRequest} message SetProfileCardRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetProfileCardRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.nickName != null && Object.hasOwnProperty.call(message, "nickName"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.nickName);
                if (message.company != null && Object.hasOwnProperty.call(message, "company"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.company);
                if (message.email != null && Object.hasOwnProperty.call(message, "email"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.email);
                if (message.college != null && Object.hasOwnProperty.call(message, "college"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.college);
                if (message.personalNote != null && Object.hasOwnProperty.call(message, "personalNote"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.personalNote);
                if (message.birthday != null && Object.hasOwnProperty.call(message, "birthday"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.birthday);
                if (message.age != null && Object.hasOwnProperty.call(message, "age"))
                    writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.age);
                return writer;
            };

            /**
             * Encodes the specified SetProfileCardRequest message, length delimited. Does not implicitly {@link kritor.friend.SetProfileCardRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.friend.SetProfileCardRequest
             * @static
             * @param {kritor.friend.ISetProfileCardRequest} message SetProfileCardRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetProfileCardRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetProfileCardRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.friend.SetProfileCardRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.friend.SetProfileCardRequest} SetProfileCardRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetProfileCardRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.friend.SetProfileCardRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.nickName = reader.string();
                            break;
                        }
                    case 2: {
                            message.company = reader.string();
                            break;
                        }
                    case 3: {
                            message.email = reader.string();
                            break;
                        }
                    case 4: {
                            message.college = reader.string();
                            break;
                        }
                    case 5: {
                            message.personalNote = reader.string();
                            break;
                        }
                    case 6: {
                            message.birthday = reader.uint32();
                            break;
                        }
                    case 7: {
                            message.age = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetProfileCardRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.friend.SetProfileCardRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.friend.SetProfileCardRequest} SetProfileCardRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetProfileCardRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetProfileCardRequest message.
             * @function verify
             * @memberof kritor.friend.SetProfileCardRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetProfileCardRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.nickName != null && message.hasOwnProperty("nickName")) {
                    properties._nickName = 1;
                    if (!$util.isString(message.nickName))
                        return "nickName: string expected";
                }
                if (message.company != null && message.hasOwnProperty("company")) {
                    properties._company = 1;
                    if (!$util.isString(message.company))
                        return "company: string expected";
                }
                if (message.email != null && message.hasOwnProperty("email")) {
                    properties._email = 1;
                    if (!$util.isString(message.email))
                        return "email: string expected";
                }
                if (message.college != null && message.hasOwnProperty("college")) {
                    properties._college = 1;
                    if (!$util.isString(message.college))
                        return "college: string expected";
                }
                if (message.personalNote != null && message.hasOwnProperty("personalNote")) {
                    properties._personalNote = 1;
                    if (!$util.isString(message.personalNote))
                        return "personalNote: string expected";
                }
                if (message.birthday != null && message.hasOwnProperty("birthday")) {
                    properties._birthday = 1;
                    if (!$util.isInteger(message.birthday))
                        return "birthday: integer expected";
                }
                if (message.age != null && message.hasOwnProperty("age")) {
                    properties._age = 1;
                    if (!$util.isInteger(message.age))
                        return "age: integer expected";
                }
                return null;
            };

            /**
             * Creates a SetProfileCardRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.friend.SetProfileCardRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.friend.SetProfileCardRequest} SetProfileCardRequest
             */
            SetProfileCardRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.friend.SetProfileCardRequest)
                    return object;
                let message = new $root.kritor.friend.SetProfileCardRequest();
                if (object.nickName != null)
                    message.nickName = String(object.nickName);
                if (object.company != null)
                    message.company = String(object.company);
                if (object.email != null)
                    message.email = String(object.email);
                if (object.college != null)
                    message.college = String(object.college);
                if (object.personalNote != null)
                    message.personalNote = String(object.personalNote);
                if (object.birthday != null)
                    message.birthday = object.birthday >>> 0;
                if (object.age != null)
                    message.age = object.age >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a SetProfileCardRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.friend.SetProfileCardRequest
             * @static
             * @param {kritor.friend.SetProfileCardRequest} message SetProfileCardRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetProfileCardRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (message.nickName != null && message.hasOwnProperty("nickName")) {
                    object.nickName = message.nickName;
                    if (options.oneofs)
                        object._nickName = "nickName";
                }
                if (message.company != null && message.hasOwnProperty("company")) {
                    object.company = message.company;
                    if (options.oneofs)
                        object._company = "company";
                }
                if (message.email != null && message.hasOwnProperty("email")) {
                    object.email = message.email;
                    if (options.oneofs)
                        object._email = "email";
                }
                if (message.college != null && message.hasOwnProperty("college")) {
                    object.college = message.college;
                    if (options.oneofs)
                        object._college = "college";
                }
                if (message.personalNote != null && message.hasOwnProperty("personalNote")) {
                    object.personalNote = message.personalNote;
                    if (options.oneofs)
                        object._personalNote = "personalNote";
                }
                if (message.birthday != null && message.hasOwnProperty("birthday")) {
                    object.birthday = message.birthday;
                    if (options.oneofs)
                        object._birthday = "birthday";
                }
                if (message.age != null && message.hasOwnProperty("age")) {
                    object.age = message.age;
                    if (options.oneofs)
                        object._age = "age";
                }
                return object;
            };

            /**
             * Converts this SetProfileCardRequest to JSON.
             * @function toJSON
             * @memberof kritor.friend.SetProfileCardRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetProfileCardRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetProfileCardRequest
             * @function getTypeUrl
             * @memberof kritor.friend.SetProfileCardRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetProfileCardRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.friend.SetProfileCardRequest";
            };

            return SetProfileCardRequest;
        })();

        friend.SetProfileCardResponse = (function() {

            /**
             * Properties of a SetProfileCardResponse.
             * @memberof kritor.friend
             * @interface ISetProfileCardResponse
             */

            /**
             * Constructs a new SetProfileCardResponse.
             * @memberof kritor.friend
             * @classdesc Represents a SetProfileCardResponse.
             * @implements ISetProfileCardResponse
             * @constructor
             * @param {kritor.friend.ISetProfileCardResponse=} [properties] Properties to set
             */
            function SetProfileCardResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new SetProfileCardResponse instance using the specified properties.
             * @function create
             * @memberof kritor.friend.SetProfileCardResponse
             * @static
             * @param {kritor.friend.ISetProfileCardResponse=} [properties] Properties to set
             * @returns {kritor.friend.SetProfileCardResponse} SetProfileCardResponse instance
             */
            SetProfileCardResponse.create = function create(properties) {
                return new SetProfileCardResponse(properties);
            };

            /**
             * Encodes the specified SetProfileCardResponse message. Does not implicitly {@link kritor.friend.SetProfileCardResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.friend.SetProfileCardResponse
             * @static
             * @param {kritor.friend.ISetProfileCardResponse} message SetProfileCardResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetProfileCardResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified SetProfileCardResponse message, length delimited. Does not implicitly {@link kritor.friend.SetProfileCardResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.friend.SetProfileCardResponse
             * @static
             * @param {kritor.friend.ISetProfileCardResponse} message SetProfileCardResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetProfileCardResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetProfileCardResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.friend.SetProfileCardResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.friend.SetProfileCardResponse} SetProfileCardResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetProfileCardResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.friend.SetProfileCardResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetProfileCardResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.friend.SetProfileCardResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.friend.SetProfileCardResponse} SetProfileCardResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetProfileCardResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetProfileCardResponse message.
             * @function verify
             * @memberof kritor.friend.SetProfileCardResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetProfileCardResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a SetProfileCardResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.friend.SetProfileCardResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.friend.SetProfileCardResponse} SetProfileCardResponse
             */
            SetProfileCardResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.friend.SetProfileCardResponse)
                    return object;
                return new $root.kritor.friend.SetProfileCardResponse();
            };

            /**
             * Creates a plain object from a SetProfileCardResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.friend.SetProfileCardResponse
             * @static
             * @param {kritor.friend.SetProfileCardResponse} message SetProfileCardResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetProfileCardResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this SetProfileCardResponse to JSON.
             * @function toJSON
             * @memberof kritor.friend.SetProfileCardResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetProfileCardResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetProfileCardResponse
             * @function getTypeUrl
             * @memberof kritor.friend.SetProfileCardResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetProfileCardResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.friend.SetProfileCardResponse";
            };

            return SetProfileCardResponse;
        })();

        friend.IsBlackListUserRequest = (function() {

            /**
             * Properties of an IsBlackListUserRequest.
             * @memberof kritor.friend
             * @interface IIsBlackListUserRequest
             * @property {string|null} [targetUid] IsBlackListUserRequest targetUid
             * @property {number|Long|null} [targetUin] IsBlackListUserRequest targetUin
             */

            /**
             * Constructs a new IsBlackListUserRequest.
             * @memberof kritor.friend
             * @classdesc Represents an IsBlackListUserRequest.
             * @implements IIsBlackListUserRequest
             * @constructor
             * @param {kritor.friend.IIsBlackListUserRequest=} [properties] Properties to set
             */
            function IsBlackListUserRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * IsBlackListUserRequest targetUid.
             * @member {string|null|undefined} targetUid
             * @memberof kritor.friend.IsBlackListUserRequest
             * @instance
             */
            IsBlackListUserRequest.prototype.targetUid = null;

            /**
             * IsBlackListUserRequest targetUin.
             * @member {number|Long|null|undefined} targetUin
             * @memberof kritor.friend.IsBlackListUserRequest
             * @instance
             */
            IsBlackListUserRequest.prototype.targetUin = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * IsBlackListUserRequest target.
             * @member {"targetUid"|"targetUin"|undefined} target
             * @memberof kritor.friend.IsBlackListUserRequest
             * @instance
             */
            Object.defineProperty(IsBlackListUserRequest.prototype, "target", {
                get: $util.oneOfGetter($oneOfFields = ["targetUid", "targetUin"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new IsBlackListUserRequest instance using the specified properties.
             * @function create
             * @memberof kritor.friend.IsBlackListUserRequest
             * @static
             * @param {kritor.friend.IIsBlackListUserRequest=} [properties] Properties to set
             * @returns {kritor.friend.IsBlackListUserRequest} IsBlackListUserRequest instance
             */
            IsBlackListUserRequest.create = function create(properties) {
                return new IsBlackListUserRequest(properties);
            };

            /**
             * Encodes the specified IsBlackListUserRequest message. Does not implicitly {@link kritor.friend.IsBlackListUserRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.friend.IsBlackListUserRequest
             * @static
             * @param {kritor.friend.IIsBlackListUserRequest} message IsBlackListUserRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IsBlackListUserRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.targetUid != null && Object.hasOwnProperty.call(message, "targetUid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.targetUid);
                if (message.targetUin != null && Object.hasOwnProperty.call(message, "targetUin"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.targetUin);
                return writer;
            };

            /**
             * Encodes the specified IsBlackListUserRequest message, length delimited. Does not implicitly {@link kritor.friend.IsBlackListUserRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.friend.IsBlackListUserRequest
             * @static
             * @param {kritor.friend.IIsBlackListUserRequest} message IsBlackListUserRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IsBlackListUserRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an IsBlackListUserRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.friend.IsBlackListUserRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.friend.IsBlackListUserRequest} IsBlackListUserRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IsBlackListUserRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.friend.IsBlackListUserRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.targetUid = reader.string();
                            break;
                        }
                    case 2: {
                            message.targetUin = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an IsBlackListUserRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.friend.IsBlackListUserRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.friend.IsBlackListUserRequest} IsBlackListUserRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IsBlackListUserRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an IsBlackListUserRequest message.
             * @function verify
             * @memberof kritor.friend.IsBlackListUserRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            IsBlackListUserRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.targetUid != null && message.hasOwnProperty("targetUid")) {
                    properties.target = 1;
                    if (!$util.isString(message.targetUid))
                        return "targetUid: string expected";
                }
                if (message.targetUin != null && message.hasOwnProperty("targetUin")) {
                    if (properties.target === 1)
                        return "target: multiple values";
                    properties.target = 1;
                    if (!$util.isInteger(message.targetUin) && !(message.targetUin && $util.isInteger(message.targetUin.low) && $util.isInteger(message.targetUin.high)))
                        return "targetUin: integer|Long expected";
                }
                return null;
            };

            /**
             * Creates an IsBlackListUserRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.friend.IsBlackListUserRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.friend.IsBlackListUserRequest} IsBlackListUserRequest
             */
            IsBlackListUserRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.friend.IsBlackListUserRequest)
                    return object;
                let message = new $root.kritor.friend.IsBlackListUserRequest();
                if (object.targetUid != null)
                    message.targetUid = String(object.targetUid);
                if (object.targetUin != null)
                    if ($util.Long)
                        (message.targetUin = $util.Long.fromValue(object.targetUin)).unsigned = true;
                    else if (typeof object.targetUin === "string")
                        message.targetUin = parseInt(object.targetUin, 10);
                    else if (typeof object.targetUin === "number")
                        message.targetUin = object.targetUin;
                    else if (typeof object.targetUin === "object")
                        message.targetUin = new $util.LongBits(object.targetUin.low >>> 0, object.targetUin.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from an IsBlackListUserRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.friend.IsBlackListUserRequest
             * @static
             * @param {kritor.friend.IsBlackListUserRequest} message IsBlackListUserRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            IsBlackListUserRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (message.targetUid != null && message.hasOwnProperty("targetUid")) {
                    object.targetUid = message.targetUid;
                    if (options.oneofs)
                        object.target = "targetUid";
                }
                if (message.targetUin != null && message.hasOwnProperty("targetUin")) {
                    if (typeof message.targetUin === "number")
                        object.targetUin = options.longs === String ? String(message.targetUin) : message.targetUin;
                    else
                        object.targetUin = options.longs === String ? $util.Long.prototype.toString.call(message.targetUin) : options.longs === Number ? new $util.LongBits(message.targetUin.low >>> 0, message.targetUin.high >>> 0).toNumber(true) : message.targetUin;
                    if (options.oneofs)
                        object.target = "targetUin";
                }
                return object;
            };

            /**
             * Converts this IsBlackListUserRequest to JSON.
             * @function toJSON
             * @memberof kritor.friend.IsBlackListUserRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            IsBlackListUserRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for IsBlackListUserRequest
             * @function getTypeUrl
             * @memberof kritor.friend.IsBlackListUserRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            IsBlackListUserRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.friend.IsBlackListUserRequest";
            };

            return IsBlackListUserRequest;
        })();

        friend.IsBlackListUserResponse = (function() {

            /**
             * Properties of an IsBlackListUserResponse.
             * @memberof kritor.friend
             * @interface IIsBlackListUserResponse
             * @property {boolean|null} [isBlackListUser] IsBlackListUserResponse isBlackListUser
             */

            /**
             * Constructs a new IsBlackListUserResponse.
             * @memberof kritor.friend
             * @classdesc Represents an IsBlackListUserResponse.
             * @implements IIsBlackListUserResponse
             * @constructor
             * @param {kritor.friend.IIsBlackListUserResponse=} [properties] Properties to set
             */
            function IsBlackListUserResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * IsBlackListUserResponse isBlackListUser.
             * @member {boolean} isBlackListUser
             * @memberof kritor.friend.IsBlackListUserResponse
             * @instance
             */
            IsBlackListUserResponse.prototype.isBlackListUser = false;

            /**
             * Creates a new IsBlackListUserResponse instance using the specified properties.
             * @function create
             * @memberof kritor.friend.IsBlackListUserResponse
             * @static
             * @param {kritor.friend.IIsBlackListUserResponse=} [properties] Properties to set
             * @returns {kritor.friend.IsBlackListUserResponse} IsBlackListUserResponse instance
             */
            IsBlackListUserResponse.create = function create(properties) {
                return new IsBlackListUserResponse(properties);
            };

            /**
             * Encodes the specified IsBlackListUserResponse message. Does not implicitly {@link kritor.friend.IsBlackListUserResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.friend.IsBlackListUserResponse
             * @static
             * @param {kritor.friend.IIsBlackListUserResponse} message IsBlackListUserResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IsBlackListUserResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.isBlackListUser != null && Object.hasOwnProperty.call(message, "isBlackListUser"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.isBlackListUser);
                return writer;
            };

            /**
             * Encodes the specified IsBlackListUserResponse message, length delimited. Does not implicitly {@link kritor.friend.IsBlackListUserResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.friend.IsBlackListUserResponse
             * @static
             * @param {kritor.friend.IIsBlackListUserResponse} message IsBlackListUserResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IsBlackListUserResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an IsBlackListUserResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.friend.IsBlackListUserResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.friend.IsBlackListUserResponse} IsBlackListUserResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IsBlackListUserResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.friend.IsBlackListUserResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.isBlackListUser = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an IsBlackListUserResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.friend.IsBlackListUserResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.friend.IsBlackListUserResponse} IsBlackListUserResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IsBlackListUserResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an IsBlackListUserResponse message.
             * @function verify
             * @memberof kritor.friend.IsBlackListUserResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            IsBlackListUserResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.isBlackListUser != null && message.hasOwnProperty("isBlackListUser"))
                    if (typeof message.isBlackListUser !== "boolean")
                        return "isBlackListUser: boolean expected";
                return null;
            };

            /**
             * Creates an IsBlackListUserResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.friend.IsBlackListUserResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.friend.IsBlackListUserResponse} IsBlackListUserResponse
             */
            IsBlackListUserResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.friend.IsBlackListUserResponse)
                    return object;
                let message = new $root.kritor.friend.IsBlackListUserResponse();
                if (object.isBlackListUser != null)
                    message.isBlackListUser = Boolean(object.isBlackListUser);
                return message;
            };

            /**
             * Creates a plain object from an IsBlackListUserResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.friend.IsBlackListUserResponse
             * @static
             * @param {kritor.friend.IsBlackListUserResponse} message IsBlackListUserResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            IsBlackListUserResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.isBlackListUser = false;
                if (message.isBlackListUser != null && message.hasOwnProperty("isBlackListUser"))
                    object.isBlackListUser = message.isBlackListUser;
                return object;
            };

            /**
             * Converts this IsBlackListUserResponse to JSON.
             * @function toJSON
             * @memberof kritor.friend.IsBlackListUserResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            IsBlackListUserResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for IsBlackListUserResponse
             * @function getTypeUrl
             * @memberof kritor.friend.IsBlackListUserResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            IsBlackListUserResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.friend.IsBlackListUserResponse";
            };

            return IsBlackListUserResponse;
        })();

        friend.VoteUserRequest = (function() {

            /**
             * Properties of a VoteUserRequest.
             * @memberof kritor.friend
             * @interface IVoteUserRequest
             * @property {string|null} [targetUid] VoteUserRequest targetUid
             * @property {number|Long|null} [targetUin] VoteUserRequest targetUin
             * @property {number|null} [voteCount] VoteUserRequest voteCount
             */

            /**
             * Constructs a new VoteUserRequest.
             * @memberof kritor.friend
             * @classdesc Represents a VoteUserRequest.
             * @implements IVoteUserRequest
             * @constructor
             * @param {kritor.friend.IVoteUserRequest=} [properties] Properties to set
             */
            function VoteUserRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * VoteUserRequest targetUid.
             * @member {string|null|undefined} targetUid
             * @memberof kritor.friend.VoteUserRequest
             * @instance
             */
            VoteUserRequest.prototype.targetUid = null;

            /**
             * VoteUserRequest targetUin.
             * @member {number|Long|null|undefined} targetUin
             * @memberof kritor.friend.VoteUserRequest
             * @instance
             */
            VoteUserRequest.prototype.targetUin = null;

            /**
             * VoteUserRequest voteCount.
             * @member {number} voteCount
             * @memberof kritor.friend.VoteUserRequest
             * @instance
             */
            VoteUserRequest.prototype.voteCount = 0;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * VoteUserRequest target.
             * @member {"targetUid"|"targetUin"|undefined} target
             * @memberof kritor.friend.VoteUserRequest
             * @instance
             */
            Object.defineProperty(VoteUserRequest.prototype, "target", {
                get: $util.oneOfGetter($oneOfFields = ["targetUid", "targetUin"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new VoteUserRequest instance using the specified properties.
             * @function create
             * @memberof kritor.friend.VoteUserRequest
             * @static
             * @param {kritor.friend.IVoteUserRequest=} [properties] Properties to set
             * @returns {kritor.friend.VoteUserRequest} VoteUserRequest instance
             */
            VoteUserRequest.create = function create(properties) {
                return new VoteUserRequest(properties);
            };

            /**
             * Encodes the specified VoteUserRequest message. Does not implicitly {@link kritor.friend.VoteUserRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.friend.VoteUserRequest
             * @static
             * @param {kritor.friend.IVoteUserRequest} message VoteUserRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VoteUserRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.targetUid != null && Object.hasOwnProperty.call(message, "targetUid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.targetUid);
                if (message.targetUin != null && Object.hasOwnProperty.call(message, "targetUin"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.targetUin);
                if (message.voteCount != null && Object.hasOwnProperty.call(message, "voteCount"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.voteCount);
                return writer;
            };

            /**
             * Encodes the specified VoteUserRequest message, length delimited. Does not implicitly {@link kritor.friend.VoteUserRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.friend.VoteUserRequest
             * @static
             * @param {kritor.friend.IVoteUserRequest} message VoteUserRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VoteUserRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a VoteUserRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.friend.VoteUserRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.friend.VoteUserRequest} VoteUserRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VoteUserRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.friend.VoteUserRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.targetUid = reader.string();
                            break;
                        }
                    case 2: {
                            message.targetUin = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.voteCount = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a VoteUserRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.friend.VoteUserRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.friend.VoteUserRequest} VoteUserRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VoteUserRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a VoteUserRequest message.
             * @function verify
             * @memberof kritor.friend.VoteUserRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            VoteUserRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.targetUid != null && message.hasOwnProperty("targetUid")) {
                    properties.target = 1;
                    if (!$util.isString(message.targetUid))
                        return "targetUid: string expected";
                }
                if (message.targetUin != null && message.hasOwnProperty("targetUin")) {
                    if (properties.target === 1)
                        return "target: multiple values";
                    properties.target = 1;
                    if (!$util.isInteger(message.targetUin) && !(message.targetUin && $util.isInteger(message.targetUin.low) && $util.isInteger(message.targetUin.high)))
                        return "targetUin: integer|Long expected";
                }
                if (message.voteCount != null && message.hasOwnProperty("voteCount"))
                    if (!$util.isInteger(message.voteCount))
                        return "voteCount: integer expected";
                return null;
            };

            /**
             * Creates a VoteUserRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.friend.VoteUserRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.friend.VoteUserRequest} VoteUserRequest
             */
            VoteUserRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.friend.VoteUserRequest)
                    return object;
                let message = new $root.kritor.friend.VoteUserRequest();
                if (object.targetUid != null)
                    message.targetUid = String(object.targetUid);
                if (object.targetUin != null)
                    if ($util.Long)
                        (message.targetUin = $util.Long.fromValue(object.targetUin)).unsigned = true;
                    else if (typeof object.targetUin === "string")
                        message.targetUin = parseInt(object.targetUin, 10);
                    else if (typeof object.targetUin === "number")
                        message.targetUin = object.targetUin;
                    else if (typeof object.targetUin === "object")
                        message.targetUin = new $util.LongBits(object.targetUin.low >>> 0, object.targetUin.high >>> 0).toNumber(true);
                if (object.voteCount != null)
                    message.voteCount = object.voteCount >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a VoteUserRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.friend.VoteUserRequest
             * @static
             * @param {kritor.friend.VoteUserRequest} message VoteUserRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            VoteUserRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.voteCount = 0;
                if (message.targetUid != null && message.hasOwnProperty("targetUid")) {
                    object.targetUid = message.targetUid;
                    if (options.oneofs)
                        object.target = "targetUid";
                }
                if (message.targetUin != null && message.hasOwnProperty("targetUin")) {
                    if (typeof message.targetUin === "number")
                        object.targetUin = options.longs === String ? String(message.targetUin) : message.targetUin;
                    else
                        object.targetUin = options.longs === String ? $util.Long.prototype.toString.call(message.targetUin) : options.longs === Number ? new $util.LongBits(message.targetUin.low >>> 0, message.targetUin.high >>> 0).toNumber(true) : message.targetUin;
                    if (options.oneofs)
                        object.target = "targetUin";
                }
                if (message.voteCount != null && message.hasOwnProperty("voteCount"))
                    object.voteCount = message.voteCount;
                return object;
            };

            /**
             * Converts this VoteUserRequest to JSON.
             * @function toJSON
             * @memberof kritor.friend.VoteUserRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            VoteUserRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for VoteUserRequest
             * @function getTypeUrl
             * @memberof kritor.friend.VoteUserRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            VoteUserRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.friend.VoteUserRequest";
            };

            return VoteUserRequest;
        })();

        friend.VoteUserResponse = (function() {

            /**
             * Properties of a VoteUserResponse.
             * @memberof kritor.friend
             * @interface IVoteUserResponse
             */

            /**
             * Constructs a new VoteUserResponse.
             * @memberof kritor.friend
             * @classdesc Represents a VoteUserResponse.
             * @implements IVoteUserResponse
             * @constructor
             * @param {kritor.friend.IVoteUserResponse=} [properties] Properties to set
             */
            function VoteUserResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new VoteUserResponse instance using the specified properties.
             * @function create
             * @memberof kritor.friend.VoteUserResponse
             * @static
             * @param {kritor.friend.IVoteUserResponse=} [properties] Properties to set
             * @returns {kritor.friend.VoteUserResponse} VoteUserResponse instance
             */
            VoteUserResponse.create = function create(properties) {
                return new VoteUserResponse(properties);
            };

            /**
             * Encodes the specified VoteUserResponse message. Does not implicitly {@link kritor.friend.VoteUserResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.friend.VoteUserResponse
             * @static
             * @param {kritor.friend.IVoteUserResponse} message VoteUserResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VoteUserResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified VoteUserResponse message, length delimited. Does not implicitly {@link kritor.friend.VoteUserResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.friend.VoteUserResponse
             * @static
             * @param {kritor.friend.IVoteUserResponse} message VoteUserResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            VoteUserResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a VoteUserResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.friend.VoteUserResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.friend.VoteUserResponse} VoteUserResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VoteUserResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.friend.VoteUserResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a VoteUserResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.friend.VoteUserResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.friend.VoteUserResponse} VoteUserResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            VoteUserResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a VoteUserResponse message.
             * @function verify
             * @memberof kritor.friend.VoteUserResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            VoteUserResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a VoteUserResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.friend.VoteUserResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.friend.VoteUserResponse} VoteUserResponse
             */
            VoteUserResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.friend.VoteUserResponse)
                    return object;
                return new $root.kritor.friend.VoteUserResponse();
            };

            /**
             * Creates a plain object from a VoteUserResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.friend.VoteUserResponse
             * @static
             * @param {kritor.friend.VoteUserResponse} message VoteUserResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            VoteUserResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this VoteUserResponse to JSON.
             * @function toJSON
             * @memberof kritor.friend.VoteUserResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            VoteUserResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for VoteUserResponse
             * @function getTypeUrl
             * @memberof kritor.friend.VoteUserResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            VoteUserResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.friend.VoteUserResponse";
            };

            return VoteUserResponse;
        })();

        friend.GetUidByUinRequest = (function() {

            /**
             * Properties of a GetUidByUinRequest.
             * @memberof kritor.friend
             * @interface IGetUidByUinRequest
             * @property {Array.<number|Long>|null} [targetUins] GetUidByUinRequest targetUins
             */

            /**
             * Constructs a new GetUidByUinRequest.
             * @memberof kritor.friend
             * @classdesc Represents a GetUidByUinRequest.
             * @implements IGetUidByUinRequest
             * @constructor
             * @param {kritor.friend.IGetUidByUinRequest=} [properties] Properties to set
             */
            function GetUidByUinRequest(properties) {
                this.targetUins = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetUidByUinRequest targetUins.
             * @member {Array.<number|Long>} targetUins
             * @memberof kritor.friend.GetUidByUinRequest
             * @instance
             */
            GetUidByUinRequest.prototype.targetUins = $util.emptyArray;

            /**
             * Creates a new GetUidByUinRequest instance using the specified properties.
             * @function create
             * @memberof kritor.friend.GetUidByUinRequest
             * @static
             * @param {kritor.friend.IGetUidByUinRequest=} [properties] Properties to set
             * @returns {kritor.friend.GetUidByUinRequest} GetUidByUinRequest instance
             */
            GetUidByUinRequest.create = function create(properties) {
                return new GetUidByUinRequest(properties);
            };

            /**
             * Encodes the specified GetUidByUinRequest message. Does not implicitly {@link kritor.friend.GetUidByUinRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.friend.GetUidByUinRequest
             * @static
             * @param {kritor.friend.IGetUidByUinRequest} message GetUidByUinRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetUidByUinRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.targetUins != null && message.targetUins.length) {
                    writer.uint32(/* id 1, wireType 2 =*/10).fork();
                    for (let i = 0; i < message.targetUins.length; ++i)
                        writer.uint64(message.targetUins[i]);
                    writer.ldelim();
                }
                return writer;
            };

            /**
             * Encodes the specified GetUidByUinRequest message, length delimited. Does not implicitly {@link kritor.friend.GetUidByUinRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.friend.GetUidByUinRequest
             * @static
             * @param {kritor.friend.IGetUidByUinRequest} message GetUidByUinRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetUidByUinRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetUidByUinRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.friend.GetUidByUinRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.friend.GetUidByUinRequest} GetUidByUinRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetUidByUinRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.friend.GetUidByUinRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.targetUins && message.targetUins.length))
                                message.targetUins = [];
                            if ((tag & 7) === 2) {
                                let end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.targetUins.push(reader.uint64());
                            } else
                                message.targetUins.push(reader.uint64());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetUidByUinRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.friend.GetUidByUinRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.friend.GetUidByUinRequest} GetUidByUinRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetUidByUinRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetUidByUinRequest message.
             * @function verify
             * @memberof kritor.friend.GetUidByUinRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetUidByUinRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.targetUins != null && message.hasOwnProperty("targetUins")) {
                    if (!Array.isArray(message.targetUins))
                        return "targetUins: array expected";
                    for (let i = 0; i < message.targetUins.length; ++i)
                        if (!$util.isInteger(message.targetUins[i]) && !(message.targetUins[i] && $util.isInteger(message.targetUins[i].low) && $util.isInteger(message.targetUins[i].high)))
                            return "targetUins: integer|Long[] expected";
                }
                return null;
            };

            /**
             * Creates a GetUidByUinRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.friend.GetUidByUinRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.friend.GetUidByUinRequest} GetUidByUinRequest
             */
            GetUidByUinRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.friend.GetUidByUinRequest)
                    return object;
                let message = new $root.kritor.friend.GetUidByUinRequest();
                if (object.targetUins) {
                    if (!Array.isArray(object.targetUins))
                        throw TypeError(".kritor.friend.GetUidByUinRequest.targetUins: array expected");
                    message.targetUins = [];
                    for (let i = 0; i < object.targetUins.length; ++i)
                        if ($util.Long)
                            (message.targetUins[i] = $util.Long.fromValue(object.targetUins[i])).unsigned = true;
                        else if (typeof object.targetUins[i] === "string")
                            message.targetUins[i] = parseInt(object.targetUins[i], 10);
                        else if (typeof object.targetUins[i] === "number")
                            message.targetUins[i] = object.targetUins[i];
                        else if (typeof object.targetUins[i] === "object")
                            message.targetUins[i] = new $util.LongBits(object.targetUins[i].low >>> 0, object.targetUins[i].high >>> 0).toNumber(true);
                }
                return message;
            };

            /**
             * Creates a plain object from a GetUidByUinRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.friend.GetUidByUinRequest
             * @static
             * @param {kritor.friend.GetUidByUinRequest} message GetUidByUinRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetUidByUinRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.targetUins = [];
                if (message.targetUins && message.targetUins.length) {
                    object.targetUins = [];
                    for (let j = 0; j < message.targetUins.length; ++j)
                        if (typeof message.targetUins[j] === "number")
                            object.targetUins[j] = options.longs === String ? String(message.targetUins[j]) : message.targetUins[j];
                        else
                            object.targetUins[j] = options.longs === String ? $util.Long.prototype.toString.call(message.targetUins[j]) : options.longs === Number ? new $util.LongBits(message.targetUins[j].low >>> 0, message.targetUins[j].high >>> 0).toNumber(true) : message.targetUins[j];
                }
                return object;
            };

            /**
             * Converts this GetUidByUinRequest to JSON.
             * @function toJSON
             * @memberof kritor.friend.GetUidByUinRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetUidByUinRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetUidByUinRequest
             * @function getTypeUrl
             * @memberof kritor.friend.GetUidByUinRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetUidByUinRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.friend.GetUidByUinRequest";
            };

            return GetUidByUinRequest;
        })();

        friend.GetUidByUinResponse = (function() {

            /**
             * Properties of a GetUidByUinResponse.
             * @memberof kritor.friend
             * @interface IGetUidByUinResponse
             * @property {Object.<string,string>|null} [uidMap] GetUidByUinResponse uidMap
             */

            /**
             * Constructs a new GetUidByUinResponse.
             * @memberof kritor.friend
             * @classdesc Represents a GetUidByUinResponse.
             * @implements IGetUidByUinResponse
             * @constructor
             * @param {kritor.friend.IGetUidByUinResponse=} [properties] Properties to set
             */
            function GetUidByUinResponse(properties) {
                this.uidMap = {};
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetUidByUinResponse uidMap.
             * @member {Object.<string,string>} uidMap
             * @memberof kritor.friend.GetUidByUinResponse
             * @instance
             */
            GetUidByUinResponse.prototype.uidMap = $util.emptyObject;

            /**
             * Creates a new GetUidByUinResponse instance using the specified properties.
             * @function create
             * @memberof kritor.friend.GetUidByUinResponse
             * @static
             * @param {kritor.friend.IGetUidByUinResponse=} [properties] Properties to set
             * @returns {kritor.friend.GetUidByUinResponse} GetUidByUinResponse instance
             */
            GetUidByUinResponse.create = function create(properties) {
                return new GetUidByUinResponse(properties);
            };

            /**
             * Encodes the specified GetUidByUinResponse message. Does not implicitly {@link kritor.friend.GetUidByUinResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.friend.GetUidByUinResponse
             * @static
             * @param {kritor.friend.IGetUidByUinResponse} message GetUidByUinResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetUidByUinResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uidMap != null && Object.hasOwnProperty.call(message, "uidMap"))
                    for (let keys = Object.keys(message.uidMap), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 0 =*/8).uint64(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.uidMap[keys[i]]).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetUidByUinResponse message, length delimited. Does not implicitly {@link kritor.friend.GetUidByUinResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.friend.GetUidByUinResponse
             * @static
             * @param {kritor.friend.IGetUidByUinResponse} message GetUidByUinResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetUidByUinResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetUidByUinResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.friend.GetUidByUinResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.friend.GetUidByUinResponse} GetUidByUinResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetUidByUinResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.friend.GetUidByUinResponse(), key, value;
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (message.uidMap === $util.emptyObject)
                                message.uidMap = {};
                            let end2 = reader.uint32() + reader.pos;
                            key = 0;
                            value = "";
                            while (reader.pos < end2) {
                                let tag2 = reader.uint32();
                                switch (tag2 >>> 3) {
                                case 1:
                                    key = reader.uint64();
                                    break;
                                case 2:
                                    value = reader.string();
                                    break;
                                default:
                                    reader.skipType(tag2 & 7);
                                    break;
                                }
                            }
                            message.uidMap[typeof key === "object" ? $util.longToHash(key) : key] = value;
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetUidByUinResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.friend.GetUidByUinResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.friend.GetUidByUinResponse} GetUidByUinResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetUidByUinResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetUidByUinResponse message.
             * @function verify
             * @memberof kritor.friend.GetUidByUinResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetUidByUinResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.uidMap != null && message.hasOwnProperty("uidMap")) {
                    if (!$util.isObject(message.uidMap))
                        return "uidMap: object expected";
                    let key = Object.keys(message.uidMap);
                    for (let i = 0; i < key.length; ++i) {
                        if (!$util.key64Re.test(key[i]))
                            return "uidMap: integer|Long key{k:uint64} expected";
                        if (!$util.isString(message.uidMap[key[i]]))
                            return "uidMap: string{k:uint64} expected";
                    }
                }
                return null;
            };

            /**
             * Creates a GetUidByUinResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.friend.GetUidByUinResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.friend.GetUidByUinResponse} GetUidByUinResponse
             */
            GetUidByUinResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.friend.GetUidByUinResponse)
                    return object;
                let message = new $root.kritor.friend.GetUidByUinResponse();
                if (object.uidMap) {
                    if (typeof object.uidMap !== "object")
                        throw TypeError(".kritor.friend.GetUidByUinResponse.uidMap: object expected");
                    message.uidMap = {};
                    for (let keys = Object.keys(object.uidMap), i = 0; i < keys.length; ++i)
                        message.uidMap[keys[i]] = String(object.uidMap[keys[i]]);
                }
                return message;
            };

            /**
             * Creates a plain object from a GetUidByUinResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.friend.GetUidByUinResponse
             * @static
             * @param {kritor.friend.GetUidByUinResponse} message GetUidByUinResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetUidByUinResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.objects || options.defaults)
                    object.uidMap = {};
                let keys2;
                if (message.uidMap && (keys2 = Object.keys(message.uidMap)).length) {
                    object.uidMap = {};
                    for (let j = 0; j < keys2.length; ++j)
                        object.uidMap[keys2[j]] = message.uidMap[keys2[j]];
                }
                return object;
            };

            /**
             * Converts this GetUidByUinResponse to JSON.
             * @function toJSON
             * @memberof kritor.friend.GetUidByUinResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetUidByUinResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetUidByUinResponse
             * @function getTypeUrl
             * @memberof kritor.friend.GetUidByUinResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetUidByUinResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.friend.GetUidByUinResponse";
            };

            return GetUidByUinResponse;
        })();

        friend.GetUinByUidRequest = (function() {

            /**
             * Properties of a GetUinByUidRequest.
             * @memberof kritor.friend
             * @interface IGetUinByUidRequest
             * @property {Array.<string>|null} [targetUids] GetUinByUidRequest targetUids
             */

            /**
             * Constructs a new GetUinByUidRequest.
             * @memberof kritor.friend
             * @classdesc Represents a GetUinByUidRequest.
             * @implements IGetUinByUidRequest
             * @constructor
             * @param {kritor.friend.IGetUinByUidRequest=} [properties] Properties to set
             */
            function GetUinByUidRequest(properties) {
                this.targetUids = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetUinByUidRequest targetUids.
             * @member {Array.<string>} targetUids
             * @memberof kritor.friend.GetUinByUidRequest
             * @instance
             */
            GetUinByUidRequest.prototype.targetUids = $util.emptyArray;

            /**
             * Creates a new GetUinByUidRequest instance using the specified properties.
             * @function create
             * @memberof kritor.friend.GetUinByUidRequest
             * @static
             * @param {kritor.friend.IGetUinByUidRequest=} [properties] Properties to set
             * @returns {kritor.friend.GetUinByUidRequest} GetUinByUidRequest instance
             */
            GetUinByUidRequest.create = function create(properties) {
                return new GetUinByUidRequest(properties);
            };

            /**
             * Encodes the specified GetUinByUidRequest message. Does not implicitly {@link kritor.friend.GetUinByUidRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.friend.GetUinByUidRequest
             * @static
             * @param {kritor.friend.IGetUinByUidRequest} message GetUinByUidRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetUinByUidRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.targetUids != null && message.targetUids.length)
                    for (let i = 0; i < message.targetUids.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.targetUids[i]);
                return writer;
            };

            /**
             * Encodes the specified GetUinByUidRequest message, length delimited. Does not implicitly {@link kritor.friend.GetUinByUidRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.friend.GetUinByUidRequest
             * @static
             * @param {kritor.friend.IGetUinByUidRequest} message GetUinByUidRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetUinByUidRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetUinByUidRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.friend.GetUinByUidRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.friend.GetUinByUidRequest} GetUinByUidRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetUinByUidRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.friend.GetUinByUidRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.targetUids && message.targetUids.length))
                                message.targetUids = [];
                            message.targetUids.push(reader.string());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetUinByUidRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.friend.GetUinByUidRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.friend.GetUinByUidRequest} GetUinByUidRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetUinByUidRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetUinByUidRequest message.
             * @function verify
             * @memberof kritor.friend.GetUinByUidRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetUinByUidRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.targetUids != null && message.hasOwnProperty("targetUids")) {
                    if (!Array.isArray(message.targetUids))
                        return "targetUids: array expected";
                    for (let i = 0; i < message.targetUids.length; ++i)
                        if (!$util.isString(message.targetUids[i]))
                            return "targetUids: string[] expected";
                }
                return null;
            };

            /**
             * Creates a GetUinByUidRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.friend.GetUinByUidRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.friend.GetUinByUidRequest} GetUinByUidRequest
             */
            GetUinByUidRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.friend.GetUinByUidRequest)
                    return object;
                let message = new $root.kritor.friend.GetUinByUidRequest();
                if (object.targetUids) {
                    if (!Array.isArray(object.targetUids))
                        throw TypeError(".kritor.friend.GetUinByUidRequest.targetUids: array expected");
                    message.targetUids = [];
                    for (let i = 0; i < object.targetUids.length; ++i)
                        message.targetUids[i] = String(object.targetUids[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a GetUinByUidRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.friend.GetUinByUidRequest
             * @static
             * @param {kritor.friend.GetUinByUidRequest} message GetUinByUidRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetUinByUidRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.targetUids = [];
                if (message.targetUids && message.targetUids.length) {
                    object.targetUids = [];
                    for (let j = 0; j < message.targetUids.length; ++j)
                        object.targetUids[j] = message.targetUids[j];
                }
                return object;
            };

            /**
             * Converts this GetUinByUidRequest to JSON.
             * @function toJSON
             * @memberof kritor.friend.GetUinByUidRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetUinByUidRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetUinByUidRequest
             * @function getTypeUrl
             * @memberof kritor.friend.GetUinByUidRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetUinByUidRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.friend.GetUinByUidRequest";
            };

            return GetUinByUidRequest;
        })();

        friend.GetUinByUidResponse = (function() {

            /**
             * Properties of a GetUinByUidResponse.
             * @memberof kritor.friend
             * @interface IGetUinByUidResponse
             * @property {Object.<string,number|Long>|null} [uinMap] GetUinByUidResponse uinMap
             */

            /**
             * Constructs a new GetUinByUidResponse.
             * @memberof kritor.friend
             * @classdesc Represents a GetUinByUidResponse.
             * @implements IGetUinByUidResponse
             * @constructor
             * @param {kritor.friend.IGetUinByUidResponse=} [properties] Properties to set
             */
            function GetUinByUidResponse(properties) {
                this.uinMap = {};
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetUinByUidResponse uinMap.
             * @member {Object.<string,number|Long>} uinMap
             * @memberof kritor.friend.GetUinByUidResponse
             * @instance
             */
            GetUinByUidResponse.prototype.uinMap = $util.emptyObject;

            /**
             * Creates a new GetUinByUidResponse instance using the specified properties.
             * @function create
             * @memberof kritor.friend.GetUinByUidResponse
             * @static
             * @param {kritor.friend.IGetUinByUidResponse=} [properties] Properties to set
             * @returns {kritor.friend.GetUinByUidResponse} GetUinByUidResponse instance
             */
            GetUinByUidResponse.create = function create(properties) {
                return new GetUinByUidResponse(properties);
            };

            /**
             * Encodes the specified GetUinByUidResponse message. Does not implicitly {@link kritor.friend.GetUinByUidResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.friend.GetUinByUidResponse
             * @static
             * @param {kritor.friend.IGetUinByUidResponse} message GetUinByUidResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetUinByUidResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uinMap != null && Object.hasOwnProperty.call(message, "uinMap"))
                    for (let keys = Object.keys(message.uinMap), i = 0; i < keys.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 0 =*/16).uint64(message.uinMap[keys[i]]).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetUinByUidResponse message, length delimited. Does not implicitly {@link kritor.friend.GetUinByUidResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.friend.GetUinByUidResponse
             * @static
             * @param {kritor.friend.IGetUinByUidResponse} message GetUinByUidResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetUinByUidResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetUinByUidResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.friend.GetUinByUidResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.friend.GetUinByUidResponse} GetUinByUidResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetUinByUidResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.friend.GetUinByUidResponse(), key, value;
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (message.uinMap === $util.emptyObject)
                                message.uinMap = {};
                            let end2 = reader.uint32() + reader.pos;
                            key = "";
                            value = 0;
                            while (reader.pos < end2) {
                                let tag2 = reader.uint32();
                                switch (tag2 >>> 3) {
                                case 1:
                                    key = reader.string();
                                    break;
                                case 2:
                                    value = reader.uint64();
                                    break;
                                default:
                                    reader.skipType(tag2 & 7);
                                    break;
                                }
                            }
                            message.uinMap[key] = value;
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetUinByUidResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.friend.GetUinByUidResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.friend.GetUinByUidResponse} GetUinByUidResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetUinByUidResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetUinByUidResponse message.
             * @function verify
             * @memberof kritor.friend.GetUinByUidResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetUinByUidResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.uinMap != null && message.hasOwnProperty("uinMap")) {
                    if (!$util.isObject(message.uinMap))
                        return "uinMap: object expected";
                    let key = Object.keys(message.uinMap);
                    for (let i = 0; i < key.length; ++i)
                        if (!$util.isInteger(message.uinMap[key[i]]) && !(message.uinMap[key[i]] && $util.isInteger(message.uinMap[key[i]].low) && $util.isInteger(message.uinMap[key[i]].high)))
                            return "uinMap: integer|Long{k:string} expected";
                }
                return null;
            };

            /**
             * Creates a GetUinByUidResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.friend.GetUinByUidResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.friend.GetUinByUidResponse} GetUinByUidResponse
             */
            GetUinByUidResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.friend.GetUinByUidResponse)
                    return object;
                let message = new $root.kritor.friend.GetUinByUidResponse();
                if (object.uinMap) {
                    if (typeof object.uinMap !== "object")
                        throw TypeError(".kritor.friend.GetUinByUidResponse.uinMap: object expected");
                    message.uinMap = {};
                    for (let keys = Object.keys(object.uinMap), i = 0; i < keys.length; ++i)
                        if ($util.Long)
                            (message.uinMap[keys[i]] = $util.Long.fromValue(object.uinMap[keys[i]])).unsigned = true;
                        else if (typeof object.uinMap[keys[i]] === "string")
                            message.uinMap[keys[i]] = parseInt(object.uinMap[keys[i]], 10);
                        else if (typeof object.uinMap[keys[i]] === "number")
                            message.uinMap[keys[i]] = object.uinMap[keys[i]];
                        else if (typeof object.uinMap[keys[i]] === "object")
                            message.uinMap[keys[i]] = new $util.LongBits(object.uinMap[keys[i]].low >>> 0, object.uinMap[keys[i]].high >>> 0).toNumber(true);
                }
                return message;
            };

            /**
             * Creates a plain object from a GetUinByUidResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.friend.GetUinByUidResponse
             * @static
             * @param {kritor.friend.GetUinByUidResponse} message GetUinByUidResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetUinByUidResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.objects || options.defaults)
                    object.uinMap = {};
                let keys2;
                if (message.uinMap && (keys2 = Object.keys(message.uinMap)).length) {
                    object.uinMap = {};
                    for (let j = 0; j < keys2.length; ++j)
                        if (typeof message.uinMap[keys2[j]] === "number")
                            object.uinMap[keys2[j]] = options.longs === String ? String(message.uinMap[keys2[j]]) : message.uinMap[keys2[j]];
                        else
                            object.uinMap[keys2[j]] = options.longs === String ? $util.Long.prototype.toString.call(message.uinMap[keys2[j]]) : options.longs === Number ? new $util.LongBits(message.uinMap[keys2[j]].low >>> 0, message.uinMap[keys2[j]].high >>> 0).toNumber(true) : message.uinMap[keys2[j]];
                }
                return object;
            };

            /**
             * Converts this GetUinByUidResponse to JSON.
             * @function toJSON
             * @memberof kritor.friend.GetUinByUidResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetUinByUidResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetUinByUidResponse
             * @function getTypeUrl
             * @memberof kritor.friend.GetUinByUidResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetUinByUidResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.friend.GetUinByUidResponse";
            };

            return GetUinByUidResponse;
        })();

        return friend;
    })();

    kritor.group = (function() {

        /**
         * Namespace group.
         * @memberof kritor
         * @namespace
         */
        const group = {};

        group.GroupService = (function() {

            /**
             * Constructs a new GroupService service.
             * @memberof kritor.group
             * @classdesc Represents a GroupService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function GroupService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (GroupService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = GroupService;

            /**
             * Creates new GroupService service using the specified rpc implementation.
             * @function create
             * @memberof kritor.group.GroupService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {GroupService} RPC service. Useful where requests and/or responses are streamed.
             */
            GroupService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link kritor.group.GroupService#banMember}.
             * @memberof kritor.group.GroupService
             * @typedef BanMemberCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.group.BanMemberResponse} [response] BanMemberResponse
             */

            /**
             * Calls BanMember.
             * @function banMember
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IBanMemberRequest} request BanMemberRequest message or plain object
             * @param {kritor.group.GroupService.BanMemberCallback} callback Node-style callback called with the error, if any, and BanMemberResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GroupService.prototype.banMember = function banMember(request, callback) {
                return this.rpcCall(banMember, $root.kritor.group.BanMemberRequest, $root.kritor.group.BanMemberResponse, request, callback);
            }, "name", { value: "BanMember" });

            /**
             * Calls BanMember.
             * @function banMember
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IBanMemberRequest} request BanMemberRequest message or plain object
             * @returns {Promise<kritor.group.BanMemberResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.group.GroupService#pokeMember}.
             * @memberof kritor.group.GroupService
             * @typedef PokeMemberCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.group.PokeMemberResponse} [response] PokeMemberResponse
             */

            /**
             * Calls PokeMember.
             * @function pokeMember
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IPokeMemberRequest} request PokeMemberRequest message or plain object
             * @param {kritor.group.GroupService.PokeMemberCallback} callback Node-style callback called with the error, if any, and PokeMemberResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GroupService.prototype.pokeMember = function pokeMember(request, callback) {
                return this.rpcCall(pokeMember, $root.kritor.group.PokeMemberRequest, $root.kritor.group.PokeMemberResponse, request, callback);
            }, "name", { value: "PokeMember" });

            /**
             * Calls PokeMember.
             * @function pokeMember
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IPokeMemberRequest} request PokeMemberRequest message or plain object
             * @returns {Promise<kritor.group.PokeMemberResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.group.GroupService#kickMember}.
             * @memberof kritor.group.GroupService
             * @typedef KickMemberCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.group.KickMemberResponse} [response] KickMemberResponse
             */

            /**
             * Calls KickMember.
             * @function kickMember
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IKickMemberRequest} request KickMemberRequest message or plain object
             * @param {kritor.group.GroupService.KickMemberCallback} callback Node-style callback called with the error, if any, and KickMemberResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GroupService.prototype.kickMember = function kickMember(request, callback) {
                return this.rpcCall(kickMember, $root.kritor.group.KickMemberRequest, $root.kritor.group.KickMemberResponse, request, callback);
            }, "name", { value: "KickMember" });

            /**
             * Calls KickMember.
             * @function kickMember
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IKickMemberRequest} request KickMemberRequest message or plain object
             * @returns {Promise<kritor.group.KickMemberResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.group.GroupService#leaveGroup}.
             * @memberof kritor.group.GroupService
             * @typedef LeaveGroupCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.group.LeaveGroupResponse} [response] LeaveGroupResponse
             */

            /**
             * Calls LeaveGroup.
             * @function leaveGroup
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.ILeaveGroupRequest} request LeaveGroupRequest message or plain object
             * @param {kritor.group.GroupService.LeaveGroupCallback} callback Node-style callback called with the error, if any, and LeaveGroupResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GroupService.prototype.leaveGroup = function leaveGroup(request, callback) {
                return this.rpcCall(leaveGroup, $root.kritor.group.LeaveGroupRequest, $root.kritor.group.LeaveGroupResponse, request, callback);
            }, "name", { value: "LeaveGroup" });

            /**
             * Calls LeaveGroup.
             * @function leaveGroup
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.ILeaveGroupRequest} request LeaveGroupRequest message or plain object
             * @returns {Promise<kritor.group.LeaveGroupResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.group.GroupService#modifyMemberCard}.
             * @memberof kritor.group.GroupService
             * @typedef ModifyMemberCardCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.group.ModifyMemberCardResponse} [response] ModifyMemberCardResponse
             */

            /**
             * Calls ModifyMemberCard.
             * @function modifyMemberCard
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IModifyMemberCardRequest} request ModifyMemberCardRequest message or plain object
             * @param {kritor.group.GroupService.ModifyMemberCardCallback} callback Node-style callback called with the error, if any, and ModifyMemberCardResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GroupService.prototype.modifyMemberCard = function modifyMemberCard(request, callback) {
                return this.rpcCall(modifyMemberCard, $root.kritor.group.ModifyMemberCardRequest, $root.kritor.group.ModifyMemberCardResponse, request, callback);
            }, "name", { value: "ModifyMemberCard" });

            /**
             * Calls ModifyMemberCard.
             * @function modifyMemberCard
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IModifyMemberCardRequest} request ModifyMemberCardRequest message or plain object
             * @returns {Promise<kritor.group.ModifyMemberCardResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.group.GroupService#modifyGroupName}.
             * @memberof kritor.group.GroupService
             * @typedef ModifyGroupNameCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.group.ModifyGroupNameResponse} [response] ModifyGroupNameResponse
             */

            /**
             * Calls ModifyGroupName.
             * @function modifyGroupName
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IModifyGroupNameRequest} request ModifyGroupNameRequest message or plain object
             * @param {kritor.group.GroupService.ModifyGroupNameCallback} callback Node-style callback called with the error, if any, and ModifyGroupNameResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GroupService.prototype.modifyGroupName = function modifyGroupName(request, callback) {
                return this.rpcCall(modifyGroupName, $root.kritor.group.ModifyGroupNameRequest, $root.kritor.group.ModifyGroupNameResponse, request, callback);
            }, "name", { value: "ModifyGroupName" });

            /**
             * Calls ModifyGroupName.
             * @function modifyGroupName
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IModifyGroupNameRequest} request ModifyGroupNameRequest message or plain object
             * @returns {Promise<kritor.group.ModifyGroupNameResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.group.GroupService#modifyGroupRemark}.
             * @memberof kritor.group.GroupService
             * @typedef ModifyGroupRemarkCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.group.ModifyGroupRemarkResponse} [response] ModifyGroupRemarkResponse
             */

            /**
             * Calls ModifyGroupRemark.
             * @function modifyGroupRemark
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IModifyGroupRemarkRequest} request ModifyGroupRemarkRequest message or plain object
             * @param {kritor.group.GroupService.ModifyGroupRemarkCallback} callback Node-style callback called with the error, if any, and ModifyGroupRemarkResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GroupService.prototype.modifyGroupRemark = function modifyGroupRemark(request, callback) {
                return this.rpcCall(modifyGroupRemark, $root.kritor.group.ModifyGroupRemarkRequest, $root.kritor.group.ModifyGroupRemarkResponse, request, callback);
            }, "name", { value: "ModifyGroupRemark" });

            /**
             * Calls ModifyGroupRemark.
             * @function modifyGroupRemark
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IModifyGroupRemarkRequest} request ModifyGroupRemarkRequest message or plain object
             * @returns {Promise<kritor.group.ModifyGroupRemarkResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.group.GroupService#setGroupAdmin}.
             * @memberof kritor.group.GroupService
             * @typedef SetGroupAdminCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.group.SetGroupAdminResponse} [response] SetGroupAdminResponse
             */

            /**
             * Calls SetGroupAdmin.
             * @function setGroupAdmin
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.ISetGroupAdminRequest} request SetGroupAdminRequest message or plain object
             * @param {kritor.group.GroupService.SetGroupAdminCallback} callback Node-style callback called with the error, if any, and SetGroupAdminResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GroupService.prototype.setGroupAdmin = function setGroupAdmin(request, callback) {
                return this.rpcCall(setGroupAdmin, $root.kritor.group.SetGroupAdminRequest, $root.kritor.group.SetGroupAdminResponse, request, callback);
            }, "name", { value: "SetGroupAdmin" });

            /**
             * Calls SetGroupAdmin.
             * @function setGroupAdmin
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.ISetGroupAdminRequest} request SetGroupAdminRequest message or plain object
             * @returns {Promise<kritor.group.SetGroupAdminResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.group.GroupService#setGroupUniqueTitle}.
             * @memberof kritor.group.GroupService
             * @typedef SetGroupUniqueTitleCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.group.SetGroupUniqueTitleResponse} [response] SetGroupUniqueTitleResponse
             */

            /**
             * Calls SetGroupUniqueTitle.
             * @function setGroupUniqueTitle
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.ISetGroupUniqueTitleRequest} request SetGroupUniqueTitleRequest message or plain object
             * @param {kritor.group.GroupService.SetGroupUniqueTitleCallback} callback Node-style callback called with the error, if any, and SetGroupUniqueTitleResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GroupService.prototype.setGroupUniqueTitle = function setGroupUniqueTitle(request, callback) {
                return this.rpcCall(setGroupUniqueTitle, $root.kritor.group.SetGroupUniqueTitleRequest, $root.kritor.group.SetGroupUniqueTitleResponse, request, callback);
            }, "name", { value: "SetGroupUniqueTitle" });

            /**
             * Calls SetGroupUniqueTitle.
             * @function setGroupUniqueTitle
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.ISetGroupUniqueTitleRequest} request SetGroupUniqueTitleRequest message or plain object
             * @returns {Promise<kritor.group.SetGroupUniqueTitleResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.group.GroupService#setGroupWholeBan}.
             * @memberof kritor.group.GroupService
             * @typedef SetGroupWholeBanCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.group.SetGroupWholeBanResponse} [response] SetGroupWholeBanResponse
             */

            /**
             * Calls SetGroupWholeBan.
             * @function setGroupWholeBan
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.ISetGroupWholeBanRequest} request SetGroupWholeBanRequest message or plain object
             * @param {kritor.group.GroupService.SetGroupWholeBanCallback} callback Node-style callback called with the error, if any, and SetGroupWholeBanResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GroupService.prototype.setGroupWholeBan = function setGroupWholeBan(request, callback) {
                return this.rpcCall(setGroupWholeBan, $root.kritor.group.SetGroupWholeBanRequest, $root.kritor.group.SetGroupWholeBanResponse, request, callback);
            }, "name", { value: "SetGroupWholeBan" });

            /**
             * Calls SetGroupWholeBan.
             * @function setGroupWholeBan
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.ISetGroupWholeBanRequest} request SetGroupWholeBanRequest message or plain object
             * @returns {Promise<kritor.group.SetGroupWholeBanResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.group.GroupService#getGroupInfo}.
             * @memberof kritor.group.GroupService
             * @typedef GetGroupInfoCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.group.GetGroupInfoResponse} [response] GetGroupInfoResponse
             */

            /**
             * Calls GetGroupInfo.
             * @function getGroupInfo
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IGetGroupInfoRequest} request GetGroupInfoRequest message or plain object
             * @param {kritor.group.GroupService.GetGroupInfoCallback} callback Node-style callback called with the error, if any, and GetGroupInfoResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GroupService.prototype.getGroupInfo = function getGroupInfo(request, callback) {
                return this.rpcCall(getGroupInfo, $root.kritor.group.GetGroupInfoRequest, $root.kritor.group.GetGroupInfoResponse, request, callback);
            }, "name", { value: "GetGroupInfo" });

            /**
             * Calls GetGroupInfo.
             * @function getGroupInfo
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IGetGroupInfoRequest} request GetGroupInfoRequest message or plain object
             * @returns {Promise<kritor.group.GetGroupInfoResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.group.GroupService#getGroupList}.
             * @memberof kritor.group.GroupService
             * @typedef GetGroupListCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.group.GetGroupListResponse} [response] GetGroupListResponse
             */

            /**
             * Calls GetGroupList.
             * @function getGroupList
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IGetGroupListRequest} request GetGroupListRequest message or plain object
             * @param {kritor.group.GroupService.GetGroupListCallback} callback Node-style callback called with the error, if any, and GetGroupListResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GroupService.prototype.getGroupList = function getGroupList(request, callback) {
                return this.rpcCall(getGroupList, $root.kritor.group.GetGroupListRequest, $root.kritor.group.GetGroupListResponse, request, callback);
            }, "name", { value: "GetGroupList" });

            /**
             * Calls GetGroupList.
             * @function getGroupList
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IGetGroupListRequest} request GetGroupListRequest message or plain object
             * @returns {Promise<kritor.group.GetGroupListResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.group.GroupService#getGroupMemberInfo}.
             * @memberof kritor.group.GroupService
             * @typedef GetGroupMemberInfoCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.group.GetGroupMemberInfoResponse} [response] GetGroupMemberInfoResponse
             */

            /**
             * Calls GetGroupMemberInfo.
             * @function getGroupMemberInfo
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IGetGroupMemberInfoRequest} request GetGroupMemberInfoRequest message or plain object
             * @param {kritor.group.GroupService.GetGroupMemberInfoCallback} callback Node-style callback called with the error, if any, and GetGroupMemberInfoResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GroupService.prototype.getGroupMemberInfo = function getGroupMemberInfo(request, callback) {
                return this.rpcCall(getGroupMemberInfo, $root.kritor.group.GetGroupMemberInfoRequest, $root.kritor.group.GetGroupMemberInfoResponse, request, callback);
            }, "name", { value: "GetGroupMemberInfo" });

            /**
             * Calls GetGroupMemberInfo.
             * @function getGroupMemberInfo
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IGetGroupMemberInfoRequest} request GetGroupMemberInfoRequest message or plain object
             * @returns {Promise<kritor.group.GetGroupMemberInfoResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.group.GroupService#getGroupMemberList}.
             * @memberof kritor.group.GroupService
             * @typedef GetGroupMemberListCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.group.GetGroupMemberListResponse} [response] GetGroupMemberListResponse
             */

            /**
             * Calls GetGroupMemberList.
             * @function getGroupMemberList
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IGetGroupMemberListRequest} request GetGroupMemberListRequest message or plain object
             * @param {kritor.group.GroupService.GetGroupMemberListCallback} callback Node-style callback called with the error, if any, and GetGroupMemberListResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GroupService.prototype.getGroupMemberList = function getGroupMemberList(request, callback) {
                return this.rpcCall(getGroupMemberList, $root.kritor.group.GetGroupMemberListRequest, $root.kritor.group.GetGroupMemberListResponse, request, callback);
            }, "name", { value: "GetGroupMemberList" });

            /**
             * Calls GetGroupMemberList.
             * @function getGroupMemberList
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IGetGroupMemberListRequest} request GetGroupMemberListRequest message or plain object
             * @returns {Promise<kritor.group.GetGroupMemberListResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.group.GroupService#getProhibitedUserList}.
             * @memberof kritor.group.GroupService
             * @typedef GetProhibitedUserListCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.group.GetProhibitedUserListResponse} [response] GetProhibitedUserListResponse
             */

            /**
             * Calls GetProhibitedUserList.
             * @function getProhibitedUserList
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IGetProhibitedUserListRequest} request GetProhibitedUserListRequest message or plain object
             * @param {kritor.group.GroupService.GetProhibitedUserListCallback} callback Node-style callback called with the error, if any, and GetProhibitedUserListResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GroupService.prototype.getProhibitedUserList = function getProhibitedUserList(request, callback) {
                return this.rpcCall(getProhibitedUserList, $root.kritor.group.GetProhibitedUserListRequest, $root.kritor.group.GetProhibitedUserListResponse, request, callback);
            }, "name", { value: "GetProhibitedUserList" });

            /**
             * Calls GetProhibitedUserList.
             * @function getProhibitedUserList
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IGetProhibitedUserListRequest} request GetProhibitedUserListRequest message or plain object
             * @returns {Promise<kritor.group.GetProhibitedUserListResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.group.GroupService#getRemainCountAtAll}.
             * @memberof kritor.group.GroupService
             * @typedef GetRemainCountAtAllCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.group.GetRemainCountAtAllResponse} [response] GetRemainCountAtAllResponse
             */

            /**
             * Calls GetRemainCountAtAll.
             * @function getRemainCountAtAll
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IGetRemainCountAtAllRequest} request GetRemainCountAtAllRequest message or plain object
             * @param {kritor.group.GroupService.GetRemainCountAtAllCallback} callback Node-style callback called with the error, if any, and GetRemainCountAtAllResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GroupService.prototype.getRemainCountAtAll = function getRemainCountAtAll(request, callback) {
                return this.rpcCall(getRemainCountAtAll, $root.kritor.group.GetRemainCountAtAllRequest, $root.kritor.group.GetRemainCountAtAllResponse, request, callback);
            }, "name", { value: "GetRemainCountAtAll" });

            /**
             * Calls GetRemainCountAtAll.
             * @function getRemainCountAtAll
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IGetRemainCountAtAllRequest} request GetRemainCountAtAllRequest message or plain object
             * @returns {Promise<kritor.group.GetRemainCountAtAllResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.group.GroupService#getNotJoinedGroupInfo}.
             * @memberof kritor.group.GroupService
             * @typedef GetNotJoinedGroupInfoCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.group.GetNotJoinedGroupInfoResponse} [response] GetNotJoinedGroupInfoResponse
             */

            /**
             * Calls GetNotJoinedGroupInfo.
             * @function getNotJoinedGroupInfo
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IGetNotJoinedGroupInfoRequest} request GetNotJoinedGroupInfoRequest message or plain object
             * @param {kritor.group.GroupService.GetNotJoinedGroupInfoCallback} callback Node-style callback called with the error, if any, and GetNotJoinedGroupInfoResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GroupService.prototype.getNotJoinedGroupInfo = function getNotJoinedGroupInfo(request, callback) {
                return this.rpcCall(getNotJoinedGroupInfo, $root.kritor.group.GetNotJoinedGroupInfoRequest, $root.kritor.group.GetNotJoinedGroupInfoResponse, request, callback);
            }, "name", { value: "GetNotJoinedGroupInfo" });

            /**
             * Calls GetNotJoinedGroupInfo.
             * @function getNotJoinedGroupInfo
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IGetNotJoinedGroupInfoRequest} request GetNotJoinedGroupInfoRequest message or plain object
             * @returns {Promise<kritor.group.GetNotJoinedGroupInfoResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.group.GroupService#getGroupHonor}.
             * @memberof kritor.group.GroupService
             * @typedef GetGroupHonorCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.group.GetGroupHonorResponse} [response] GetGroupHonorResponse
             */

            /**
             * Calls GetGroupHonor.
             * @function getGroupHonor
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IGetGroupHonorRequest} request GetGroupHonorRequest message or plain object
             * @param {kritor.group.GroupService.GetGroupHonorCallback} callback Node-style callback called with the error, if any, and GetGroupHonorResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GroupService.prototype.getGroupHonor = function getGroupHonor(request, callback) {
                return this.rpcCall(getGroupHonor, $root.kritor.group.GetGroupHonorRequest, $root.kritor.group.GetGroupHonorResponse, request, callback);
            }, "name", { value: "GetGroupHonor" });

            /**
             * Calls GetGroupHonor.
             * @function getGroupHonor
             * @memberof kritor.group.GroupService
             * @instance
             * @param {kritor.group.IGetGroupHonorRequest} request GetGroupHonorRequest message or plain object
             * @returns {Promise<kritor.group.GetGroupHonorResponse>} Promise
             * @variation 2
             */

            return GroupService;
        })();

        group.BanMemberRequest = (function() {

            /**
             * Properties of a BanMemberRequest.
             * @memberof kritor.group
             * @interface IBanMemberRequest
             * @property {number|Long|null} [groupId] BanMemberRequest groupId
             * @property {string|null} [targetUid] BanMemberRequest targetUid
             * @property {number|Long|null} [targetUin] BanMemberRequest targetUin
             * @property {number|null} [duration] BanMemberRequest duration
             */

            /**
             * Constructs a new BanMemberRequest.
             * @memberof kritor.group
             * @classdesc Represents a BanMemberRequest.
             * @implements IBanMemberRequest
             * @constructor
             * @param {kritor.group.IBanMemberRequest=} [properties] Properties to set
             */
            function BanMemberRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BanMemberRequest groupId.
             * @member {number|Long} groupId
             * @memberof kritor.group.BanMemberRequest
             * @instance
             */
            BanMemberRequest.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * BanMemberRequest targetUid.
             * @member {string|null|undefined} targetUid
             * @memberof kritor.group.BanMemberRequest
             * @instance
             */
            BanMemberRequest.prototype.targetUid = null;

            /**
             * BanMemberRequest targetUin.
             * @member {number|Long|null|undefined} targetUin
             * @memberof kritor.group.BanMemberRequest
             * @instance
             */
            BanMemberRequest.prototype.targetUin = null;

            /**
             * BanMemberRequest duration.
             * @member {number} duration
             * @memberof kritor.group.BanMemberRequest
             * @instance
             */
            BanMemberRequest.prototype.duration = 0;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * BanMemberRequest target.
             * @member {"targetUid"|"targetUin"|undefined} target
             * @memberof kritor.group.BanMemberRequest
             * @instance
             */
            Object.defineProperty(BanMemberRequest.prototype, "target", {
                get: $util.oneOfGetter($oneOfFields = ["targetUid", "targetUin"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new BanMemberRequest instance using the specified properties.
             * @function create
             * @memberof kritor.group.BanMemberRequest
             * @static
             * @param {kritor.group.IBanMemberRequest=} [properties] Properties to set
             * @returns {kritor.group.BanMemberRequest} BanMemberRequest instance
             */
            BanMemberRequest.create = function create(properties) {
                return new BanMemberRequest(properties);
            };

            /**
             * Encodes the specified BanMemberRequest message. Does not implicitly {@link kritor.group.BanMemberRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.BanMemberRequest
             * @static
             * @param {kritor.group.IBanMemberRequest} message BanMemberRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BanMemberRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                if (message.targetUid != null && Object.hasOwnProperty.call(message, "targetUid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.targetUid);
                if (message.targetUin != null && Object.hasOwnProperty.call(message, "targetUin"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.targetUin);
                if (message.duration != null && Object.hasOwnProperty.call(message, "duration"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.duration);
                return writer;
            };

            /**
             * Encodes the specified BanMemberRequest message, length delimited. Does not implicitly {@link kritor.group.BanMemberRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.BanMemberRequest
             * @static
             * @param {kritor.group.IBanMemberRequest} message BanMemberRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BanMemberRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BanMemberRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.BanMemberRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.BanMemberRequest} BanMemberRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BanMemberRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.BanMemberRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.targetUid = reader.string();
                            break;
                        }
                    case 3: {
                            message.targetUin = reader.uint64();
                            break;
                        }
                    case 4: {
                            message.duration = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BanMemberRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.BanMemberRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.BanMemberRequest} BanMemberRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BanMemberRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BanMemberRequest message.
             * @function verify
             * @memberof kritor.group.BanMemberRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BanMemberRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                if (message.targetUid != null && message.hasOwnProperty("targetUid")) {
                    properties.target = 1;
                    if (!$util.isString(message.targetUid))
                        return "targetUid: string expected";
                }
                if (message.targetUin != null && message.hasOwnProperty("targetUin")) {
                    if (properties.target === 1)
                        return "target: multiple values";
                    properties.target = 1;
                    if (!$util.isInteger(message.targetUin) && !(message.targetUin && $util.isInteger(message.targetUin.low) && $util.isInteger(message.targetUin.high)))
                        return "targetUin: integer|Long expected";
                }
                if (message.duration != null && message.hasOwnProperty("duration"))
                    if (!$util.isInteger(message.duration))
                        return "duration: integer expected";
                return null;
            };

            /**
             * Creates a BanMemberRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.BanMemberRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.BanMemberRequest} BanMemberRequest
             */
            BanMemberRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.BanMemberRequest)
                    return object;
                let message = new $root.kritor.group.BanMemberRequest();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                if (object.targetUid != null)
                    message.targetUid = String(object.targetUid);
                if (object.targetUin != null)
                    if ($util.Long)
                        (message.targetUin = $util.Long.fromValue(object.targetUin)).unsigned = true;
                    else if (typeof object.targetUin === "string")
                        message.targetUin = parseInt(object.targetUin, 10);
                    else if (typeof object.targetUin === "number")
                        message.targetUin = object.targetUin;
                    else if (typeof object.targetUin === "object")
                        message.targetUin = new $util.LongBits(object.targetUin.low >>> 0, object.targetUin.high >>> 0).toNumber(true);
                if (object.duration != null)
                    message.duration = object.duration >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a BanMemberRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.BanMemberRequest
             * @static
             * @param {kritor.group.BanMemberRequest} message BanMemberRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BanMemberRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                    object.duration = 0;
                }
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                if (message.targetUid != null && message.hasOwnProperty("targetUid")) {
                    object.targetUid = message.targetUid;
                    if (options.oneofs)
                        object.target = "targetUid";
                }
                if (message.targetUin != null && message.hasOwnProperty("targetUin")) {
                    if (typeof message.targetUin === "number")
                        object.targetUin = options.longs === String ? String(message.targetUin) : message.targetUin;
                    else
                        object.targetUin = options.longs === String ? $util.Long.prototype.toString.call(message.targetUin) : options.longs === Number ? new $util.LongBits(message.targetUin.low >>> 0, message.targetUin.high >>> 0).toNumber(true) : message.targetUin;
                    if (options.oneofs)
                        object.target = "targetUin";
                }
                if (message.duration != null && message.hasOwnProperty("duration"))
                    object.duration = message.duration;
                return object;
            };

            /**
             * Converts this BanMemberRequest to JSON.
             * @function toJSON
             * @memberof kritor.group.BanMemberRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BanMemberRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for BanMemberRequest
             * @function getTypeUrl
             * @memberof kritor.group.BanMemberRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            BanMemberRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.BanMemberRequest";
            };

            return BanMemberRequest;
        })();

        group.BanMemberResponse = (function() {

            /**
             * Properties of a BanMemberResponse.
             * @memberof kritor.group
             * @interface IBanMemberResponse
             * @property {number|Long|null} [groupId] BanMemberResponse groupId
             */

            /**
             * Constructs a new BanMemberResponse.
             * @memberof kritor.group
             * @classdesc Represents a BanMemberResponse.
             * @implements IBanMemberResponse
             * @constructor
             * @param {kritor.group.IBanMemberResponse=} [properties] Properties to set
             */
            function BanMemberResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BanMemberResponse groupId.
             * @member {number|Long} groupId
             * @memberof kritor.group.BanMemberResponse
             * @instance
             */
            BanMemberResponse.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new BanMemberResponse instance using the specified properties.
             * @function create
             * @memberof kritor.group.BanMemberResponse
             * @static
             * @param {kritor.group.IBanMemberResponse=} [properties] Properties to set
             * @returns {kritor.group.BanMemberResponse} BanMemberResponse instance
             */
            BanMemberResponse.create = function create(properties) {
                return new BanMemberResponse(properties);
            };

            /**
             * Encodes the specified BanMemberResponse message. Does not implicitly {@link kritor.group.BanMemberResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.BanMemberResponse
             * @static
             * @param {kritor.group.IBanMemberResponse} message BanMemberResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BanMemberResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                return writer;
            };

            /**
             * Encodes the specified BanMemberResponse message, length delimited. Does not implicitly {@link kritor.group.BanMemberResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.BanMemberResponse
             * @static
             * @param {kritor.group.IBanMemberResponse} message BanMemberResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BanMemberResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BanMemberResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.BanMemberResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.BanMemberResponse} BanMemberResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BanMemberResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.BanMemberResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BanMemberResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.BanMemberResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.BanMemberResponse} BanMemberResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BanMemberResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BanMemberResponse message.
             * @function verify
             * @memberof kritor.group.BanMemberResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BanMemberResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                return null;
            };

            /**
             * Creates a BanMemberResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.BanMemberResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.BanMemberResponse} BanMemberResponse
             */
            BanMemberResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.BanMemberResponse)
                    return object;
                let message = new $root.kritor.group.BanMemberResponse();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a BanMemberResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.BanMemberResponse
             * @static
             * @param {kritor.group.BanMemberResponse} message BanMemberResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BanMemberResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                return object;
            };

            /**
             * Converts this BanMemberResponse to JSON.
             * @function toJSON
             * @memberof kritor.group.BanMemberResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BanMemberResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for BanMemberResponse
             * @function getTypeUrl
             * @memberof kritor.group.BanMemberResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            BanMemberResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.BanMemberResponse";
            };

            return BanMemberResponse;
        })();

        group.PokeMemberRequest = (function() {

            /**
             * Properties of a PokeMemberRequest.
             * @memberof kritor.group
             * @interface IPokeMemberRequest
             * @property {number|Long|null} [groupId] PokeMemberRequest groupId
             * @property {string|null} [targetUid] PokeMemberRequest targetUid
             * @property {number|Long|null} [targetUin] PokeMemberRequest targetUin
             */

            /**
             * Constructs a new PokeMemberRequest.
             * @memberof kritor.group
             * @classdesc Represents a PokeMemberRequest.
             * @implements IPokeMemberRequest
             * @constructor
             * @param {kritor.group.IPokeMemberRequest=} [properties] Properties to set
             */
            function PokeMemberRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PokeMemberRequest groupId.
             * @member {number|Long} groupId
             * @memberof kritor.group.PokeMemberRequest
             * @instance
             */
            PokeMemberRequest.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * PokeMemberRequest targetUid.
             * @member {string|null|undefined} targetUid
             * @memberof kritor.group.PokeMemberRequest
             * @instance
             */
            PokeMemberRequest.prototype.targetUid = null;

            /**
             * PokeMemberRequest targetUin.
             * @member {number|Long|null|undefined} targetUin
             * @memberof kritor.group.PokeMemberRequest
             * @instance
             */
            PokeMemberRequest.prototype.targetUin = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * PokeMemberRequest target.
             * @member {"targetUid"|"targetUin"|undefined} target
             * @memberof kritor.group.PokeMemberRequest
             * @instance
             */
            Object.defineProperty(PokeMemberRequest.prototype, "target", {
                get: $util.oneOfGetter($oneOfFields = ["targetUid", "targetUin"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new PokeMemberRequest instance using the specified properties.
             * @function create
             * @memberof kritor.group.PokeMemberRequest
             * @static
             * @param {kritor.group.IPokeMemberRequest=} [properties] Properties to set
             * @returns {kritor.group.PokeMemberRequest} PokeMemberRequest instance
             */
            PokeMemberRequest.create = function create(properties) {
                return new PokeMemberRequest(properties);
            };

            /**
             * Encodes the specified PokeMemberRequest message. Does not implicitly {@link kritor.group.PokeMemberRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.PokeMemberRequest
             * @static
             * @param {kritor.group.IPokeMemberRequest} message PokeMemberRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PokeMemberRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                if (message.targetUid != null && Object.hasOwnProperty.call(message, "targetUid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.targetUid);
                if (message.targetUin != null && Object.hasOwnProperty.call(message, "targetUin"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.targetUin);
                return writer;
            };

            /**
             * Encodes the specified PokeMemberRequest message, length delimited. Does not implicitly {@link kritor.group.PokeMemberRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.PokeMemberRequest
             * @static
             * @param {kritor.group.IPokeMemberRequest} message PokeMemberRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PokeMemberRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PokeMemberRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.PokeMemberRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.PokeMemberRequest} PokeMemberRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PokeMemberRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.PokeMemberRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.targetUid = reader.string();
                            break;
                        }
                    case 3: {
                            message.targetUin = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PokeMemberRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.PokeMemberRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.PokeMemberRequest} PokeMemberRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PokeMemberRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PokeMemberRequest message.
             * @function verify
             * @memberof kritor.group.PokeMemberRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PokeMemberRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                if (message.targetUid != null && message.hasOwnProperty("targetUid")) {
                    properties.target = 1;
                    if (!$util.isString(message.targetUid))
                        return "targetUid: string expected";
                }
                if (message.targetUin != null && message.hasOwnProperty("targetUin")) {
                    if (properties.target === 1)
                        return "target: multiple values";
                    properties.target = 1;
                    if (!$util.isInteger(message.targetUin) && !(message.targetUin && $util.isInteger(message.targetUin.low) && $util.isInteger(message.targetUin.high)))
                        return "targetUin: integer|Long expected";
                }
                return null;
            };

            /**
             * Creates a PokeMemberRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.PokeMemberRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.PokeMemberRequest} PokeMemberRequest
             */
            PokeMemberRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.PokeMemberRequest)
                    return object;
                let message = new $root.kritor.group.PokeMemberRequest();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                if (object.targetUid != null)
                    message.targetUid = String(object.targetUid);
                if (object.targetUin != null)
                    if ($util.Long)
                        (message.targetUin = $util.Long.fromValue(object.targetUin)).unsigned = true;
                    else if (typeof object.targetUin === "string")
                        message.targetUin = parseInt(object.targetUin, 10);
                    else if (typeof object.targetUin === "number")
                        message.targetUin = object.targetUin;
                    else if (typeof object.targetUin === "object")
                        message.targetUin = new $util.LongBits(object.targetUin.low >>> 0, object.targetUin.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a PokeMemberRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.PokeMemberRequest
             * @static
             * @param {kritor.group.PokeMemberRequest} message PokeMemberRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PokeMemberRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                if (message.targetUid != null && message.hasOwnProperty("targetUid")) {
                    object.targetUid = message.targetUid;
                    if (options.oneofs)
                        object.target = "targetUid";
                }
                if (message.targetUin != null && message.hasOwnProperty("targetUin")) {
                    if (typeof message.targetUin === "number")
                        object.targetUin = options.longs === String ? String(message.targetUin) : message.targetUin;
                    else
                        object.targetUin = options.longs === String ? $util.Long.prototype.toString.call(message.targetUin) : options.longs === Number ? new $util.LongBits(message.targetUin.low >>> 0, message.targetUin.high >>> 0).toNumber(true) : message.targetUin;
                    if (options.oneofs)
                        object.target = "targetUin";
                }
                return object;
            };

            /**
             * Converts this PokeMemberRequest to JSON.
             * @function toJSON
             * @memberof kritor.group.PokeMemberRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PokeMemberRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for PokeMemberRequest
             * @function getTypeUrl
             * @memberof kritor.group.PokeMemberRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            PokeMemberRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.PokeMemberRequest";
            };

            return PokeMemberRequest;
        })();

        group.PokeMemberResponse = (function() {

            /**
             * Properties of a PokeMemberResponse.
             * @memberof kritor.group
             * @interface IPokeMemberResponse
             */

            /**
             * Constructs a new PokeMemberResponse.
             * @memberof kritor.group
             * @classdesc Represents a PokeMemberResponse.
             * @implements IPokeMemberResponse
             * @constructor
             * @param {kritor.group.IPokeMemberResponse=} [properties] Properties to set
             */
            function PokeMemberResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new PokeMemberResponse instance using the specified properties.
             * @function create
             * @memberof kritor.group.PokeMemberResponse
             * @static
             * @param {kritor.group.IPokeMemberResponse=} [properties] Properties to set
             * @returns {kritor.group.PokeMemberResponse} PokeMemberResponse instance
             */
            PokeMemberResponse.create = function create(properties) {
                return new PokeMemberResponse(properties);
            };

            /**
             * Encodes the specified PokeMemberResponse message. Does not implicitly {@link kritor.group.PokeMemberResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.PokeMemberResponse
             * @static
             * @param {kritor.group.IPokeMemberResponse} message PokeMemberResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PokeMemberResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified PokeMemberResponse message, length delimited. Does not implicitly {@link kritor.group.PokeMemberResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.PokeMemberResponse
             * @static
             * @param {kritor.group.IPokeMemberResponse} message PokeMemberResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PokeMemberResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PokeMemberResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.PokeMemberResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.PokeMemberResponse} PokeMemberResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PokeMemberResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.PokeMemberResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PokeMemberResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.PokeMemberResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.PokeMemberResponse} PokeMemberResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PokeMemberResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PokeMemberResponse message.
             * @function verify
             * @memberof kritor.group.PokeMemberResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PokeMemberResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a PokeMemberResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.PokeMemberResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.PokeMemberResponse} PokeMemberResponse
             */
            PokeMemberResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.PokeMemberResponse)
                    return object;
                return new $root.kritor.group.PokeMemberResponse();
            };

            /**
             * Creates a plain object from a PokeMemberResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.PokeMemberResponse
             * @static
             * @param {kritor.group.PokeMemberResponse} message PokeMemberResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PokeMemberResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this PokeMemberResponse to JSON.
             * @function toJSON
             * @memberof kritor.group.PokeMemberResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PokeMemberResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for PokeMemberResponse
             * @function getTypeUrl
             * @memberof kritor.group.PokeMemberResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            PokeMemberResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.PokeMemberResponse";
            };

            return PokeMemberResponse;
        })();

        group.KickMemberRequest = (function() {

            /**
             * Properties of a KickMemberRequest.
             * @memberof kritor.group
             * @interface IKickMemberRequest
             * @property {number|Long|null} [groupId] KickMemberRequest groupId
             * @property {string|null} [targetUid] KickMemberRequest targetUid
             * @property {number|Long|null} [targetUin] KickMemberRequest targetUin
             * @property {boolean|null} [rejectAddRequest] KickMemberRequest rejectAddRequest
             * @property {string|null} [kickReason] KickMemberRequest kickReason
             */

            /**
             * Constructs a new KickMemberRequest.
             * @memberof kritor.group
             * @classdesc Represents a KickMemberRequest.
             * @implements IKickMemberRequest
             * @constructor
             * @param {kritor.group.IKickMemberRequest=} [properties] Properties to set
             */
            function KickMemberRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * KickMemberRequest groupId.
             * @member {number|Long} groupId
             * @memberof kritor.group.KickMemberRequest
             * @instance
             */
            KickMemberRequest.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * KickMemberRequest targetUid.
             * @member {string|null|undefined} targetUid
             * @memberof kritor.group.KickMemberRequest
             * @instance
             */
            KickMemberRequest.prototype.targetUid = null;

            /**
             * KickMemberRequest targetUin.
             * @member {number|Long|null|undefined} targetUin
             * @memberof kritor.group.KickMemberRequest
             * @instance
             */
            KickMemberRequest.prototype.targetUin = null;

            /**
             * KickMemberRequest rejectAddRequest.
             * @member {boolean|null|undefined} rejectAddRequest
             * @memberof kritor.group.KickMemberRequest
             * @instance
             */
            KickMemberRequest.prototype.rejectAddRequest = null;

            /**
             * KickMemberRequest kickReason.
             * @member {string|null|undefined} kickReason
             * @memberof kritor.group.KickMemberRequest
             * @instance
             */
            KickMemberRequest.prototype.kickReason = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * KickMemberRequest target.
             * @member {"targetUid"|"targetUin"|undefined} target
             * @memberof kritor.group.KickMemberRequest
             * @instance
             */
            Object.defineProperty(KickMemberRequest.prototype, "target", {
                get: $util.oneOfGetter($oneOfFields = ["targetUid", "targetUin"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * KickMemberRequest _rejectAddRequest.
             * @member {"rejectAddRequest"|undefined} _rejectAddRequest
             * @memberof kritor.group.KickMemberRequest
             * @instance
             */
            Object.defineProperty(KickMemberRequest.prototype, "_rejectAddRequest", {
                get: $util.oneOfGetter($oneOfFields = ["rejectAddRequest"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * KickMemberRequest _kickReason.
             * @member {"kickReason"|undefined} _kickReason
             * @memberof kritor.group.KickMemberRequest
             * @instance
             */
            Object.defineProperty(KickMemberRequest.prototype, "_kickReason", {
                get: $util.oneOfGetter($oneOfFields = ["kickReason"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new KickMemberRequest instance using the specified properties.
             * @function create
             * @memberof kritor.group.KickMemberRequest
             * @static
             * @param {kritor.group.IKickMemberRequest=} [properties] Properties to set
             * @returns {kritor.group.KickMemberRequest} KickMemberRequest instance
             */
            KickMemberRequest.create = function create(properties) {
                return new KickMemberRequest(properties);
            };

            /**
             * Encodes the specified KickMemberRequest message. Does not implicitly {@link kritor.group.KickMemberRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.KickMemberRequest
             * @static
             * @param {kritor.group.IKickMemberRequest} message KickMemberRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KickMemberRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                if (message.targetUid != null && Object.hasOwnProperty.call(message, "targetUid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.targetUid);
                if (message.targetUin != null && Object.hasOwnProperty.call(message, "targetUin"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.targetUin);
                if (message.kickReason != null && Object.hasOwnProperty.call(message, "kickReason"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.kickReason);
                if (message.rejectAddRequest != null && Object.hasOwnProperty.call(message, "rejectAddRequest"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.rejectAddRequest);
                return writer;
            };

            /**
             * Encodes the specified KickMemberRequest message, length delimited. Does not implicitly {@link kritor.group.KickMemberRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.KickMemberRequest
             * @static
             * @param {kritor.group.IKickMemberRequest} message KickMemberRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KickMemberRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KickMemberRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.KickMemberRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.KickMemberRequest} KickMemberRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KickMemberRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.KickMemberRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.targetUid = reader.string();
                            break;
                        }
                    case 3: {
                            message.targetUin = reader.uint64();
                            break;
                        }
                    case 6: {
                            message.rejectAddRequest = reader.bool();
                            break;
                        }
                    case 5: {
                            message.kickReason = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KickMemberRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.KickMemberRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.KickMemberRequest} KickMemberRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KickMemberRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KickMemberRequest message.
             * @function verify
             * @memberof kritor.group.KickMemberRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KickMemberRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                if (message.targetUid != null && message.hasOwnProperty("targetUid")) {
                    properties.target = 1;
                    if (!$util.isString(message.targetUid))
                        return "targetUid: string expected";
                }
                if (message.targetUin != null && message.hasOwnProperty("targetUin")) {
                    if (properties.target === 1)
                        return "target: multiple values";
                    properties.target = 1;
                    if (!$util.isInteger(message.targetUin) && !(message.targetUin && $util.isInteger(message.targetUin.low) && $util.isInteger(message.targetUin.high)))
                        return "targetUin: integer|Long expected";
                }
                if (message.rejectAddRequest != null && message.hasOwnProperty("rejectAddRequest")) {
                    properties._rejectAddRequest = 1;
                    if (typeof message.rejectAddRequest !== "boolean")
                        return "rejectAddRequest: boolean expected";
                }
                if (message.kickReason != null && message.hasOwnProperty("kickReason")) {
                    properties._kickReason = 1;
                    if (!$util.isString(message.kickReason))
                        return "kickReason: string expected";
                }
                return null;
            };

            /**
             * Creates a KickMemberRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.KickMemberRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.KickMemberRequest} KickMemberRequest
             */
            KickMemberRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.KickMemberRequest)
                    return object;
                let message = new $root.kritor.group.KickMemberRequest();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                if (object.targetUid != null)
                    message.targetUid = String(object.targetUid);
                if (object.targetUin != null)
                    if ($util.Long)
                        (message.targetUin = $util.Long.fromValue(object.targetUin)).unsigned = true;
                    else if (typeof object.targetUin === "string")
                        message.targetUin = parseInt(object.targetUin, 10);
                    else if (typeof object.targetUin === "number")
                        message.targetUin = object.targetUin;
                    else if (typeof object.targetUin === "object")
                        message.targetUin = new $util.LongBits(object.targetUin.low >>> 0, object.targetUin.high >>> 0).toNumber(true);
                if (object.rejectAddRequest != null)
                    message.rejectAddRequest = Boolean(object.rejectAddRequest);
                if (object.kickReason != null)
                    message.kickReason = String(object.kickReason);
                return message;
            };

            /**
             * Creates a plain object from a KickMemberRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.KickMemberRequest
             * @static
             * @param {kritor.group.KickMemberRequest} message KickMemberRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KickMemberRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                if (message.targetUid != null && message.hasOwnProperty("targetUid")) {
                    object.targetUid = message.targetUid;
                    if (options.oneofs)
                        object.target = "targetUid";
                }
                if (message.targetUin != null && message.hasOwnProperty("targetUin")) {
                    if (typeof message.targetUin === "number")
                        object.targetUin = options.longs === String ? String(message.targetUin) : message.targetUin;
                    else
                        object.targetUin = options.longs === String ? $util.Long.prototype.toString.call(message.targetUin) : options.longs === Number ? new $util.LongBits(message.targetUin.low >>> 0, message.targetUin.high >>> 0).toNumber(true) : message.targetUin;
                    if (options.oneofs)
                        object.target = "targetUin";
                }
                if (message.kickReason != null && message.hasOwnProperty("kickReason")) {
                    object.kickReason = message.kickReason;
                    if (options.oneofs)
                        object._kickReason = "kickReason";
                }
                if (message.rejectAddRequest != null && message.hasOwnProperty("rejectAddRequest")) {
                    object.rejectAddRequest = message.rejectAddRequest;
                    if (options.oneofs)
                        object._rejectAddRequest = "rejectAddRequest";
                }
                return object;
            };

            /**
             * Converts this KickMemberRequest to JSON.
             * @function toJSON
             * @memberof kritor.group.KickMemberRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KickMemberRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for KickMemberRequest
             * @function getTypeUrl
             * @memberof kritor.group.KickMemberRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            KickMemberRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.KickMemberRequest";
            };

            return KickMemberRequest;
        })();

        group.KickMemberResponse = (function() {

            /**
             * Properties of a KickMemberResponse.
             * @memberof kritor.group
             * @interface IKickMemberResponse
             */

            /**
             * Constructs a new KickMemberResponse.
             * @memberof kritor.group
             * @classdesc Represents a KickMemberResponse.
             * @implements IKickMemberResponse
             * @constructor
             * @param {kritor.group.IKickMemberResponse=} [properties] Properties to set
             */
            function KickMemberResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new KickMemberResponse instance using the specified properties.
             * @function create
             * @memberof kritor.group.KickMemberResponse
             * @static
             * @param {kritor.group.IKickMemberResponse=} [properties] Properties to set
             * @returns {kritor.group.KickMemberResponse} KickMemberResponse instance
             */
            KickMemberResponse.create = function create(properties) {
                return new KickMemberResponse(properties);
            };

            /**
             * Encodes the specified KickMemberResponse message. Does not implicitly {@link kritor.group.KickMemberResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.KickMemberResponse
             * @static
             * @param {kritor.group.IKickMemberResponse} message KickMemberResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KickMemberResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified KickMemberResponse message, length delimited. Does not implicitly {@link kritor.group.KickMemberResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.KickMemberResponse
             * @static
             * @param {kritor.group.IKickMemberResponse} message KickMemberResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            KickMemberResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a KickMemberResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.KickMemberResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.KickMemberResponse} KickMemberResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KickMemberResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.KickMemberResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a KickMemberResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.KickMemberResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.KickMemberResponse} KickMemberResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            KickMemberResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a KickMemberResponse message.
             * @function verify
             * @memberof kritor.group.KickMemberResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            KickMemberResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a KickMemberResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.KickMemberResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.KickMemberResponse} KickMemberResponse
             */
            KickMemberResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.KickMemberResponse)
                    return object;
                return new $root.kritor.group.KickMemberResponse();
            };

            /**
             * Creates a plain object from a KickMemberResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.KickMemberResponse
             * @static
             * @param {kritor.group.KickMemberResponse} message KickMemberResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            KickMemberResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this KickMemberResponse to JSON.
             * @function toJSON
             * @memberof kritor.group.KickMemberResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            KickMemberResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for KickMemberResponse
             * @function getTypeUrl
             * @memberof kritor.group.KickMemberResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            KickMemberResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.KickMemberResponse";
            };

            return KickMemberResponse;
        })();

        group.LeaveGroupRequest = (function() {

            /**
             * Properties of a LeaveGroupRequest.
             * @memberof kritor.group
             * @interface ILeaveGroupRequest
             * @property {number|Long|null} [groupId] LeaveGroupRequest groupId
             */

            /**
             * Constructs a new LeaveGroupRequest.
             * @memberof kritor.group
             * @classdesc Represents a LeaveGroupRequest.
             * @implements ILeaveGroupRequest
             * @constructor
             * @param {kritor.group.ILeaveGroupRequest=} [properties] Properties to set
             */
            function LeaveGroupRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LeaveGroupRequest groupId.
             * @member {number|Long} groupId
             * @memberof kritor.group.LeaveGroupRequest
             * @instance
             */
            LeaveGroupRequest.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new LeaveGroupRequest instance using the specified properties.
             * @function create
             * @memberof kritor.group.LeaveGroupRequest
             * @static
             * @param {kritor.group.ILeaveGroupRequest=} [properties] Properties to set
             * @returns {kritor.group.LeaveGroupRequest} LeaveGroupRequest instance
             */
            LeaveGroupRequest.create = function create(properties) {
                return new LeaveGroupRequest(properties);
            };

            /**
             * Encodes the specified LeaveGroupRequest message. Does not implicitly {@link kritor.group.LeaveGroupRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.LeaveGroupRequest
             * @static
             * @param {kritor.group.ILeaveGroupRequest} message LeaveGroupRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LeaveGroupRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                return writer;
            };

            /**
             * Encodes the specified LeaveGroupRequest message, length delimited. Does not implicitly {@link kritor.group.LeaveGroupRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.LeaveGroupRequest
             * @static
             * @param {kritor.group.ILeaveGroupRequest} message LeaveGroupRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LeaveGroupRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LeaveGroupRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.LeaveGroupRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.LeaveGroupRequest} LeaveGroupRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LeaveGroupRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.LeaveGroupRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a LeaveGroupRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.LeaveGroupRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.LeaveGroupRequest} LeaveGroupRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LeaveGroupRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LeaveGroupRequest message.
             * @function verify
             * @memberof kritor.group.LeaveGroupRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LeaveGroupRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                return null;
            };

            /**
             * Creates a LeaveGroupRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.LeaveGroupRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.LeaveGroupRequest} LeaveGroupRequest
             */
            LeaveGroupRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.LeaveGroupRequest)
                    return object;
                let message = new $root.kritor.group.LeaveGroupRequest();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a LeaveGroupRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.LeaveGroupRequest
             * @static
             * @param {kritor.group.LeaveGroupRequest} message LeaveGroupRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LeaveGroupRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                return object;
            };

            /**
             * Converts this LeaveGroupRequest to JSON.
             * @function toJSON
             * @memberof kritor.group.LeaveGroupRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LeaveGroupRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for LeaveGroupRequest
             * @function getTypeUrl
             * @memberof kritor.group.LeaveGroupRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            LeaveGroupRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.LeaveGroupRequest";
            };

            return LeaveGroupRequest;
        })();

        group.LeaveGroupResponse = (function() {

            /**
             * Properties of a LeaveGroupResponse.
             * @memberof kritor.group
             * @interface ILeaveGroupResponse
             */

            /**
             * Constructs a new LeaveGroupResponse.
             * @memberof kritor.group
             * @classdesc Represents a LeaveGroupResponse.
             * @implements ILeaveGroupResponse
             * @constructor
             * @param {kritor.group.ILeaveGroupResponse=} [properties] Properties to set
             */
            function LeaveGroupResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new LeaveGroupResponse instance using the specified properties.
             * @function create
             * @memberof kritor.group.LeaveGroupResponse
             * @static
             * @param {kritor.group.ILeaveGroupResponse=} [properties] Properties to set
             * @returns {kritor.group.LeaveGroupResponse} LeaveGroupResponse instance
             */
            LeaveGroupResponse.create = function create(properties) {
                return new LeaveGroupResponse(properties);
            };

            /**
             * Encodes the specified LeaveGroupResponse message. Does not implicitly {@link kritor.group.LeaveGroupResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.LeaveGroupResponse
             * @static
             * @param {kritor.group.ILeaveGroupResponse} message LeaveGroupResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LeaveGroupResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified LeaveGroupResponse message, length delimited. Does not implicitly {@link kritor.group.LeaveGroupResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.LeaveGroupResponse
             * @static
             * @param {kritor.group.ILeaveGroupResponse} message LeaveGroupResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LeaveGroupResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LeaveGroupResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.LeaveGroupResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.LeaveGroupResponse} LeaveGroupResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LeaveGroupResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.LeaveGroupResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a LeaveGroupResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.LeaveGroupResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.LeaveGroupResponse} LeaveGroupResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LeaveGroupResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LeaveGroupResponse message.
             * @function verify
             * @memberof kritor.group.LeaveGroupResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LeaveGroupResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a LeaveGroupResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.LeaveGroupResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.LeaveGroupResponse} LeaveGroupResponse
             */
            LeaveGroupResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.LeaveGroupResponse)
                    return object;
                return new $root.kritor.group.LeaveGroupResponse();
            };

            /**
             * Creates a plain object from a LeaveGroupResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.LeaveGroupResponse
             * @static
             * @param {kritor.group.LeaveGroupResponse} message LeaveGroupResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            LeaveGroupResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this LeaveGroupResponse to JSON.
             * @function toJSON
             * @memberof kritor.group.LeaveGroupResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            LeaveGroupResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for LeaveGroupResponse
             * @function getTypeUrl
             * @memberof kritor.group.LeaveGroupResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            LeaveGroupResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.LeaveGroupResponse";
            };

            return LeaveGroupResponse;
        })();

        group.ModifyMemberCardRequest = (function() {

            /**
             * Properties of a ModifyMemberCardRequest.
             * @memberof kritor.group
             * @interface IModifyMemberCardRequest
             * @property {number|Long|null} [groupId] ModifyMemberCardRequest groupId
             * @property {string|null} [targetUid] ModifyMemberCardRequest targetUid
             * @property {number|Long|null} [targetUin] ModifyMemberCardRequest targetUin
             * @property {string|null} [card] ModifyMemberCardRequest card
             */

            /**
             * Constructs a new ModifyMemberCardRequest.
             * @memberof kritor.group
             * @classdesc Represents a ModifyMemberCardRequest.
             * @implements IModifyMemberCardRequest
             * @constructor
             * @param {kritor.group.IModifyMemberCardRequest=} [properties] Properties to set
             */
            function ModifyMemberCardRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ModifyMemberCardRequest groupId.
             * @member {number|Long} groupId
             * @memberof kritor.group.ModifyMemberCardRequest
             * @instance
             */
            ModifyMemberCardRequest.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * ModifyMemberCardRequest targetUid.
             * @member {string|null|undefined} targetUid
             * @memberof kritor.group.ModifyMemberCardRequest
             * @instance
             */
            ModifyMemberCardRequest.prototype.targetUid = null;

            /**
             * ModifyMemberCardRequest targetUin.
             * @member {number|Long|null|undefined} targetUin
             * @memberof kritor.group.ModifyMemberCardRequest
             * @instance
             */
            ModifyMemberCardRequest.prototype.targetUin = null;

            /**
             * ModifyMemberCardRequest card.
             * @member {string} card
             * @memberof kritor.group.ModifyMemberCardRequest
             * @instance
             */
            ModifyMemberCardRequest.prototype.card = "";

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * ModifyMemberCardRequest target.
             * @member {"targetUid"|"targetUin"|undefined} target
             * @memberof kritor.group.ModifyMemberCardRequest
             * @instance
             */
            Object.defineProperty(ModifyMemberCardRequest.prototype, "target", {
                get: $util.oneOfGetter($oneOfFields = ["targetUid", "targetUin"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new ModifyMemberCardRequest instance using the specified properties.
             * @function create
             * @memberof kritor.group.ModifyMemberCardRequest
             * @static
             * @param {kritor.group.IModifyMemberCardRequest=} [properties] Properties to set
             * @returns {kritor.group.ModifyMemberCardRequest} ModifyMemberCardRequest instance
             */
            ModifyMemberCardRequest.create = function create(properties) {
                return new ModifyMemberCardRequest(properties);
            };

            /**
             * Encodes the specified ModifyMemberCardRequest message. Does not implicitly {@link kritor.group.ModifyMemberCardRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.ModifyMemberCardRequest
             * @static
             * @param {kritor.group.IModifyMemberCardRequest} message ModifyMemberCardRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ModifyMemberCardRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                if (message.targetUid != null && Object.hasOwnProperty.call(message, "targetUid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.targetUid);
                if (message.targetUin != null && Object.hasOwnProperty.call(message, "targetUin"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.targetUin);
                if (message.card != null && Object.hasOwnProperty.call(message, "card"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.card);
                return writer;
            };

            /**
             * Encodes the specified ModifyMemberCardRequest message, length delimited. Does not implicitly {@link kritor.group.ModifyMemberCardRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.ModifyMemberCardRequest
             * @static
             * @param {kritor.group.IModifyMemberCardRequest} message ModifyMemberCardRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ModifyMemberCardRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ModifyMemberCardRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.ModifyMemberCardRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.ModifyMemberCardRequest} ModifyMemberCardRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ModifyMemberCardRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.ModifyMemberCardRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.targetUid = reader.string();
                            break;
                        }
                    case 3: {
                            message.targetUin = reader.uint64();
                            break;
                        }
                    case 4: {
                            message.card = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ModifyMemberCardRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.ModifyMemberCardRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.ModifyMemberCardRequest} ModifyMemberCardRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ModifyMemberCardRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ModifyMemberCardRequest message.
             * @function verify
             * @memberof kritor.group.ModifyMemberCardRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ModifyMemberCardRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                if (message.targetUid != null && message.hasOwnProperty("targetUid")) {
                    properties.target = 1;
                    if (!$util.isString(message.targetUid))
                        return "targetUid: string expected";
                }
                if (message.targetUin != null && message.hasOwnProperty("targetUin")) {
                    if (properties.target === 1)
                        return "target: multiple values";
                    properties.target = 1;
                    if (!$util.isInteger(message.targetUin) && !(message.targetUin && $util.isInteger(message.targetUin.low) && $util.isInteger(message.targetUin.high)))
                        return "targetUin: integer|Long expected";
                }
                if (message.card != null && message.hasOwnProperty("card"))
                    if (!$util.isString(message.card))
                        return "card: string expected";
                return null;
            };

            /**
             * Creates a ModifyMemberCardRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.ModifyMemberCardRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.ModifyMemberCardRequest} ModifyMemberCardRequest
             */
            ModifyMemberCardRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.ModifyMemberCardRequest)
                    return object;
                let message = new $root.kritor.group.ModifyMemberCardRequest();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                if (object.targetUid != null)
                    message.targetUid = String(object.targetUid);
                if (object.targetUin != null)
                    if ($util.Long)
                        (message.targetUin = $util.Long.fromValue(object.targetUin)).unsigned = true;
                    else if (typeof object.targetUin === "string")
                        message.targetUin = parseInt(object.targetUin, 10);
                    else if (typeof object.targetUin === "number")
                        message.targetUin = object.targetUin;
                    else if (typeof object.targetUin === "object")
                        message.targetUin = new $util.LongBits(object.targetUin.low >>> 0, object.targetUin.high >>> 0).toNumber(true);
                if (object.card != null)
                    message.card = String(object.card);
                return message;
            };

            /**
             * Creates a plain object from a ModifyMemberCardRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.ModifyMemberCardRequest
             * @static
             * @param {kritor.group.ModifyMemberCardRequest} message ModifyMemberCardRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ModifyMemberCardRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                    object.card = "";
                }
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                if (message.targetUid != null && message.hasOwnProperty("targetUid")) {
                    object.targetUid = message.targetUid;
                    if (options.oneofs)
                        object.target = "targetUid";
                }
                if (message.targetUin != null && message.hasOwnProperty("targetUin")) {
                    if (typeof message.targetUin === "number")
                        object.targetUin = options.longs === String ? String(message.targetUin) : message.targetUin;
                    else
                        object.targetUin = options.longs === String ? $util.Long.prototype.toString.call(message.targetUin) : options.longs === Number ? new $util.LongBits(message.targetUin.low >>> 0, message.targetUin.high >>> 0).toNumber(true) : message.targetUin;
                    if (options.oneofs)
                        object.target = "targetUin";
                }
                if (message.card != null && message.hasOwnProperty("card"))
                    object.card = message.card;
                return object;
            };

            /**
             * Converts this ModifyMemberCardRequest to JSON.
             * @function toJSON
             * @memberof kritor.group.ModifyMemberCardRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ModifyMemberCardRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ModifyMemberCardRequest
             * @function getTypeUrl
             * @memberof kritor.group.ModifyMemberCardRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ModifyMemberCardRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.ModifyMemberCardRequest";
            };

            return ModifyMemberCardRequest;
        })();

        group.ModifyMemberCardResponse = (function() {

            /**
             * Properties of a ModifyMemberCardResponse.
             * @memberof kritor.group
             * @interface IModifyMemberCardResponse
             */

            /**
             * Constructs a new ModifyMemberCardResponse.
             * @memberof kritor.group
             * @classdesc Represents a ModifyMemberCardResponse.
             * @implements IModifyMemberCardResponse
             * @constructor
             * @param {kritor.group.IModifyMemberCardResponse=} [properties] Properties to set
             */
            function ModifyMemberCardResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new ModifyMemberCardResponse instance using the specified properties.
             * @function create
             * @memberof kritor.group.ModifyMemberCardResponse
             * @static
             * @param {kritor.group.IModifyMemberCardResponse=} [properties] Properties to set
             * @returns {kritor.group.ModifyMemberCardResponse} ModifyMemberCardResponse instance
             */
            ModifyMemberCardResponse.create = function create(properties) {
                return new ModifyMemberCardResponse(properties);
            };

            /**
             * Encodes the specified ModifyMemberCardResponse message. Does not implicitly {@link kritor.group.ModifyMemberCardResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.ModifyMemberCardResponse
             * @static
             * @param {kritor.group.IModifyMemberCardResponse} message ModifyMemberCardResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ModifyMemberCardResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified ModifyMemberCardResponse message, length delimited. Does not implicitly {@link kritor.group.ModifyMemberCardResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.ModifyMemberCardResponse
             * @static
             * @param {kritor.group.IModifyMemberCardResponse} message ModifyMemberCardResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ModifyMemberCardResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ModifyMemberCardResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.ModifyMemberCardResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.ModifyMemberCardResponse} ModifyMemberCardResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ModifyMemberCardResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.ModifyMemberCardResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ModifyMemberCardResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.ModifyMemberCardResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.ModifyMemberCardResponse} ModifyMemberCardResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ModifyMemberCardResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ModifyMemberCardResponse message.
             * @function verify
             * @memberof kritor.group.ModifyMemberCardResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ModifyMemberCardResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a ModifyMemberCardResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.ModifyMemberCardResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.ModifyMemberCardResponse} ModifyMemberCardResponse
             */
            ModifyMemberCardResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.ModifyMemberCardResponse)
                    return object;
                return new $root.kritor.group.ModifyMemberCardResponse();
            };

            /**
             * Creates a plain object from a ModifyMemberCardResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.ModifyMemberCardResponse
             * @static
             * @param {kritor.group.ModifyMemberCardResponse} message ModifyMemberCardResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ModifyMemberCardResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this ModifyMemberCardResponse to JSON.
             * @function toJSON
             * @memberof kritor.group.ModifyMemberCardResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ModifyMemberCardResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ModifyMemberCardResponse
             * @function getTypeUrl
             * @memberof kritor.group.ModifyMemberCardResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ModifyMemberCardResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.ModifyMemberCardResponse";
            };

            return ModifyMemberCardResponse;
        })();

        group.ModifyGroupNameRequest = (function() {

            /**
             * Properties of a ModifyGroupNameRequest.
             * @memberof kritor.group
             * @interface IModifyGroupNameRequest
             * @property {number|Long|null} [groupId] ModifyGroupNameRequest groupId
             * @property {string|null} [groupName] ModifyGroupNameRequest groupName
             */

            /**
             * Constructs a new ModifyGroupNameRequest.
             * @memberof kritor.group
             * @classdesc Represents a ModifyGroupNameRequest.
             * @implements IModifyGroupNameRequest
             * @constructor
             * @param {kritor.group.IModifyGroupNameRequest=} [properties] Properties to set
             */
            function ModifyGroupNameRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ModifyGroupNameRequest groupId.
             * @member {number|Long} groupId
             * @memberof kritor.group.ModifyGroupNameRequest
             * @instance
             */
            ModifyGroupNameRequest.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * ModifyGroupNameRequest groupName.
             * @member {string} groupName
             * @memberof kritor.group.ModifyGroupNameRequest
             * @instance
             */
            ModifyGroupNameRequest.prototype.groupName = "";

            /**
             * Creates a new ModifyGroupNameRequest instance using the specified properties.
             * @function create
             * @memberof kritor.group.ModifyGroupNameRequest
             * @static
             * @param {kritor.group.IModifyGroupNameRequest=} [properties] Properties to set
             * @returns {kritor.group.ModifyGroupNameRequest} ModifyGroupNameRequest instance
             */
            ModifyGroupNameRequest.create = function create(properties) {
                return new ModifyGroupNameRequest(properties);
            };

            /**
             * Encodes the specified ModifyGroupNameRequest message. Does not implicitly {@link kritor.group.ModifyGroupNameRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.ModifyGroupNameRequest
             * @static
             * @param {kritor.group.IModifyGroupNameRequest} message ModifyGroupNameRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ModifyGroupNameRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                if (message.groupName != null && Object.hasOwnProperty.call(message, "groupName"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.groupName);
                return writer;
            };

            /**
             * Encodes the specified ModifyGroupNameRequest message, length delimited. Does not implicitly {@link kritor.group.ModifyGroupNameRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.ModifyGroupNameRequest
             * @static
             * @param {kritor.group.IModifyGroupNameRequest} message ModifyGroupNameRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ModifyGroupNameRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ModifyGroupNameRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.ModifyGroupNameRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.ModifyGroupNameRequest} ModifyGroupNameRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ModifyGroupNameRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.ModifyGroupNameRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.groupName = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ModifyGroupNameRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.ModifyGroupNameRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.ModifyGroupNameRequest} ModifyGroupNameRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ModifyGroupNameRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ModifyGroupNameRequest message.
             * @function verify
             * @memberof kritor.group.ModifyGroupNameRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ModifyGroupNameRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                if (message.groupName != null && message.hasOwnProperty("groupName"))
                    if (!$util.isString(message.groupName))
                        return "groupName: string expected";
                return null;
            };

            /**
             * Creates a ModifyGroupNameRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.ModifyGroupNameRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.ModifyGroupNameRequest} ModifyGroupNameRequest
             */
            ModifyGroupNameRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.ModifyGroupNameRequest)
                    return object;
                let message = new $root.kritor.group.ModifyGroupNameRequest();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                if (object.groupName != null)
                    message.groupName = String(object.groupName);
                return message;
            };

            /**
             * Creates a plain object from a ModifyGroupNameRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.ModifyGroupNameRequest
             * @static
             * @param {kritor.group.ModifyGroupNameRequest} message ModifyGroupNameRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ModifyGroupNameRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                    object.groupName = "";
                }
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                if (message.groupName != null && message.hasOwnProperty("groupName"))
                    object.groupName = message.groupName;
                return object;
            };

            /**
             * Converts this ModifyGroupNameRequest to JSON.
             * @function toJSON
             * @memberof kritor.group.ModifyGroupNameRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ModifyGroupNameRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ModifyGroupNameRequest
             * @function getTypeUrl
             * @memberof kritor.group.ModifyGroupNameRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ModifyGroupNameRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.ModifyGroupNameRequest";
            };

            return ModifyGroupNameRequest;
        })();

        group.ModifyGroupNameResponse = (function() {

            /**
             * Properties of a ModifyGroupNameResponse.
             * @memberof kritor.group
             * @interface IModifyGroupNameResponse
             */

            /**
             * Constructs a new ModifyGroupNameResponse.
             * @memberof kritor.group
             * @classdesc Represents a ModifyGroupNameResponse.
             * @implements IModifyGroupNameResponse
             * @constructor
             * @param {kritor.group.IModifyGroupNameResponse=} [properties] Properties to set
             */
            function ModifyGroupNameResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new ModifyGroupNameResponse instance using the specified properties.
             * @function create
             * @memberof kritor.group.ModifyGroupNameResponse
             * @static
             * @param {kritor.group.IModifyGroupNameResponse=} [properties] Properties to set
             * @returns {kritor.group.ModifyGroupNameResponse} ModifyGroupNameResponse instance
             */
            ModifyGroupNameResponse.create = function create(properties) {
                return new ModifyGroupNameResponse(properties);
            };

            /**
             * Encodes the specified ModifyGroupNameResponse message. Does not implicitly {@link kritor.group.ModifyGroupNameResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.ModifyGroupNameResponse
             * @static
             * @param {kritor.group.IModifyGroupNameResponse} message ModifyGroupNameResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ModifyGroupNameResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified ModifyGroupNameResponse message, length delimited. Does not implicitly {@link kritor.group.ModifyGroupNameResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.ModifyGroupNameResponse
             * @static
             * @param {kritor.group.IModifyGroupNameResponse} message ModifyGroupNameResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ModifyGroupNameResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ModifyGroupNameResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.ModifyGroupNameResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.ModifyGroupNameResponse} ModifyGroupNameResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ModifyGroupNameResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.ModifyGroupNameResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ModifyGroupNameResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.ModifyGroupNameResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.ModifyGroupNameResponse} ModifyGroupNameResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ModifyGroupNameResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ModifyGroupNameResponse message.
             * @function verify
             * @memberof kritor.group.ModifyGroupNameResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ModifyGroupNameResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a ModifyGroupNameResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.ModifyGroupNameResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.ModifyGroupNameResponse} ModifyGroupNameResponse
             */
            ModifyGroupNameResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.ModifyGroupNameResponse)
                    return object;
                return new $root.kritor.group.ModifyGroupNameResponse();
            };

            /**
             * Creates a plain object from a ModifyGroupNameResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.ModifyGroupNameResponse
             * @static
             * @param {kritor.group.ModifyGroupNameResponse} message ModifyGroupNameResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ModifyGroupNameResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this ModifyGroupNameResponse to JSON.
             * @function toJSON
             * @memberof kritor.group.ModifyGroupNameResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ModifyGroupNameResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ModifyGroupNameResponse
             * @function getTypeUrl
             * @memberof kritor.group.ModifyGroupNameResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ModifyGroupNameResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.ModifyGroupNameResponse";
            };

            return ModifyGroupNameResponse;
        })();

        group.ModifyGroupRemarkRequest = (function() {

            /**
             * Properties of a ModifyGroupRemarkRequest.
             * @memberof kritor.group
             * @interface IModifyGroupRemarkRequest
             * @property {number|Long|null} [groupId] ModifyGroupRemarkRequest groupId
             * @property {string|null} [remark] ModifyGroupRemarkRequest remark
             */

            /**
             * Constructs a new ModifyGroupRemarkRequest.
             * @memberof kritor.group
             * @classdesc Represents a ModifyGroupRemarkRequest.
             * @implements IModifyGroupRemarkRequest
             * @constructor
             * @param {kritor.group.IModifyGroupRemarkRequest=} [properties] Properties to set
             */
            function ModifyGroupRemarkRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ModifyGroupRemarkRequest groupId.
             * @member {number|Long} groupId
             * @memberof kritor.group.ModifyGroupRemarkRequest
             * @instance
             */
            ModifyGroupRemarkRequest.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * ModifyGroupRemarkRequest remark.
             * @member {string} remark
             * @memberof kritor.group.ModifyGroupRemarkRequest
             * @instance
             */
            ModifyGroupRemarkRequest.prototype.remark = "";

            /**
             * Creates a new ModifyGroupRemarkRequest instance using the specified properties.
             * @function create
             * @memberof kritor.group.ModifyGroupRemarkRequest
             * @static
             * @param {kritor.group.IModifyGroupRemarkRequest=} [properties] Properties to set
             * @returns {kritor.group.ModifyGroupRemarkRequest} ModifyGroupRemarkRequest instance
             */
            ModifyGroupRemarkRequest.create = function create(properties) {
                return new ModifyGroupRemarkRequest(properties);
            };

            /**
             * Encodes the specified ModifyGroupRemarkRequest message. Does not implicitly {@link kritor.group.ModifyGroupRemarkRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.ModifyGroupRemarkRequest
             * @static
             * @param {kritor.group.IModifyGroupRemarkRequest} message ModifyGroupRemarkRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ModifyGroupRemarkRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                if (message.remark != null && Object.hasOwnProperty.call(message, "remark"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.remark);
                return writer;
            };

            /**
             * Encodes the specified ModifyGroupRemarkRequest message, length delimited. Does not implicitly {@link kritor.group.ModifyGroupRemarkRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.ModifyGroupRemarkRequest
             * @static
             * @param {kritor.group.IModifyGroupRemarkRequest} message ModifyGroupRemarkRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ModifyGroupRemarkRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ModifyGroupRemarkRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.ModifyGroupRemarkRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.ModifyGroupRemarkRequest} ModifyGroupRemarkRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ModifyGroupRemarkRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.ModifyGroupRemarkRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.remark = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ModifyGroupRemarkRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.ModifyGroupRemarkRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.ModifyGroupRemarkRequest} ModifyGroupRemarkRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ModifyGroupRemarkRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ModifyGroupRemarkRequest message.
             * @function verify
             * @memberof kritor.group.ModifyGroupRemarkRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ModifyGroupRemarkRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                if (message.remark != null && message.hasOwnProperty("remark"))
                    if (!$util.isString(message.remark))
                        return "remark: string expected";
                return null;
            };

            /**
             * Creates a ModifyGroupRemarkRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.ModifyGroupRemarkRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.ModifyGroupRemarkRequest} ModifyGroupRemarkRequest
             */
            ModifyGroupRemarkRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.ModifyGroupRemarkRequest)
                    return object;
                let message = new $root.kritor.group.ModifyGroupRemarkRequest();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                if (object.remark != null)
                    message.remark = String(object.remark);
                return message;
            };

            /**
             * Creates a plain object from a ModifyGroupRemarkRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.ModifyGroupRemarkRequest
             * @static
             * @param {kritor.group.ModifyGroupRemarkRequest} message ModifyGroupRemarkRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ModifyGroupRemarkRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                    object.remark = "";
                }
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                if (message.remark != null && message.hasOwnProperty("remark"))
                    object.remark = message.remark;
                return object;
            };

            /**
             * Converts this ModifyGroupRemarkRequest to JSON.
             * @function toJSON
             * @memberof kritor.group.ModifyGroupRemarkRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ModifyGroupRemarkRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ModifyGroupRemarkRequest
             * @function getTypeUrl
             * @memberof kritor.group.ModifyGroupRemarkRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ModifyGroupRemarkRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.ModifyGroupRemarkRequest";
            };

            return ModifyGroupRemarkRequest;
        })();

        group.ModifyGroupRemarkResponse = (function() {

            /**
             * Properties of a ModifyGroupRemarkResponse.
             * @memberof kritor.group
             * @interface IModifyGroupRemarkResponse
             */

            /**
             * Constructs a new ModifyGroupRemarkResponse.
             * @memberof kritor.group
             * @classdesc Represents a ModifyGroupRemarkResponse.
             * @implements IModifyGroupRemarkResponse
             * @constructor
             * @param {kritor.group.IModifyGroupRemarkResponse=} [properties] Properties to set
             */
            function ModifyGroupRemarkResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new ModifyGroupRemarkResponse instance using the specified properties.
             * @function create
             * @memberof kritor.group.ModifyGroupRemarkResponse
             * @static
             * @param {kritor.group.IModifyGroupRemarkResponse=} [properties] Properties to set
             * @returns {kritor.group.ModifyGroupRemarkResponse} ModifyGroupRemarkResponse instance
             */
            ModifyGroupRemarkResponse.create = function create(properties) {
                return new ModifyGroupRemarkResponse(properties);
            };

            /**
             * Encodes the specified ModifyGroupRemarkResponse message. Does not implicitly {@link kritor.group.ModifyGroupRemarkResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.ModifyGroupRemarkResponse
             * @static
             * @param {kritor.group.IModifyGroupRemarkResponse} message ModifyGroupRemarkResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ModifyGroupRemarkResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified ModifyGroupRemarkResponse message, length delimited. Does not implicitly {@link kritor.group.ModifyGroupRemarkResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.ModifyGroupRemarkResponse
             * @static
             * @param {kritor.group.IModifyGroupRemarkResponse} message ModifyGroupRemarkResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ModifyGroupRemarkResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ModifyGroupRemarkResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.ModifyGroupRemarkResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.ModifyGroupRemarkResponse} ModifyGroupRemarkResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ModifyGroupRemarkResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.ModifyGroupRemarkResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ModifyGroupRemarkResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.ModifyGroupRemarkResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.ModifyGroupRemarkResponse} ModifyGroupRemarkResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ModifyGroupRemarkResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ModifyGroupRemarkResponse message.
             * @function verify
             * @memberof kritor.group.ModifyGroupRemarkResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ModifyGroupRemarkResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a ModifyGroupRemarkResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.ModifyGroupRemarkResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.ModifyGroupRemarkResponse} ModifyGroupRemarkResponse
             */
            ModifyGroupRemarkResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.ModifyGroupRemarkResponse)
                    return object;
                return new $root.kritor.group.ModifyGroupRemarkResponse();
            };

            /**
             * Creates a plain object from a ModifyGroupRemarkResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.ModifyGroupRemarkResponse
             * @static
             * @param {kritor.group.ModifyGroupRemarkResponse} message ModifyGroupRemarkResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ModifyGroupRemarkResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this ModifyGroupRemarkResponse to JSON.
             * @function toJSON
             * @memberof kritor.group.ModifyGroupRemarkResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ModifyGroupRemarkResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ModifyGroupRemarkResponse
             * @function getTypeUrl
             * @memberof kritor.group.ModifyGroupRemarkResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ModifyGroupRemarkResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.ModifyGroupRemarkResponse";
            };

            return ModifyGroupRemarkResponse;
        })();

        group.SetGroupAdminRequest = (function() {

            /**
             * Properties of a SetGroupAdminRequest.
             * @memberof kritor.group
             * @interface ISetGroupAdminRequest
             * @property {number|Long|null} [groupId] SetGroupAdminRequest groupId
             * @property {string|null} [targetUid] SetGroupAdminRequest targetUid
             * @property {number|Long|null} [targetUin] SetGroupAdminRequest targetUin
             * @property {boolean|null} [isAdmin] SetGroupAdminRequest isAdmin
             */

            /**
             * Constructs a new SetGroupAdminRequest.
             * @memberof kritor.group
             * @classdesc Represents a SetGroupAdminRequest.
             * @implements ISetGroupAdminRequest
             * @constructor
             * @param {kritor.group.ISetGroupAdminRequest=} [properties] Properties to set
             */
            function SetGroupAdminRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SetGroupAdminRequest groupId.
             * @member {number|Long} groupId
             * @memberof kritor.group.SetGroupAdminRequest
             * @instance
             */
            SetGroupAdminRequest.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * SetGroupAdminRequest targetUid.
             * @member {string|null|undefined} targetUid
             * @memberof kritor.group.SetGroupAdminRequest
             * @instance
             */
            SetGroupAdminRequest.prototype.targetUid = null;

            /**
             * SetGroupAdminRequest targetUin.
             * @member {number|Long|null|undefined} targetUin
             * @memberof kritor.group.SetGroupAdminRequest
             * @instance
             */
            SetGroupAdminRequest.prototype.targetUin = null;

            /**
             * SetGroupAdminRequest isAdmin.
             * @member {boolean} isAdmin
             * @memberof kritor.group.SetGroupAdminRequest
             * @instance
             */
            SetGroupAdminRequest.prototype.isAdmin = false;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * SetGroupAdminRequest target.
             * @member {"targetUid"|"targetUin"|undefined} target
             * @memberof kritor.group.SetGroupAdminRequest
             * @instance
             */
            Object.defineProperty(SetGroupAdminRequest.prototype, "target", {
                get: $util.oneOfGetter($oneOfFields = ["targetUid", "targetUin"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new SetGroupAdminRequest instance using the specified properties.
             * @function create
             * @memberof kritor.group.SetGroupAdminRequest
             * @static
             * @param {kritor.group.ISetGroupAdminRequest=} [properties] Properties to set
             * @returns {kritor.group.SetGroupAdminRequest} SetGroupAdminRequest instance
             */
            SetGroupAdminRequest.create = function create(properties) {
                return new SetGroupAdminRequest(properties);
            };

            /**
             * Encodes the specified SetGroupAdminRequest message. Does not implicitly {@link kritor.group.SetGroupAdminRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.SetGroupAdminRequest
             * @static
             * @param {kritor.group.ISetGroupAdminRequest} message SetGroupAdminRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetGroupAdminRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                if (message.targetUid != null && Object.hasOwnProperty.call(message, "targetUid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.targetUid);
                if (message.targetUin != null && Object.hasOwnProperty.call(message, "targetUin"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.targetUin);
                if (message.isAdmin != null && Object.hasOwnProperty.call(message, "isAdmin"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.isAdmin);
                return writer;
            };

            /**
             * Encodes the specified SetGroupAdminRequest message, length delimited. Does not implicitly {@link kritor.group.SetGroupAdminRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.SetGroupAdminRequest
             * @static
             * @param {kritor.group.ISetGroupAdminRequest} message SetGroupAdminRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetGroupAdminRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetGroupAdminRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.SetGroupAdminRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.SetGroupAdminRequest} SetGroupAdminRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetGroupAdminRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.SetGroupAdminRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.targetUid = reader.string();
                            break;
                        }
                    case 3: {
                            message.targetUin = reader.uint64();
                            break;
                        }
                    case 4: {
                            message.isAdmin = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetGroupAdminRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.SetGroupAdminRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.SetGroupAdminRequest} SetGroupAdminRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetGroupAdminRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetGroupAdminRequest message.
             * @function verify
             * @memberof kritor.group.SetGroupAdminRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetGroupAdminRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                if (message.targetUid != null && message.hasOwnProperty("targetUid")) {
                    properties.target = 1;
                    if (!$util.isString(message.targetUid))
                        return "targetUid: string expected";
                }
                if (message.targetUin != null && message.hasOwnProperty("targetUin")) {
                    if (properties.target === 1)
                        return "target: multiple values";
                    properties.target = 1;
                    if (!$util.isInteger(message.targetUin) && !(message.targetUin && $util.isInteger(message.targetUin.low) && $util.isInteger(message.targetUin.high)))
                        return "targetUin: integer|Long expected";
                }
                if (message.isAdmin != null && message.hasOwnProperty("isAdmin"))
                    if (typeof message.isAdmin !== "boolean")
                        return "isAdmin: boolean expected";
                return null;
            };

            /**
             * Creates a SetGroupAdminRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.SetGroupAdminRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.SetGroupAdminRequest} SetGroupAdminRequest
             */
            SetGroupAdminRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.SetGroupAdminRequest)
                    return object;
                let message = new $root.kritor.group.SetGroupAdminRequest();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                if (object.targetUid != null)
                    message.targetUid = String(object.targetUid);
                if (object.targetUin != null)
                    if ($util.Long)
                        (message.targetUin = $util.Long.fromValue(object.targetUin)).unsigned = true;
                    else if (typeof object.targetUin === "string")
                        message.targetUin = parseInt(object.targetUin, 10);
                    else if (typeof object.targetUin === "number")
                        message.targetUin = object.targetUin;
                    else if (typeof object.targetUin === "object")
                        message.targetUin = new $util.LongBits(object.targetUin.low >>> 0, object.targetUin.high >>> 0).toNumber(true);
                if (object.isAdmin != null)
                    message.isAdmin = Boolean(object.isAdmin);
                return message;
            };

            /**
             * Creates a plain object from a SetGroupAdminRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.SetGroupAdminRequest
             * @static
             * @param {kritor.group.SetGroupAdminRequest} message SetGroupAdminRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetGroupAdminRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                    object.isAdmin = false;
                }
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                if (message.targetUid != null && message.hasOwnProperty("targetUid")) {
                    object.targetUid = message.targetUid;
                    if (options.oneofs)
                        object.target = "targetUid";
                }
                if (message.targetUin != null && message.hasOwnProperty("targetUin")) {
                    if (typeof message.targetUin === "number")
                        object.targetUin = options.longs === String ? String(message.targetUin) : message.targetUin;
                    else
                        object.targetUin = options.longs === String ? $util.Long.prototype.toString.call(message.targetUin) : options.longs === Number ? new $util.LongBits(message.targetUin.low >>> 0, message.targetUin.high >>> 0).toNumber(true) : message.targetUin;
                    if (options.oneofs)
                        object.target = "targetUin";
                }
                if (message.isAdmin != null && message.hasOwnProperty("isAdmin"))
                    object.isAdmin = message.isAdmin;
                return object;
            };

            /**
             * Converts this SetGroupAdminRequest to JSON.
             * @function toJSON
             * @memberof kritor.group.SetGroupAdminRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetGroupAdminRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetGroupAdminRequest
             * @function getTypeUrl
             * @memberof kritor.group.SetGroupAdminRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetGroupAdminRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.SetGroupAdminRequest";
            };

            return SetGroupAdminRequest;
        })();

        group.SetGroupAdminResponse = (function() {

            /**
             * Properties of a SetGroupAdminResponse.
             * @memberof kritor.group
             * @interface ISetGroupAdminResponse
             */

            /**
             * Constructs a new SetGroupAdminResponse.
             * @memberof kritor.group
             * @classdesc Represents a SetGroupAdminResponse.
             * @implements ISetGroupAdminResponse
             * @constructor
             * @param {kritor.group.ISetGroupAdminResponse=} [properties] Properties to set
             */
            function SetGroupAdminResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new SetGroupAdminResponse instance using the specified properties.
             * @function create
             * @memberof kritor.group.SetGroupAdminResponse
             * @static
             * @param {kritor.group.ISetGroupAdminResponse=} [properties] Properties to set
             * @returns {kritor.group.SetGroupAdminResponse} SetGroupAdminResponse instance
             */
            SetGroupAdminResponse.create = function create(properties) {
                return new SetGroupAdminResponse(properties);
            };

            /**
             * Encodes the specified SetGroupAdminResponse message. Does not implicitly {@link kritor.group.SetGroupAdminResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.SetGroupAdminResponse
             * @static
             * @param {kritor.group.ISetGroupAdminResponse} message SetGroupAdminResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetGroupAdminResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified SetGroupAdminResponse message, length delimited. Does not implicitly {@link kritor.group.SetGroupAdminResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.SetGroupAdminResponse
             * @static
             * @param {kritor.group.ISetGroupAdminResponse} message SetGroupAdminResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetGroupAdminResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetGroupAdminResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.SetGroupAdminResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.SetGroupAdminResponse} SetGroupAdminResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetGroupAdminResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.SetGroupAdminResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetGroupAdminResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.SetGroupAdminResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.SetGroupAdminResponse} SetGroupAdminResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetGroupAdminResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetGroupAdminResponse message.
             * @function verify
             * @memberof kritor.group.SetGroupAdminResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetGroupAdminResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a SetGroupAdminResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.SetGroupAdminResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.SetGroupAdminResponse} SetGroupAdminResponse
             */
            SetGroupAdminResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.SetGroupAdminResponse)
                    return object;
                return new $root.kritor.group.SetGroupAdminResponse();
            };

            /**
             * Creates a plain object from a SetGroupAdminResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.SetGroupAdminResponse
             * @static
             * @param {kritor.group.SetGroupAdminResponse} message SetGroupAdminResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetGroupAdminResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this SetGroupAdminResponse to JSON.
             * @function toJSON
             * @memberof kritor.group.SetGroupAdminResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetGroupAdminResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetGroupAdminResponse
             * @function getTypeUrl
             * @memberof kritor.group.SetGroupAdminResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetGroupAdminResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.SetGroupAdminResponse";
            };

            return SetGroupAdminResponse;
        })();

        group.SetGroupUniqueTitleRequest = (function() {

            /**
             * Properties of a SetGroupUniqueTitleRequest.
             * @memberof kritor.group
             * @interface ISetGroupUniqueTitleRequest
             * @property {number|Long|null} [groupId] SetGroupUniqueTitleRequest groupId
             * @property {string|null} [targetUid] SetGroupUniqueTitleRequest targetUid
             * @property {number|Long|null} [targetUin] SetGroupUniqueTitleRequest targetUin
             * @property {string|null} [uniqueTitle] SetGroupUniqueTitleRequest uniqueTitle
             */

            /**
             * Constructs a new SetGroupUniqueTitleRequest.
             * @memberof kritor.group
             * @classdesc Represents a SetGroupUniqueTitleRequest.
             * @implements ISetGroupUniqueTitleRequest
             * @constructor
             * @param {kritor.group.ISetGroupUniqueTitleRequest=} [properties] Properties to set
             */
            function SetGroupUniqueTitleRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SetGroupUniqueTitleRequest groupId.
             * @member {number|Long} groupId
             * @memberof kritor.group.SetGroupUniqueTitleRequest
             * @instance
             */
            SetGroupUniqueTitleRequest.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * SetGroupUniqueTitleRequest targetUid.
             * @member {string|null|undefined} targetUid
             * @memberof kritor.group.SetGroupUniqueTitleRequest
             * @instance
             */
            SetGroupUniqueTitleRequest.prototype.targetUid = null;

            /**
             * SetGroupUniqueTitleRequest targetUin.
             * @member {number|Long|null|undefined} targetUin
             * @memberof kritor.group.SetGroupUniqueTitleRequest
             * @instance
             */
            SetGroupUniqueTitleRequest.prototype.targetUin = null;

            /**
             * SetGroupUniqueTitleRequest uniqueTitle.
             * @member {string} uniqueTitle
             * @memberof kritor.group.SetGroupUniqueTitleRequest
             * @instance
             */
            SetGroupUniqueTitleRequest.prototype.uniqueTitle = "";

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * SetGroupUniqueTitleRequest target.
             * @member {"targetUid"|"targetUin"|undefined} target
             * @memberof kritor.group.SetGroupUniqueTitleRequest
             * @instance
             */
            Object.defineProperty(SetGroupUniqueTitleRequest.prototype, "target", {
                get: $util.oneOfGetter($oneOfFields = ["targetUid", "targetUin"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new SetGroupUniqueTitleRequest instance using the specified properties.
             * @function create
             * @memberof kritor.group.SetGroupUniqueTitleRequest
             * @static
             * @param {kritor.group.ISetGroupUniqueTitleRequest=} [properties] Properties to set
             * @returns {kritor.group.SetGroupUniqueTitleRequest} SetGroupUniqueTitleRequest instance
             */
            SetGroupUniqueTitleRequest.create = function create(properties) {
                return new SetGroupUniqueTitleRequest(properties);
            };

            /**
             * Encodes the specified SetGroupUniqueTitleRequest message. Does not implicitly {@link kritor.group.SetGroupUniqueTitleRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.SetGroupUniqueTitleRequest
             * @static
             * @param {kritor.group.ISetGroupUniqueTitleRequest} message SetGroupUniqueTitleRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetGroupUniqueTitleRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                if (message.targetUid != null && Object.hasOwnProperty.call(message, "targetUid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.targetUid);
                if (message.targetUin != null && Object.hasOwnProperty.call(message, "targetUin"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.targetUin);
                if (message.uniqueTitle != null && Object.hasOwnProperty.call(message, "uniqueTitle"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.uniqueTitle);
                return writer;
            };

            /**
             * Encodes the specified SetGroupUniqueTitleRequest message, length delimited. Does not implicitly {@link kritor.group.SetGroupUniqueTitleRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.SetGroupUniqueTitleRequest
             * @static
             * @param {kritor.group.ISetGroupUniqueTitleRequest} message SetGroupUniqueTitleRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetGroupUniqueTitleRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetGroupUniqueTitleRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.SetGroupUniqueTitleRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.SetGroupUniqueTitleRequest} SetGroupUniqueTitleRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetGroupUniqueTitleRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.SetGroupUniqueTitleRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.targetUid = reader.string();
                            break;
                        }
                    case 3: {
                            message.targetUin = reader.uint64();
                            break;
                        }
                    case 4: {
                            message.uniqueTitle = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetGroupUniqueTitleRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.SetGroupUniqueTitleRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.SetGroupUniqueTitleRequest} SetGroupUniqueTitleRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetGroupUniqueTitleRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetGroupUniqueTitleRequest message.
             * @function verify
             * @memberof kritor.group.SetGroupUniqueTitleRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetGroupUniqueTitleRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                if (message.targetUid != null && message.hasOwnProperty("targetUid")) {
                    properties.target = 1;
                    if (!$util.isString(message.targetUid))
                        return "targetUid: string expected";
                }
                if (message.targetUin != null && message.hasOwnProperty("targetUin")) {
                    if (properties.target === 1)
                        return "target: multiple values";
                    properties.target = 1;
                    if (!$util.isInteger(message.targetUin) && !(message.targetUin && $util.isInteger(message.targetUin.low) && $util.isInteger(message.targetUin.high)))
                        return "targetUin: integer|Long expected";
                }
                if (message.uniqueTitle != null && message.hasOwnProperty("uniqueTitle"))
                    if (!$util.isString(message.uniqueTitle))
                        return "uniqueTitle: string expected";
                return null;
            };

            /**
             * Creates a SetGroupUniqueTitleRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.SetGroupUniqueTitleRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.SetGroupUniqueTitleRequest} SetGroupUniqueTitleRequest
             */
            SetGroupUniqueTitleRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.SetGroupUniqueTitleRequest)
                    return object;
                let message = new $root.kritor.group.SetGroupUniqueTitleRequest();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                if (object.targetUid != null)
                    message.targetUid = String(object.targetUid);
                if (object.targetUin != null)
                    if ($util.Long)
                        (message.targetUin = $util.Long.fromValue(object.targetUin)).unsigned = true;
                    else if (typeof object.targetUin === "string")
                        message.targetUin = parseInt(object.targetUin, 10);
                    else if (typeof object.targetUin === "number")
                        message.targetUin = object.targetUin;
                    else if (typeof object.targetUin === "object")
                        message.targetUin = new $util.LongBits(object.targetUin.low >>> 0, object.targetUin.high >>> 0).toNumber(true);
                if (object.uniqueTitle != null)
                    message.uniqueTitle = String(object.uniqueTitle);
                return message;
            };

            /**
             * Creates a plain object from a SetGroupUniqueTitleRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.SetGroupUniqueTitleRequest
             * @static
             * @param {kritor.group.SetGroupUniqueTitleRequest} message SetGroupUniqueTitleRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetGroupUniqueTitleRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                    object.uniqueTitle = "";
                }
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                if (message.targetUid != null && message.hasOwnProperty("targetUid")) {
                    object.targetUid = message.targetUid;
                    if (options.oneofs)
                        object.target = "targetUid";
                }
                if (message.targetUin != null && message.hasOwnProperty("targetUin")) {
                    if (typeof message.targetUin === "number")
                        object.targetUin = options.longs === String ? String(message.targetUin) : message.targetUin;
                    else
                        object.targetUin = options.longs === String ? $util.Long.prototype.toString.call(message.targetUin) : options.longs === Number ? new $util.LongBits(message.targetUin.low >>> 0, message.targetUin.high >>> 0).toNumber(true) : message.targetUin;
                    if (options.oneofs)
                        object.target = "targetUin";
                }
                if (message.uniqueTitle != null && message.hasOwnProperty("uniqueTitle"))
                    object.uniqueTitle = message.uniqueTitle;
                return object;
            };

            /**
             * Converts this SetGroupUniqueTitleRequest to JSON.
             * @function toJSON
             * @memberof kritor.group.SetGroupUniqueTitleRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetGroupUniqueTitleRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetGroupUniqueTitleRequest
             * @function getTypeUrl
             * @memberof kritor.group.SetGroupUniqueTitleRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetGroupUniqueTitleRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.SetGroupUniqueTitleRequest";
            };

            return SetGroupUniqueTitleRequest;
        })();

        group.SetGroupUniqueTitleResponse = (function() {

            /**
             * Properties of a SetGroupUniqueTitleResponse.
             * @memberof kritor.group
             * @interface ISetGroupUniqueTitleResponse
             */

            /**
             * Constructs a new SetGroupUniqueTitleResponse.
             * @memberof kritor.group
             * @classdesc Represents a SetGroupUniqueTitleResponse.
             * @implements ISetGroupUniqueTitleResponse
             * @constructor
             * @param {kritor.group.ISetGroupUniqueTitleResponse=} [properties] Properties to set
             */
            function SetGroupUniqueTitleResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new SetGroupUniqueTitleResponse instance using the specified properties.
             * @function create
             * @memberof kritor.group.SetGroupUniqueTitleResponse
             * @static
             * @param {kritor.group.ISetGroupUniqueTitleResponse=} [properties] Properties to set
             * @returns {kritor.group.SetGroupUniqueTitleResponse} SetGroupUniqueTitleResponse instance
             */
            SetGroupUniqueTitleResponse.create = function create(properties) {
                return new SetGroupUniqueTitleResponse(properties);
            };

            /**
             * Encodes the specified SetGroupUniqueTitleResponse message. Does not implicitly {@link kritor.group.SetGroupUniqueTitleResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.SetGroupUniqueTitleResponse
             * @static
             * @param {kritor.group.ISetGroupUniqueTitleResponse} message SetGroupUniqueTitleResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetGroupUniqueTitleResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified SetGroupUniqueTitleResponse message, length delimited. Does not implicitly {@link kritor.group.SetGroupUniqueTitleResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.SetGroupUniqueTitleResponse
             * @static
             * @param {kritor.group.ISetGroupUniqueTitleResponse} message SetGroupUniqueTitleResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetGroupUniqueTitleResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetGroupUniqueTitleResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.SetGroupUniqueTitleResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.SetGroupUniqueTitleResponse} SetGroupUniqueTitleResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetGroupUniqueTitleResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.SetGroupUniqueTitleResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetGroupUniqueTitleResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.SetGroupUniqueTitleResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.SetGroupUniqueTitleResponse} SetGroupUniqueTitleResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetGroupUniqueTitleResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetGroupUniqueTitleResponse message.
             * @function verify
             * @memberof kritor.group.SetGroupUniqueTitleResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetGroupUniqueTitleResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a SetGroupUniqueTitleResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.SetGroupUniqueTitleResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.SetGroupUniqueTitleResponse} SetGroupUniqueTitleResponse
             */
            SetGroupUniqueTitleResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.SetGroupUniqueTitleResponse)
                    return object;
                return new $root.kritor.group.SetGroupUniqueTitleResponse();
            };

            /**
             * Creates a plain object from a SetGroupUniqueTitleResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.SetGroupUniqueTitleResponse
             * @static
             * @param {kritor.group.SetGroupUniqueTitleResponse} message SetGroupUniqueTitleResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetGroupUniqueTitleResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this SetGroupUniqueTitleResponse to JSON.
             * @function toJSON
             * @memberof kritor.group.SetGroupUniqueTitleResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetGroupUniqueTitleResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetGroupUniqueTitleResponse
             * @function getTypeUrl
             * @memberof kritor.group.SetGroupUniqueTitleResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetGroupUniqueTitleResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.SetGroupUniqueTitleResponse";
            };

            return SetGroupUniqueTitleResponse;
        })();

        group.SetGroupWholeBanRequest = (function() {

            /**
             * Properties of a SetGroupWholeBanRequest.
             * @memberof kritor.group
             * @interface ISetGroupWholeBanRequest
             * @property {number|Long|null} [groupId] SetGroupWholeBanRequest groupId
             * @property {boolean|null} [isBan] SetGroupWholeBanRequest isBan
             */

            /**
             * Constructs a new SetGroupWholeBanRequest.
             * @memberof kritor.group
             * @classdesc Represents a SetGroupWholeBanRequest.
             * @implements ISetGroupWholeBanRequest
             * @constructor
             * @param {kritor.group.ISetGroupWholeBanRequest=} [properties] Properties to set
             */
            function SetGroupWholeBanRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SetGroupWholeBanRequest groupId.
             * @member {number|Long} groupId
             * @memberof kritor.group.SetGroupWholeBanRequest
             * @instance
             */
            SetGroupWholeBanRequest.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * SetGroupWholeBanRequest isBan.
             * @member {boolean} isBan
             * @memberof kritor.group.SetGroupWholeBanRequest
             * @instance
             */
            SetGroupWholeBanRequest.prototype.isBan = false;

            /**
             * Creates a new SetGroupWholeBanRequest instance using the specified properties.
             * @function create
             * @memberof kritor.group.SetGroupWholeBanRequest
             * @static
             * @param {kritor.group.ISetGroupWholeBanRequest=} [properties] Properties to set
             * @returns {kritor.group.SetGroupWholeBanRequest} SetGroupWholeBanRequest instance
             */
            SetGroupWholeBanRequest.create = function create(properties) {
                return new SetGroupWholeBanRequest(properties);
            };

            /**
             * Encodes the specified SetGroupWholeBanRequest message. Does not implicitly {@link kritor.group.SetGroupWholeBanRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.SetGroupWholeBanRequest
             * @static
             * @param {kritor.group.ISetGroupWholeBanRequest} message SetGroupWholeBanRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetGroupWholeBanRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                if (message.isBan != null && Object.hasOwnProperty.call(message, "isBan"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isBan);
                return writer;
            };

            /**
             * Encodes the specified SetGroupWholeBanRequest message, length delimited. Does not implicitly {@link kritor.group.SetGroupWholeBanRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.SetGroupWholeBanRequest
             * @static
             * @param {kritor.group.ISetGroupWholeBanRequest} message SetGroupWholeBanRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetGroupWholeBanRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetGroupWholeBanRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.SetGroupWholeBanRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.SetGroupWholeBanRequest} SetGroupWholeBanRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetGroupWholeBanRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.SetGroupWholeBanRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.isBan = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetGroupWholeBanRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.SetGroupWholeBanRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.SetGroupWholeBanRequest} SetGroupWholeBanRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetGroupWholeBanRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetGroupWholeBanRequest message.
             * @function verify
             * @memberof kritor.group.SetGroupWholeBanRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetGroupWholeBanRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                if (message.isBan != null && message.hasOwnProperty("isBan"))
                    if (typeof message.isBan !== "boolean")
                        return "isBan: boolean expected";
                return null;
            };

            /**
             * Creates a SetGroupWholeBanRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.SetGroupWholeBanRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.SetGroupWholeBanRequest} SetGroupWholeBanRequest
             */
            SetGroupWholeBanRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.SetGroupWholeBanRequest)
                    return object;
                let message = new $root.kritor.group.SetGroupWholeBanRequest();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                if (object.isBan != null)
                    message.isBan = Boolean(object.isBan);
                return message;
            };

            /**
             * Creates a plain object from a SetGroupWholeBanRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.SetGroupWholeBanRequest
             * @static
             * @param {kritor.group.SetGroupWholeBanRequest} message SetGroupWholeBanRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetGroupWholeBanRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                    object.isBan = false;
                }
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                if (message.isBan != null && message.hasOwnProperty("isBan"))
                    object.isBan = message.isBan;
                return object;
            };

            /**
             * Converts this SetGroupWholeBanRequest to JSON.
             * @function toJSON
             * @memberof kritor.group.SetGroupWholeBanRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetGroupWholeBanRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetGroupWholeBanRequest
             * @function getTypeUrl
             * @memberof kritor.group.SetGroupWholeBanRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetGroupWholeBanRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.SetGroupWholeBanRequest";
            };

            return SetGroupWholeBanRequest;
        })();

        group.SetGroupWholeBanResponse = (function() {

            /**
             * Properties of a SetGroupWholeBanResponse.
             * @memberof kritor.group
             * @interface ISetGroupWholeBanResponse
             */

            /**
             * Constructs a new SetGroupWholeBanResponse.
             * @memberof kritor.group
             * @classdesc Represents a SetGroupWholeBanResponse.
             * @implements ISetGroupWholeBanResponse
             * @constructor
             * @param {kritor.group.ISetGroupWholeBanResponse=} [properties] Properties to set
             */
            function SetGroupWholeBanResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new SetGroupWholeBanResponse instance using the specified properties.
             * @function create
             * @memberof kritor.group.SetGroupWholeBanResponse
             * @static
             * @param {kritor.group.ISetGroupWholeBanResponse=} [properties] Properties to set
             * @returns {kritor.group.SetGroupWholeBanResponse} SetGroupWholeBanResponse instance
             */
            SetGroupWholeBanResponse.create = function create(properties) {
                return new SetGroupWholeBanResponse(properties);
            };

            /**
             * Encodes the specified SetGroupWholeBanResponse message. Does not implicitly {@link kritor.group.SetGroupWholeBanResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.SetGroupWholeBanResponse
             * @static
             * @param {kritor.group.ISetGroupWholeBanResponse} message SetGroupWholeBanResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetGroupWholeBanResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified SetGroupWholeBanResponse message, length delimited. Does not implicitly {@link kritor.group.SetGroupWholeBanResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.SetGroupWholeBanResponse
             * @static
             * @param {kritor.group.ISetGroupWholeBanResponse} message SetGroupWholeBanResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetGroupWholeBanResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetGroupWholeBanResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.SetGroupWholeBanResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.SetGroupWholeBanResponse} SetGroupWholeBanResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetGroupWholeBanResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.SetGroupWholeBanResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetGroupWholeBanResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.SetGroupWholeBanResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.SetGroupWholeBanResponse} SetGroupWholeBanResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetGroupWholeBanResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetGroupWholeBanResponse message.
             * @function verify
             * @memberof kritor.group.SetGroupWholeBanResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetGroupWholeBanResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a SetGroupWholeBanResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.SetGroupWholeBanResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.SetGroupWholeBanResponse} SetGroupWholeBanResponse
             */
            SetGroupWholeBanResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.SetGroupWholeBanResponse)
                    return object;
                return new $root.kritor.group.SetGroupWholeBanResponse();
            };

            /**
             * Creates a plain object from a SetGroupWholeBanResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.SetGroupWholeBanResponse
             * @static
             * @param {kritor.group.SetGroupWholeBanResponse} message SetGroupWholeBanResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetGroupWholeBanResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this SetGroupWholeBanResponse to JSON.
             * @function toJSON
             * @memberof kritor.group.SetGroupWholeBanResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetGroupWholeBanResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetGroupWholeBanResponse
             * @function getTypeUrl
             * @memberof kritor.group.SetGroupWholeBanResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetGroupWholeBanResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.SetGroupWholeBanResponse";
            };

            return SetGroupWholeBanResponse;
        })();

        group.GetGroupInfoRequest = (function() {

            /**
             * Properties of a GetGroupInfoRequest.
             * @memberof kritor.group
             * @interface IGetGroupInfoRequest
             * @property {number|Long|null} [groupId] GetGroupInfoRequest groupId
             */

            /**
             * Constructs a new GetGroupInfoRequest.
             * @memberof kritor.group
             * @classdesc Represents a GetGroupInfoRequest.
             * @implements IGetGroupInfoRequest
             * @constructor
             * @param {kritor.group.IGetGroupInfoRequest=} [properties] Properties to set
             */
            function GetGroupInfoRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetGroupInfoRequest groupId.
             * @member {number|Long} groupId
             * @memberof kritor.group.GetGroupInfoRequest
             * @instance
             */
            GetGroupInfoRequest.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new GetGroupInfoRequest instance using the specified properties.
             * @function create
             * @memberof kritor.group.GetGroupInfoRequest
             * @static
             * @param {kritor.group.IGetGroupInfoRequest=} [properties] Properties to set
             * @returns {kritor.group.GetGroupInfoRequest} GetGroupInfoRequest instance
             */
            GetGroupInfoRequest.create = function create(properties) {
                return new GetGroupInfoRequest(properties);
            };

            /**
             * Encodes the specified GetGroupInfoRequest message. Does not implicitly {@link kritor.group.GetGroupInfoRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.GetGroupInfoRequest
             * @static
             * @param {kritor.group.IGetGroupInfoRequest} message GetGroupInfoRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGroupInfoRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                return writer;
            };

            /**
             * Encodes the specified GetGroupInfoRequest message, length delimited. Does not implicitly {@link kritor.group.GetGroupInfoRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.GetGroupInfoRequest
             * @static
             * @param {kritor.group.IGetGroupInfoRequest} message GetGroupInfoRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGroupInfoRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetGroupInfoRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.GetGroupInfoRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.GetGroupInfoRequest} GetGroupInfoRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGroupInfoRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.GetGroupInfoRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetGroupInfoRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.GetGroupInfoRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.GetGroupInfoRequest} GetGroupInfoRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGroupInfoRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetGroupInfoRequest message.
             * @function verify
             * @memberof kritor.group.GetGroupInfoRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetGroupInfoRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                return null;
            };

            /**
             * Creates a GetGroupInfoRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.GetGroupInfoRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.GetGroupInfoRequest} GetGroupInfoRequest
             */
            GetGroupInfoRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.GetGroupInfoRequest)
                    return object;
                let message = new $root.kritor.group.GetGroupInfoRequest();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a GetGroupInfoRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.GetGroupInfoRequest
             * @static
             * @param {kritor.group.GetGroupInfoRequest} message GetGroupInfoRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetGroupInfoRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                return object;
            };

            /**
             * Converts this GetGroupInfoRequest to JSON.
             * @function toJSON
             * @memberof kritor.group.GetGroupInfoRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetGroupInfoRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetGroupInfoRequest
             * @function getTypeUrl
             * @memberof kritor.group.GetGroupInfoRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetGroupInfoRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.GetGroupInfoRequest";
            };

            return GetGroupInfoRequest;
        })();

        group.GetGroupInfoResponse = (function() {

            /**
             * Properties of a GetGroupInfoResponse.
             * @memberof kritor.group
             * @interface IGetGroupInfoResponse
             * @property {kritor.group.IGroupInfo|null} [groupInfo] GetGroupInfoResponse groupInfo
             */

            /**
             * Constructs a new GetGroupInfoResponse.
             * @memberof kritor.group
             * @classdesc Represents a GetGroupInfoResponse.
             * @implements IGetGroupInfoResponse
             * @constructor
             * @param {kritor.group.IGetGroupInfoResponse=} [properties] Properties to set
             */
            function GetGroupInfoResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetGroupInfoResponse groupInfo.
             * @member {kritor.group.IGroupInfo|null|undefined} groupInfo
             * @memberof kritor.group.GetGroupInfoResponse
             * @instance
             */
            GetGroupInfoResponse.prototype.groupInfo = null;

            /**
             * Creates a new GetGroupInfoResponse instance using the specified properties.
             * @function create
             * @memberof kritor.group.GetGroupInfoResponse
             * @static
             * @param {kritor.group.IGetGroupInfoResponse=} [properties] Properties to set
             * @returns {kritor.group.GetGroupInfoResponse} GetGroupInfoResponse instance
             */
            GetGroupInfoResponse.create = function create(properties) {
                return new GetGroupInfoResponse(properties);
            };

            /**
             * Encodes the specified GetGroupInfoResponse message. Does not implicitly {@link kritor.group.GetGroupInfoResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.GetGroupInfoResponse
             * @static
             * @param {kritor.group.IGetGroupInfoResponse} message GetGroupInfoResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGroupInfoResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupInfo != null && Object.hasOwnProperty.call(message, "groupInfo"))
                    $root.kritor.group.GroupInfo.encode(message.groupInfo, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetGroupInfoResponse message, length delimited. Does not implicitly {@link kritor.group.GetGroupInfoResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.GetGroupInfoResponse
             * @static
             * @param {kritor.group.IGetGroupInfoResponse} message GetGroupInfoResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGroupInfoResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetGroupInfoResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.GetGroupInfoResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.GetGroupInfoResponse} GetGroupInfoResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGroupInfoResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.GetGroupInfoResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupInfo = $root.kritor.group.GroupInfo.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetGroupInfoResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.GetGroupInfoResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.GetGroupInfoResponse} GetGroupInfoResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGroupInfoResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetGroupInfoResponse message.
             * @function verify
             * @memberof kritor.group.GetGroupInfoResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetGroupInfoResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupInfo != null && message.hasOwnProperty("groupInfo")) {
                    let error = $root.kritor.group.GroupInfo.verify(message.groupInfo);
                    if (error)
                        return "groupInfo." + error;
                }
                return null;
            };

            /**
             * Creates a GetGroupInfoResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.GetGroupInfoResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.GetGroupInfoResponse} GetGroupInfoResponse
             */
            GetGroupInfoResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.GetGroupInfoResponse)
                    return object;
                let message = new $root.kritor.group.GetGroupInfoResponse();
                if (object.groupInfo != null) {
                    if (typeof object.groupInfo !== "object")
                        throw TypeError(".kritor.group.GetGroupInfoResponse.groupInfo: object expected");
                    message.groupInfo = $root.kritor.group.GroupInfo.fromObject(object.groupInfo);
                }
                return message;
            };

            /**
             * Creates a plain object from a GetGroupInfoResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.GetGroupInfoResponse
             * @static
             * @param {kritor.group.GetGroupInfoResponse} message GetGroupInfoResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetGroupInfoResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.groupInfo = null;
                if (message.groupInfo != null && message.hasOwnProperty("groupInfo"))
                    object.groupInfo = $root.kritor.group.GroupInfo.toObject(message.groupInfo, options);
                return object;
            };

            /**
             * Converts this GetGroupInfoResponse to JSON.
             * @function toJSON
             * @memberof kritor.group.GetGroupInfoResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetGroupInfoResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetGroupInfoResponse
             * @function getTypeUrl
             * @memberof kritor.group.GetGroupInfoResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetGroupInfoResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.GetGroupInfoResponse";
            };

            return GetGroupInfoResponse;
        })();

        group.GetGroupListRequest = (function() {

            /**
             * Properties of a GetGroupListRequest.
             * @memberof kritor.group
             * @interface IGetGroupListRequest
             * @property {boolean|null} [refresh] GetGroupListRequest refresh
             */

            /**
             * Constructs a new GetGroupListRequest.
             * @memberof kritor.group
             * @classdesc Represents a GetGroupListRequest.
             * @implements IGetGroupListRequest
             * @constructor
             * @param {kritor.group.IGetGroupListRequest=} [properties] Properties to set
             */
            function GetGroupListRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetGroupListRequest refresh.
             * @member {boolean|null|undefined} refresh
             * @memberof kritor.group.GetGroupListRequest
             * @instance
             */
            GetGroupListRequest.prototype.refresh = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * GetGroupListRequest _refresh.
             * @member {"refresh"|undefined} _refresh
             * @memberof kritor.group.GetGroupListRequest
             * @instance
             */
            Object.defineProperty(GetGroupListRequest.prototype, "_refresh", {
                get: $util.oneOfGetter($oneOfFields = ["refresh"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new GetGroupListRequest instance using the specified properties.
             * @function create
             * @memberof kritor.group.GetGroupListRequest
             * @static
             * @param {kritor.group.IGetGroupListRequest=} [properties] Properties to set
             * @returns {kritor.group.GetGroupListRequest} GetGroupListRequest instance
             */
            GetGroupListRequest.create = function create(properties) {
                return new GetGroupListRequest(properties);
            };

            /**
             * Encodes the specified GetGroupListRequest message. Does not implicitly {@link kritor.group.GetGroupListRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.GetGroupListRequest
             * @static
             * @param {kritor.group.IGetGroupListRequest} message GetGroupListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGroupListRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.refresh != null && Object.hasOwnProperty.call(message, "refresh"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.refresh);
                return writer;
            };

            /**
             * Encodes the specified GetGroupListRequest message, length delimited. Does not implicitly {@link kritor.group.GetGroupListRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.GetGroupListRequest
             * @static
             * @param {kritor.group.IGetGroupListRequest} message GetGroupListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGroupListRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetGroupListRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.GetGroupListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.GetGroupListRequest} GetGroupListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGroupListRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.GetGroupListRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.refresh = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetGroupListRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.GetGroupListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.GetGroupListRequest} GetGroupListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGroupListRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetGroupListRequest message.
             * @function verify
             * @memberof kritor.group.GetGroupListRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetGroupListRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.refresh != null && message.hasOwnProperty("refresh")) {
                    properties._refresh = 1;
                    if (typeof message.refresh !== "boolean")
                        return "refresh: boolean expected";
                }
                return null;
            };

            /**
             * Creates a GetGroupListRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.GetGroupListRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.GetGroupListRequest} GetGroupListRequest
             */
            GetGroupListRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.GetGroupListRequest)
                    return object;
                let message = new $root.kritor.group.GetGroupListRequest();
                if (object.refresh != null)
                    message.refresh = Boolean(object.refresh);
                return message;
            };

            /**
             * Creates a plain object from a GetGroupListRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.GetGroupListRequest
             * @static
             * @param {kritor.group.GetGroupListRequest} message GetGroupListRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetGroupListRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (message.refresh != null && message.hasOwnProperty("refresh")) {
                    object.refresh = message.refresh;
                    if (options.oneofs)
                        object._refresh = "refresh";
                }
                return object;
            };

            /**
             * Converts this GetGroupListRequest to JSON.
             * @function toJSON
             * @memberof kritor.group.GetGroupListRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetGroupListRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetGroupListRequest
             * @function getTypeUrl
             * @memberof kritor.group.GetGroupListRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetGroupListRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.GetGroupListRequest";
            };

            return GetGroupListRequest;
        })();

        group.GetGroupListResponse = (function() {

            /**
             * Properties of a GetGroupListResponse.
             * @memberof kritor.group
             * @interface IGetGroupListResponse
             * @property {Array.<kritor.group.IGroupInfo>|null} [groupsInfo] GetGroupListResponse groupsInfo
             */

            /**
             * Constructs a new GetGroupListResponse.
             * @memberof kritor.group
             * @classdesc Represents a GetGroupListResponse.
             * @implements IGetGroupListResponse
             * @constructor
             * @param {kritor.group.IGetGroupListResponse=} [properties] Properties to set
             */
            function GetGroupListResponse(properties) {
                this.groupsInfo = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetGroupListResponse groupsInfo.
             * @member {Array.<kritor.group.IGroupInfo>} groupsInfo
             * @memberof kritor.group.GetGroupListResponse
             * @instance
             */
            GetGroupListResponse.prototype.groupsInfo = $util.emptyArray;

            /**
             * Creates a new GetGroupListResponse instance using the specified properties.
             * @function create
             * @memberof kritor.group.GetGroupListResponse
             * @static
             * @param {kritor.group.IGetGroupListResponse=} [properties] Properties to set
             * @returns {kritor.group.GetGroupListResponse} GetGroupListResponse instance
             */
            GetGroupListResponse.create = function create(properties) {
                return new GetGroupListResponse(properties);
            };

            /**
             * Encodes the specified GetGroupListResponse message. Does not implicitly {@link kritor.group.GetGroupListResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.GetGroupListResponse
             * @static
             * @param {kritor.group.IGetGroupListResponse} message GetGroupListResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGroupListResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupsInfo != null && message.groupsInfo.length)
                    for (let i = 0; i < message.groupsInfo.length; ++i)
                        $root.kritor.group.GroupInfo.encode(message.groupsInfo[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetGroupListResponse message, length delimited. Does not implicitly {@link kritor.group.GetGroupListResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.GetGroupListResponse
             * @static
             * @param {kritor.group.IGetGroupListResponse} message GetGroupListResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGroupListResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetGroupListResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.GetGroupListResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.GetGroupListResponse} GetGroupListResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGroupListResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.GetGroupListResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.groupsInfo && message.groupsInfo.length))
                                message.groupsInfo = [];
                            message.groupsInfo.push($root.kritor.group.GroupInfo.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetGroupListResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.GetGroupListResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.GetGroupListResponse} GetGroupListResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGroupListResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetGroupListResponse message.
             * @function verify
             * @memberof kritor.group.GetGroupListResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetGroupListResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupsInfo != null && message.hasOwnProperty("groupsInfo")) {
                    if (!Array.isArray(message.groupsInfo))
                        return "groupsInfo: array expected";
                    for (let i = 0; i < message.groupsInfo.length; ++i) {
                        let error = $root.kritor.group.GroupInfo.verify(message.groupsInfo[i]);
                        if (error)
                            return "groupsInfo." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a GetGroupListResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.GetGroupListResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.GetGroupListResponse} GetGroupListResponse
             */
            GetGroupListResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.GetGroupListResponse)
                    return object;
                let message = new $root.kritor.group.GetGroupListResponse();
                if (object.groupsInfo) {
                    if (!Array.isArray(object.groupsInfo))
                        throw TypeError(".kritor.group.GetGroupListResponse.groupsInfo: array expected");
                    message.groupsInfo = [];
                    for (let i = 0; i < object.groupsInfo.length; ++i) {
                        if (typeof object.groupsInfo[i] !== "object")
                            throw TypeError(".kritor.group.GetGroupListResponse.groupsInfo: object expected");
                        message.groupsInfo[i] = $root.kritor.group.GroupInfo.fromObject(object.groupsInfo[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a GetGroupListResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.GetGroupListResponse
             * @static
             * @param {kritor.group.GetGroupListResponse} message GetGroupListResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetGroupListResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.groupsInfo = [];
                if (message.groupsInfo && message.groupsInfo.length) {
                    object.groupsInfo = [];
                    for (let j = 0; j < message.groupsInfo.length; ++j)
                        object.groupsInfo[j] = $root.kritor.group.GroupInfo.toObject(message.groupsInfo[j], options);
                }
                return object;
            };

            /**
             * Converts this GetGroupListResponse to JSON.
             * @function toJSON
             * @memberof kritor.group.GetGroupListResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetGroupListResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetGroupListResponse
             * @function getTypeUrl
             * @memberof kritor.group.GetGroupListResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetGroupListResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.GetGroupListResponse";
            };

            return GetGroupListResponse;
        })();

        group.GetGroupMemberInfoRequest = (function() {

            /**
             * Properties of a GetGroupMemberInfoRequest.
             * @memberof kritor.group
             * @interface IGetGroupMemberInfoRequest
             * @property {number|Long|null} [groupId] GetGroupMemberInfoRequest groupId
             * @property {string|null} [targetUid] GetGroupMemberInfoRequest targetUid
             * @property {number|Long|null} [targetUin] GetGroupMemberInfoRequest targetUin
             * @property {boolean|null} [refresh] GetGroupMemberInfoRequest refresh
             */

            /**
             * Constructs a new GetGroupMemberInfoRequest.
             * @memberof kritor.group
             * @classdesc Represents a GetGroupMemberInfoRequest.
             * @implements IGetGroupMemberInfoRequest
             * @constructor
             * @param {kritor.group.IGetGroupMemberInfoRequest=} [properties] Properties to set
             */
            function GetGroupMemberInfoRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetGroupMemberInfoRequest groupId.
             * @member {number|Long} groupId
             * @memberof kritor.group.GetGroupMemberInfoRequest
             * @instance
             */
            GetGroupMemberInfoRequest.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GetGroupMemberInfoRequest targetUid.
             * @member {string|null|undefined} targetUid
             * @memberof kritor.group.GetGroupMemberInfoRequest
             * @instance
             */
            GetGroupMemberInfoRequest.prototype.targetUid = null;

            /**
             * GetGroupMemberInfoRequest targetUin.
             * @member {number|Long|null|undefined} targetUin
             * @memberof kritor.group.GetGroupMemberInfoRequest
             * @instance
             */
            GetGroupMemberInfoRequest.prototype.targetUin = null;

            /**
             * GetGroupMemberInfoRequest refresh.
             * @member {boolean|null|undefined} refresh
             * @memberof kritor.group.GetGroupMemberInfoRequest
             * @instance
             */
            GetGroupMemberInfoRequest.prototype.refresh = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * GetGroupMemberInfoRequest target.
             * @member {"targetUid"|"targetUin"|undefined} target
             * @memberof kritor.group.GetGroupMemberInfoRequest
             * @instance
             */
            Object.defineProperty(GetGroupMemberInfoRequest.prototype, "target", {
                get: $util.oneOfGetter($oneOfFields = ["targetUid", "targetUin"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * GetGroupMemberInfoRequest _refresh.
             * @member {"refresh"|undefined} _refresh
             * @memberof kritor.group.GetGroupMemberInfoRequest
             * @instance
             */
            Object.defineProperty(GetGroupMemberInfoRequest.prototype, "_refresh", {
                get: $util.oneOfGetter($oneOfFields = ["refresh"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new GetGroupMemberInfoRequest instance using the specified properties.
             * @function create
             * @memberof kritor.group.GetGroupMemberInfoRequest
             * @static
             * @param {kritor.group.IGetGroupMemberInfoRequest=} [properties] Properties to set
             * @returns {kritor.group.GetGroupMemberInfoRequest} GetGroupMemberInfoRequest instance
             */
            GetGroupMemberInfoRequest.create = function create(properties) {
                return new GetGroupMemberInfoRequest(properties);
            };

            /**
             * Encodes the specified GetGroupMemberInfoRequest message. Does not implicitly {@link kritor.group.GetGroupMemberInfoRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.GetGroupMemberInfoRequest
             * @static
             * @param {kritor.group.IGetGroupMemberInfoRequest} message GetGroupMemberInfoRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGroupMemberInfoRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                if (message.targetUid != null && Object.hasOwnProperty.call(message, "targetUid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.targetUid);
                if (message.targetUin != null && Object.hasOwnProperty.call(message, "targetUin"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.targetUin);
                if (message.refresh != null && Object.hasOwnProperty.call(message, "refresh"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.refresh);
                return writer;
            };

            /**
             * Encodes the specified GetGroupMemberInfoRequest message, length delimited. Does not implicitly {@link kritor.group.GetGroupMemberInfoRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.GetGroupMemberInfoRequest
             * @static
             * @param {kritor.group.IGetGroupMemberInfoRequest} message GetGroupMemberInfoRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGroupMemberInfoRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetGroupMemberInfoRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.GetGroupMemberInfoRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.GetGroupMemberInfoRequest} GetGroupMemberInfoRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGroupMemberInfoRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.GetGroupMemberInfoRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.targetUid = reader.string();
                            break;
                        }
                    case 3: {
                            message.targetUin = reader.uint64();
                            break;
                        }
                    case 4: {
                            message.refresh = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetGroupMemberInfoRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.GetGroupMemberInfoRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.GetGroupMemberInfoRequest} GetGroupMemberInfoRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGroupMemberInfoRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetGroupMemberInfoRequest message.
             * @function verify
             * @memberof kritor.group.GetGroupMemberInfoRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetGroupMemberInfoRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                if (message.targetUid != null && message.hasOwnProperty("targetUid")) {
                    properties.target = 1;
                    if (!$util.isString(message.targetUid))
                        return "targetUid: string expected";
                }
                if (message.targetUin != null && message.hasOwnProperty("targetUin")) {
                    if (properties.target === 1)
                        return "target: multiple values";
                    properties.target = 1;
                    if (!$util.isInteger(message.targetUin) && !(message.targetUin && $util.isInteger(message.targetUin.low) && $util.isInteger(message.targetUin.high)))
                        return "targetUin: integer|Long expected";
                }
                if (message.refresh != null && message.hasOwnProperty("refresh")) {
                    properties._refresh = 1;
                    if (typeof message.refresh !== "boolean")
                        return "refresh: boolean expected";
                }
                return null;
            };

            /**
             * Creates a GetGroupMemberInfoRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.GetGroupMemberInfoRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.GetGroupMemberInfoRequest} GetGroupMemberInfoRequest
             */
            GetGroupMemberInfoRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.GetGroupMemberInfoRequest)
                    return object;
                let message = new $root.kritor.group.GetGroupMemberInfoRequest();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                if (object.targetUid != null)
                    message.targetUid = String(object.targetUid);
                if (object.targetUin != null)
                    if ($util.Long)
                        (message.targetUin = $util.Long.fromValue(object.targetUin)).unsigned = true;
                    else if (typeof object.targetUin === "string")
                        message.targetUin = parseInt(object.targetUin, 10);
                    else if (typeof object.targetUin === "number")
                        message.targetUin = object.targetUin;
                    else if (typeof object.targetUin === "object")
                        message.targetUin = new $util.LongBits(object.targetUin.low >>> 0, object.targetUin.high >>> 0).toNumber(true);
                if (object.refresh != null)
                    message.refresh = Boolean(object.refresh);
                return message;
            };

            /**
             * Creates a plain object from a GetGroupMemberInfoRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.GetGroupMemberInfoRequest
             * @static
             * @param {kritor.group.GetGroupMemberInfoRequest} message GetGroupMemberInfoRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetGroupMemberInfoRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                if (message.targetUid != null && message.hasOwnProperty("targetUid")) {
                    object.targetUid = message.targetUid;
                    if (options.oneofs)
                        object.target = "targetUid";
                }
                if (message.targetUin != null && message.hasOwnProperty("targetUin")) {
                    if (typeof message.targetUin === "number")
                        object.targetUin = options.longs === String ? String(message.targetUin) : message.targetUin;
                    else
                        object.targetUin = options.longs === String ? $util.Long.prototype.toString.call(message.targetUin) : options.longs === Number ? new $util.LongBits(message.targetUin.low >>> 0, message.targetUin.high >>> 0).toNumber(true) : message.targetUin;
                    if (options.oneofs)
                        object.target = "targetUin";
                }
                if (message.refresh != null && message.hasOwnProperty("refresh")) {
                    object.refresh = message.refresh;
                    if (options.oneofs)
                        object._refresh = "refresh";
                }
                return object;
            };

            /**
             * Converts this GetGroupMemberInfoRequest to JSON.
             * @function toJSON
             * @memberof kritor.group.GetGroupMemberInfoRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetGroupMemberInfoRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetGroupMemberInfoRequest
             * @function getTypeUrl
             * @memberof kritor.group.GetGroupMemberInfoRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetGroupMemberInfoRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.GetGroupMemberInfoRequest";
            };

            return GetGroupMemberInfoRequest;
        })();

        group.GetGroupMemberInfoResponse = (function() {

            /**
             * Properties of a GetGroupMemberInfoResponse.
             * @memberof kritor.group
             * @interface IGetGroupMemberInfoResponse
             * @property {kritor.group.IGroupMemberInfo|null} [groupMemberInfo] GetGroupMemberInfoResponse groupMemberInfo
             */

            /**
             * Constructs a new GetGroupMemberInfoResponse.
             * @memberof kritor.group
             * @classdesc Represents a GetGroupMemberInfoResponse.
             * @implements IGetGroupMemberInfoResponse
             * @constructor
             * @param {kritor.group.IGetGroupMemberInfoResponse=} [properties] Properties to set
             */
            function GetGroupMemberInfoResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetGroupMemberInfoResponse groupMemberInfo.
             * @member {kritor.group.IGroupMemberInfo|null|undefined} groupMemberInfo
             * @memberof kritor.group.GetGroupMemberInfoResponse
             * @instance
             */
            GetGroupMemberInfoResponse.prototype.groupMemberInfo = null;

            /**
             * Creates a new GetGroupMemberInfoResponse instance using the specified properties.
             * @function create
             * @memberof kritor.group.GetGroupMemberInfoResponse
             * @static
             * @param {kritor.group.IGetGroupMemberInfoResponse=} [properties] Properties to set
             * @returns {kritor.group.GetGroupMemberInfoResponse} GetGroupMemberInfoResponse instance
             */
            GetGroupMemberInfoResponse.create = function create(properties) {
                return new GetGroupMemberInfoResponse(properties);
            };

            /**
             * Encodes the specified GetGroupMemberInfoResponse message. Does not implicitly {@link kritor.group.GetGroupMemberInfoResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.GetGroupMemberInfoResponse
             * @static
             * @param {kritor.group.IGetGroupMemberInfoResponse} message GetGroupMemberInfoResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGroupMemberInfoResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupMemberInfo != null && Object.hasOwnProperty.call(message, "groupMemberInfo"))
                    $root.kritor.group.GroupMemberInfo.encode(message.groupMemberInfo, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetGroupMemberInfoResponse message, length delimited. Does not implicitly {@link kritor.group.GetGroupMemberInfoResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.GetGroupMemberInfoResponse
             * @static
             * @param {kritor.group.IGetGroupMemberInfoResponse} message GetGroupMemberInfoResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGroupMemberInfoResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetGroupMemberInfoResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.GetGroupMemberInfoResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.GetGroupMemberInfoResponse} GetGroupMemberInfoResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGroupMemberInfoResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.GetGroupMemberInfoResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupMemberInfo = $root.kritor.group.GroupMemberInfo.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetGroupMemberInfoResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.GetGroupMemberInfoResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.GetGroupMemberInfoResponse} GetGroupMemberInfoResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGroupMemberInfoResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetGroupMemberInfoResponse message.
             * @function verify
             * @memberof kritor.group.GetGroupMemberInfoResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetGroupMemberInfoResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupMemberInfo != null && message.hasOwnProperty("groupMemberInfo")) {
                    let error = $root.kritor.group.GroupMemberInfo.verify(message.groupMemberInfo);
                    if (error)
                        return "groupMemberInfo." + error;
                }
                return null;
            };

            /**
             * Creates a GetGroupMemberInfoResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.GetGroupMemberInfoResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.GetGroupMemberInfoResponse} GetGroupMemberInfoResponse
             */
            GetGroupMemberInfoResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.GetGroupMemberInfoResponse)
                    return object;
                let message = new $root.kritor.group.GetGroupMemberInfoResponse();
                if (object.groupMemberInfo != null) {
                    if (typeof object.groupMemberInfo !== "object")
                        throw TypeError(".kritor.group.GetGroupMemberInfoResponse.groupMemberInfo: object expected");
                    message.groupMemberInfo = $root.kritor.group.GroupMemberInfo.fromObject(object.groupMemberInfo);
                }
                return message;
            };

            /**
             * Creates a plain object from a GetGroupMemberInfoResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.GetGroupMemberInfoResponse
             * @static
             * @param {kritor.group.GetGroupMemberInfoResponse} message GetGroupMemberInfoResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetGroupMemberInfoResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.groupMemberInfo = null;
                if (message.groupMemberInfo != null && message.hasOwnProperty("groupMemberInfo"))
                    object.groupMemberInfo = $root.kritor.group.GroupMemberInfo.toObject(message.groupMemberInfo, options);
                return object;
            };

            /**
             * Converts this GetGroupMemberInfoResponse to JSON.
             * @function toJSON
             * @memberof kritor.group.GetGroupMemberInfoResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetGroupMemberInfoResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetGroupMemberInfoResponse
             * @function getTypeUrl
             * @memberof kritor.group.GetGroupMemberInfoResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetGroupMemberInfoResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.GetGroupMemberInfoResponse";
            };

            return GetGroupMemberInfoResponse;
        })();

        group.GetGroupMemberListRequest = (function() {

            /**
             * Properties of a GetGroupMemberListRequest.
             * @memberof kritor.group
             * @interface IGetGroupMemberListRequest
             * @property {number|Long|null} [groupId] GetGroupMemberListRequest groupId
             * @property {boolean|null} [refresh] GetGroupMemberListRequest refresh
             */

            /**
             * Constructs a new GetGroupMemberListRequest.
             * @memberof kritor.group
             * @classdesc Represents a GetGroupMemberListRequest.
             * @implements IGetGroupMemberListRequest
             * @constructor
             * @param {kritor.group.IGetGroupMemberListRequest=} [properties] Properties to set
             */
            function GetGroupMemberListRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetGroupMemberListRequest groupId.
             * @member {number|Long} groupId
             * @memberof kritor.group.GetGroupMemberListRequest
             * @instance
             */
            GetGroupMemberListRequest.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GetGroupMemberListRequest refresh.
             * @member {boolean|null|undefined} refresh
             * @memberof kritor.group.GetGroupMemberListRequest
             * @instance
             */
            GetGroupMemberListRequest.prototype.refresh = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * GetGroupMemberListRequest _refresh.
             * @member {"refresh"|undefined} _refresh
             * @memberof kritor.group.GetGroupMemberListRequest
             * @instance
             */
            Object.defineProperty(GetGroupMemberListRequest.prototype, "_refresh", {
                get: $util.oneOfGetter($oneOfFields = ["refresh"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new GetGroupMemberListRequest instance using the specified properties.
             * @function create
             * @memberof kritor.group.GetGroupMemberListRequest
             * @static
             * @param {kritor.group.IGetGroupMemberListRequest=} [properties] Properties to set
             * @returns {kritor.group.GetGroupMemberListRequest} GetGroupMemberListRequest instance
             */
            GetGroupMemberListRequest.create = function create(properties) {
                return new GetGroupMemberListRequest(properties);
            };

            /**
             * Encodes the specified GetGroupMemberListRequest message. Does not implicitly {@link kritor.group.GetGroupMemberListRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.GetGroupMemberListRequest
             * @static
             * @param {kritor.group.IGetGroupMemberListRequest} message GetGroupMemberListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGroupMemberListRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                if (message.refresh != null && Object.hasOwnProperty.call(message, "refresh"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.refresh);
                return writer;
            };

            /**
             * Encodes the specified GetGroupMemberListRequest message, length delimited. Does not implicitly {@link kritor.group.GetGroupMemberListRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.GetGroupMemberListRequest
             * @static
             * @param {kritor.group.IGetGroupMemberListRequest} message GetGroupMemberListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGroupMemberListRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetGroupMemberListRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.GetGroupMemberListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.GetGroupMemberListRequest} GetGroupMemberListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGroupMemberListRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.GetGroupMemberListRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.refresh = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetGroupMemberListRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.GetGroupMemberListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.GetGroupMemberListRequest} GetGroupMemberListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGroupMemberListRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetGroupMemberListRequest message.
             * @function verify
             * @memberof kritor.group.GetGroupMemberListRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetGroupMemberListRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                if (message.refresh != null && message.hasOwnProperty("refresh")) {
                    properties._refresh = 1;
                    if (typeof message.refresh !== "boolean")
                        return "refresh: boolean expected";
                }
                return null;
            };

            /**
             * Creates a GetGroupMemberListRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.GetGroupMemberListRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.GetGroupMemberListRequest} GetGroupMemberListRequest
             */
            GetGroupMemberListRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.GetGroupMemberListRequest)
                    return object;
                let message = new $root.kritor.group.GetGroupMemberListRequest();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                if (object.refresh != null)
                    message.refresh = Boolean(object.refresh);
                return message;
            };

            /**
             * Creates a plain object from a GetGroupMemberListRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.GetGroupMemberListRequest
             * @static
             * @param {kritor.group.GetGroupMemberListRequest} message GetGroupMemberListRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetGroupMemberListRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                if (message.refresh != null && message.hasOwnProperty("refresh")) {
                    object.refresh = message.refresh;
                    if (options.oneofs)
                        object._refresh = "refresh";
                }
                return object;
            };

            /**
             * Converts this GetGroupMemberListRequest to JSON.
             * @function toJSON
             * @memberof kritor.group.GetGroupMemberListRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetGroupMemberListRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetGroupMemberListRequest
             * @function getTypeUrl
             * @memberof kritor.group.GetGroupMemberListRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetGroupMemberListRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.GetGroupMemberListRequest";
            };

            return GetGroupMemberListRequest;
        })();

        group.GetGroupMemberListResponse = (function() {

            /**
             * Properties of a GetGroupMemberListResponse.
             * @memberof kritor.group
             * @interface IGetGroupMemberListResponse
             * @property {Array.<kritor.group.IGroupMemberInfo>|null} [groupMembersInfo] GetGroupMemberListResponse groupMembersInfo
             */

            /**
             * Constructs a new GetGroupMemberListResponse.
             * @memberof kritor.group
             * @classdesc Represents a GetGroupMemberListResponse.
             * @implements IGetGroupMemberListResponse
             * @constructor
             * @param {kritor.group.IGetGroupMemberListResponse=} [properties] Properties to set
             */
            function GetGroupMemberListResponse(properties) {
                this.groupMembersInfo = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetGroupMemberListResponse groupMembersInfo.
             * @member {Array.<kritor.group.IGroupMemberInfo>} groupMembersInfo
             * @memberof kritor.group.GetGroupMemberListResponse
             * @instance
             */
            GetGroupMemberListResponse.prototype.groupMembersInfo = $util.emptyArray;

            /**
             * Creates a new GetGroupMemberListResponse instance using the specified properties.
             * @function create
             * @memberof kritor.group.GetGroupMemberListResponse
             * @static
             * @param {kritor.group.IGetGroupMemberListResponse=} [properties] Properties to set
             * @returns {kritor.group.GetGroupMemberListResponse} GetGroupMemberListResponse instance
             */
            GetGroupMemberListResponse.create = function create(properties) {
                return new GetGroupMemberListResponse(properties);
            };

            /**
             * Encodes the specified GetGroupMemberListResponse message. Does not implicitly {@link kritor.group.GetGroupMemberListResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.GetGroupMemberListResponse
             * @static
             * @param {kritor.group.IGetGroupMemberListResponse} message GetGroupMemberListResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGroupMemberListResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupMembersInfo != null && message.groupMembersInfo.length)
                    for (let i = 0; i < message.groupMembersInfo.length; ++i)
                        $root.kritor.group.GroupMemberInfo.encode(message.groupMembersInfo[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetGroupMemberListResponse message, length delimited. Does not implicitly {@link kritor.group.GetGroupMemberListResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.GetGroupMemberListResponse
             * @static
             * @param {kritor.group.IGetGroupMemberListResponse} message GetGroupMemberListResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGroupMemberListResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetGroupMemberListResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.GetGroupMemberListResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.GetGroupMemberListResponse} GetGroupMemberListResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGroupMemberListResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.GetGroupMemberListResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.groupMembersInfo && message.groupMembersInfo.length))
                                message.groupMembersInfo = [];
                            message.groupMembersInfo.push($root.kritor.group.GroupMemberInfo.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetGroupMemberListResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.GetGroupMemberListResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.GetGroupMemberListResponse} GetGroupMemberListResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGroupMemberListResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetGroupMemberListResponse message.
             * @function verify
             * @memberof kritor.group.GetGroupMemberListResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetGroupMemberListResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupMembersInfo != null && message.hasOwnProperty("groupMembersInfo")) {
                    if (!Array.isArray(message.groupMembersInfo))
                        return "groupMembersInfo: array expected";
                    for (let i = 0; i < message.groupMembersInfo.length; ++i) {
                        let error = $root.kritor.group.GroupMemberInfo.verify(message.groupMembersInfo[i]);
                        if (error)
                            return "groupMembersInfo." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a GetGroupMemberListResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.GetGroupMemberListResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.GetGroupMemberListResponse} GetGroupMemberListResponse
             */
            GetGroupMemberListResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.GetGroupMemberListResponse)
                    return object;
                let message = new $root.kritor.group.GetGroupMemberListResponse();
                if (object.groupMembersInfo) {
                    if (!Array.isArray(object.groupMembersInfo))
                        throw TypeError(".kritor.group.GetGroupMemberListResponse.groupMembersInfo: array expected");
                    message.groupMembersInfo = [];
                    for (let i = 0; i < object.groupMembersInfo.length; ++i) {
                        if (typeof object.groupMembersInfo[i] !== "object")
                            throw TypeError(".kritor.group.GetGroupMemberListResponse.groupMembersInfo: object expected");
                        message.groupMembersInfo[i] = $root.kritor.group.GroupMemberInfo.fromObject(object.groupMembersInfo[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a GetGroupMemberListResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.GetGroupMemberListResponse
             * @static
             * @param {kritor.group.GetGroupMemberListResponse} message GetGroupMemberListResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetGroupMemberListResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.groupMembersInfo = [];
                if (message.groupMembersInfo && message.groupMembersInfo.length) {
                    object.groupMembersInfo = [];
                    for (let j = 0; j < message.groupMembersInfo.length; ++j)
                        object.groupMembersInfo[j] = $root.kritor.group.GroupMemberInfo.toObject(message.groupMembersInfo[j], options);
                }
                return object;
            };

            /**
             * Converts this GetGroupMemberListResponse to JSON.
             * @function toJSON
             * @memberof kritor.group.GetGroupMemberListResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetGroupMemberListResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetGroupMemberListResponse
             * @function getTypeUrl
             * @memberof kritor.group.GetGroupMemberListResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetGroupMemberListResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.GetGroupMemberListResponse";
            };

            return GetGroupMemberListResponse;
        })();

        group.GetProhibitedUserListRequest = (function() {

            /**
             * Properties of a GetProhibitedUserListRequest.
             * @memberof kritor.group
             * @interface IGetProhibitedUserListRequest
             * @property {number|Long|null} [groupId] GetProhibitedUserListRequest groupId
             */

            /**
             * Constructs a new GetProhibitedUserListRequest.
             * @memberof kritor.group
             * @classdesc Represents a GetProhibitedUserListRequest.
             * @implements IGetProhibitedUserListRequest
             * @constructor
             * @param {kritor.group.IGetProhibitedUserListRequest=} [properties] Properties to set
             */
            function GetProhibitedUserListRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetProhibitedUserListRequest groupId.
             * @member {number|Long} groupId
             * @memberof kritor.group.GetProhibitedUserListRequest
             * @instance
             */
            GetProhibitedUserListRequest.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new GetProhibitedUserListRequest instance using the specified properties.
             * @function create
             * @memberof kritor.group.GetProhibitedUserListRequest
             * @static
             * @param {kritor.group.IGetProhibitedUserListRequest=} [properties] Properties to set
             * @returns {kritor.group.GetProhibitedUserListRequest} GetProhibitedUserListRequest instance
             */
            GetProhibitedUserListRequest.create = function create(properties) {
                return new GetProhibitedUserListRequest(properties);
            };

            /**
             * Encodes the specified GetProhibitedUserListRequest message. Does not implicitly {@link kritor.group.GetProhibitedUserListRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.GetProhibitedUserListRequest
             * @static
             * @param {kritor.group.IGetProhibitedUserListRequest} message GetProhibitedUserListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetProhibitedUserListRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                return writer;
            };

            /**
             * Encodes the specified GetProhibitedUserListRequest message, length delimited. Does not implicitly {@link kritor.group.GetProhibitedUserListRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.GetProhibitedUserListRequest
             * @static
             * @param {kritor.group.IGetProhibitedUserListRequest} message GetProhibitedUserListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetProhibitedUserListRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetProhibitedUserListRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.GetProhibitedUserListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.GetProhibitedUserListRequest} GetProhibitedUserListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetProhibitedUserListRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.GetProhibitedUserListRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetProhibitedUserListRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.GetProhibitedUserListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.GetProhibitedUserListRequest} GetProhibitedUserListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetProhibitedUserListRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetProhibitedUserListRequest message.
             * @function verify
             * @memberof kritor.group.GetProhibitedUserListRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetProhibitedUserListRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                return null;
            };

            /**
             * Creates a GetProhibitedUserListRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.GetProhibitedUserListRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.GetProhibitedUserListRequest} GetProhibitedUserListRequest
             */
            GetProhibitedUserListRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.GetProhibitedUserListRequest)
                    return object;
                let message = new $root.kritor.group.GetProhibitedUserListRequest();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a GetProhibitedUserListRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.GetProhibitedUserListRequest
             * @static
             * @param {kritor.group.GetProhibitedUserListRequest} message GetProhibitedUserListRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetProhibitedUserListRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                return object;
            };

            /**
             * Converts this GetProhibitedUserListRequest to JSON.
             * @function toJSON
             * @memberof kritor.group.GetProhibitedUserListRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetProhibitedUserListRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetProhibitedUserListRequest
             * @function getTypeUrl
             * @memberof kritor.group.GetProhibitedUserListRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetProhibitedUserListRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.GetProhibitedUserListRequest";
            };

            return GetProhibitedUserListRequest;
        })();

        group.GetProhibitedUserListResponse = (function() {

            /**
             * Properties of a GetProhibitedUserListResponse.
             * @memberof kritor.group
             * @interface IGetProhibitedUserListResponse
             * @property {Array.<kritor.group.IProhibitedUserInfo>|null} [prohibitedUsersInfo] GetProhibitedUserListResponse prohibitedUsersInfo
             */

            /**
             * Constructs a new GetProhibitedUserListResponse.
             * @memberof kritor.group
             * @classdesc Represents a GetProhibitedUserListResponse.
             * @implements IGetProhibitedUserListResponse
             * @constructor
             * @param {kritor.group.IGetProhibitedUserListResponse=} [properties] Properties to set
             */
            function GetProhibitedUserListResponse(properties) {
                this.prohibitedUsersInfo = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetProhibitedUserListResponse prohibitedUsersInfo.
             * @member {Array.<kritor.group.IProhibitedUserInfo>} prohibitedUsersInfo
             * @memberof kritor.group.GetProhibitedUserListResponse
             * @instance
             */
            GetProhibitedUserListResponse.prototype.prohibitedUsersInfo = $util.emptyArray;

            /**
             * Creates a new GetProhibitedUserListResponse instance using the specified properties.
             * @function create
             * @memberof kritor.group.GetProhibitedUserListResponse
             * @static
             * @param {kritor.group.IGetProhibitedUserListResponse=} [properties] Properties to set
             * @returns {kritor.group.GetProhibitedUserListResponse} GetProhibitedUserListResponse instance
             */
            GetProhibitedUserListResponse.create = function create(properties) {
                return new GetProhibitedUserListResponse(properties);
            };

            /**
             * Encodes the specified GetProhibitedUserListResponse message. Does not implicitly {@link kritor.group.GetProhibitedUserListResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.GetProhibitedUserListResponse
             * @static
             * @param {kritor.group.IGetProhibitedUserListResponse} message GetProhibitedUserListResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetProhibitedUserListResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.prohibitedUsersInfo != null && message.prohibitedUsersInfo.length)
                    for (let i = 0; i < message.prohibitedUsersInfo.length; ++i)
                        $root.kritor.group.ProhibitedUserInfo.encode(message.prohibitedUsersInfo[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetProhibitedUserListResponse message, length delimited. Does not implicitly {@link kritor.group.GetProhibitedUserListResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.GetProhibitedUserListResponse
             * @static
             * @param {kritor.group.IGetProhibitedUserListResponse} message GetProhibitedUserListResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetProhibitedUserListResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetProhibitedUserListResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.GetProhibitedUserListResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.GetProhibitedUserListResponse} GetProhibitedUserListResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetProhibitedUserListResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.GetProhibitedUserListResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.prohibitedUsersInfo && message.prohibitedUsersInfo.length))
                                message.prohibitedUsersInfo = [];
                            message.prohibitedUsersInfo.push($root.kritor.group.ProhibitedUserInfo.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetProhibitedUserListResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.GetProhibitedUserListResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.GetProhibitedUserListResponse} GetProhibitedUserListResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetProhibitedUserListResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetProhibitedUserListResponse message.
             * @function verify
             * @memberof kritor.group.GetProhibitedUserListResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetProhibitedUserListResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.prohibitedUsersInfo != null && message.hasOwnProperty("prohibitedUsersInfo")) {
                    if (!Array.isArray(message.prohibitedUsersInfo))
                        return "prohibitedUsersInfo: array expected";
                    for (let i = 0; i < message.prohibitedUsersInfo.length; ++i) {
                        let error = $root.kritor.group.ProhibitedUserInfo.verify(message.prohibitedUsersInfo[i]);
                        if (error)
                            return "prohibitedUsersInfo." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a GetProhibitedUserListResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.GetProhibitedUserListResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.GetProhibitedUserListResponse} GetProhibitedUserListResponse
             */
            GetProhibitedUserListResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.GetProhibitedUserListResponse)
                    return object;
                let message = new $root.kritor.group.GetProhibitedUserListResponse();
                if (object.prohibitedUsersInfo) {
                    if (!Array.isArray(object.prohibitedUsersInfo))
                        throw TypeError(".kritor.group.GetProhibitedUserListResponse.prohibitedUsersInfo: array expected");
                    message.prohibitedUsersInfo = [];
                    for (let i = 0; i < object.prohibitedUsersInfo.length; ++i) {
                        if (typeof object.prohibitedUsersInfo[i] !== "object")
                            throw TypeError(".kritor.group.GetProhibitedUserListResponse.prohibitedUsersInfo: object expected");
                        message.prohibitedUsersInfo[i] = $root.kritor.group.ProhibitedUserInfo.fromObject(object.prohibitedUsersInfo[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a GetProhibitedUserListResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.GetProhibitedUserListResponse
             * @static
             * @param {kritor.group.GetProhibitedUserListResponse} message GetProhibitedUserListResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetProhibitedUserListResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.prohibitedUsersInfo = [];
                if (message.prohibitedUsersInfo && message.prohibitedUsersInfo.length) {
                    object.prohibitedUsersInfo = [];
                    for (let j = 0; j < message.prohibitedUsersInfo.length; ++j)
                        object.prohibitedUsersInfo[j] = $root.kritor.group.ProhibitedUserInfo.toObject(message.prohibitedUsersInfo[j], options);
                }
                return object;
            };

            /**
             * Converts this GetProhibitedUserListResponse to JSON.
             * @function toJSON
             * @memberof kritor.group.GetProhibitedUserListResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetProhibitedUserListResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetProhibitedUserListResponse
             * @function getTypeUrl
             * @memberof kritor.group.GetProhibitedUserListResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetProhibitedUserListResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.GetProhibitedUserListResponse";
            };

            return GetProhibitedUserListResponse;
        })();

        group.GetRemainCountAtAllRequest = (function() {

            /**
             * Properties of a GetRemainCountAtAllRequest.
             * @memberof kritor.group
             * @interface IGetRemainCountAtAllRequest
             * @property {number|Long|null} [groupId] GetRemainCountAtAllRequest groupId
             */

            /**
             * Constructs a new GetRemainCountAtAllRequest.
             * @memberof kritor.group
             * @classdesc Represents a GetRemainCountAtAllRequest.
             * @implements IGetRemainCountAtAllRequest
             * @constructor
             * @param {kritor.group.IGetRemainCountAtAllRequest=} [properties] Properties to set
             */
            function GetRemainCountAtAllRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetRemainCountAtAllRequest groupId.
             * @member {number|Long} groupId
             * @memberof kritor.group.GetRemainCountAtAllRequest
             * @instance
             */
            GetRemainCountAtAllRequest.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new GetRemainCountAtAllRequest instance using the specified properties.
             * @function create
             * @memberof kritor.group.GetRemainCountAtAllRequest
             * @static
             * @param {kritor.group.IGetRemainCountAtAllRequest=} [properties] Properties to set
             * @returns {kritor.group.GetRemainCountAtAllRequest} GetRemainCountAtAllRequest instance
             */
            GetRemainCountAtAllRequest.create = function create(properties) {
                return new GetRemainCountAtAllRequest(properties);
            };

            /**
             * Encodes the specified GetRemainCountAtAllRequest message. Does not implicitly {@link kritor.group.GetRemainCountAtAllRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.GetRemainCountAtAllRequest
             * @static
             * @param {kritor.group.IGetRemainCountAtAllRequest} message GetRemainCountAtAllRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetRemainCountAtAllRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                return writer;
            };

            /**
             * Encodes the specified GetRemainCountAtAllRequest message, length delimited. Does not implicitly {@link kritor.group.GetRemainCountAtAllRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.GetRemainCountAtAllRequest
             * @static
             * @param {kritor.group.IGetRemainCountAtAllRequest} message GetRemainCountAtAllRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetRemainCountAtAllRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetRemainCountAtAllRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.GetRemainCountAtAllRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.GetRemainCountAtAllRequest} GetRemainCountAtAllRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetRemainCountAtAllRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.GetRemainCountAtAllRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetRemainCountAtAllRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.GetRemainCountAtAllRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.GetRemainCountAtAllRequest} GetRemainCountAtAllRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetRemainCountAtAllRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetRemainCountAtAllRequest message.
             * @function verify
             * @memberof kritor.group.GetRemainCountAtAllRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetRemainCountAtAllRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                return null;
            };

            /**
             * Creates a GetRemainCountAtAllRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.GetRemainCountAtAllRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.GetRemainCountAtAllRequest} GetRemainCountAtAllRequest
             */
            GetRemainCountAtAllRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.GetRemainCountAtAllRequest)
                    return object;
                let message = new $root.kritor.group.GetRemainCountAtAllRequest();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a GetRemainCountAtAllRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.GetRemainCountAtAllRequest
             * @static
             * @param {kritor.group.GetRemainCountAtAllRequest} message GetRemainCountAtAllRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetRemainCountAtAllRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                return object;
            };

            /**
             * Converts this GetRemainCountAtAllRequest to JSON.
             * @function toJSON
             * @memberof kritor.group.GetRemainCountAtAllRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetRemainCountAtAllRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetRemainCountAtAllRequest
             * @function getTypeUrl
             * @memberof kritor.group.GetRemainCountAtAllRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetRemainCountAtAllRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.GetRemainCountAtAllRequest";
            };

            return GetRemainCountAtAllRequest;
        })();

        group.GetRemainCountAtAllResponse = (function() {

            /**
             * Properties of a GetRemainCountAtAllResponse.
             * @memberof kritor.group
             * @interface IGetRemainCountAtAllResponse
             * @property {boolean|null} [accessAtAll] GetRemainCountAtAllResponse accessAtAll
             * @property {number|null} [remainCountForGroup] GetRemainCountAtAllResponse remainCountForGroup
             * @property {number|null} [remainCountForSelf] GetRemainCountAtAllResponse remainCountForSelf
             */

            /**
             * Constructs a new GetRemainCountAtAllResponse.
             * @memberof kritor.group
             * @classdesc Represents a GetRemainCountAtAllResponse.
             * @implements IGetRemainCountAtAllResponse
             * @constructor
             * @param {kritor.group.IGetRemainCountAtAllResponse=} [properties] Properties to set
             */
            function GetRemainCountAtAllResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetRemainCountAtAllResponse accessAtAll.
             * @member {boolean} accessAtAll
             * @memberof kritor.group.GetRemainCountAtAllResponse
             * @instance
             */
            GetRemainCountAtAllResponse.prototype.accessAtAll = false;

            /**
             * GetRemainCountAtAllResponse remainCountForGroup.
             * @member {number} remainCountForGroup
             * @memberof kritor.group.GetRemainCountAtAllResponse
             * @instance
             */
            GetRemainCountAtAllResponse.prototype.remainCountForGroup = 0;

            /**
             * GetRemainCountAtAllResponse remainCountForSelf.
             * @member {number} remainCountForSelf
             * @memberof kritor.group.GetRemainCountAtAllResponse
             * @instance
             */
            GetRemainCountAtAllResponse.prototype.remainCountForSelf = 0;

            /**
             * Creates a new GetRemainCountAtAllResponse instance using the specified properties.
             * @function create
             * @memberof kritor.group.GetRemainCountAtAllResponse
             * @static
             * @param {kritor.group.IGetRemainCountAtAllResponse=} [properties] Properties to set
             * @returns {kritor.group.GetRemainCountAtAllResponse} GetRemainCountAtAllResponse instance
             */
            GetRemainCountAtAllResponse.create = function create(properties) {
                return new GetRemainCountAtAllResponse(properties);
            };

            /**
             * Encodes the specified GetRemainCountAtAllResponse message. Does not implicitly {@link kritor.group.GetRemainCountAtAllResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.GetRemainCountAtAllResponse
             * @static
             * @param {kritor.group.IGetRemainCountAtAllResponse} message GetRemainCountAtAllResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetRemainCountAtAllResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.accessAtAll != null && Object.hasOwnProperty.call(message, "accessAtAll"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.accessAtAll);
                if (message.remainCountForGroup != null && Object.hasOwnProperty.call(message, "remainCountForGroup"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.remainCountForGroup);
                if (message.remainCountForSelf != null && Object.hasOwnProperty.call(message, "remainCountForSelf"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.remainCountForSelf);
                return writer;
            };

            /**
             * Encodes the specified GetRemainCountAtAllResponse message, length delimited. Does not implicitly {@link kritor.group.GetRemainCountAtAllResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.GetRemainCountAtAllResponse
             * @static
             * @param {kritor.group.IGetRemainCountAtAllResponse} message GetRemainCountAtAllResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetRemainCountAtAllResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetRemainCountAtAllResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.GetRemainCountAtAllResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.GetRemainCountAtAllResponse} GetRemainCountAtAllResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetRemainCountAtAllResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.GetRemainCountAtAllResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.accessAtAll = reader.bool();
                            break;
                        }
                    case 2: {
                            message.remainCountForGroup = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.remainCountForSelf = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetRemainCountAtAllResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.GetRemainCountAtAllResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.GetRemainCountAtAllResponse} GetRemainCountAtAllResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetRemainCountAtAllResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetRemainCountAtAllResponse message.
             * @function verify
             * @memberof kritor.group.GetRemainCountAtAllResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetRemainCountAtAllResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.accessAtAll != null && message.hasOwnProperty("accessAtAll"))
                    if (typeof message.accessAtAll !== "boolean")
                        return "accessAtAll: boolean expected";
                if (message.remainCountForGroup != null && message.hasOwnProperty("remainCountForGroup"))
                    if (!$util.isInteger(message.remainCountForGroup))
                        return "remainCountForGroup: integer expected";
                if (message.remainCountForSelf != null && message.hasOwnProperty("remainCountForSelf"))
                    if (!$util.isInteger(message.remainCountForSelf))
                        return "remainCountForSelf: integer expected";
                return null;
            };

            /**
             * Creates a GetRemainCountAtAllResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.GetRemainCountAtAllResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.GetRemainCountAtAllResponse} GetRemainCountAtAllResponse
             */
            GetRemainCountAtAllResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.GetRemainCountAtAllResponse)
                    return object;
                let message = new $root.kritor.group.GetRemainCountAtAllResponse();
                if (object.accessAtAll != null)
                    message.accessAtAll = Boolean(object.accessAtAll);
                if (object.remainCountForGroup != null)
                    message.remainCountForGroup = object.remainCountForGroup >>> 0;
                if (object.remainCountForSelf != null)
                    message.remainCountForSelf = object.remainCountForSelf >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a GetRemainCountAtAllResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.GetRemainCountAtAllResponse
             * @static
             * @param {kritor.group.GetRemainCountAtAllResponse} message GetRemainCountAtAllResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetRemainCountAtAllResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.accessAtAll = false;
                    object.remainCountForGroup = 0;
                    object.remainCountForSelf = 0;
                }
                if (message.accessAtAll != null && message.hasOwnProperty("accessAtAll"))
                    object.accessAtAll = message.accessAtAll;
                if (message.remainCountForGroup != null && message.hasOwnProperty("remainCountForGroup"))
                    object.remainCountForGroup = message.remainCountForGroup;
                if (message.remainCountForSelf != null && message.hasOwnProperty("remainCountForSelf"))
                    object.remainCountForSelf = message.remainCountForSelf;
                return object;
            };

            /**
             * Converts this GetRemainCountAtAllResponse to JSON.
             * @function toJSON
             * @memberof kritor.group.GetRemainCountAtAllResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetRemainCountAtAllResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetRemainCountAtAllResponse
             * @function getTypeUrl
             * @memberof kritor.group.GetRemainCountAtAllResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetRemainCountAtAllResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.GetRemainCountAtAllResponse";
            };

            return GetRemainCountAtAllResponse;
        })();

        group.GetNotJoinedGroupInfoRequest = (function() {

            /**
             * Properties of a GetNotJoinedGroupInfoRequest.
             * @memberof kritor.group
             * @interface IGetNotJoinedGroupInfoRequest
             * @property {number|Long|null} [groupId] GetNotJoinedGroupInfoRequest groupId
             */

            /**
             * Constructs a new GetNotJoinedGroupInfoRequest.
             * @memberof kritor.group
             * @classdesc Represents a GetNotJoinedGroupInfoRequest.
             * @implements IGetNotJoinedGroupInfoRequest
             * @constructor
             * @param {kritor.group.IGetNotJoinedGroupInfoRequest=} [properties] Properties to set
             */
            function GetNotJoinedGroupInfoRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetNotJoinedGroupInfoRequest groupId.
             * @member {number|Long} groupId
             * @memberof kritor.group.GetNotJoinedGroupInfoRequest
             * @instance
             */
            GetNotJoinedGroupInfoRequest.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new GetNotJoinedGroupInfoRequest instance using the specified properties.
             * @function create
             * @memberof kritor.group.GetNotJoinedGroupInfoRequest
             * @static
             * @param {kritor.group.IGetNotJoinedGroupInfoRequest=} [properties] Properties to set
             * @returns {kritor.group.GetNotJoinedGroupInfoRequest} GetNotJoinedGroupInfoRequest instance
             */
            GetNotJoinedGroupInfoRequest.create = function create(properties) {
                return new GetNotJoinedGroupInfoRequest(properties);
            };

            /**
             * Encodes the specified GetNotJoinedGroupInfoRequest message. Does not implicitly {@link kritor.group.GetNotJoinedGroupInfoRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.GetNotJoinedGroupInfoRequest
             * @static
             * @param {kritor.group.IGetNotJoinedGroupInfoRequest} message GetNotJoinedGroupInfoRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetNotJoinedGroupInfoRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                return writer;
            };

            /**
             * Encodes the specified GetNotJoinedGroupInfoRequest message, length delimited. Does not implicitly {@link kritor.group.GetNotJoinedGroupInfoRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.GetNotJoinedGroupInfoRequest
             * @static
             * @param {kritor.group.IGetNotJoinedGroupInfoRequest} message GetNotJoinedGroupInfoRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetNotJoinedGroupInfoRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetNotJoinedGroupInfoRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.GetNotJoinedGroupInfoRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.GetNotJoinedGroupInfoRequest} GetNotJoinedGroupInfoRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetNotJoinedGroupInfoRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.GetNotJoinedGroupInfoRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetNotJoinedGroupInfoRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.GetNotJoinedGroupInfoRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.GetNotJoinedGroupInfoRequest} GetNotJoinedGroupInfoRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetNotJoinedGroupInfoRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetNotJoinedGroupInfoRequest message.
             * @function verify
             * @memberof kritor.group.GetNotJoinedGroupInfoRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetNotJoinedGroupInfoRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                return null;
            };

            /**
             * Creates a GetNotJoinedGroupInfoRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.GetNotJoinedGroupInfoRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.GetNotJoinedGroupInfoRequest} GetNotJoinedGroupInfoRequest
             */
            GetNotJoinedGroupInfoRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.GetNotJoinedGroupInfoRequest)
                    return object;
                let message = new $root.kritor.group.GetNotJoinedGroupInfoRequest();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a GetNotJoinedGroupInfoRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.GetNotJoinedGroupInfoRequest
             * @static
             * @param {kritor.group.GetNotJoinedGroupInfoRequest} message GetNotJoinedGroupInfoRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetNotJoinedGroupInfoRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                return object;
            };

            /**
             * Converts this GetNotJoinedGroupInfoRequest to JSON.
             * @function toJSON
             * @memberof kritor.group.GetNotJoinedGroupInfoRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetNotJoinedGroupInfoRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetNotJoinedGroupInfoRequest
             * @function getTypeUrl
             * @memberof kritor.group.GetNotJoinedGroupInfoRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetNotJoinedGroupInfoRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.GetNotJoinedGroupInfoRequest";
            };

            return GetNotJoinedGroupInfoRequest;
        })();

        group.GetNotJoinedGroupInfoResponse = (function() {

            /**
             * Properties of a GetNotJoinedGroupInfoResponse.
             * @memberof kritor.group
             * @interface IGetNotJoinedGroupInfoResponse
             * @property {kritor.group.INotJoinedGroupInfo|null} [groupInfo] GetNotJoinedGroupInfoResponse groupInfo
             */

            /**
             * Constructs a new GetNotJoinedGroupInfoResponse.
             * @memberof kritor.group
             * @classdesc Represents a GetNotJoinedGroupInfoResponse.
             * @implements IGetNotJoinedGroupInfoResponse
             * @constructor
             * @param {kritor.group.IGetNotJoinedGroupInfoResponse=} [properties] Properties to set
             */
            function GetNotJoinedGroupInfoResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetNotJoinedGroupInfoResponse groupInfo.
             * @member {kritor.group.INotJoinedGroupInfo|null|undefined} groupInfo
             * @memberof kritor.group.GetNotJoinedGroupInfoResponse
             * @instance
             */
            GetNotJoinedGroupInfoResponse.prototype.groupInfo = null;

            /**
             * Creates a new GetNotJoinedGroupInfoResponse instance using the specified properties.
             * @function create
             * @memberof kritor.group.GetNotJoinedGroupInfoResponse
             * @static
             * @param {kritor.group.IGetNotJoinedGroupInfoResponse=} [properties] Properties to set
             * @returns {kritor.group.GetNotJoinedGroupInfoResponse} GetNotJoinedGroupInfoResponse instance
             */
            GetNotJoinedGroupInfoResponse.create = function create(properties) {
                return new GetNotJoinedGroupInfoResponse(properties);
            };

            /**
             * Encodes the specified GetNotJoinedGroupInfoResponse message. Does not implicitly {@link kritor.group.GetNotJoinedGroupInfoResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.GetNotJoinedGroupInfoResponse
             * @static
             * @param {kritor.group.IGetNotJoinedGroupInfoResponse} message GetNotJoinedGroupInfoResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetNotJoinedGroupInfoResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupInfo != null && Object.hasOwnProperty.call(message, "groupInfo"))
                    $root.kritor.group.NotJoinedGroupInfo.encode(message.groupInfo, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetNotJoinedGroupInfoResponse message, length delimited. Does not implicitly {@link kritor.group.GetNotJoinedGroupInfoResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.GetNotJoinedGroupInfoResponse
             * @static
             * @param {kritor.group.IGetNotJoinedGroupInfoResponse} message GetNotJoinedGroupInfoResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetNotJoinedGroupInfoResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetNotJoinedGroupInfoResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.GetNotJoinedGroupInfoResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.GetNotJoinedGroupInfoResponse} GetNotJoinedGroupInfoResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetNotJoinedGroupInfoResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.GetNotJoinedGroupInfoResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupInfo = $root.kritor.group.NotJoinedGroupInfo.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetNotJoinedGroupInfoResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.GetNotJoinedGroupInfoResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.GetNotJoinedGroupInfoResponse} GetNotJoinedGroupInfoResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetNotJoinedGroupInfoResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetNotJoinedGroupInfoResponse message.
             * @function verify
             * @memberof kritor.group.GetNotJoinedGroupInfoResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetNotJoinedGroupInfoResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupInfo != null && message.hasOwnProperty("groupInfo")) {
                    let error = $root.kritor.group.NotJoinedGroupInfo.verify(message.groupInfo);
                    if (error)
                        return "groupInfo." + error;
                }
                return null;
            };

            /**
             * Creates a GetNotJoinedGroupInfoResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.GetNotJoinedGroupInfoResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.GetNotJoinedGroupInfoResponse} GetNotJoinedGroupInfoResponse
             */
            GetNotJoinedGroupInfoResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.GetNotJoinedGroupInfoResponse)
                    return object;
                let message = new $root.kritor.group.GetNotJoinedGroupInfoResponse();
                if (object.groupInfo != null) {
                    if (typeof object.groupInfo !== "object")
                        throw TypeError(".kritor.group.GetNotJoinedGroupInfoResponse.groupInfo: object expected");
                    message.groupInfo = $root.kritor.group.NotJoinedGroupInfo.fromObject(object.groupInfo);
                }
                return message;
            };

            /**
             * Creates a plain object from a GetNotJoinedGroupInfoResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.GetNotJoinedGroupInfoResponse
             * @static
             * @param {kritor.group.GetNotJoinedGroupInfoResponse} message GetNotJoinedGroupInfoResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetNotJoinedGroupInfoResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.groupInfo = null;
                if (message.groupInfo != null && message.hasOwnProperty("groupInfo"))
                    object.groupInfo = $root.kritor.group.NotJoinedGroupInfo.toObject(message.groupInfo, options);
                return object;
            };

            /**
             * Converts this GetNotJoinedGroupInfoResponse to JSON.
             * @function toJSON
             * @memberof kritor.group.GetNotJoinedGroupInfoResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetNotJoinedGroupInfoResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetNotJoinedGroupInfoResponse
             * @function getTypeUrl
             * @memberof kritor.group.GetNotJoinedGroupInfoResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetNotJoinedGroupInfoResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.GetNotJoinedGroupInfoResponse";
            };

            return GetNotJoinedGroupInfoResponse;
        })();

        group.GetGroupHonorRequest = (function() {

            /**
             * Properties of a GetGroupHonorRequest.
             * @memberof kritor.group
             * @interface IGetGroupHonorRequest
             * @property {number|Long|null} [groupId] GetGroupHonorRequest groupId
             * @property {boolean|null} [refresh] GetGroupHonorRequest refresh
             */

            /**
             * Constructs a new GetGroupHonorRequest.
             * @memberof kritor.group
             * @classdesc Represents a GetGroupHonorRequest.
             * @implements IGetGroupHonorRequest
             * @constructor
             * @param {kritor.group.IGetGroupHonorRequest=} [properties] Properties to set
             */
            function GetGroupHonorRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetGroupHonorRequest groupId.
             * @member {number|Long} groupId
             * @memberof kritor.group.GetGroupHonorRequest
             * @instance
             */
            GetGroupHonorRequest.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GetGroupHonorRequest refresh.
             * @member {boolean|null|undefined} refresh
             * @memberof kritor.group.GetGroupHonorRequest
             * @instance
             */
            GetGroupHonorRequest.prototype.refresh = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * GetGroupHonorRequest _refresh.
             * @member {"refresh"|undefined} _refresh
             * @memberof kritor.group.GetGroupHonorRequest
             * @instance
             */
            Object.defineProperty(GetGroupHonorRequest.prototype, "_refresh", {
                get: $util.oneOfGetter($oneOfFields = ["refresh"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new GetGroupHonorRequest instance using the specified properties.
             * @function create
             * @memberof kritor.group.GetGroupHonorRequest
             * @static
             * @param {kritor.group.IGetGroupHonorRequest=} [properties] Properties to set
             * @returns {kritor.group.GetGroupHonorRequest} GetGroupHonorRequest instance
             */
            GetGroupHonorRequest.create = function create(properties) {
                return new GetGroupHonorRequest(properties);
            };

            /**
             * Encodes the specified GetGroupHonorRequest message. Does not implicitly {@link kritor.group.GetGroupHonorRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.GetGroupHonorRequest
             * @static
             * @param {kritor.group.IGetGroupHonorRequest} message GetGroupHonorRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGroupHonorRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                if (message.refresh != null && Object.hasOwnProperty.call(message, "refresh"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.refresh);
                return writer;
            };

            /**
             * Encodes the specified GetGroupHonorRequest message, length delimited. Does not implicitly {@link kritor.group.GetGroupHonorRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.GetGroupHonorRequest
             * @static
             * @param {kritor.group.IGetGroupHonorRequest} message GetGroupHonorRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGroupHonorRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetGroupHonorRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.GetGroupHonorRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.GetGroupHonorRequest} GetGroupHonorRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGroupHonorRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.GetGroupHonorRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.refresh = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetGroupHonorRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.GetGroupHonorRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.GetGroupHonorRequest} GetGroupHonorRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGroupHonorRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetGroupHonorRequest message.
             * @function verify
             * @memberof kritor.group.GetGroupHonorRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetGroupHonorRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                if (message.refresh != null && message.hasOwnProperty("refresh")) {
                    properties._refresh = 1;
                    if (typeof message.refresh !== "boolean")
                        return "refresh: boolean expected";
                }
                return null;
            };

            /**
             * Creates a GetGroupHonorRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.GetGroupHonorRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.GetGroupHonorRequest} GetGroupHonorRequest
             */
            GetGroupHonorRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.GetGroupHonorRequest)
                    return object;
                let message = new $root.kritor.group.GetGroupHonorRequest();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                if (object.refresh != null)
                    message.refresh = Boolean(object.refresh);
                return message;
            };

            /**
             * Creates a plain object from a GetGroupHonorRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.GetGroupHonorRequest
             * @static
             * @param {kritor.group.GetGroupHonorRequest} message GetGroupHonorRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetGroupHonorRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                if (message.refresh != null && message.hasOwnProperty("refresh")) {
                    object.refresh = message.refresh;
                    if (options.oneofs)
                        object._refresh = "refresh";
                }
                return object;
            };

            /**
             * Converts this GetGroupHonorRequest to JSON.
             * @function toJSON
             * @memberof kritor.group.GetGroupHonorRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetGroupHonorRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetGroupHonorRequest
             * @function getTypeUrl
             * @memberof kritor.group.GetGroupHonorRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetGroupHonorRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.GetGroupHonorRequest";
            };

            return GetGroupHonorRequest;
        })();

        group.GetGroupHonorResponse = (function() {

            /**
             * Properties of a GetGroupHonorResponse.
             * @memberof kritor.group
             * @interface IGetGroupHonorResponse
             * @property {Array.<kritor.group.IGroupHonorInfo>|null} [groupHonorsInfo] GetGroupHonorResponse groupHonorsInfo
             */

            /**
             * Constructs a new GetGroupHonorResponse.
             * @memberof kritor.group
             * @classdesc Represents a GetGroupHonorResponse.
             * @implements IGetGroupHonorResponse
             * @constructor
             * @param {kritor.group.IGetGroupHonorResponse=} [properties] Properties to set
             */
            function GetGroupHonorResponse(properties) {
                this.groupHonorsInfo = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetGroupHonorResponse groupHonorsInfo.
             * @member {Array.<kritor.group.IGroupHonorInfo>} groupHonorsInfo
             * @memberof kritor.group.GetGroupHonorResponse
             * @instance
             */
            GetGroupHonorResponse.prototype.groupHonorsInfo = $util.emptyArray;

            /**
             * Creates a new GetGroupHonorResponse instance using the specified properties.
             * @function create
             * @memberof kritor.group.GetGroupHonorResponse
             * @static
             * @param {kritor.group.IGetGroupHonorResponse=} [properties] Properties to set
             * @returns {kritor.group.GetGroupHonorResponse} GetGroupHonorResponse instance
             */
            GetGroupHonorResponse.create = function create(properties) {
                return new GetGroupHonorResponse(properties);
            };

            /**
             * Encodes the specified GetGroupHonorResponse message. Does not implicitly {@link kritor.group.GetGroupHonorResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.GetGroupHonorResponse
             * @static
             * @param {kritor.group.IGetGroupHonorResponse} message GetGroupHonorResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGroupHonorResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupHonorsInfo != null && message.groupHonorsInfo.length)
                    for (let i = 0; i < message.groupHonorsInfo.length; ++i)
                        $root.kritor.group.GroupHonorInfo.encode(message.groupHonorsInfo[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetGroupHonorResponse message, length delimited. Does not implicitly {@link kritor.group.GetGroupHonorResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.GetGroupHonorResponse
             * @static
             * @param {kritor.group.IGetGroupHonorResponse} message GetGroupHonorResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGroupHonorResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetGroupHonorResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.GetGroupHonorResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.GetGroupHonorResponse} GetGroupHonorResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGroupHonorResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.GetGroupHonorResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.groupHonorsInfo && message.groupHonorsInfo.length))
                                message.groupHonorsInfo = [];
                            message.groupHonorsInfo.push($root.kritor.group.GroupHonorInfo.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetGroupHonorResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.GetGroupHonorResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.GetGroupHonorResponse} GetGroupHonorResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGroupHonorResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetGroupHonorResponse message.
             * @function verify
             * @memberof kritor.group.GetGroupHonorResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetGroupHonorResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupHonorsInfo != null && message.hasOwnProperty("groupHonorsInfo")) {
                    if (!Array.isArray(message.groupHonorsInfo))
                        return "groupHonorsInfo: array expected";
                    for (let i = 0; i < message.groupHonorsInfo.length; ++i) {
                        let error = $root.kritor.group.GroupHonorInfo.verify(message.groupHonorsInfo[i]);
                        if (error)
                            return "groupHonorsInfo." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a GetGroupHonorResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.GetGroupHonorResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.GetGroupHonorResponse} GetGroupHonorResponse
             */
            GetGroupHonorResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.GetGroupHonorResponse)
                    return object;
                let message = new $root.kritor.group.GetGroupHonorResponse();
                if (object.groupHonorsInfo) {
                    if (!Array.isArray(object.groupHonorsInfo))
                        throw TypeError(".kritor.group.GetGroupHonorResponse.groupHonorsInfo: array expected");
                    message.groupHonorsInfo = [];
                    for (let i = 0; i < object.groupHonorsInfo.length; ++i) {
                        if (typeof object.groupHonorsInfo[i] !== "object")
                            throw TypeError(".kritor.group.GetGroupHonorResponse.groupHonorsInfo: object expected");
                        message.groupHonorsInfo[i] = $root.kritor.group.GroupHonorInfo.fromObject(object.groupHonorsInfo[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a GetGroupHonorResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.GetGroupHonorResponse
             * @static
             * @param {kritor.group.GetGroupHonorResponse} message GetGroupHonorResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetGroupHonorResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.groupHonorsInfo = [];
                if (message.groupHonorsInfo && message.groupHonorsInfo.length) {
                    object.groupHonorsInfo = [];
                    for (let j = 0; j < message.groupHonorsInfo.length; ++j)
                        object.groupHonorsInfo[j] = $root.kritor.group.GroupHonorInfo.toObject(message.groupHonorsInfo[j], options);
                }
                return object;
            };

            /**
             * Converts this GetGroupHonorResponse to JSON.
             * @function toJSON
             * @memberof kritor.group.GetGroupHonorResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetGroupHonorResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetGroupHonorResponse
             * @function getTypeUrl
             * @memberof kritor.group.GetGroupHonorResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetGroupHonorResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.GetGroupHonorResponse";
            };

            return GetGroupHonorResponse;
        })();

        group.GroupInfo = (function() {

            /**
             * Properties of a GroupInfo.
             * @memberof kritor.group
             * @interface IGroupInfo
             * @property {number|Long|null} [groupId] GroupInfo groupId
             * @property {string|null} [groupName] GroupInfo groupName
             * @property {string|null} [groupRemark] GroupInfo groupRemark
             * @property {number|Long|null} [owner] GroupInfo owner
             * @property {Array.<number|Long>|null} [admins] GroupInfo admins
             * @property {number|null} [maxMemberCount] GroupInfo maxMemberCount
             * @property {number|null} [memberCount] GroupInfo memberCount
             * @property {number|Long|null} [groupUin] GroupInfo groupUin
             */

            /**
             * Constructs a new GroupInfo.
             * @memberof kritor.group
             * @classdesc Represents a GroupInfo.
             * @implements IGroupInfo
             * @constructor
             * @param {kritor.group.IGroupInfo=} [properties] Properties to set
             */
            function GroupInfo(properties) {
                this.admins = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupInfo groupId.
             * @member {number|Long} groupId
             * @memberof kritor.group.GroupInfo
             * @instance
             */
            GroupInfo.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupInfo groupName.
             * @member {string} groupName
             * @memberof kritor.group.GroupInfo
             * @instance
             */
            GroupInfo.prototype.groupName = "";

            /**
             * GroupInfo groupRemark.
             * @member {string} groupRemark
             * @memberof kritor.group.GroupInfo
             * @instance
             */
            GroupInfo.prototype.groupRemark = "";

            /**
             * GroupInfo owner.
             * @member {number|Long} owner
             * @memberof kritor.group.GroupInfo
             * @instance
             */
            GroupInfo.prototype.owner = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupInfo admins.
             * @member {Array.<number|Long>} admins
             * @memberof kritor.group.GroupInfo
             * @instance
             */
            GroupInfo.prototype.admins = $util.emptyArray;

            /**
             * GroupInfo maxMemberCount.
             * @member {number} maxMemberCount
             * @memberof kritor.group.GroupInfo
             * @instance
             */
            GroupInfo.prototype.maxMemberCount = 0;

            /**
             * GroupInfo memberCount.
             * @member {number} memberCount
             * @memberof kritor.group.GroupInfo
             * @instance
             */
            GroupInfo.prototype.memberCount = 0;

            /**
             * GroupInfo groupUin.
             * @member {number|Long} groupUin
             * @memberof kritor.group.GroupInfo
             * @instance
             */
            GroupInfo.prototype.groupUin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new GroupInfo instance using the specified properties.
             * @function create
             * @memberof kritor.group.GroupInfo
             * @static
             * @param {kritor.group.IGroupInfo=} [properties] Properties to set
             * @returns {kritor.group.GroupInfo} GroupInfo instance
             */
            GroupInfo.create = function create(properties) {
                return new GroupInfo(properties);
            };

            /**
             * Encodes the specified GroupInfo message. Does not implicitly {@link kritor.group.GroupInfo.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.GroupInfo
             * @static
             * @param {kritor.group.IGroupInfo} message GroupInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                if (message.groupName != null && Object.hasOwnProperty.call(message, "groupName"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.groupName);
                if (message.groupRemark != null && Object.hasOwnProperty.call(message, "groupRemark"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.groupRemark);
                if (message.owner != null && Object.hasOwnProperty.call(message, "owner"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.owner);
                if (message.admins != null && message.admins.length) {
                    writer.uint32(/* id 5, wireType 2 =*/42).fork();
                    for (let i = 0; i < message.admins.length; ++i)
                        writer.uint64(message.admins[i]);
                    writer.ldelim();
                }
                if (message.maxMemberCount != null && Object.hasOwnProperty.call(message, "maxMemberCount"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.maxMemberCount);
                if (message.memberCount != null && Object.hasOwnProperty.call(message, "memberCount"))
                    writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.memberCount);
                if (message.groupUin != null && Object.hasOwnProperty.call(message, "groupUin"))
                    writer.uint32(/* id 10, wireType 0 =*/80).uint64(message.groupUin);
                return writer;
            };

            /**
             * Encodes the specified GroupInfo message, length delimited. Does not implicitly {@link kritor.group.GroupInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.GroupInfo
             * @static
             * @param {kritor.group.IGroupInfo} message GroupInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupInfo message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.GroupInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.GroupInfo} GroupInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.GroupInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.groupName = reader.string();
                            break;
                        }
                    case 3: {
                            message.groupRemark = reader.string();
                            break;
                        }
                    case 4: {
                            message.owner = reader.uint64();
                            break;
                        }
                    case 5: {
                            if (!(message.admins && message.admins.length))
                                message.admins = [];
                            if ((tag & 7) === 2) {
                                let end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.admins.push(reader.uint64());
                            } else
                                message.admins.push(reader.uint64());
                            break;
                        }
                    case 6: {
                            message.maxMemberCount = reader.uint32();
                            break;
                        }
                    case 7: {
                            message.memberCount = reader.uint32();
                            break;
                        }
                    case 10: {
                            message.groupUin = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.GroupInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.GroupInfo} GroupInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupInfo message.
             * @function verify
             * @memberof kritor.group.GroupInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                if (message.groupName != null && message.hasOwnProperty("groupName"))
                    if (!$util.isString(message.groupName))
                        return "groupName: string expected";
                if (message.groupRemark != null && message.hasOwnProperty("groupRemark"))
                    if (!$util.isString(message.groupRemark))
                        return "groupRemark: string expected";
                if (message.owner != null && message.hasOwnProperty("owner"))
                    if (!$util.isInteger(message.owner) && !(message.owner && $util.isInteger(message.owner.low) && $util.isInteger(message.owner.high)))
                        return "owner: integer|Long expected";
                if (message.admins != null && message.hasOwnProperty("admins")) {
                    if (!Array.isArray(message.admins))
                        return "admins: array expected";
                    for (let i = 0; i < message.admins.length; ++i)
                        if (!$util.isInteger(message.admins[i]) && !(message.admins[i] && $util.isInteger(message.admins[i].low) && $util.isInteger(message.admins[i].high)))
                            return "admins: integer|Long[] expected";
                }
                if (message.maxMemberCount != null && message.hasOwnProperty("maxMemberCount"))
                    if (!$util.isInteger(message.maxMemberCount))
                        return "maxMemberCount: integer expected";
                if (message.memberCount != null && message.hasOwnProperty("memberCount"))
                    if (!$util.isInteger(message.memberCount))
                        return "memberCount: integer expected";
                if (message.groupUin != null && message.hasOwnProperty("groupUin"))
                    if (!$util.isInteger(message.groupUin) && !(message.groupUin && $util.isInteger(message.groupUin.low) && $util.isInteger(message.groupUin.high)))
                        return "groupUin: integer|Long expected";
                return null;
            };

            /**
             * Creates a GroupInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.GroupInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.GroupInfo} GroupInfo
             */
            GroupInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.GroupInfo)
                    return object;
                let message = new $root.kritor.group.GroupInfo();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                if (object.groupName != null)
                    message.groupName = String(object.groupName);
                if (object.groupRemark != null)
                    message.groupRemark = String(object.groupRemark);
                if (object.owner != null)
                    if ($util.Long)
                        (message.owner = $util.Long.fromValue(object.owner)).unsigned = true;
                    else if (typeof object.owner === "string")
                        message.owner = parseInt(object.owner, 10);
                    else if (typeof object.owner === "number")
                        message.owner = object.owner;
                    else if (typeof object.owner === "object")
                        message.owner = new $util.LongBits(object.owner.low >>> 0, object.owner.high >>> 0).toNumber(true);
                if (object.admins) {
                    if (!Array.isArray(object.admins))
                        throw TypeError(".kritor.group.GroupInfo.admins: array expected");
                    message.admins = [];
                    for (let i = 0; i < object.admins.length; ++i)
                        if ($util.Long)
                            (message.admins[i] = $util.Long.fromValue(object.admins[i])).unsigned = true;
                        else if (typeof object.admins[i] === "string")
                            message.admins[i] = parseInt(object.admins[i], 10);
                        else if (typeof object.admins[i] === "number")
                            message.admins[i] = object.admins[i];
                        else if (typeof object.admins[i] === "object")
                            message.admins[i] = new $util.LongBits(object.admins[i].low >>> 0, object.admins[i].high >>> 0).toNumber(true);
                }
                if (object.maxMemberCount != null)
                    message.maxMemberCount = object.maxMemberCount >>> 0;
                if (object.memberCount != null)
                    message.memberCount = object.memberCount >>> 0;
                if (object.groupUin != null)
                    if ($util.Long)
                        (message.groupUin = $util.Long.fromValue(object.groupUin)).unsigned = true;
                    else if (typeof object.groupUin === "string")
                        message.groupUin = parseInt(object.groupUin, 10);
                    else if (typeof object.groupUin === "number")
                        message.groupUin = object.groupUin;
                    else if (typeof object.groupUin === "object")
                        message.groupUin = new $util.LongBits(object.groupUin.low >>> 0, object.groupUin.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a GroupInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.GroupInfo
             * @static
             * @param {kritor.group.GroupInfo} message GroupInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.admins = [];
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                    object.groupName = "";
                    object.groupRemark = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.owner = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.owner = options.longs === String ? "0" : 0;
                    object.maxMemberCount = 0;
                    object.memberCount = 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupUin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupUin = options.longs === String ? "0" : 0;
                }
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                if (message.groupName != null && message.hasOwnProperty("groupName"))
                    object.groupName = message.groupName;
                if (message.groupRemark != null && message.hasOwnProperty("groupRemark"))
                    object.groupRemark = message.groupRemark;
                if (message.owner != null && message.hasOwnProperty("owner"))
                    if (typeof message.owner === "number")
                        object.owner = options.longs === String ? String(message.owner) : message.owner;
                    else
                        object.owner = options.longs === String ? $util.Long.prototype.toString.call(message.owner) : options.longs === Number ? new $util.LongBits(message.owner.low >>> 0, message.owner.high >>> 0).toNumber(true) : message.owner;
                if (message.admins && message.admins.length) {
                    object.admins = [];
                    for (let j = 0; j < message.admins.length; ++j)
                        if (typeof message.admins[j] === "number")
                            object.admins[j] = options.longs === String ? String(message.admins[j]) : message.admins[j];
                        else
                            object.admins[j] = options.longs === String ? $util.Long.prototype.toString.call(message.admins[j]) : options.longs === Number ? new $util.LongBits(message.admins[j].low >>> 0, message.admins[j].high >>> 0).toNumber(true) : message.admins[j];
                }
                if (message.maxMemberCount != null && message.hasOwnProperty("maxMemberCount"))
                    object.maxMemberCount = message.maxMemberCount;
                if (message.memberCount != null && message.hasOwnProperty("memberCount"))
                    object.memberCount = message.memberCount;
                if (message.groupUin != null && message.hasOwnProperty("groupUin"))
                    if (typeof message.groupUin === "number")
                        object.groupUin = options.longs === String ? String(message.groupUin) : message.groupUin;
                    else
                        object.groupUin = options.longs === String ? $util.Long.prototype.toString.call(message.groupUin) : options.longs === Number ? new $util.LongBits(message.groupUin.low >>> 0, message.groupUin.high >>> 0).toNumber(true) : message.groupUin;
                return object;
            };

            /**
             * Converts this GroupInfo to JSON.
             * @function toJSON
             * @memberof kritor.group.GroupInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GroupInfo
             * @function getTypeUrl
             * @memberof kritor.group.GroupInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GroupInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.GroupInfo";
            };

            return GroupInfo;
        })();

        group.NotJoinedGroupInfo = (function() {

            /**
             * Properties of a NotJoinedGroupInfo.
             * @memberof kritor.group
             * @interface INotJoinedGroupInfo
             * @property {number|Long|null} [groupId] NotJoinedGroupInfo groupId
             * @property {number|null} [maxMemberCount] NotJoinedGroupInfo maxMemberCount
             * @property {number|null} [memberCount] NotJoinedGroupInfo memberCount
             * @property {string|null} [groupName] NotJoinedGroupInfo groupName
             * @property {string|null} [groupDesc] NotJoinedGroupInfo groupDesc
             * @property {number|Long|null} [owner] NotJoinedGroupInfo owner
             * @property {number|null} [createTime] NotJoinedGroupInfo createTime
             * @property {number|null} [groupFlag] NotJoinedGroupInfo groupFlag
             * @property {number|null} [groupFlagExt] NotJoinedGroupInfo groupFlagExt
             */

            /**
             * Constructs a new NotJoinedGroupInfo.
             * @memberof kritor.group
             * @classdesc Represents a NotJoinedGroupInfo.
             * @implements INotJoinedGroupInfo
             * @constructor
             * @param {kritor.group.INotJoinedGroupInfo=} [properties] Properties to set
             */
            function NotJoinedGroupInfo(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * NotJoinedGroupInfo groupId.
             * @member {number|Long} groupId
             * @memberof kritor.group.NotJoinedGroupInfo
             * @instance
             */
            NotJoinedGroupInfo.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * NotJoinedGroupInfo maxMemberCount.
             * @member {number} maxMemberCount
             * @memberof kritor.group.NotJoinedGroupInfo
             * @instance
             */
            NotJoinedGroupInfo.prototype.maxMemberCount = 0;

            /**
             * NotJoinedGroupInfo memberCount.
             * @member {number} memberCount
             * @memberof kritor.group.NotJoinedGroupInfo
             * @instance
             */
            NotJoinedGroupInfo.prototype.memberCount = 0;

            /**
             * NotJoinedGroupInfo groupName.
             * @member {string} groupName
             * @memberof kritor.group.NotJoinedGroupInfo
             * @instance
             */
            NotJoinedGroupInfo.prototype.groupName = "";

            /**
             * NotJoinedGroupInfo groupDesc.
             * @member {string} groupDesc
             * @memberof kritor.group.NotJoinedGroupInfo
             * @instance
             */
            NotJoinedGroupInfo.prototype.groupDesc = "";

            /**
             * NotJoinedGroupInfo owner.
             * @member {number|Long} owner
             * @memberof kritor.group.NotJoinedGroupInfo
             * @instance
             */
            NotJoinedGroupInfo.prototype.owner = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * NotJoinedGroupInfo createTime.
             * @member {number} createTime
             * @memberof kritor.group.NotJoinedGroupInfo
             * @instance
             */
            NotJoinedGroupInfo.prototype.createTime = 0;

            /**
             * NotJoinedGroupInfo groupFlag.
             * @member {number} groupFlag
             * @memberof kritor.group.NotJoinedGroupInfo
             * @instance
             */
            NotJoinedGroupInfo.prototype.groupFlag = 0;

            /**
             * NotJoinedGroupInfo groupFlagExt.
             * @member {number} groupFlagExt
             * @memberof kritor.group.NotJoinedGroupInfo
             * @instance
             */
            NotJoinedGroupInfo.prototype.groupFlagExt = 0;

            /**
             * Creates a new NotJoinedGroupInfo instance using the specified properties.
             * @function create
             * @memberof kritor.group.NotJoinedGroupInfo
             * @static
             * @param {kritor.group.INotJoinedGroupInfo=} [properties] Properties to set
             * @returns {kritor.group.NotJoinedGroupInfo} NotJoinedGroupInfo instance
             */
            NotJoinedGroupInfo.create = function create(properties) {
                return new NotJoinedGroupInfo(properties);
            };

            /**
             * Encodes the specified NotJoinedGroupInfo message. Does not implicitly {@link kritor.group.NotJoinedGroupInfo.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.NotJoinedGroupInfo
             * @static
             * @param {kritor.group.INotJoinedGroupInfo} message NotJoinedGroupInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NotJoinedGroupInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                if (message.maxMemberCount != null && Object.hasOwnProperty.call(message, "maxMemberCount"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.maxMemberCount);
                if (message.memberCount != null && Object.hasOwnProperty.call(message, "memberCount"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.memberCount);
                if (message.groupName != null && Object.hasOwnProperty.call(message, "groupName"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.groupName);
                if (message.groupDesc != null && Object.hasOwnProperty.call(message, "groupDesc"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.groupDesc);
                if (message.owner != null && Object.hasOwnProperty.call(message, "owner"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.owner);
                if (message.createTime != null && Object.hasOwnProperty.call(message, "createTime"))
                    writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.createTime);
                if (message.groupFlag != null && Object.hasOwnProperty.call(message, "groupFlag"))
                    writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.groupFlag);
                if (message.groupFlagExt != null && Object.hasOwnProperty.call(message, "groupFlagExt"))
                    writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.groupFlagExt);
                return writer;
            };

            /**
             * Encodes the specified NotJoinedGroupInfo message, length delimited. Does not implicitly {@link kritor.group.NotJoinedGroupInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.NotJoinedGroupInfo
             * @static
             * @param {kritor.group.INotJoinedGroupInfo} message NotJoinedGroupInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            NotJoinedGroupInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a NotJoinedGroupInfo message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.NotJoinedGroupInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.NotJoinedGroupInfo} NotJoinedGroupInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NotJoinedGroupInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.NotJoinedGroupInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.maxMemberCount = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.memberCount = reader.uint32();
                            break;
                        }
                    case 4: {
                            message.groupName = reader.string();
                            break;
                        }
                    case 5: {
                            message.groupDesc = reader.string();
                            break;
                        }
                    case 6: {
                            message.owner = reader.uint64();
                            break;
                        }
                    case 7: {
                            message.createTime = reader.uint32();
                            break;
                        }
                    case 8: {
                            message.groupFlag = reader.uint32();
                            break;
                        }
                    case 9: {
                            message.groupFlagExt = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a NotJoinedGroupInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.NotJoinedGroupInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.NotJoinedGroupInfo} NotJoinedGroupInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            NotJoinedGroupInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a NotJoinedGroupInfo message.
             * @function verify
             * @memberof kritor.group.NotJoinedGroupInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            NotJoinedGroupInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                if (message.maxMemberCount != null && message.hasOwnProperty("maxMemberCount"))
                    if (!$util.isInteger(message.maxMemberCount))
                        return "maxMemberCount: integer expected";
                if (message.memberCount != null && message.hasOwnProperty("memberCount"))
                    if (!$util.isInteger(message.memberCount))
                        return "memberCount: integer expected";
                if (message.groupName != null && message.hasOwnProperty("groupName"))
                    if (!$util.isString(message.groupName))
                        return "groupName: string expected";
                if (message.groupDesc != null && message.hasOwnProperty("groupDesc"))
                    if (!$util.isString(message.groupDesc))
                        return "groupDesc: string expected";
                if (message.owner != null && message.hasOwnProperty("owner"))
                    if (!$util.isInteger(message.owner) && !(message.owner && $util.isInteger(message.owner.low) && $util.isInteger(message.owner.high)))
                        return "owner: integer|Long expected";
                if (message.createTime != null && message.hasOwnProperty("createTime"))
                    if (!$util.isInteger(message.createTime))
                        return "createTime: integer expected";
                if (message.groupFlag != null && message.hasOwnProperty("groupFlag"))
                    if (!$util.isInteger(message.groupFlag))
                        return "groupFlag: integer expected";
                if (message.groupFlagExt != null && message.hasOwnProperty("groupFlagExt"))
                    if (!$util.isInteger(message.groupFlagExt))
                        return "groupFlagExt: integer expected";
                return null;
            };

            /**
             * Creates a NotJoinedGroupInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.NotJoinedGroupInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.NotJoinedGroupInfo} NotJoinedGroupInfo
             */
            NotJoinedGroupInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.NotJoinedGroupInfo)
                    return object;
                let message = new $root.kritor.group.NotJoinedGroupInfo();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                if (object.maxMemberCount != null)
                    message.maxMemberCount = object.maxMemberCount >>> 0;
                if (object.memberCount != null)
                    message.memberCount = object.memberCount >>> 0;
                if (object.groupName != null)
                    message.groupName = String(object.groupName);
                if (object.groupDesc != null)
                    message.groupDesc = String(object.groupDesc);
                if (object.owner != null)
                    if ($util.Long)
                        (message.owner = $util.Long.fromValue(object.owner)).unsigned = true;
                    else if (typeof object.owner === "string")
                        message.owner = parseInt(object.owner, 10);
                    else if (typeof object.owner === "number")
                        message.owner = object.owner;
                    else if (typeof object.owner === "object")
                        message.owner = new $util.LongBits(object.owner.low >>> 0, object.owner.high >>> 0).toNumber(true);
                if (object.createTime != null)
                    message.createTime = object.createTime >>> 0;
                if (object.groupFlag != null)
                    message.groupFlag = object.groupFlag >>> 0;
                if (object.groupFlagExt != null)
                    message.groupFlagExt = object.groupFlagExt >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a NotJoinedGroupInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.NotJoinedGroupInfo
             * @static
             * @param {kritor.group.NotJoinedGroupInfo} message NotJoinedGroupInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            NotJoinedGroupInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                    object.maxMemberCount = 0;
                    object.memberCount = 0;
                    object.groupName = "";
                    object.groupDesc = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.owner = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.owner = options.longs === String ? "0" : 0;
                    object.createTime = 0;
                    object.groupFlag = 0;
                    object.groupFlagExt = 0;
                }
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                if (message.maxMemberCount != null && message.hasOwnProperty("maxMemberCount"))
                    object.maxMemberCount = message.maxMemberCount;
                if (message.memberCount != null && message.hasOwnProperty("memberCount"))
                    object.memberCount = message.memberCount;
                if (message.groupName != null && message.hasOwnProperty("groupName"))
                    object.groupName = message.groupName;
                if (message.groupDesc != null && message.hasOwnProperty("groupDesc"))
                    object.groupDesc = message.groupDesc;
                if (message.owner != null && message.hasOwnProperty("owner"))
                    if (typeof message.owner === "number")
                        object.owner = options.longs === String ? String(message.owner) : message.owner;
                    else
                        object.owner = options.longs === String ? $util.Long.prototype.toString.call(message.owner) : options.longs === Number ? new $util.LongBits(message.owner.low >>> 0, message.owner.high >>> 0).toNumber(true) : message.owner;
                if (message.createTime != null && message.hasOwnProperty("createTime"))
                    object.createTime = message.createTime;
                if (message.groupFlag != null && message.hasOwnProperty("groupFlag"))
                    object.groupFlag = message.groupFlag;
                if (message.groupFlagExt != null && message.hasOwnProperty("groupFlagExt"))
                    object.groupFlagExt = message.groupFlagExt;
                return object;
            };

            /**
             * Converts this NotJoinedGroupInfo to JSON.
             * @function toJSON
             * @memberof kritor.group.NotJoinedGroupInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            NotJoinedGroupInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for NotJoinedGroupInfo
             * @function getTypeUrl
             * @memberof kritor.group.NotJoinedGroupInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            NotJoinedGroupInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.NotJoinedGroupInfo";
            };

            return NotJoinedGroupInfo;
        })();

        group.ProhibitedUserInfo = (function() {

            /**
             * Properties of a ProhibitedUserInfo.
             * @memberof kritor.group
             * @interface IProhibitedUserInfo
             * @property {string|null} [uid] ProhibitedUserInfo uid
             * @property {number|Long|null} [uin] ProhibitedUserInfo uin
             * @property {number|null} [prohibitedTime] ProhibitedUserInfo prohibitedTime
             */

            /**
             * Constructs a new ProhibitedUserInfo.
             * @memberof kritor.group
             * @classdesc Represents a ProhibitedUserInfo.
             * @implements IProhibitedUserInfo
             * @constructor
             * @param {kritor.group.IProhibitedUserInfo=} [properties] Properties to set
             */
            function ProhibitedUserInfo(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ProhibitedUserInfo uid.
             * @member {string} uid
             * @memberof kritor.group.ProhibitedUserInfo
             * @instance
             */
            ProhibitedUserInfo.prototype.uid = "";

            /**
             * ProhibitedUserInfo uin.
             * @member {number|Long} uin
             * @memberof kritor.group.ProhibitedUserInfo
             * @instance
             */
            ProhibitedUserInfo.prototype.uin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * ProhibitedUserInfo prohibitedTime.
             * @member {number} prohibitedTime
             * @memberof kritor.group.ProhibitedUserInfo
             * @instance
             */
            ProhibitedUserInfo.prototype.prohibitedTime = 0;

            /**
             * Creates a new ProhibitedUserInfo instance using the specified properties.
             * @function create
             * @memberof kritor.group.ProhibitedUserInfo
             * @static
             * @param {kritor.group.IProhibitedUserInfo=} [properties] Properties to set
             * @returns {kritor.group.ProhibitedUserInfo} ProhibitedUserInfo instance
             */
            ProhibitedUserInfo.create = function create(properties) {
                return new ProhibitedUserInfo(properties);
            };

            /**
             * Encodes the specified ProhibitedUserInfo message. Does not implicitly {@link kritor.group.ProhibitedUserInfo.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.ProhibitedUserInfo
             * @static
             * @param {kritor.group.IProhibitedUserInfo} message ProhibitedUserInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProhibitedUserInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.uid);
                if (message.uin != null && Object.hasOwnProperty.call(message, "uin"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.uin);
                if (message.prohibitedTime != null && Object.hasOwnProperty.call(message, "prohibitedTime"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.prohibitedTime);
                return writer;
            };

            /**
             * Encodes the specified ProhibitedUserInfo message, length delimited. Does not implicitly {@link kritor.group.ProhibitedUserInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.ProhibitedUserInfo
             * @static
             * @param {kritor.group.IProhibitedUserInfo} message ProhibitedUserInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ProhibitedUserInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ProhibitedUserInfo message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.ProhibitedUserInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.ProhibitedUserInfo} ProhibitedUserInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProhibitedUserInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.ProhibitedUserInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.uid = reader.string();
                            break;
                        }
                    case 2: {
                            message.uin = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.prohibitedTime = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ProhibitedUserInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.ProhibitedUserInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.ProhibitedUserInfo} ProhibitedUserInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ProhibitedUserInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ProhibitedUserInfo message.
             * @function verify
             * @memberof kritor.group.ProhibitedUserInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ProhibitedUserInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.uid != null && message.hasOwnProperty("uid"))
                    if (!$util.isString(message.uid))
                        return "uid: string expected";
                if (message.uin != null && message.hasOwnProperty("uin"))
                    if (!$util.isInteger(message.uin) && !(message.uin && $util.isInteger(message.uin.low) && $util.isInteger(message.uin.high)))
                        return "uin: integer|Long expected";
                if (message.prohibitedTime != null && message.hasOwnProperty("prohibitedTime"))
                    if (!$util.isInteger(message.prohibitedTime))
                        return "prohibitedTime: integer expected";
                return null;
            };

            /**
             * Creates a ProhibitedUserInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.ProhibitedUserInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.ProhibitedUserInfo} ProhibitedUserInfo
             */
            ProhibitedUserInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.ProhibitedUserInfo)
                    return object;
                let message = new $root.kritor.group.ProhibitedUserInfo();
                if (object.uid != null)
                    message.uid = String(object.uid);
                if (object.uin != null)
                    if ($util.Long)
                        (message.uin = $util.Long.fromValue(object.uin)).unsigned = true;
                    else if (typeof object.uin === "string")
                        message.uin = parseInt(object.uin, 10);
                    else if (typeof object.uin === "number")
                        message.uin = object.uin;
                    else if (typeof object.uin === "object")
                        message.uin = new $util.LongBits(object.uin.low >>> 0, object.uin.high >>> 0).toNumber(true);
                if (object.prohibitedTime != null)
                    message.prohibitedTime = object.prohibitedTime >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a ProhibitedUserInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.ProhibitedUserInfo
             * @static
             * @param {kritor.group.ProhibitedUserInfo} message ProhibitedUserInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ProhibitedUserInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.uid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.uin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.uin = options.longs === String ? "0" : 0;
                    object.prohibitedTime = 0;
                }
                if (message.uid != null && message.hasOwnProperty("uid"))
                    object.uid = message.uid;
                if (message.uin != null && message.hasOwnProperty("uin"))
                    if (typeof message.uin === "number")
                        object.uin = options.longs === String ? String(message.uin) : message.uin;
                    else
                        object.uin = options.longs === String ? $util.Long.prototype.toString.call(message.uin) : options.longs === Number ? new $util.LongBits(message.uin.low >>> 0, message.uin.high >>> 0).toNumber(true) : message.uin;
                if (message.prohibitedTime != null && message.hasOwnProperty("prohibitedTime"))
                    object.prohibitedTime = message.prohibitedTime;
                return object;
            };

            /**
             * Converts this ProhibitedUserInfo to JSON.
             * @function toJSON
             * @memberof kritor.group.ProhibitedUserInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ProhibitedUserInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ProhibitedUserInfo
             * @function getTypeUrl
             * @memberof kritor.group.ProhibitedUserInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ProhibitedUserInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.ProhibitedUserInfo";
            };

            return ProhibitedUserInfo;
        })();

        group.GroupHonorInfo = (function() {

            /**
             * Properties of a GroupHonorInfo.
             * @memberof kritor.group
             * @interface IGroupHonorInfo
             * @property {string|null} [uid] GroupHonorInfo uid
             * @property {number|Long|null} [uin] GroupHonorInfo uin
             * @property {string|null} [nick] GroupHonorInfo nick
             * @property {string|null} [honorName] GroupHonorInfo honorName
             * @property {string|null} [avatar] GroupHonorInfo avatar
             * @property {number|null} [id] GroupHonorInfo id
             * @property {string|null} [description] GroupHonorInfo description
             */

            /**
             * Constructs a new GroupHonorInfo.
             * @memberof kritor.group
             * @classdesc Represents a GroupHonorInfo.
             * @implements IGroupHonorInfo
             * @constructor
             * @param {kritor.group.IGroupHonorInfo=} [properties] Properties to set
             */
            function GroupHonorInfo(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupHonorInfo uid.
             * @member {string} uid
             * @memberof kritor.group.GroupHonorInfo
             * @instance
             */
            GroupHonorInfo.prototype.uid = "";

            /**
             * GroupHonorInfo uin.
             * @member {number|Long} uin
             * @memberof kritor.group.GroupHonorInfo
             * @instance
             */
            GroupHonorInfo.prototype.uin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupHonorInfo nick.
             * @member {string} nick
             * @memberof kritor.group.GroupHonorInfo
             * @instance
             */
            GroupHonorInfo.prototype.nick = "";

            /**
             * GroupHonorInfo honorName.
             * @member {string} honorName
             * @memberof kritor.group.GroupHonorInfo
             * @instance
             */
            GroupHonorInfo.prototype.honorName = "";

            /**
             * GroupHonorInfo avatar.
             * @member {string} avatar
             * @memberof kritor.group.GroupHonorInfo
             * @instance
             */
            GroupHonorInfo.prototype.avatar = "";

            /**
             * GroupHonorInfo id.
             * @member {number} id
             * @memberof kritor.group.GroupHonorInfo
             * @instance
             */
            GroupHonorInfo.prototype.id = 0;

            /**
             * GroupHonorInfo description.
             * @member {string} description
             * @memberof kritor.group.GroupHonorInfo
             * @instance
             */
            GroupHonorInfo.prototype.description = "";

            /**
             * Creates a new GroupHonorInfo instance using the specified properties.
             * @function create
             * @memberof kritor.group.GroupHonorInfo
             * @static
             * @param {kritor.group.IGroupHonorInfo=} [properties] Properties to set
             * @returns {kritor.group.GroupHonorInfo} GroupHonorInfo instance
             */
            GroupHonorInfo.create = function create(properties) {
                return new GroupHonorInfo(properties);
            };

            /**
             * Encodes the specified GroupHonorInfo message. Does not implicitly {@link kritor.group.GroupHonorInfo.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.GroupHonorInfo
             * @static
             * @param {kritor.group.IGroupHonorInfo} message GroupHonorInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupHonorInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.uid);
                if (message.uin != null && Object.hasOwnProperty.call(message, "uin"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.uin);
                if (message.nick != null && Object.hasOwnProperty.call(message, "nick"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.nick);
                if (message.honorName != null && Object.hasOwnProperty.call(message, "honorName"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.honorName);
                if (message.avatar != null && Object.hasOwnProperty.call(message, "avatar"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.avatar);
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.id);
                if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.description);
                return writer;
            };

            /**
             * Encodes the specified GroupHonorInfo message, length delimited. Does not implicitly {@link kritor.group.GroupHonorInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.GroupHonorInfo
             * @static
             * @param {kritor.group.IGroupHonorInfo} message GroupHonorInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupHonorInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupHonorInfo message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.GroupHonorInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.GroupHonorInfo} GroupHonorInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupHonorInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.GroupHonorInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.uid = reader.string();
                            break;
                        }
                    case 2: {
                            message.uin = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.nick = reader.string();
                            break;
                        }
                    case 4: {
                            message.honorName = reader.string();
                            break;
                        }
                    case 5: {
                            message.avatar = reader.string();
                            break;
                        }
                    case 6: {
                            message.id = reader.uint32();
                            break;
                        }
                    case 7: {
                            message.description = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupHonorInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.GroupHonorInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.GroupHonorInfo} GroupHonorInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupHonorInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupHonorInfo message.
             * @function verify
             * @memberof kritor.group.GroupHonorInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupHonorInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.uid != null && message.hasOwnProperty("uid"))
                    if (!$util.isString(message.uid))
                        return "uid: string expected";
                if (message.uin != null && message.hasOwnProperty("uin"))
                    if (!$util.isInteger(message.uin) && !(message.uin && $util.isInteger(message.uin.low) && $util.isInteger(message.uin.high)))
                        return "uin: integer|Long expected";
                if (message.nick != null && message.hasOwnProperty("nick"))
                    if (!$util.isString(message.nick))
                        return "nick: string expected";
                if (message.honorName != null && message.hasOwnProperty("honorName"))
                    if (!$util.isString(message.honorName))
                        return "honorName: string expected";
                if (message.avatar != null && message.hasOwnProperty("avatar"))
                    if (!$util.isString(message.avatar))
                        return "avatar: string expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isInteger(message.id))
                        return "id: integer expected";
                if (message.description != null && message.hasOwnProperty("description"))
                    if (!$util.isString(message.description))
                        return "description: string expected";
                return null;
            };

            /**
             * Creates a GroupHonorInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.GroupHonorInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.GroupHonorInfo} GroupHonorInfo
             */
            GroupHonorInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.GroupHonorInfo)
                    return object;
                let message = new $root.kritor.group.GroupHonorInfo();
                if (object.uid != null)
                    message.uid = String(object.uid);
                if (object.uin != null)
                    if ($util.Long)
                        (message.uin = $util.Long.fromValue(object.uin)).unsigned = true;
                    else if (typeof object.uin === "string")
                        message.uin = parseInt(object.uin, 10);
                    else if (typeof object.uin === "number")
                        message.uin = object.uin;
                    else if (typeof object.uin === "object")
                        message.uin = new $util.LongBits(object.uin.low >>> 0, object.uin.high >>> 0).toNumber(true);
                if (object.nick != null)
                    message.nick = String(object.nick);
                if (object.honorName != null)
                    message.honorName = String(object.honorName);
                if (object.avatar != null)
                    message.avatar = String(object.avatar);
                if (object.id != null)
                    message.id = object.id >>> 0;
                if (object.description != null)
                    message.description = String(object.description);
                return message;
            };

            /**
             * Creates a plain object from a GroupHonorInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.GroupHonorInfo
             * @static
             * @param {kritor.group.GroupHonorInfo} message GroupHonorInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupHonorInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.uid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.uin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.uin = options.longs === String ? "0" : 0;
                    object.nick = "";
                    object.honorName = "";
                    object.avatar = "";
                    object.id = 0;
                    object.description = "";
                }
                if (message.uid != null && message.hasOwnProperty("uid"))
                    object.uid = message.uid;
                if (message.uin != null && message.hasOwnProperty("uin"))
                    if (typeof message.uin === "number")
                        object.uin = options.longs === String ? String(message.uin) : message.uin;
                    else
                        object.uin = options.longs === String ? $util.Long.prototype.toString.call(message.uin) : options.longs === Number ? new $util.LongBits(message.uin.low >>> 0, message.uin.high >>> 0).toNumber(true) : message.uin;
                if (message.nick != null && message.hasOwnProperty("nick"))
                    object.nick = message.nick;
                if (message.honorName != null && message.hasOwnProperty("honorName"))
                    object.honorName = message.honorName;
                if (message.avatar != null && message.hasOwnProperty("avatar"))
                    object.avatar = message.avatar;
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.description != null && message.hasOwnProperty("description"))
                    object.description = message.description;
                return object;
            };

            /**
             * Converts this GroupHonorInfo to JSON.
             * @function toJSON
             * @memberof kritor.group.GroupHonorInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupHonorInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GroupHonorInfo
             * @function getTypeUrl
             * @memberof kritor.group.GroupHonorInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GroupHonorInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.GroupHonorInfo";
            };

            return GroupHonorInfo;
        })();

        /**
         * MemberRole enum.
         * @name kritor.group.MemberRole
         * @enum {number}
         * @property {number} ADMIN=0 ADMIN value
         * @property {number} MEMBER=1 MEMBER value
         * @property {number} OWNER=2 OWNER value
         * @property {number} STRANGER=3 STRANGER value
         */
        group.MemberRole = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "ADMIN"] = 0;
            values[valuesById[1] = "MEMBER"] = 1;
            values[valuesById[2] = "OWNER"] = 2;
            values[valuesById[3] = "STRANGER"] = 3;
            return values;
        })();

        group.GroupMemberInfo = (function() {

            /**
             * Properties of a GroupMemberInfo.
             * @memberof kritor.group
             * @interface IGroupMemberInfo
             * @property {string|null} [uid] GroupMemberInfo uid
             * @property {number|Long|null} [uin] GroupMemberInfo uin
             * @property {string|null} [nick] GroupMemberInfo nick
             * @property {number|null} [age] GroupMemberInfo age
             * @property {string|null} [uniqueTitle] GroupMemberInfo uniqueTitle
             * @property {number|null} [uniqueTitleExpireTime] GroupMemberInfo uniqueTitleExpireTime
             * @property {string|null} [card] GroupMemberInfo card
             * @property {number|Long|null} [joinTime] GroupMemberInfo joinTime
             * @property {number|Long|null} [lastActiveTime] GroupMemberInfo lastActiveTime
             * @property {number|null} [level] GroupMemberInfo level
             * @property {number|Long|null} [shutUpTimestamp] GroupMemberInfo shutUpTimestamp
             * @property {number|null} [distance] GroupMemberInfo distance
             * @property {Array.<number>|null} [honors] GroupMemberInfo honors
             * @property {boolean|null} [unfriendly] GroupMemberInfo unfriendly
             * @property {boolean|null} [cardChangeable] GroupMemberInfo cardChangeable
             */

            /**
             * Constructs a new GroupMemberInfo.
             * @memberof kritor.group
             * @classdesc Represents a GroupMemberInfo.
             * @implements IGroupMemberInfo
             * @constructor
             * @param {kritor.group.IGroupMemberInfo=} [properties] Properties to set
             */
            function GroupMemberInfo(properties) {
                this.honors = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupMemberInfo uid.
             * @member {string} uid
             * @memberof kritor.group.GroupMemberInfo
             * @instance
             */
            GroupMemberInfo.prototype.uid = "";

            /**
             * GroupMemberInfo uin.
             * @member {number|Long} uin
             * @memberof kritor.group.GroupMemberInfo
             * @instance
             */
            GroupMemberInfo.prototype.uin = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupMemberInfo nick.
             * @member {string} nick
             * @memberof kritor.group.GroupMemberInfo
             * @instance
             */
            GroupMemberInfo.prototype.nick = "";

            /**
             * GroupMemberInfo age.
             * @member {number} age
             * @memberof kritor.group.GroupMemberInfo
             * @instance
             */
            GroupMemberInfo.prototype.age = 0;

            /**
             * GroupMemberInfo uniqueTitle.
             * @member {string} uniqueTitle
             * @memberof kritor.group.GroupMemberInfo
             * @instance
             */
            GroupMemberInfo.prototype.uniqueTitle = "";

            /**
             * GroupMemberInfo uniqueTitleExpireTime.
             * @member {number} uniqueTitleExpireTime
             * @memberof kritor.group.GroupMemberInfo
             * @instance
             */
            GroupMemberInfo.prototype.uniqueTitleExpireTime = 0;

            /**
             * GroupMemberInfo card.
             * @member {string} card
             * @memberof kritor.group.GroupMemberInfo
             * @instance
             */
            GroupMemberInfo.prototype.card = "";

            /**
             * GroupMemberInfo joinTime.
             * @member {number|Long} joinTime
             * @memberof kritor.group.GroupMemberInfo
             * @instance
             */
            GroupMemberInfo.prototype.joinTime = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupMemberInfo lastActiveTime.
             * @member {number|Long} lastActiveTime
             * @memberof kritor.group.GroupMemberInfo
             * @instance
             */
            GroupMemberInfo.prototype.lastActiveTime = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupMemberInfo level.
             * @member {number} level
             * @memberof kritor.group.GroupMemberInfo
             * @instance
             */
            GroupMemberInfo.prototype.level = 0;

            /**
             * GroupMemberInfo shutUpTimestamp.
             * @member {number|Long} shutUpTimestamp
             * @memberof kritor.group.GroupMemberInfo
             * @instance
             */
            GroupMemberInfo.prototype.shutUpTimestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupMemberInfo distance.
             * @member {number|null|undefined} distance
             * @memberof kritor.group.GroupMemberInfo
             * @instance
             */
            GroupMemberInfo.prototype.distance = null;

            /**
             * GroupMemberInfo honors.
             * @member {Array.<number>} honors
             * @memberof kritor.group.GroupMemberInfo
             * @instance
             */
            GroupMemberInfo.prototype.honors = $util.emptyArray;

            /**
             * GroupMemberInfo unfriendly.
             * @member {boolean|null|undefined} unfriendly
             * @memberof kritor.group.GroupMemberInfo
             * @instance
             */
            GroupMemberInfo.prototype.unfriendly = null;

            /**
             * GroupMemberInfo cardChangeable.
             * @member {boolean|null|undefined} cardChangeable
             * @memberof kritor.group.GroupMemberInfo
             * @instance
             */
            GroupMemberInfo.prototype.cardChangeable = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * GroupMemberInfo _distance.
             * @member {"distance"|undefined} _distance
             * @memberof kritor.group.GroupMemberInfo
             * @instance
             */
            Object.defineProperty(GroupMemberInfo.prototype, "_distance", {
                get: $util.oneOfGetter($oneOfFields = ["distance"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * GroupMemberInfo _unfriendly.
             * @member {"unfriendly"|undefined} _unfriendly
             * @memberof kritor.group.GroupMemberInfo
             * @instance
             */
            Object.defineProperty(GroupMemberInfo.prototype, "_unfriendly", {
                get: $util.oneOfGetter($oneOfFields = ["unfriendly"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * GroupMemberInfo _cardChangeable.
             * @member {"cardChangeable"|undefined} _cardChangeable
             * @memberof kritor.group.GroupMemberInfo
             * @instance
             */
            Object.defineProperty(GroupMemberInfo.prototype, "_cardChangeable", {
                get: $util.oneOfGetter($oneOfFields = ["cardChangeable"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new GroupMemberInfo instance using the specified properties.
             * @function create
             * @memberof kritor.group.GroupMemberInfo
             * @static
             * @param {kritor.group.IGroupMemberInfo=} [properties] Properties to set
             * @returns {kritor.group.GroupMemberInfo} GroupMemberInfo instance
             */
            GroupMemberInfo.create = function create(properties) {
                return new GroupMemberInfo(properties);
            };

            /**
             * Encodes the specified GroupMemberInfo message. Does not implicitly {@link kritor.group.GroupMemberInfo.verify|verify} messages.
             * @function encode
             * @memberof kritor.group.GroupMemberInfo
             * @static
             * @param {kritor.group.IGroupMemberInfo} message GroupMemberInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupMemberInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uid != null && Object.hasOwnProperty.call(message, "uid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.uid);
                if (message.uin != null && Object.hasOwnProperty.call(message, "uin"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.uin);
                if (message.nick != null && Object.hasOwnProperty.call(message, "nick"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.nick);
                if (message.age != null && Object.hasOwnProperty.call(message, "age"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.age);
                if (message.uniqueTitle != null && Object.hasOwnProperty.call(message, "uniqueTitle"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.uniqueTitle);
                if (message.uniqueTitleExpireTime != null && Object.hasOwnProperty.call(message, "uniqueTitleExpireTime"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.uniqueTitleExpireTime);
                if (message.card != null && Object.hasOwnProperty.call(message, "card"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.card);
                if (message.joinTime != null && Object.hasOwnProperty.call(message, "joinTime"))
                    writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.joinTime);
                if (message.lastActiveTime != null && Object.hasOwnProperty.call(message, "lastActiveTime"))
                    writer.uint32(/* id 9, wireType 0 =*/72).uint64(message.lastActiveTime);
                if (message.level != null && Object.hasOwnProperty.call(message, "level"))
                    writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.level);
                if (message.shutUpTimestamp != null && Object.hasOwnProperty.call(message, "shutUpTimestamp"))
                    writer.uint32(/* id 11, wireType 0 =*/88).uint64(message.shutUpTimestamp);
                if (message.distance != null && Object.hasOwnProperty.call(message, "distance"))
                    writer.uint32(/* id 100, wireType 0 =*/800).uint32(message.distance);
                if (message.honors != null && message.honors.length) {
                    writer.uint32(/* id 101, wireType 2 =*/810).fork();
                    for (let i = 0; i < message.honors.length; ++i)
                        writer.uint32(message.honors[i]);
                    writer.ldelim();
                }
                if (message.unfriendly != null && Object.hasOwnProperty.call(message, "unfriendly"))
                    writer.uint32(/* id 102, wireType 0 =*/816).bool(message.unfriendly);
                if (message.cardChangeable != null && Object.hasOwnProperty.call(message, "cardChangeable"))
                    writer.uint32(/* id 103, wireType 0 =*/824).bool(message.cardChangeable);
                return writer;
            };

            /**
             * Encodes the specified GroupMemberInfo message, length delimited. Does not implicitly {@link kritor.group.GroupMemberInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.group.GroupMemberInfo
             * @static
             * @param {kritor.group.IGroupMemberInfo} message GroupMemberInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupMemberInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupMemberInfo message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.group.GroupMemberInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.group.GroupMemberInfo} GroupMemberInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupMemberInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.group.GroupMemberInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.uid = reader.string();
                            break;
                        }
                    case 2: {
                            message.uin = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.nick = reader.string();
                            break;
                        }
                    case 4: {
                            message.age = reader.uint32();
                            break;
                        }
                    case 5: {
                            message.uniqueTitle = reader.string();
                            break;
                        }
                    case 6: {
                            message.uniqueTitleExpireTime = reader.uint32();
                            break;
                        }
                    case 7: {
                            message.card = reader.string();
                            break;
                        }
                    case 8: {
                            message.joinTime = reader.uint64();
                            break;
                        }
                    case 9: {
                            message.lastActiveTime = reader.uint64();
                            break;
                        }
                    case 10: {
                            message.level = reader.uint32();
                            break;
                        }
                    case 11: {
                            message.shutUpTimestamp = reader.uint64();
                            break;
                        }
                    case 100: {
                            message.distance = reader.uint32();
                            break;
                        }
                    case 101: {
                            if (!(message.honors && message.honors.length))
                                message.honors = [];
                            if ((tag & 7) === 2) {
                                let end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.honors.push(reader.uint32());
                            } else
                                message.honors.push(reader.uint32());
                            break;
                        }
                    case 102: {
                            message.unfriendly = reader.bool();
                            break;
                        }
                    case 103: {
                            message.cardChangeable = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupMemberInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.group.GroupMemberInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.group.GroupMemberInfo} GroupMemberInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupMemberInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupMemberInfo message.
             * @function verify
             * @memberof kritor.group.GroupMemberInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupMemberInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.uid != null && message.hasOwnProperty("uid"))
                    if (!$util.isString(message.uid))
                        return "uid: string expected";
                if (message.uin != null && message.hasOwnProperty("uin"))
                    if (!$util.isInteger(message.uin) && !(message.uin && $util.isInteger(message.uin.low) && $util.isInteger(message.uin.high)))
                        return "uin: integer|Long expected";
                if (message.nick != null && message.hasOwnProperty("nick"))
                    if (!$util.isString(message.nick))
                        return "nick: string expected";
                if (message.age != null && message.hasOwnProperty("age"))
                    if (!$util.isInteger(message.age))
                        return "age: integer expected";
                if (message.uniqueTitle != null && message.hasOwnProperty("uniqueTitle"))
                    if (!$util.isString(message.uniqueTitle))
                        return "uniqueTitle: string expected";
                if (message.uniqueTitleExpireTime != null && message.hasOwnProperty("uniqueTitleExpireTime"))
                    if (!$util.isInteger(message.uniqueTitleExpireTime))
                        return "uniqueTitleExpireTime: integer expected";
                if (message.card != null && message.hasOwnProperty("card"))
                    if (!$util.isString(message.card))
                        return "card: string expected";
                if (message.joinTime != null && message.hasOwnProperty("joinTime"))
                    if (!$util.isInteger(message.joinTime) && !(message.joinTime && $util.isInteger(message.joinTime.low) && $util.isInteger(message.joinTime.high)))
                        return "joinTime: integer|Long expected";
                if (message.lastActiveTime != null && message.hasOwnProperty("lastActiveTime"))
                    if (!$util.isInteger(message.lastActiveTime) && !(message.lastActiveTime && $util.isInteger(message.lastActiveTime.low) && $util.isInteger(message.lastActiveTime.high)))
                        return "lastActiveTime: integer|Long expected";
                if (message.level != null && message.hasOwnProperty("level"))
                    if (!$util.isInteger(message.level))
                        return "level: integer expected";
                if (message.shutUpTimestamp != null && message.hasOwnProperty("shutUpTimestamp"))
                    if (!$util.isInteger(message.shutUpTimestamp) && !(message.shutUpTimestamp && $util.isInteger(message.shutUpTimestamp.low) && $util.isInteger(message.shutUpTimestamp.high)))
                        return "shutUpTimestamp: integer|Long expected";
                if (message.distance != null && message.hasOwnProperty("distance")) {
                    properties._distance = 1;
                    if (!$util.isInteger(message.distance))
                        return "distance: integer expected";
                }
                if (message.honors != null && message.hasOwnProperty("honors")) {
                    if (!Array.isArray(message.honors))
                        return "honors: array expected";
                    for (let i = 0; i < message.honors.length; ++i)
                        if (!$util.isInteger(message.honors[i]))
                            return "honors: integer[] expected";
                }
                if (message.unfriendly != null && message.hasOwnProperty("unfriendly")) {
                    properties._unfriendly = 1;
                    if (typeof message.unfriendly !== "boolean")
                        return "unfriendly: boolean expected";
                }
                if (message.cardChangeable != null && message.hasOwnProperty("cardChangeable")) {
                    properties._cardChangeable = 1;
                    if (typeof message.cardChangeable !== "boolean")
                        return "cardChangeable: boolean expected";
                }
                return null;
            };

            /**
             * Creates a GroupMemberInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.group.GroupMemberInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.group.GroupMemberInfo} GroupMemberInfo
             */
            GroupMemberInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.group.GroupMemberInfo)
                    return object;
                let message = new $root.kritor.group.GroupMemberInfo();
                if (object.uid != null)
                    message.uid = String(object.uid);
                if (object.uin != null)
                    if ($util.Long)
                        (message.uin = $util.Long.fromValue(object.uin)).unsigned = true;
                    else if (typeof object.uin === "string")
                        message.uin = parseInt(object.uin, 10);
                    else if (typeof object.uin === "number")
                        message.uin = object.uin;
                    else if (typeof object.uin === "object")
                        message.uin = new $util.LongBits(object.uin.low >>> 0, object.uin.high >>> 0).toNumber(true);
                if (object.nick != null)
                    message.nick = String(object.nick);
                if (object.age != null)
                    message.age = object.age >>> 0;
                if (object.uniqueTitle != null)
                    message.uniqueTitle = String(object.uniqueTitle);
                if (object.uniqueTitleExpireTime != null)
                    message.uniqueTitleExpireTime = object.uniqueTitleExpireTime >>> 0;
                if (object.card != null)
                    message.card = String(object.card);
                if (object.joinTime != null)
                    if ($util.Long)
                        (message.joinTime = $util.Long.fromValue(object.joinTime)).unsigned = true;
                    else if (typeof object.joinTime === "string")
                        message.joinTime = parseInt(object.joinTime, 10);
                    else if (typeof object.joinTime === "number")
                        message.joinTime = object.joinTime;
                    else if (typeof object.joinTime === "object")
                        message.joinTime = new $util.LongBits(object.joinTime.low >>> 0, object.joinTime.high >>> 0).toNumber(true);
                if (object.lastActiveTime != null)
                    if ($util.Long)
                        (message.lastActiveTime = $util.Long.fromValue(object.lastActiveTime)).unsigned = true;
                    else if (typeof object.lastActiveTime === "string")
                        message.lastActiveTime = parseInt(object.lastActiveTime, 10);
                    else if (typeof object.lastActiveTime === "number")
                        message.lastActiveTime = object.lastActiveTime;
                    else if (typeof object.lastActiveTime === "object")
                        message.lastActiveTime = new $util.LongBits(object.lastActiveTime.low >>> 0, object.lastActiveTime.high >>> 0).toNumber(true);
                if (object.level != null)
                    message.level = object.level >>> 0;
                if (object.shutUpTimestamp != null)
                    if ($util.Long)
                        (message.shutUpTimestamp = $util.Long.fromValue(object.shutUpTimestamp)).unsigned = true;
                    else if (typeof object.shutUpTimestamp === "string")
                        message.shutUpTimestamp = parseInt(object.shutUpTimestamp, 10);
                    else if (typeof object.shutUpTimestamp === "number")
                        message.shutUpTimestamp = object.shutUpTimestamp;
                    else if (typeof object.shutUpTimestamp === "object")
                        message.shutUpTimestamp = new $util.LongBits(object.shutUpTimestamp.low >>> 0, object.shutUpTimestamp.high >>> 0).toNumber(true);
                if (object.distance != null)
                    message.distance = object.distance >>> 0;
                if (object.honors) {
                    if (!Array.isArray(object.honors))
                        throw TypeError(".kritor.group.GroupMemberInfo.honors: array expected");
                    message.honors = [];
                    for (let i = 0; i < object.honors.length; ++i)
                        message.honors[i] = object.honors[i] >>> 0;
                }
                if (object.unfriendly != null)
                    message.unfriendly = Boolean(object.unfriendly);
                if (object.cardChangeable != null)
                    message.cardChangeable = Boolean(object.cardChangeable);
                return message;
            };

            /**
             * Creates a plain object from a GroupMemberInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.group.GroupMemberInfo
             * @static
             * @param {kritor.group.GroupMemberInfo} message GroupMemberInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupMemberInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.honors = [];
                if (options.defaults) {
                    object.uid = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.uin = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.uin = options.longs === String ? "0" : 0;
                    object.nick = "";
                    object.age = 0;
                    object.uniqueTitle = "";
                    object.uniqueTitleExpireTime = 0;
                    object.card = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.joinTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.joinTime = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.lastActiveTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.lastActiveTime = options.longs === String ? "0" : 0;
                    object.level = 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.shutUpTimestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.shutUpTimestamp = options.longs === String ? "0" : 0;
                }
                if (message.uid != null && message.hasOwnProperty("uid"))
                    object.uid = message.uid;
                if (message.uin != null && message.hasOwnProperty("uin"))
                    if (typeof message.uin === "number")
                        object.uin = options.longs === String ? String(message.uin) : message.uin;
                    else
                        object.uin = options.longs === String ? $util.Long.prototype.toString.call(message.uin) : options.longs === Number ? new $util.LongBits(message.uin.low >>> 0, message.uin.high >>> 0).toNumber(true) : message.uin;
                if (message.nick != null && message.hasOwnProperty("nick"))
                    object.nick = message.nick;
                if (message.age != null && message.hasOwnProperty("age"))
                    object.age = message.age;
                if (message.uniqueTitle != null && message.hasOwnProperty("uniqueTitle"))
                    object.uniqueTitle = message.uniqueTitle;
                if (message.uniqueTitleExpireTime != null && message.hasOwnProperty("uniqueTitleExpireTime"))
                    object.uniqueTitleExpireTime = message.uniqueTitleExpireTime;
                if (message.card != null && message.hasOwnProperty("card"))
                    object.card = message.card;
                if (message.joinTime != null && message.hasOwnProperty("joinTime"))
                    if (typeof message.joinTime === "number")
                        object.joinTime = options.longs === String ? String(message.joinTime) : message.joinTime;
                    else
                        object.joinTime = options.longs === String ? $util.Long.prototype.toString.call(message.joinTime) : options.longs === Number ? new $util.LongBits(message.joinTime.low >>> 0, message.joinTime.high >>> 0).toNumber(true) : message.joinTime;
                if (message.lastActiveTime != null && message.hasOwnProperty("lastActiveTime"))
                    if (typeof message.lastActiveTime === "number")
                        object.lastActiveTime = options.longs === String ? String(message.lastActiveTime) : message.lastActiveTime;
                    else
                        object.lastActiveTime = options.longs === String ? $util.Long.prototype.toString.call(message.lastActiveTime) : options.longs === Number ? new $util.LongBits(message.lastActiveTime.low >>> 0, message.lastActiveTime.high >>> 0).toNumber(true) : message.lastActiveTime;
                if (message.level != null && message.hasOwnProperty("level"))
                    object.level = message.level;
                if (message.shutUpTimestamp != null && message.hasOwnProperty("shutUpTimestamp"))
                    if (typeof message.shutUpTimestamp === "number")
                        object.shutUpTimestamp = options.longs === String ? String(message.shutUpTimestamp) : message.shutUpTimestamp;
                    else
                        object.shutUpTimestamp = options.longs === String ? $util.Long.prototype.toString.call(message.shutUpTimestamp) : options.longs === Number ? new $util.LongBits(message.shutUpTimestamp.low >>> 0, message.shutUpTimestamp.high >>> 0).toNumber(true) : message.shutUpTimestamp;
                if (message.distance != null && message.hasOwnProperty("distance")) {
                    object.distance = message.distance;
                    if (options.oneofs)
                        object._distance = "distance";
                }
                if (message.honors && message.honors.length) {
                    object.honors = [];
                    for (let j = 0; j < message.honors.length; ++j)
                        object.honors[j] = message.honors[j];
                }
                if (message.unfriendly != null && message.hasOwnProperty("unfriendly")) {
                    object.unfriendly = message.unfriendly;
                    if (options.oneofs)
                        object._unfriendly = "unfriendly";
                }
                if (message.cardChangeable != null && message.hasOwnProperty("cardChangeable")) {
                    object.cardChangeable = message.cardChangeable;
                    if (options.oneofs)
                        object._cardChangeable = "cardChangeable";
                }
                return object;
            };

            /**
             * Converts this GroupMemberInfo to JSON.
             * @function toJSON
             * @memberof kritor.group.GroupMemberInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupMemberInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GroupMemberInfo
             * @function getTypeUrl
             * @memberof kritor.group.GroupMemberInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GroupMemberInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.group.GroupMemberInfo";
            };

            return GroupMemberInfo;
        })();

        return group;
    })();

    kritor.guild = (function() {

        /**
         * Namespace guild.
         * @memberof kritor
         * @namespace
         */
        const guild = {};

        guild.GuildService = (function() {

            /**
             * Constructs a new GuildService service.
             * @memberof kritor.guild
             * @classdesc Represents a GuildService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function GuildService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (GuildService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = GuildService;

            /**
             * Creates new GuildService service using the specified rpc implementation.
             * @function create
             * @memberof kritor.guild.GuildService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {GuildService} RPC service. Useful where requests and/or responses are streamed.
             */
            GuildService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link kritor.guild.GuildService#getBotInfo}.
             * @memberof kritor.guild.GuildService
             * @typedef GetBotInfoCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.guild.GetBotInfoResponse} [response] GetBotInfoResponse
             */

            /**
             * Calls GetBotInfo.
             * @function getBotInfo
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.IGetBotInfoRequest} request GetBotInfoRequest message or plain object
             * @param {kritor.guild.GuildService.GetBotInfoCallback} callback Node-style callback called with the error, if any, and GetBotInfoResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GuildService.prototype.getBotInfo = function getBotInfo(request, callback) {
                return this.rpcCall(getBotInfo, $root.kritor.guild.GetBotInfoRequest, $root.kritor.guild.GetBotInfoResponse, request, callback);
            }, "name", { value: "GetBotInfo" });

            /**
             * Calls GetBotInfo.
             * @function getBotInfo
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.IGetBotInfoRequest} request GetBotInfoRequest message or plain object
             * @returns {Promise<kritor.guild.GetBotInfoResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.guild.GuildService#getChannelList}.
             * @memberof kritor.guild.GuildService
             * @typedef GetChannelListCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.guild.GetChannelListResponse} [response] GetChannelListResponse
             */

            /**
             * Calls GetChannelList.
             * @function getChannelList
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.IGetChannelListRequest} request GetChannelListRequest message or plain object
             * @param {kritor.guild.GuildService.GetChannelListCallback} callback Node-style callback called with the error, if any, and GetChannelListResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GuildService.prototype.getChannelList = function getChannelList(request, callback) {
                return this.rpcCall(getChannelList, $root.kritor.guild.GetChannelListRequest, $root.kritor.guild.GetChannelListResponse, request, callback);
            }, "name", { value: "GetChannelList" });

            /**
             * Calls GetChannelList.
             * @function getChannelList
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.IGetChannelListRequest} request GetChannelListRequest message or plain object
             * @returns {Promise<kritor.guild.GetChannelListResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.guild.GuildService#getGuildMetaByGuest}.
             * @memberof kritor.guild.GuildService
             * @typedef GetGuildMetaByGuestCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.guild.GetGuildMetaByGuestResponse} [response] GetGuildMetaByGuestResponse
             */

            /**
             * Calls GetGuildMetaByGuest.
             * @function getGuildMetaByGuest
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.IGetGuildMetaByGuestRequest} request GetGuildMetaByGuestRequest message or plain object
             * @param {kritor.guild.GuildService.GetGuildMetaByGuestCallback} callback Node-style callback called with the error, if any, and GetGuildMetaByGuestResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GuildService.prototype.getGuildMetaByGuest = function getGuildMetaByGuest(request, callback) {
                return this.rpcCall(getGuildMetaByGuest, $root.kritor.guild.GetGuildMetaByGuestRequest, $root.kritor.guild.GetGuildMetaByGuestResponse, request, callback);
            }, "name", { value: "GetGuildMetaByGuest" });

            /**
             * Calls GetGuildMetaByGuest.
             * @function getGuildMetaByGuest
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.IGetGuildMetaByGuestRequest} request GetGuildMetaByGuestRequest message or plain object
             * @returns {Promise<kritor.guild.GetGuildMetaByGuestResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.guild.GuildService#getGuildChannelList}.
             * @memberof kritor.guild.GuildService
             * @typedef GetGuildChannelListCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.guild.GetGuildChannelListResponse} [response] GetGuildChannelListResponse
             */

            /**
             * Calls GetGuildChannelList.
             * @function getGuildChannelList
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.IGetGuildChannelListRequest} request GetGuildChannelListRequest message or plain object
             * @param {kritor.guild.GuildService.GetGuildChannelListCallback} callback Node-style callback called with the error, if any, and GetGuildChannelListResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GuildService.prototype.getGuildChannelList = function getGuildChannelList(request, callback) {
                return this.rpcCall(getGuildChannelList, $root.kritor.guild.GetGuildChannelListRequest, $root.kritor.guild.GetGuildChannelListResponse, request, callback);
            }, "name", { value: "GetGuildChannelList" });

            /**
             * Calls GetGuildChannelList.
             * @function getGuildChannelList
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.IGetGuildChannelListRequest} request GetGuildChannelListRequest message or plain object
             * @returns {Promise<kritor.guild.GetGuildChannelListResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.guild.GuildService#getGuildMemberList}.
             * @memberof kritor.guild.GuildService
             * @typedef GetGuildMemberListCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.guild.GetGuildMemberListResponse} [response] GetGuildMemberListResponse
             */

            /**
             * Calls GetGuildMemberList.
             * @function getGuildMemberList
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.IGetGuildMemberListRequest} request GetGuildMemberListRequest message or plain object
             * @param {kritor.guild.GuildService.GetGuildMemberListCallback} callback Node-style callback called with the error, if any, and GetGuildMemberListResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GuildService.prototype.getGuildMemberList = function getGuildMemberList(request, callback) {
                return this.rpcCall(getGuildMemberList, $root.kritor.guild.GetGuildMemberListRequest, $root.kritor.guild.GetGuildMemberListResponse, request, callback);
            }, "name", { value: "GetGuildMemberList" });

            /**
             * Calls GetGuildMemberList.
             * @function getGuildMemberList
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.IGetGuildMemberListRequest} request GetGuildMemberListRequest message or plain object
             * @returns {Promise<kritor.guild.GetGuildMemberListResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.guild.GuildService#getGuildMember}.
             * @memberof kritor.guild.GuildService
             * @typedef GetGuildMemberCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.guild.GetGuildMemberResponse} [response] GetGuildMemberResponse
             */

            /**
             * Calls GetGuildMember.
             * @function getGuildMember
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.IGetGuildMemberRequest} request GetGuildMemberRequest message or plain object
             * @param {kritor.guild.GuildService.GetGuildMemberCallback} callback Node-style callback called with the error, if any, and GetGuildMemberResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GuildService.prototype.getGuildMember = function getGuildMember(request, callback) {
                return this.rpcCall(getGuildMember, $root.kritor.guild.GetGuildMemberRequest, $root.kritor.guild.GetGuildMemberResponse, request, callback);
            }, "name", { value: "GetGuildMember" });

            /**
             * Calls GetGuildMember.
             * @function getGuildMember
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.IGetGuildMemberRequest} request GetGuildMemberRequest message or plain object
             * @returns {Promise<kritor.guild.GetGuildMemberResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.guild.GuildService#sendChannelMessage}.
             * @memberof kritor.guild.GuildService
             * @typedef SendChannelMessageCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.guild.SendChannelMessageResponse} [response] SendChannelMessageResponse
             */

            /**
             * Calls SendChannelMessage.
             * @function sendChannelMessage
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.ISendChannelMessageRequest} request SendChannelMessageRequest message or plain object
             * @param {kritor.guild.GuildService.SendChannelMessageCallback} callback Node-style callback called with the error, if any, and SendChannelMessageResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GuildService.prototype.sendChannelMessage = function sendChannelMessage(request, callback) {
                return this.rpcCall(sendChannelMessage, $root.kritor.guild.SendChannelMessageRequest, $root.kritor.guild.SendChannelMessageResponse, request, callback);
            }, "name", { value: "SendChannelMessage" });

            /**
             * Calls SendChannelMessage.
             * @function sendChannelMessage
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.ISendChannelMessageRequest} request SendChannelMessageRequest message or plain object
             * @returns {Promise<kritor.guild.SendChannelMessageResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.guild.GuildService#getGuildFeedList}.
             * @memberof kritor.guild.GuildService
             * @typedef GetGuildFeedListCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.guild.GetGuildFeedListResponse} [response] GetGuildFeedListResponse
             */

            /**
             * Calls GetGuildFeedList.
             * @function getGuildFeedList
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.IGetGuildFeedListRequest} request GetGuildFeedListRequest message or plain object
             * @param {kritor.guild.GuildService.GetGuildFeedListCallback} callback Node-style callback called with the error, if any, and GetGuildFeedListResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GuildService.prototype.getGuildFeedList = function getGuildFeedList(request, callback) {
                return this.rpcCall(getGuildFeedList, $root.kritor.guild.GetGuildFeedListRequest, $root.kritor.guild.GetGuildFeedListResponse, request, callback);
            }, "name", { value: "GetGuildFeedList" });

            /**
             * Calls GetGuildFeedList.
             * @function getGuildFeedList
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.IGetGuildFeedListRequest} request GetGuildFeedListRequest message or plain object
             * @returns {Promise<kritor.guild.GetGuildFeedListResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.guild.GuildService#getGuildRoleList}.
             * @memberof kritor.guild.GuildService
             * @typedef GetGuildRoleListCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.guild.GetGuildRoleListResponse} [response] GetGuildRoleListResponse
             */

            /**
             * Calls GetGuildRoleList.
             * @function getGuildRoleList
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.IGetGuildRoleListRequest} request GetGuildRoleListRequest message or plain object
             * @param {kritor.guild.GuildService.GetGuildRoleListCallback} callback Node-style callback called with the error, if any, and GetGuildRoleListResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GuildService.prototype.getGuildRoleList = function getGuildRoleList(request, callback) {
                return this.rpcCall(getGuildRoleList, $root.kritor.guild.GetGuildRoleListRequest, $root.kritor.guild.GetGuildRoleListResponse, request, callback);
            }, "name", { value: "GetGuildRoleList" });

            /**
             * Calls GetGuildRoleList.
             * @function getGuildRoleList
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.IGetGuildRoleListRequest} request GetGuildRoleListRequest message or plain object
             * @returns {Promise<kritor.guild.GetGuildRoleListResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.guild.GuildService#deleteGuildRole}.
             * @memberof kritor.guild.GuildService
             * @typedef DeleteGuildRoleCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.guild.DeleteGuildRoleResponse} [response] DeleteGuildRoleResponse
             */

            /**
             * Calls DeleteGuildRole.
             * @function deleteGuildRole
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.IDeleteGuildRoleRequest} request DeleteGuildRoleRequest message or plain object
             * @param {kritor.guild.GuildService.DeleteGuildRoleCallback} callback Node-style callback called with the error, if any, and DeleteGuildRoleResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GuildService.prototype.deleteGuildRole = function deleteGuildRole(request, callback) {
                return this.rpcCall(deleteGuildRole, $root.kritor.guild.DeleteGuildRoleRequest, $root.kritor.guild.DeleteGuildRoleResponse, request, callback);
            }, "name", { value: "DeleteGuildRole" });

            /**
             * Calls DeleteGuildRole.
             * @function deleteGuildRole
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.IDeleteGuildRoleRequest} request DeleteGuildRoleRequest message or plain object
             * @returns {Promise<kritor.guild.DeleteGuildRoleResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.guild.GuildService#setGuildMemberRole}.
             * @memberof kritor.guild.GuildService
             * @typedef SetGuildMemberRoleCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.guild.SetGuildMemberRoleResponse} [response] SetGuildMemberRoleResponse
             */

            /**
             * Calls SetGuildMemberRole.
             * @function setGuildMemberRole
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.ISetGuildMemberRoleRequest} request SetGuildMemberRoleRequest message or plain object
             * @param {kritor.guild.GuildService.SetGuildMemberRoleCallback} callback Node-style callback called with the error, if any, and SetGuildMemberRoleResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GuildService.prototype.setGuildMemberRole = function setGuildMemberRole(request, callback) {
                return this.rpcCall(setGuildMemberRole, $root.kritor.guild.SetGuildMemberRoleRequest, $root.kritor.guild.SetGuildMemberRoleResponse, request, callback);
            }, "name", { value: "SetGuildMemberRole" });

            /**
             * Calls SetGuildMemberRole.
             * @function setGuildMemberRole
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.ISetGuildMemberRoleRequest} request SetGuildMemberRoleRequest message or plain object
             * @returns {Promise<kritor.guild.SetGuildMemberRoleResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.guild.GuildService#updateGuildRole}.
             * @memberof kritor.guild.GuildService
             * @typedef UpdateGuildRoleCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.guild.UpdateGuildRoleResponse} [response] UpdateGuildRoleResponse
             */

            /**
             * Calls UpdateGuildRole.
             * @function updateGuildRole
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.IUpdateGuildRoleRequest} request UpdateGuildRoleRequest message or plain object
             * @param {kritor.guild.GuildService.UpdateGuildRoleCallback} callback Node-style callback called with the error, if any, and UpdateGuildRoleResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GuildService.prototype.updateGuildRole = function updateGuildRole(request, callback) {
                return this.rpcCall(updateGuildRole, $root.kritor.guild.UpdateGuildRoleRequest, $root.kritor.guild.UpdateGuildRoleResponse, request, callback);
            }, "name", { value: "UpdateGuildRole" });

            /**
             * Calls UpdateGuildRole.
             * @function updateGuildRole
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.IUpdateGuildRoleRequest} request UpdateGuildRoleRequest message or plain object
             * @returns {Promise<kritor.guild.UpdateGuildRoleResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.guild.GuildService#createGuildRole}.
             * @memberof kritor.guild.GuildService
             * @typedef CreateGuildRoleCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.guild.CreateGuildRoleResponse} [response] CreateGuildRoleResponse
             */

            /**
             * Calls CreateGuildRole.
             * @function createGuildRole
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.ICreateGuildRoleRequest} request CreateGuildRoleRequest message or plain object
             * @param {kritor.guild.GuildService.CreateGuildRoleCallback} callback Node-style callback called with the error, if any, and CreateGuildRoleResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(GuildService.prototype.createGuildRole = function createGuildRole(request, callback) {
                return this.rpcCall(createGuildRole, $root.kritor.guild.CreateGuildRoleRequest, $root.kritor.guild.CreateGuildRoleResponse, request, callback);
            }, "name", { value: "CreateGuildRole" });

            /**
             * Calls CreateGuildRole.
             * @function createGuildRole
             * @memberof kritor.guild.GuildService
             * @instance
             * @param {kritor.guild.ICreateGuildRoleRequest} request CreateGuildRoleRequest message or plain object
             * @returns {Promise<kritor.guild.CreateGuildRoleResponse>} Promise
             * @variation 2
             */

            return GuildService;
        })();

        guild.GetBotInfoRequest = (function() {

            /**
             * Properties of a GetBotInfoRequest.
             * @memberof kritor.guild
             * @interface IGetBotInfoRequest
             */

            /**
             * Constructs a new GetBotInfoRequest.
             * @memberof kritor.guild
             * @classdesc Represents a GetBotInfoRequest.
             * @implements IGetBotInfoRequest
             * @constructor
             * @param {kritor.guild.IGetBotInfoRequest=} [properties] Properties to set
             */
            function GetBotInfoRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new GetBotInfoRequest instance using the specified properties.
             * @function create
             * @memberof kritor.guild.GetBotInfoRequest
             * @static
             * @param {kritor.guild.IGetBotInfoRequest=} [properties] Properties to set
             * @returns {kritor.guild.GetBotInfoRequest} GetBotInfoRequest instance
             */
            GetBotInfoRequest.create = function create(properties) {
                return new GetBotInfoRequest(properties);
            };

            /**
             * Encodes the specified GetBotInfoRequest message. Does not implicitly {@link kritor.guild.GetBotInfoRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.GetBotInfoRequest
             * @static
             * @param {kritor.guild.IGetBotInfoRequest} message GetBotInfoRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetBotInfoRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified GetBotInfoRequest message, length delimited. Does not implicitly {@link kritor.guild.GetBotInfoRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.GetBotInfoRequest
             * @static
             * @param {kritor.guild.IGetBotInfoRequest} message GetBotInfoRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetBotInfoRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetBotInfoRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.GetBotInfoRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.GetBotInfoRequest} GetBotInfoRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetBotInfoRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.GetBotInfoRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetBotInfoRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.GetBotInfoRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.GetBotInfoRequest} GetBotInfoRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetBotInfoRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetBotInfoRequest message.
             * @function verify
             * @memberof kritor.guild.GetBotInfoRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetBotInfoRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a GetBotInfoRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.GetBotInfoRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.GetBotInfoRequest} GetBotInfoRequest
             */
            GetBotInfoRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.GetBotInfoRequest)
                    return object;
                return new $root.kritor.guild.GetBotInfoRequest();
            };

            /**
             * Creates a plain object from a GetBotInfoRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.GetBotInfoRequest
             * @static
             * @param {kritor.guild.GetBotInfoRequest} message GetBotInfoRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetBotInfoRequest.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this GetBotInfoRequest to JSON.
             * @function toJSON
             * @memberof kritor.guild.GetBotInfoRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetBotInfoRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetBotInfoRequest
             * @function getTypeUrl
             * @memberof kritor.guild.GetBotInfoRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetBotInfoRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.GetBotInfoRequest";
            };

            return GetBotInfoRequest;
        })();

        guild.GetBotInfoResponse = (function() {

            /**
             * Properties of a GetBotInfoResponse.
             * @memberof kritor.guild
             * @interface IGetBotInfoResponse
             * @property {string|null} [nickname] GetBotInfoResponse nickname
             * @property {number|Long|null} [tinyId] GetBotInfoResponse tinyId
             * @property {string|null} [avatar] GetBotInfoResponse avatar
             */

            /**
             * Constructs a new GetBotInfoResponse.
             * @memberof kritor.guild
             * @classdesc Represents a GetBotInfoResponse.
             * @implements IGetBotInfoResponse
             * @constructor
             * @param {kritor.guild.IGetBotInfoResponse=} [properties] Properties to set
             */
            function GetBotInfoResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetBotInfoResponse nickname.
             * @member {string} nickname
             * @memberof kritor.guild.GetBotInfoResponse
             * @instance
             */
            GetBotInfoResponse.prototype.nickname = "";

            /**
             * GetBotInfoResponse tinyId.
             * @member {number|Long} tinyId
             * @memberof kritor.guild.GetBotInfoResponse
             * @instance
             */
            GetBotInfoResponse.prototype.tinyId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GetBotInfoResponse avatar.
             * @member {string} avatar
             * @memberof kritor.guild.GetBotInfoResponse
             * @instance
             */
            GetBotInfoResponse.prototype.avatar = "";

            /**
             * Creates a new GetBotInfoResponse instance using the specified properties.
             * @function create
             * @memberof kritor.guild.GetBotInfoResponse
             * @static
             * @param {kritor.guild.IGetBotInfoResponse=} [properties] Properties to set
             * @returns {kritor.guild.GetBotInfoResponse} GetBotInfoResponse instance
             */
            GetBotInfoResponse.create = function create(properties) {
                return new GetBotInfoResponse(properties);
            };

            /**
             * Encodes the specified GetBotInfoResponse message. Does not implicitly {@link kritor.guild.GetBotInfoResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.GetBotInfoResponse
             * @static
             * @param {kritor.guild.IGetBotInfoResponse} message GetBotInfoResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetBotInfoResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.nickname != null && Object.hasOwnProperty.call(message, "nickname"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.nickname);
                if (message.tinyId != null && Object.hasOwnProperty.call(message, "tinyId"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.tinyId);
                if (message.avatar != null && Object.hasOwnProperty.call(message, "avatar"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.avatar);
                return writer;
            };

            /**
             * Encodes the specified GetBotInfoResponse message, length delimited. Does not implicitly {@link kritor.guild.GetBotInfoResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.GetBotInfoResponse
             * @static
             * @param {kritor.guild.IGetBotInfoResponse} message GetBotInfoResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetBotInfoResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetBotInfoResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.GetBotInfoResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.GetBotInfoResponse} GetBotInfoResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetBotInfoResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.GetBotInfoResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.nickname = reader.string();
                            break;
                        }
                    case 2: {
                            message.tinyId = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.avatar = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetBotInfoResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.GetBotInfoResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.GetBotInfoResponse} GetBotInfoResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetBotInfoResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetBotInfoResponse message.
             * @function verify
             * @memberof kritor.guild.GetBotInfoResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetBotInfoResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.nickname != null && message.hasOwnProperty("nickname"))
                    if (!$util.isString(message.nickname))
                        return "nickname: string expected";
                if (message.tinyId != null && message.hasOwnProperty("tinyId"))
                    if (!$util.isInteger(message.tinyId) && !(message.tinyId && $util.isInteger(message.tinyId.low) && $util.isInteger(message.tinyId.high)))
                        return "tinyId: integer|Long expected";
                if (message.avatar != null && message.hasOwnProperty("avatar"))
                    if (!$util.isString(message.avatar))
                        return "avatar: string expected";
                return null;
            };

            /**
             * Creates a GetBotInfoResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.GetBotInfoResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.GetBotInfoResponse} GetBotInfoResponse
             */
            GetBotInfoResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.GetBotInfoResponse)
                    return object;
                let message = new $root.kritor.guild.GetBotInfoResponse();
                if (object.nickname != null)
                    message.nickname = String(object.nickname);
                if (object.tinyId != null)
                    if ($util.Long)
                        (message.tinyId = $util.Long.fromValue(object.tinyId)).unsigned = true;
                    else if (typeof object.tinyId === "string")
                        message.tinyId = parseInt(object.tinyId, 10);
                    else if (typeof object.tinyId === "number")
                        message.tinyId = object.tinyId;
                    else if (typeof object.tinyId === "object")
                        message.tinyId = new $util.LongBits(object.tinyId.low >>> 0, object.tinyId.high >>> 0).toNumber(true);
                if (object.avatar != null)
                    message.avatar = String(object.avatar);
                return message;
            };

            /**
             * Creates a plain object from a GetBotInfoResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.GetBotInfoResponse
             * @static
             * @param {kritor.guild.GetBotInfoResponse} message GetBotInfoResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetBotInfoResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.nickname = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.tinyId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.tinyId = options.longs === String ? "0" : 0;
                    object.avatar = "";
                }
                if (message.nickname != null && message.hasOwnProperty("nickname"))
                    object.nickname = message.nickname;
                if (message.tinyId != null && message.hasOwnProperty("tinyId"))
                    if (typeof message.tinyId === "number")
                        object.tinyId = options.longs === String ? String(message.tinyId) : message.tinyId;
                    else
                        object.tinyId = options.longs === String ? $util.Long.prototype.toString.call(message.tinyId) : options.longs === Number ? new $util.LongBits(message.tinyId.low >>> 0, message.tinyId.high >>> 0).toNumber(true) : message.tinyId;
                if (message.avatar != null && message.hasOwnProperty("avatar"))
                    object.avatar = message.avatar;
                return object;
            };

            /**
             * Converts this GetBotInfoResponse to JSON.
             * @function toJSON
             * @memberof kritor.guild.GetBotInfoResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetBotInfoResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetBotInfoResponse
             * @function getTypeUrl
             * @memberof kritor.guild.GetBotInfoResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetBotInfoResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.GetBotInfoResponse";
            };

            return GetBotInfoResponse;
        })();

        guild.GetChannelListRequest = (function() {

            /**
             * Properties of a GetChannelListRequest.
             * @memberof kritor.guild
             * @interface IGetChannelListRequest
             */

            /**
             * Constructs a new GetChannelListRequest.
             * @memberof kritor.guild
             * @classdesc Represents a GetChannelListRequest.
             * @implements IGetChannelListRequest
             * @constructor
             * @param {kritor.guild.IGetChannelListRequest=} [properties] Properties to set
             */
            function GetChannelListRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new GetChannelListRequest instance using the specified properties.
             * @function create
             * @memberof kritor.guild.GetChannelListRequest
             * @static
             * @param {kritor.guild.IGetChannelListRequest=} [properties] Properties to set
             * @returns {kritor.guild.GetChannelListRequest} GetChannelListRequest instance
             */
            GetChannelListRequest.create = function create(properties) {
                return new GetChannelListRequest(properties);
            };

            /**
             * Encodes the specified GetChannelListRequest message. Does not implicitly {@link kritor.guild.GetChannelListRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.GetChannelListRequest
             * @static
             * @param {kritor.guild.IGetChannelListRequest} message GetChannelListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetChannelListRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified GetChannelListRequest message, length delimited. Does not implicitly {@link kritor.guild.GetChannelListRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.GetChannelListRequest
             * @static
             * @param {kritor.guild.IGetChannelListRequest} message GetChannelListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetChannelListRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetChannelListRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.GetChannelListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.GetChannelListRequest} GetChannelListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetChannelListRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.GetChannelListRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetChannelListRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.GetChannelListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.GetChannelListRequest} GetChannelListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetChannelListRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetChannelListRequest message.
             * @function verify
             * @memberof kritor.guild.GetChannelListRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetChannelListRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a GetChannelListRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.GetChannelListRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.GetChannelListRequest} GetChannelListRequest
             */
            GetChannelListRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.GetChannelListRequest)
                    return object;
                return new $root.kritor.guild.GetChannelListRequest();
            };

            /**
             * Creates a plain object from a GetChannelListRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.GetChannelListRequest
             * @static
             * @param {kritor.guild.GetChannelListRequest} message GetChannelListRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetChannelListRequest.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this GetChannelListRequest to JSON.
             * @function toJSON
             * @memberof kritor.guild.GetChannelListRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetChannelListRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetChannelListRequest
             * @function getTypeUrl
             * @memberof kritor.guild.GetChannelListRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetChannelListRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.GetChannelListRequest";
            };

            return GetChannelListRequest;
        })();

        guild.GetChannelListResponse = (function() {

            /**
             * Properties of a GetChannelListResponse.
             * @memberof kritor.guild
             * @interface IGetChannelListResponse
             * @property {Array.<kritor.guild.IGuildInfo>|null} [getGuildList] GetChannelListResponse getGuildList
             */

            /**
             * Constructs a new GetChannelListResponse.
             * @memberof kritor.guild
             * @classdesc Represents a GetChannelListResponse.
             * @implements IGetChannelListResponse
             * @constructor
             * @param {kritor.guild.IGetChannelListResponse=} [properties] Properties to set
             */
            function GetChannelListResponse(properties) {
                this.getGuildList = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetChannelListResponse getGuildList.
             * @member {Array.<kritor.guild.IGuildInfo>} getGuildList
             * @memberof kritor.guild.GetChannelListResponse
             * @instance
             */
            GetChannelListResponse.prototype.getGuildList = $util.emptyArray;

            /**
             * Creates a new GetChannelListResponse instance using the specified properties.
             * @function create
             * @memberof kritor.guild.GetChannelListResponse
             * @static
             * @param {kritor.guild.IGetChannelListResponse=} [properties] Properties to set
             * @returns {kritor.guild.GetChannelListResponse} GetChannelListResponse instance
             */
            GetChannelListResponse.create = function create(properties) {
                return new GetChannelListResponse(properties);
            };

            /**
             * Encodes the specified GetChannelListResponse message. Does not implicitly {@link kritor.guild.GetChannelListResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.GetChannelListResponse
             * @static
             * @param {kritor.guild.IGetChannelListResponse} message GetChannelListResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetChannelListResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.getGuildList != null && message.getGuildList.length)
                    for (let i = 0; i < message.getGuildList.length; ++i)
                        $root.kritor.guild.GuildInfo.encode(message.getGuildList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetChannelListResponse message, length delimited. Does not implicitly {@link kritor.guild.GetChannelListResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.GetChannelListResponse
             * @static
             * @param {kritor.guild.IGetChannelListResponse} message GetChannelListResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetChannelListResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetChannelListResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.GetChannelListResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.GetChannelListResponse} GetChannelListResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetChannelListResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.GetChannelListResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.getGuildList && message.getGuildList.length))
                                message.getGuildList = [];
                            message.getGuildList.push($root.kritor.guild.GuildInfo.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetChannelListResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.GetChannelListResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.GetChannelListResponse} GetChannelListResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetChannelListResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetChannelListResponse message.
             * @function verify
             * @memberof kritor.guild.GetChannelListResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetChannelListResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.getGuildList != null && message.hasOwnProperty("getGuildList")) {
                    if (!Array.isArray(message.getGuildList))
                        return "getGuildList: array expected";
                    for (let i = 0; i < message.getGuildList.length; ++i) {
                        let error = $root.kritor.guild.GuildInfo.verify(message.getGuildList[i]);
                        if (error)
                            return "getGuildList." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a GetChannelListResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.GetChannelListResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.GetChannelListResponse} GetChannelListResponse
             */
            GetChannelListResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.GetChannelListResponse)
                    return object;
                let message = new $root.kritor.guild.GetChannelListResponse();
                if (object.getGuildList) {
                    if (!Array.isArray(object.getGuildList))
                        throw TypeError(".kritor.guild.GetChannelListResponse.getGuildList: array expected");
                    message.getGuildList = [];
                    for (let i = 0; i < object.getGuildList.length; ++i) {
                        if (typeof object.getGuildList[i] !== "object")
                            throw TypeError(".kritor.guild.GetChannelListResponse.getGuildList: object expected");
                        message.getGuildList[i] = $root.kritor.guild.GuildInfo.fromObject(object.getGuildList[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a GetChannelListResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.GetChannelListResponse
             * @static
             * @param {kritor.guild.GetChannelListResponse} message GetChannelListResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetChannelListResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.getGuildList = [];
                if (message.getGuildList && message.getGuildList.length) {
                    object.getGuildList = [];
                    for (let j = 0; j < message.getGuildList.length; ++j)
                        object.getGuildList[j] = $root.kritor.guild.GuildInfo.toObject(message.getGuildList[j], options);
                }
                return object;
            };

            /**
             * Converts this GetChannelListResponse to JSON.
             * @function toJSON
             * @memberof kritor.guild.GetChannelListResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetChannelListResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetChannelListResponse
             * @function getTypeUrl
             * @memberof kritor.guild.GetChannelListResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetChannelListResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.GetChannelListResponse";
            };

            return GetChannelListResponse;
        })();

        guild.GetGuildMetaByGuestRequest = (function() {

            /**
             * Properties of a GetGuildMetaByGuestRequest.
             * @memberof kritor.guild
             * @interface IGetGuildMetaByGuestRequest
             * @property {number|Long|null} [guildId] GetGuildMetaByGuestRequest guildId
             */

            /**
             * Constructs a new GetGuildMetaByGuestRequest.
             * @memberof kritor.guild
             * @classdesc Represents a GetGuildMetaByGuestRequest.
             * @implements IGetGuildMetaByGuestRequest
             * @constructor
             * @param {kritor.guild.IGetGuildMetaByGuestRequest=} [properties] Properties to set
             */
            function GetGuildMetaByGuestRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetGuildMetaByGuestRequest guildId.
             * @member {number|Long} guildId
             * @memberof kritor.guild.GetGuildMetaByGuestRequest
             * @instance
             */
            GetGuildMetaByGuestRequest.prototype.guildId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new GetGuildMetaByGuestRequest instance using the specified properties.
             * @function create
             * @memberof kritor.guild.GetGuildMetaByGuestRequest
             * @static
             * @param {kritor.guild.IGetGuildMetaByGuestRequest=} [properties] Properties to set
             * @returns {kritor.guild.GetGuildMetaByGuestRequest} GetGuildMetaByGuestRequest instance
             */
            GetGuildMetaByGuestRequest.create = function create(properties) {
                return new GetGuildMetaByGuestRequest(properties);
            };

            /**
             * Encodes the specified GetGuildMetaByGuestRequest message. Does not implicitly {@link kritor.guild.GetGuildMetaByGuestRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.GetGuildMetaByGuestRequest
             * @static
             * @param {kritor.guild.IGetGuildMetaByGuestRequest} message GetGuildMetaByGuestRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGuildMetaByGuestRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.guildId != null && Object.hasOwnProperty.call(message, "guildId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.guildId);
                return writer;
            };

            /**
             * Encodes the specified GetGuildMetaByGuestRequest message, length delimited. Does not implicitly {@link kritor.guild.GetGuildMetaByGuestRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.GetGuildMetaByGuestRequest
             * @static
             * @param {kritor.guild.IGetGuildMetaByGuestRequest} message GetGuildMetaByGuestRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGuildMetaByGuestRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetGuildMetaByGuestRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.GetGuildMetaByGuestRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.GetGuildMetaByGuestRequest} GetGuildMetaByGuestRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGuildMetaByGuestRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.GetGuildMetaByGuestRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.guildId = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetGuildMetaByGuestRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.GetGuildMetaByGuestRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.GetGuildMetaByGuestRequest} GetGuildMetaByGuestRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGuildMetaByGuestRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetGuildMetaByGuestRequest message.
             * @function verify
             * @memberof kritor.guild.GetGuildMetaByGuestRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetGuildMetaByGuestRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.guildId != null && message.hasOwnProperty("guildId"))
                    if (!$util.isInteger(message.guildId) && !(message.guildId && $util.isInteger(message.guildId.low) && $util.isInteger(message.guildId.high)))
                        return "guildId: integer|Long expected";
                return null;
            };

            /**
             * Creates a GetGuildMetaByGuestRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.GetGuildMetaByGuestRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.GetGuildMetaByGuestRequest} GetGuildMetaByGuestRequest
             */
            GetGuildMetaByGuestRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.GetGuildMetaByGuestRequest)
                    return object;
                let message = new $root.kritor.guild.GetGuildMetaByGuestRequest();
                if (object.guildId != null)
                    if ($util.Long)
                        (message.guildId = $util.Long.fromValue(object.guildId)).unsigned = true;
                    else if (typeof object.guildId === "string")
                        message.guildId = parseInt(object.guildId, 10);
                    else if (typeof object.guildId === "number")
                        message.guildId = object.guildId;
                    else if (typeof object.guildId === "object")
                        message.guildId = new $util.LongBits(object.guildId.low >>> 0, object.guildId.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a GetGuildMetaByGuestRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.GetGuildMetaByGuestRequest
             * @static
             * @param {kritor.guild.GetGuildMetaByGuestRequest} message GetGuildMetaByGuestRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetGuildMetaByGuestRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.guildId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.guildId = options.longs === String ? "0" : 0;
                if (message.guildId != null && message.hasOwnProperty("guildId"))
                    if (typeof message.guildId === "number")
                        object.guildId = options.longs === String ? String(message.guildId) : message.guildId;
                    else
                        object.guildId = options.longs === String ? $util.Long.prototype.toString.call(message.guildId) : options.longs === Number ? new $util.LongBits(message.guildId.low >>> 0, message.guildId.high >>> 0).toNumber(true) : message.guildId;
                return object;
            };

            /**
             * Converts this GetGuildMetaByGuestRequest to JSON.
             * @function toJSON
             * @memberof kritor.guild.GetGuildMetaByGuestRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetGuildMetaByGuestRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetGuildMetaByGuestRequest
             * @function getTypeUrl
             * @memberof kritor.guild.GetGuildMetaByGuestRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetGuildMetaByGuestRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.GetGuildMetaByGuestRequest";
            };

            return GetGuildMetaByGuestRequest;
        })();

        guild.GetGuildMetaByGuestResponse = (function() {

            /**
             * Properties of a GetGuildMetaByGuestResponse.
             * @memberof kritor.guild
             * @interface IGetGuildMetaByGuestResponse
             * @property {number|Long|null} [guildId] GetGuildMetaByGuestResponse guildId
             * @property {string|null} [guildName] GetGuildMetaByGuestResponse guildName
             * @property {string|null} [guildProfile] GetGuildMetaByGuestResponse guildProfile
             * @property {number|Long|null} [createTime] GetGuildMetaByGuestResponse createTime
             * @property {number|Long|null} [maxMemberCount] GetGuildMetaByGuestResponse maxMemberCount
             * @property {number|Long|null} [maxRobotCount] GetGuildMetaByGuestResponse maxRobotCount
             * @property {number|Long|null} [maxAdminCount] GetGuildMetaByGuestResponse maxAdminCount
             * @property {number|Long|null} [memberCount] GetGuildMetaByGuestResponse memberCount
             * @property {number|Long|null} [ownerId] GetGuildMetaByGuestResponse ownerId
             * @property {string|null} [guildDisplayId] GetGuildMetaByGuestResponse guildDisplayId
             */

            /**
             * Constructs a new GetGuildMetaByGuestResponse.
             * @memberof kritor.guild
             * @classdesc Represents a GetGuildMetaByGuestResponse.
             * @implements IGetGuildMetaByGuestResponse
             * @constructor
             * @param {kritor.guild.IGetGuildMetaByGuestResponse=} [properties] Properties to set
             */
            function GetGuildMetaByGuestResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetGuildMetaByGuestResponse guildId.
             * @member {number|Long} guildId
             * @memberof kritor.guild.GetGuildMetaByGuestResponse
             * @instance
             */
            GetGuildMetaByGuestResponse.prototype.guildId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GetGuildMetaByGuestResponse guildName.
             * @member {string} guildName
             * @memberof kritor.guild.GetGuildMetaByGuestResponse
             * @instance
             */
            GetGuildMetaByGuestResponse.prototype.guildName = "";

            /**
             * GetGuildMetaByGuestResponse guildProfile.
             * @member {string} guildProfile
             * @memberof kritor.guild.GetGuildMetaByGuestResponse
             * @instance
             */
            GetGuildMetaByGuestResponse.prototype.guildProfile = "";

            /**
             * GetGuildMetaByGuestResponse createTime.
             * @member {number|Long} createTime
             * @memberof kritor.guild.GetGuildMetaByGuestResponse
             * @instance
             */
            GetGuildMetaByGuestResponse.prototype.createTime = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GetGuildMetaByGuestResponse maxMemberCount.
             * @member {number|Long} maxMemberCount
             * @memberof kritor.guild.GetGuildMetaByGuestResponse
             * @instance
             */
            GetGuildMetaByGuestResponse.prototype.maxMemberCount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GetGuildMetaByGuestResponse maxRobotCount.
             * @member {number|Long} maxRobotCount
             * @memberof kritor.guild.GetGuildMetaByGuestResponse
             * @instance
             */
            GetGuildMetaByGuestResponse.prototype.maxRobotCount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GetGuildMetaByGuestResponse maxAdminCount.
             * @member {number|Long} maxAdminCount
             * @memberof kritor.guild.GetGuildMetaByGuestResponse
             * @instance
             */
            GetGuildMetaByGuestResponse.prototype.maxAdminCount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GetGuildMetaByGuestResponse memberCount.
             * @member {number|Long} memberCount
             * @memberof kritor.guild.GetGuildMetaByGuestResponse
             * @instance
             */
            GetGuildMetaByGuestResponse.prototype.memberCount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GetGuildMetaByGuestResponse ownerId.
             * @member {number|Long} ownerId
             * @memberof kritor.guild.GetGuildMetaByGuestResponse
             * @instance
             */
            GetGuildMetaByGuestResponse.prototype.ownerId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GetGuildMetaByGuestResponse guildDisplayId.
             * @member {string} guildDisplayId
             * @memberof kritor.guild.GetGuildMetaByGuestResponse
             * @instance
             */
            GetGuildMetaByGuestResponse.prototype.guildDisplayId = "";

            /**
             * Creates a new GetGuildMetaByGuestResponse instance using the specified properties.
             * @function create
             * @memberof kritor.guild.GetGuildMetaByGuestResponse
             * @static
             * @param {kritor.guild.IGetGuildMetaByGuestResponse=} [properties] Properties to set
             * @returns {kritor.guild.GetGuildMetaByGuestResponse} GetGuildMetaByGuestResponse instance
             */
            GetGuildMetaByGuestResponse.create = function create(properties) {
                return new GetGuildMetaByGuestResponse(properties);
            };

            /**
             * Encodes the specified GetGuildMetaByGuestResponse message. Does not implicitly {@link kritor.guild.GetGuildMetaByGuestResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.GetGuildMetaByGuestResponse
             * @static
             * @param {kritor.guild.IGetGuildMetaByGuestResponse} message GetGuildMetaByGuestResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGuildMetaByGuestResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.guildId != null && Object.hasOwnProperty.call(message, "guildId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.guildId);
                if (message.guildName != null && Object.hasOwnProperty.call(message, "guildName"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.guildName);
                if (message.guildProfile != null && Object.hasOwnProperty.call(message, "guildProfile"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.guildProfile);
                if (message.createTime != null && Object.hasOwnProperty.call(message, "createTime"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.createTime);
                if (message.maxMemberCount != null && Object.hasOwnProperty.call(message, "maxMemberCount"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.maxMemberCount);
                if (message.maxRobotCount != null && Object.hasOwnProperty.call(message, "maxRobotCount"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.maxRobotCount);
                if (message.maxAdminCount != null && Object.hasOwnProperty.call(message, "maxAdminCount"))
                    writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.maxAdminCount);
                if (message.memberCount != null && Object.hasOwnProperty.call(message, "memberCount"))
                    writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.memberCount);
                if (message.ownerId != null && Object.hasOwnProperty.call(message, "ownerId"))
                    writer.uint32(/* id 9, wireType 0 =*/72).uint64(message.ownerId);
                if (message.guildDisplayId != null && Object.hasOwnProperty.call(message, "guildDisplayId"))
                    writer.uint32(/* id 10, wireType 2 =*/82).string(message.guildDisplayId);
                return writer;
            };

            /**
             * Encodes the specified GetGuildMetaByGuestResponse message, length delimited. Does not implicitly {@link kritor.guild.GetGuildMetaByGuestResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.GetGuildMetaByGuestResponse
             * @static
             * @param {kritor.guild.IGetGuildMetaByGuestResponse} message GetGuildMetaByGuestResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGuildMetaByGuestResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetGuildMetaByGuestResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.GetGuildMetaByGuestResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.GetGuildMetaByGuestResponse} GetGuildMetaByGuestResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGuildMetaByGuestResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.GetGuildMetaByGuestResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.guildId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.guildName = reader.string();
                            break;
                        }
                    case 3: {
                            message.guildProfile = reader.string();
                            break;
                        }
                    case 4: {
                            message.createTime = reader.uint64();
                            break;
                        }
                    case 5: {
                            message.maxMemberCount = reader.uint64();
                            break;
                        }
                    case 6: {
                            message.maxRobotCount = reader.uint64();
                            break;
                        }
                    case 7: {
                            message.maxAdminCount = reader.uint64();
                            break;
                        }
                    case 8: {
                            message.memberCount = reader.uint64();
                            break;
                        }
                    case 9: {
                            message.ownerId = reader.uint64();
                            break;
                        }
                    case 10: {
                            message.guildDisplayId = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetGuildMetaByGuestResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.GetGuildMetaByGuestResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.GetGuildMetaByGuestResponse} GetGuildMetaByGuestResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGuildMetaByGuestResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetGuildMetaByGuestResponse message.
             * @function verify
             * @memberof kritor.guild.GetGuildMetaByGuestResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetGuildMetaByGuestResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.guildId != null && message.hasOwnProperty("guildId"))
                    if (!$util.isInteger(message.guildId) && !(message.guildId && $util.isInteger(message.guildId.low) && $util.isInteger(message.guildId.high)))
                        return "guildId: integer|Long expected";
                if (message.guildName != null && message.hasOwnProperty("guildName"))
                    if (!$util.isString(message.guildName))
                        return "guildName: string expected";
                if (message.guildProfile != null && message.hasOwnProperty("guildProfile"))
                    if (!$util.isString(message.guildProfile))
                        return "guildProfile: string expected";
                if (message.createTime != null && message.hasOwnProperty("createTime"))
                    if (!$util.isInteger(message.createTime) && !(message.createTime && $util.isInteger(message.createTime.low) && $util.isInteger(message.createTime.high)))
                        return "createTime: integer|Long expected";
                if (message.maxMemberCount != null && message.hasOwnProperty("maxMemberCount"))
                    if (!$util.isInteger(message.maxMemberCount) && !(message.maxMemberCount && $util.isInteger(message.maxMemberCount.low) && $util.isInteger(message.maxMemberCount.high)))
                        return "maxMemberCount: integer|Long expected";
                if (message.maxRobotCount != null && message.hasOwnProperty("maxRobotCount"))
                    if (!$util.isInteger(message.maxRobotCount) && !(message.maxRobotCount && $util.isInteger(message.maxRobotCount.low) && $util.isInteger(message.maxRobotCount.high)))
                        return "maxRobotCount: integer|Long expected";
                if (message.maxAdminCount != null && message.hasOwnProperty("maxAdminCount"))
                    if (!$util.isInteger(message.maxAdminCount) && !(message.maxAdminCount && $util.isInteger(message.maxAdminCount.low) && $util.isInteger(message.maxAdminCount.high)))
                        return "maxAdminCount: integer|Long expected";
                if (message.memberCount != null && message.hasOwnProperty("memberCount"))
                    if (!$util.isInteger(message.memberCount) && !(message.memberCount && $util.isInteger(message.memberCount.low) && $util.isInteger(message.memberCount.high)))
                        return "memberCount: integer|Long expected";
                if (message.ownerId != null && message.hasOwnProperty("ownerId"))
                    if (!$util.isInteger(message.ownerId) && !(message.ownerId && $util.isInteger(message.ownerId.low) && $util.isInteger(message.ownerId.high)))
                        return "ownerId: integer|Long expected";
                if (message.guildDisplayId != null && message.hasOwnProperty("guildDisplayId"))
                    if (!$util.isString(message.guildDisplayId))
                        return "guildDisplayId: string expected";
                return null;
            };

            /**
             * Creates a GetGuildMetaByGuestResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.GetGuildMetaByGuestResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.GetGuildMetaByGuestResponse} GetGuildMetaByGuestResponse
             */
            GetGuildMetaByGuestResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.GetGuildMetaByGuestResponse)
                    return object;
                let message = new $root.kritor.guild.GetGuildMetaByGuestResponse();
                if (object.guildId != null)
                    if ($util.Long)
                        (message.guildId = $util.Long.fromValue(object.guildId)).unsigned = true;
                    else if (typeof object.guildId === "string")
                        message.guildId = parseInt(object.guildId, 10);
                    else if (typeof object.guildId === "number")
                        message.guildId = object.guildId;
                    else if (typeof object.guildId === "object")
                        message.guildId = new $util.LongBits(object.guildId.low >>> 0, object.guildId.high >>> 0).toNumber(true);
                if (object.guildName != null)
                    message.guildName = String(object.guildName);
                if (object.guildProfile != null)
                    message.guildProfile = String(object.guildProfile);
                if (object.createTime != null)
                    if ($util.Long)
                        (message.createTime = $util.Long.fromValue(object.createTime)).unsigned = true;
                    else if (typeof object.createTime === "string")
                        message.createTime = parseInt(object.createTime, 10);
                    else if (typeof object.createTime === "number")
                        message.createTime = object.createTime;
                    else if (typeof object.createTime === "object")
                        message.createTime = new $util.LongBits(object.createTime.low >>> 0, object.createTime.high >>> 0).toNumber(true);
                if (object.maxMemberCount != null)
                    if ($util.Long)
                        (message.maxMemberCount = $util.Long.fromValue(object.maxMemberCount)).unsigned = true;
                    else if (typeof object.maxMemberCount === "string")
                        message.maxMemberCount = parseInt(object.maxMemberCount, 10);
                    else if (typeof object.maxMemberCount === "number")
                        message.maxMemberCount = object.maxMemberCount;
                    else if (typeof object.maxMemberCount === "object")
                        message.maxMemberCount = new $util.LongBits(object.maxMemberCount.low >>> 0, object.maxMemberCount.high >>> 0).toNumber(true);
                if (object.maxRobotCount != null)
                    if ($util.Long)
                        (message.maxRobotCount = $util.Long.fromValue(object.maxRobotCount)).unsigned = true;
                    else if (typeof object.maxRobotCount === "string")
                        message.maxRobotCount = parseInt(object.maxRobotCount, 10);
                    else if (typeof object.maxRobotCount === "number")
                        message.maxRobotCount = object.maxRobotCount;
                    else if (typeof object.maxRobotCount === "object")
                        message.maxRobotCount = new $util.LongBits(object.maxRobotCount.low >>> 0, object.maxRobotCount.high >>> 0).toNumber(true);
                if (object.maxAdminCount != null)
                    if ($util.Long)
                        (message.maxAdminCount = $util.Long.fromValue(object.maxAdminCount)).unsigned = true;
                    else if (typeof object.maxAdminCount === "string")
                        message.maxAdminCount = parseInt(object.maxAdminCount, 10);
                    else if (typeof object.maxAdminCount === "number")
                        message.maxAdminCount = object.maxAdminCount;
                    else if (typeof object.maxAdminCount === "object")
                        message.maxAdminCount = new $util.LongBits(object.maxAdminCount.low >>> 0, object.maxAdminCount.high >>> 0).toNumber(true);
                if (object.memberCount != null)
                    if ($util.Long)
                        (message.memberCount = $util.Long.fromValue(object.memberCount)).unsigned = true;
                    else if (typeof object.memberCount === "string")
                        message.memberCount = parseInt(object.memberCount, 10);
                    else if (typeof object.memberCount === "number")
                        message.memberCount = object.memberCount;
                    else if (typeof object.memberCount === "object")
                        message.memberCount = new $util.LongBits(object.memberCount.low >>> 0, object.memberCount.high >>> 0).toNumber(true);
                if (object.ownerId != null)
                    if ($util.Long)
                        (message.ownerId = $util.Long.fromValue(object.ownerId)).unsigned = true;
                    else if (typeof object.ownerId === "string")
                        message.ownerId = parseInt(object.ownerId, 10);
                    else if (typeof object.ownerId === "number")
                        message.ownerId = object.ownerId;
                    else if (typeof object.ownerId === "object")
                        message.ownerId = new $util.LongBits(object.ownerId.low >>> 0, object.ownerId.high >>> 0).toNumber(true);
                if (object.guildDisplayId != null)
                    message.guildDisplayId = String(object.guildDisplayId);
                return message;
            };

            /**
             * Creates a plain object from a GetGuildMetaByGuestResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.GetGuildMetaByGuestResponse
             * @static
             * @param {kritor.guild.GetGuildMetaByGuestResponse} message GetGuildMetaByGuestResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetGuildMetaByGuestResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.guildId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.guildId = options.longs === String ? "0" : 0;
                    object.guildName = "";
                    object.guildProfile = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.createTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.createTime = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.maxMemberCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.maxMemberCount = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.maxRobotCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.maxRobotCount = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.maxAdminCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.maxAdminCount = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.memberCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.memberCount = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.ownerId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.ownerId = options.longs === String ? "0" : 0;
                    object.guildDisplayId = "";
                }
                if (message.guildId != null && message.hasOwnProperty("guildId"))
                    if (typeof message.guildId === "number")
                        object.guildId = options.longs === String ? String(message.guildId) : message.guildId;
                    else
                        object.guildId = options.longs === String ? $util.Long.prototype.toString.call(message.guildId) : options.longs === Number ? new $util.LongBits(message.guildId.low >>> 0, message.guildId.high >>> 0).toNumber(true) : message.guildId;
                if (message.guildName != null && message.hasOwnProperty("guildName"))
                    object.guildName = message.guildName;
                if (message.guildProfile != null && message.hasOwnProperty("guildProfile"))
                    object.guildProfile = message.guildProfile;
                if (message.createTime != null && message.hasOwnProperty("createTime"))
                    if (typeof message.createTime === "number")
                        object.createTime = options.longs === String ? String(message.createTime) : message.createTime;
                    else
                        object.createTime = options.longs === String ? $util.Long.prototype.toString.call(message.createTime) : options.longs === Number ? new $util.LongBits(message.createTime.low >>> 0, message.createTime.high >>> 0).toNumber(true) : message.createTime;
                if (message.maxMemberCount != null && message.hasOwnProperty("maxMemberCount"))
                    if (typeof message.maxMemberCount === "number")
                        object.maxMemberCount = options.longs === String ? String(message.maxMemberCount) : message.maxMemberCount;
                    else
                        object.maxMemberCount = options.longs === String ? $util.Long.prototype.toString.call(message.maxMemberCount) : options.longs === Number ? new $util.LongBits(message.maxMemberCount.low >>> 0, message.maxMemberCount.high >>> 0).toNumber(true) : message.maxMemberCount;
                if (message.maxRobotCount != null && message.hasOwnProperty("maxRobotCount"))
                    if (typeof message.maxRobotCount === "number")
                        object.maxRobotCount = options.longs === String ? String(message.maxRobotCount) : message.maxRobotCount;
                    else
                        object.maxRobotCount = options.longs === String ? $util.Long.prototype.toString.call(message.maxRobotCount) : options.longs === Number ? new $util.LongBits(message.maxRobotCount.low >>> 0, message.maxRobotCount.high >>> 0).toNumber(true) : message.maxRobotCount;
                if (message.maxAdminCount != null && message.hasOwnProperty("maxAdminCount"))
                    if (typeof message.maxAdminCount === "number")
                        object.maxAdminCount = options.longs === String ? String(message.maxAdminCount) : message.maxAdminCount;
                    else
                        object.maxAdminCount = options.longs === String ? $util.Long.prototype.toString.call(message.maxAdminCount) : options.longs === Number ? new $util.LongBits(message.maxAdminCount.low >>> 0, message.maxAdminCount.high >>> 0).toNumber(true) : message.maxAdminCount;
                if (message.memberCount != null && message.hasOwnProperty("memberCount"))
                    if (typeof message.memberCount === "number")
                        object.memberCount = options.longs === String ? String(message.memberCount) : message.memberCount;
                    else
                        object.memberCount = options.longs === String ? $util.Long.prototype.toString.call(message.memberCount) : options.longs === Number ? new $util.LongBits(message.memberCount.low >>> 0, message.memberCount.high >>> 0).toNumber(true) : message.memberCount;
                if (message.ownerId != null && message.hasOwnProperty("ownerId"))
                    if (typeof message.ownerId === "number")
                        object.ownerId = options.longs === String ? String(message.ownerId) : message.ownerId;
                    else
                        object.ownerId = options.longs === String ? $util.Long.prototype.toString.call(message.ownerId) : options.longs === Number ? new $util.LongBits(message.ownerId.low >>> 0, message.ownerId.high >>> 0).toNumber(true) : message.ownerId;
                if (message.guildDisplayId != null && message.hasOwnProperty("guildDisplayId"))
                    object.guildDisplayId = message.guildDisplayId;
                return object;
            };

            /**
             * Converts this GetGuildMetaByGuestResponse to JSON.
             * @function toJSON
             * @memberof kritor.guild.GetGuildMetaByGuestResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetGuildMetaByGuestResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetGuildMetaByGuestResponse
             * @function getTypeUrl
             * @memberof kritor.guild.GetGuildMetaByGuestResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetGuildMetaByGuestResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.GetGuildMetaByGuestResponse";
            };

            return GetGuildMetaByGuestResponse;
        })();

        guild.GetGuildChannelListRequest = (function() {

            /**
             * Properties of a GetGuildChannelListRequest.
             * @memberof kritor.guild
             * @interface IGetGuildChannelListRequest
             * @property {number|Long|null} [guildId] GetGuildChannelListRequest guildId
             * @property {boolean|null} [refresh] GetGuildChannelListRequest refresh
             */

            /**
             * Constructs a new GetGuildChannelListRequest.
             * @memberof kritor.guild
             * @classdesc Represents a GetGuildChannelListRequest.
             * @implements IGetGuildChannelListRequest
             * @constructor
             * @param {kritor.guild.IGetGuildChannelListRequest=} [properties] Properties to set
             */
            function GetGuildChannelListRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetGuildChannelListRequest guildId.
             * @member {number|Long} guildId
             * @memberof kritor.guild.GetGuildChannelListRequest
             * @instance
             */
            GetGuildChannelListRequest.prototype.guildId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GetGuildChannelListRequest refresh.
             * @member {boolean} refresh
             * @memberof kritor.guild.GetGuildChannelListRequest
             * @instance
             */
            GetGuildChannelListRequest.prototype.refresh = false;

            /**
             * Creates a new GetGuildChannelListRequest instance using the specified properties.
             * @function create
             * @memberof kritor.guild.GetGuildChannelListRequest
             * @static
             * @param {kritor.guild.IGetGuildChannelListRequest=} [properties] Properties to set
             * @returns {kritor.guild.GetGuildChannelListRequest} GetGuildChannelListRequest instance
             */
            GetGuildChannelListRequest.create = function create(properties) {
                return new GetGuildChannelListRequest(properties);
            };

            /**
             * Encodes the specified GetGuildChannelListRequest message. Does not implicitly {@link kritor.guild.GetGuildChannelListRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.GetGuildChannelListRequest
             * @static
             * @param {kritor.guild.IGetGuildChannelListRequest} message GetGuildChannelListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGuildChannelListRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.guildId != null && Object.hasOwnProperty.call(message, "guildId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.guildId);
                if (message.refresh != null && Object.hasOwnProperty.call(message, "refresh"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.refresh);
                return writer;
            };

            /**
             * Encodes the specified GetGuildChannelListRequest message, length delimited. Does not implicitly {@link kritor.guild.GetGuildChannelListRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.GetGuildChannelListRequest
             * @static
             * @param {kritor.guild.IGetGuildChannelListRequest} message GetGuildChannelListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGuildChannelListRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetGuildChannelListRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.GetGuildChannelListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.GetGuildChannelListRequest} GetGuildChannelListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGuildChannelListRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.GetGuildChannelListRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.guildId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.refresh = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetGuildChannelListRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.GetGuildChannelListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.GetGuildChannelListRequest} GetGuildChannelListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGuildChannelListRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetGuildChannelListRequest message.
             * @function verify
             * @memberof kritor.guild.GetGuildChannelListRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetGuildChannelListRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.guildId != null && message.hasOwnProperty("guildId"))
                    if (!$util.isInteger(message.guildId) && !(message.guildId && $util.isInteger(message.guildId.low) && $util.isInteger(message.guildId.high)))
                        return "guildId: integer|Long expected";
                if (message.refresh != null && message.hasOwnProperty("refresh"))
                    if (typeof message.refresh !== "boolean")
                        return "refresh: boolean expected";
                return null;
            };

            /**
             * Creates a GetGuildChannelListRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.GetGuildChannelListRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.GetGuildChannelListRequest} GetGuildChannelListRequest
             */
            GetGuildChannelListRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.GetGuildChannelListRequest)
                    return object;
                let message = new $root.kritor.guild.GetGuildChannelListRequest();
                if (object.guildId != null)
                    if ($util.Long)
                        (message.guildId = $util.Long.fromValue(object.guildId)).unsigned = true;
                    else if (typeof object.guildId === "string")
                        message.guildId = parseInt(object.guildId, 10);
                    else if (typeof object.guildId === "number")
                        message.guildId = object.guildId;
                    else if (typeof object.guildId === "object")
                        message.guildId = new $util.LongBits(object.guildId.low >>> 0, object.guildId.high >>> 0).toNumber(true);
                if (object.refresh != null)
                    message.refresh = Boolean(object.refresh);
                return message;
            };

            /**
             * Creates a plain object from a GetGuildChannelListRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.GetGuildChannelListRequest
             * @static
             * @param {kritor.guild.GetGuildChannelListRequest} message GetGuildChannelListRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetGuildChannelListRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.guildId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.guildId = options.longs === String ? "0" : 0;
                    object.refresh = false;
                }
                if (message.guildId != null && message.hasOwnProperty("guildId"))
                    if (typeof message.guildId === "number")
                        object.guildId = options.longs === String ? String(message.guildId) : message.guildId;
                    else
                        object.guildId = options.longs === String ? $util.Long.prototype.toString.call(message.guildId) : options.longs === Number ? new $util.LongBits(message.guildId.low >>> 0, message.guildId.high >>> 0).toNumber(true) : message.guildId;
                if (message.refresh != null && message.hasOwnProperty("refresh"))
                    object.refresh = message.refresh;
                return object;
            };

            /**
             * Converts this GetGuildChannelListRequest to JSON.
             * @function toJSON
             * @memberof kritor.guild.GetGuildChannelListRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetGuildChannelListRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetGuildChannelListRequest
             * @function getTypeUrl
             * @memberof kritor.guild.GetGuildChannelListRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetGuildChannelListRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.GetGuildChannelListRequest";
            };

            return GetGuildChannelListRequest;
        })();

        guild.GetGuildChannelListResponse = (function() {

            /**
             * Properties of a GetGuildChannelListResponse.
             * @memberof kritor.guild
             * @interface IGetGuildChannelListResponse
             * @property {Array.<kritor.guild.IChannelInfo>|null} [channelsInfo] GetGuildChannelListResponse channelsInfo
             */

            /**
             * Constructs a new GetGuildChannelListResponse.
             * @memberof kritor.guild
             * @classdesc Represents a GetGuildChannelListResponse.
             * @implements IGetGuildChannelListResponse
             * @constructor
             * @param {kritor.guild.IGetGuildChannelListResponse=} [properties] Properties to set
             */
            function GetGuildChannelListResponse(properties) {
                this.channelsInfo = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetGuildChannelListResponse channelsInfo.
             * @member {Array.<kritor.guild.IChannelInfo>} channelsInfo
             * @memberof kritor.guild.GetGuildChannelListResponse
             * @instance
             */
            GetGuildChannelListResponse.prototype.channelsInfo = $util.emptyArray;

            /**
             * Creates a new GetGuildChannelListResponse instance using the specified properties.
             * @function create
             * @memberof kritor.guild.GetGuildChannelListResponse
             * @static
             * @param {kritor.guild.IGetGuildChannelListResponse=} [properties] Properties to set
             * @returns {kritor.guild.GetGuildChannelListResponse} GetGuildChannelListResponse instance
             */
            GetGuildChannelListResponse.create = function create(properties) {
                return new GetGuildChannelListResponse(properties);
            };

            /**
             * Encodes the specified GetGuildChannelListResponse message. Does not implicitly {@link kritor.guild.GetGuildChannelListResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.GetGuildChannelListResponse
             * @static
             * @param {kritor.guild.IGetGuildChannelListResponse} message GetGuildChannelListResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGuildChannelListResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.channelsInfo != null && message.channelsInfo.length)
                    for (let i = 0; i < message.channelsInfo.length; ++i)
                        $root.kritor.guild.ChannelInfo.encode(message.channelsInfo[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetGuildChannelListResponse message, length delimited. Does not implicitly {@link kritor.guild.GetGuildChannelListResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.GetGuildChannelListResponse
             * @static
             * @param {kritor.guild.IGetGuildChannelListResponse} message GetGuildChannelListResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGuildChannelListResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetGuildChannelListResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.GetGuildChannelListResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.GetGuildChannelListResponse} GetGuildChannelListResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGuildChannelListResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.GetGuildChannelListResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.channelsInfo && message.channelsInfo.length))
                                message.channelsInfo = [];
                            message.channelsInfo.push($root.kritor.guild.ChannelInfo.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetGuildChannelListResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.GetGuildChannelListResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.GetGuildChannelListResponse} GetGuildChannelListResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGuildChannelListResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetGuildChannelListResponse message.
             * @function verify
             * @memberof kritor.guild.GetGuildChannelListResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetGuildChannelListResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.channelsInfo != null && message.hasOwnProperty("channelsInfo")) {
                    if (!Array.isArray(message.channelsInfo))
                        return "channelsInfo: array expected";
                    for (let i = 0; i < message.channelsInfo.length; ++i) {
                        let error = $root.kritor.guild.ChannelInfo.verify(message.channelsInfo[i]);
                        if (error)
                            return "channelsInfo." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a GetGuildChannelListResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.GetGuildChannelListResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.GetGuildChannelListResponse} GetGuildChannelListResponse
             */
            GetGuildChannelListResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.GetGuildChannelListResponse)
                    return object;
                let message = new $root.kritor.guild.GetGuildChannelListResponse();
                if (object.channelsInfo) {
                    if (!Array.isArray(object.channelsInfo))
                        throw TypeError(".kritor.guild.GetGuildChannelListResponse.channelsInfo: array expected");
                    message.channelsInfo = [];
                    for (let i = 0; i < object.channelsInfo.length; ++i) {
                        if (typeof object.channelsInfo[i] !== "object")
                            throw TypeError(".kritor.guild.GetGuildChannelListResponse.channelsInfo: object expected");
                        message.channelsInfo[i] = $root.kritor.guild.ChannelInfo.fromObject(object.channelsInfo[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a GetGuildChannelListResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.GetGuildChannelListResponse
             * @static
             * @param {kritor.guild.GetGuildChannelListResponse} message GetGuildChannelListResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetGuildChannelListResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.channelsInfo = [];
                if (message.channelsInfo && message.channelsInfo.length) {
                    object.channelsInfo = [];
                    for (let j = 0; j < message.channelsInfo.length; ++j)
                        object.channelsInfo[j] = $root.kritor.guild.ChannelInfo.toObject(message.channelsInfo[j], options);
                }
                return object;
            };

            /**
             * Converts this GetGuildChannelListResponse to JSON.
             * @function toJSON
             * @memberof kritor.guild.GetGuildChannelListResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetGuildChannelListResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetGuildChannelListResponse
             * @function getTypeUrl
             * @memberof kritor.guild.GetGuildChannelListResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetGuildChannelListResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.GetGuildChannelListResponse";
            };

            return GetGuildChannelListResponse;
        })();

        guild.GetGuildMemberListRequest = (function() {

            /**
             * Properties of a GetGuildMemberListRequest.
             * @memberof kritor.guild
             * @interface IGetGuildMemberListRequest
             * @property {number|Long|null} [guildId] GetGuildMemberListRequest guildId
             * @property {string|null} [nextToken] GetGuildMemberListRequest nextToken
             * @property {boolean|null} [all] GetGuildMemberListRequest all
             * @property {boolean|null} [refresh] GetGuildMemberListRequest refresh
             */

            /**
             * Constructs a new GetGuildMemberListRequest.
             * @memberof kritor.guild
             * @classdesc Represents a GetGuildMemberListRequest.
             * @implements IGetGuildMemberListRequest
             * @constructor
             * @param {kritor.guild.IGetGuildMemberListRequest=} [properties] Properties to set
             */
            function GetGuildMemberListRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetGuildMemberListRequest guildId.
             * @member {number|Long} guildId
             * @memberof kritor.guild.GetGuildMemberListRequest
             * @instance
             */
            GetGuildMemberListRequest.prototype.guildId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GetGuildMemberListRequest nextToken.
             * @member {string} nextToken
             * @memberof kritor.guild.GetGuildMemberListRequest
             * @instance
             */
            GetGuildMemberListRequest.prototype.nextToken = "";

            /**
             * GetGuildMemberListRequest all.
             * @member {boolean} all
             * @memberof kritor.guild.GetGuildMemberListRequest
             * @instance
             */
            GetGuildMemberListRequest.prototype.all = false;

            /**
             * GetGuildMemberListRequest refresh.
             * @member {boolean} refresh
             * @memberof kritor.guild.GetGuildMemberListRequest
             * @instance
             */
            GetGuildMemberListRequest.prototype.refresh = false;

            /**
             * Creates a new GetGuildMemberListRequest instance using the specified properties.
             * @function create
             * @memberof kritor.guild.GetGuildMemberListRequest
             * @static
             * @param {kritor.guild.IGetGuildMemberListRequest=} [properties] Properties to set
             * @returns {kritor.guild.GetGuildMemberListRequest} GetGuildMemberListRequest instance
             */
            GetGuildMemberListRequest.create = function create(properties) {
                return new GetGuildMemberListRequest(properties);
            };

            /**
             * Encodes the specified GetGuildMemberListRequest message. Does not implicitly {@link kritor.guild.GetGuildMemberListRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.GetGuildMemberListRequest
             * @static
             * @param {kritor.guild.IGetGuildMemberListRequest} message GetGuildMemberListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGuildMemberListRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.guildId != null && Object.hasOwnProperty.call(message, "guildId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.guildId);
                if (message.nextToken != null && Object.hasOwnProperty.call(message, "nextToken"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.nextToken);
                if (message.all != null && Object.hasOwnProperty.call(message, "all"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.all);
                if (message.refresh != null && Object.hasOwnProperty.call(message, "refresh"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.refresh);
                return writer;
            };

            /**
             * Encodes the specified GetGuildMemberListRequest message, length delimited. Does not implicitly {@link kritor.guild.GetGuildMemberListRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.GetGuildMemberListRequest
             * @static
             * @param {kritor.guild.IGetGuildMemberListRequest} message GetGuildMemberListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGuildMemberListRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetGuildMemberListRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.GetGuildMemberListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.GetGuildMemberListRequest} GetGuildMemberListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGuildMemberListRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.GetGuildMemberListRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.guildId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.nextToken = reader.string();
                            break;
                        }
                    case 3: {
                            message.all = reader.bool();
                            break;
                        }
                    case 4: {
                            message.refresh = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetGuildMemberListRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.GetGuildMemberListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.GetGuildMemberListRequest} GetGuildMemberListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGuildMemberListRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetGuildMemberListRequest message.
             * @function verify
             * @memberof kritor.guild.GetGuildMemberListRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetGuildMemberListRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.guildId != null && message.hasOwnProperty("guildId"))
                    if (!$util.isInteger(message.guildId) && !(message.guildId && $util.isInteger(message.guildId.low) && $util.isInteger(message.guildId.high)))
                        return "guildId: integer|Long expected";
                if (message.nextToken != null && message.hasOwnProperty("nextToken"))
                    if (!$util.isString(message.nextToken))
                        return "nextToken: string expected";
                if (message.all != null && message.hasOwnProperty("all"))
                    if (typeof message.all !== "boolean")
                        return "all: boolean expected";
                if (message.refresh != null && message.hasOwnProperty("refresh"))
                    if (typeof message.refresh !== "boolean")
                        return "refresh: boolean expected";
                return null;
            };

            /**
             * Creates a GetGuildMemberListRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.GetGuildMemberListRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.GetGuildMemberListRequest} GetGuildMemberListRequest
             */
            GetGuildMemberListRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.GetGuildMemberListRequest)
                    return object;
                let message = new $root.kritor.guild.GetGuildMemberListRequest();
                if (object.guildId != null)
                    if ($util.Long)
                        (message.guildId = $util.Long.fromValue(object.guildId)).unsigned = true;
                    else if (typeof object.guildId === "string")
                        message.guildId = parseInt(object.guildId, 10);
                    else if (typeof object.guildId === "number")
                        message.guildId = object.guildId;
                    else if (typeof object.guildId === "object")
                        message.guildId = new $util.LongBits(object.guildId.low >>> 0, object.guildId.high >>> 0).toNumber(true);
                if (object.nextToken != null)
                    message.nextToken = String(object.nextToken);
                if (object.all != null)
                    message.all = Boolean(object.all);
                if (object.refresh != null)
                    message.refresh = Boolean(object.refresh);
                return message;
            };

            /**
             * Creates a plain object from a GetGuildMemberListRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.GetGuildMemberListRequest
             * @static
             * @param {kritor.guild.GetGuildMemberListRequest} message GetGuildMemberListRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetGuildMemberListRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.guildId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.guildId = options.longs === String ? "0" : 0;
                    object.nextToken = "";
                    object.all = false;
                    object.refresh = false;
                }
                if (message.guildId != null && message.hasOwnProperty("guildId"))
                    if (typeof message.guildId === "number")
                        object.guildId = options.longs === String ? String(message.guildId) : message.guildId;
                    else
                        object.guildId = options.longs === String ? $util.Long.prototype.toString.call(message.guildId) : options.longs === Number ? new $util.LongBits(message.guildId.low >>> 0, message.guildId.high >>> 0).toNumber(true) : message.guildId;
                if (message.nextToken != null && message.hasOwnProperty("nextToken"))
                    object.nextToken = message.nextToken;
                if (message.all != null && message.hasOwnProperty("all"))
                    object.all = message.all;
                if (message.refresh != null && message.hasOwnProperty("refresh"))
                    object.refresh = message.refresh;
                return object;
            };

            /**
             * Converts this GetGuildMemberListRequest to JSON.
             * @function toJSON
             * @memberof kritor.guild.GetGuildMemberListRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetGuildMemberListRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetGuildMemberListRequest
             * @function getTypeUrl
             * @memberof kritor.guild.GetGuildMemberListRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetGuildMemberListRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.GetGuildMemberListRequest";
            };

            return GetGuildMemberListRequest;
        })();

        guild.GetGuildMemberListResponse = (function() {

            /**
             * Properties of a GetGuildMemberListResponse.
             * @memberof kritor.guild
             * @interface IGetGuildMemberListResponse
             * @property {Array.<kritor.guild.IMemberInfo>|null} [membersInfo] GetGuildMemberListResponse membersInfo
             * @property {string|null} [nextToken] GetGuildMemberListResponse nextToken
             * @property {boolean|null} [finished] GetGuildMemberListResponse finished
             */

            /**
             * Constructs a new GetGuildMemberListResponse.
             * @memberof kritor.guild
             * @classdesc Represents a GetGuildMemberListResponse.
             * @implements IGetGuildMemberListResponse
             * @constructor
             * @param {kritor.guild.IGetGuildMemberListResponse=} [properties] Properties to set
             */
            function GetGuildMemberListResponse(properties) {
                this.membersInfo = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetGuildMemberListResponse membersInfo.
             * @member {Array.<kritor.guild.IMemberInfo>} membersInfo
             * @memberof kritor.guild.GetGuildMemberListResponse
             * @instance
             */
            GetGuildMemberListResponse.prototype.membersInfo = $util.emptyArray;

            /**
             * GetGuildMemberListResponse nextToken.
             * @member {string} nextToken
             * @memberof kritor.guild.GetGuildMemberListResponse
             * @instance
             */
            GetGuildMemberListResponse.prototype.nextToken = "";

            /**
             * GetGuildMemberListResponse finished.
             * @member {boolean} finished
             * @memberof kritor.guild.GetGuildMemberListResponse
             * @instance
             */
            GetGuildMemberListResponse.prototype.finished = false;

            /**
             * Creates a new GetGuildMemberListResponse instance using the specified properties.
             * @function create
             * @memberof kritor.guild.GetGuildMemberListResponse
             * @static
             * @param {kritor.guild.IGetGuildMemberListResponse=} [properties] Properties to set
             * @returns {kritor.guild.GetGuildMemberListResponse} GetGuildMemberListResponse instance
             */
            GetGuildMemberListResponse.create = function create(properties) {
                return new GetGuildMemberListResponse(properties);
            };

            /**
             * Encodes the specified GetGuildMemberListResponse message. Does not implicitly {@link kritor.guild.GetGuildMemberListResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.GetGuildMemberListResponse
             * @static
             * @param {kritor.guild.IGetGuildMemberListResponse} message GetGuildMemberListResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGuildMemberListResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.membersInfo != null && message.membersInfo.length)
                    for (let i = 0; i < message.membersInfo.length; ++i)
                        $root.kritor.guild.MemberInfo.encode(message.membersInfo[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.nextToken != null && Object.hasOwnProperty.call(message, "nextToken"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.nextToken);
                if (message.finished != null && Object.hasOwnProperty.call(message, "finished"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.finished);
                return writer;
            };

            /**
             * Encodes the specified GetGuildMemberListResponse message, length delimited. Does not implicitly {@link kritor.guild.GetGuildMemberListResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.GetGuildMemberListResponse
             * @static
             * @param {kritor.guild.IGetGuildMemberListResponse} message GetGuildMemberListResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGuildMemberListResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetGuildMemberListResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.GetGuildMemberListResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.GetGuildMemberListResponse} GetGuildMemberListResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGuildMemberListResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.GetGuildMemberListResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.membersInfo && message.membersInfo.length))
                                message.membersInfo = [];
                            message.membersInfo.push($root.kritor.guild.MemberInfo.decode(reader, reader.uint32()));
                            break;
                        }
                    case 2: {
                            message.nextToken = reader.string();
                            break;
                        }
                    case 3: {
                            message.finished = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetGuildMemberListResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.GetGuildMemberListResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.GetGuildMemberListResponse} GetGuildMemberListResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGuildMemberListResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetGuildMemberListResponse message.
             * @function verify
             * @memberof kritor.guild.GetGuildMemberListResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetGuildMemberListResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.membersInfo != null && message.hasOwnProperty("membersInfo")) {
                    if (!Array.isArray(message.membersInfo))
                        return "membersInfo: array expected";
                    for (let i = 0; i < message.membersInfo.length; ++i) {
                        let error = $root.kritor.guild.MemberInfo.verify(message.membersInfo[i]);
                        if (error)
                            return "membersInfo." + error;
                    }
                }
                if (message.nextToken != null && message.hasOwnProperty("nextToken"))
                    if (!$util.isString(message.nextToken))
                        return "nextToken: string expected";
                if (message.finished != null && message.hasOwnProperty("finished"))
                    if (typeof message.finished !== "boolean")
                        return "finished: boolean expected";
                return null;
            };

            /**
             * Creates a GetGuildMemberListResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.GetGuildMemberListResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.GetGuildMemberListResponse} GetGuildMemberListResponse
             */
            GetGuildMemberListResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.GetGuildMemberListResponse)
                    return object;
                let message = new $root.kritor.guild.GetGuildMemberListResponse();
                if (object.membersInfo) {
                    if (!Array.isArray(object.membersInfo))
                        throw TypeError(".kritor.guild.GetGuildMemberListResponse.membersInfo: array expected");
                    message.membersInfo = [];
                    for (let i = 0; i < object.membersInfo.length; ++i) {
                        if (typeof object.membersInfo[i] !== "object")
                            throw TypeError(".kritor.guild.GetGuildMemberListResponse.membersInfo: object expected");
                        message.membersInfo[i] = $root.kritor.guild.MemberInfo.fromObject(object.membersInfo[i]);
                    }
                }
                if (object.nextToken != null)
                    message.nextToken = String(object.nextToken);
                if (object.finished != null)
                    message.finished = Boolean(object.finished);
                return message;
            };

            /**
             * Creates a plain object from a GetGuildMemberListResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.GetGuildMemberListResponse
             * @static
             * @param {kritor.guild.GetGuildMemberListResponse} message GetGuildMemberListResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetGuildMemberListResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.membersInfo = [];
                if (options.defaults) {
                    object.nextToken = "";
                    object.finished = false;
                }
                if (message.membersInfo && message.membersInfo.length) {
                    object.membersInfo = [];
                    for (let j = 0; j < message.membersInfo.length; ++j)
                        object.membersInfo[j] = $root.kritor.guild.MemberInfo.toObject(message.membersInfo[j], options);
                }
                if (message.nextToken != null && message.hasOwnProperty("nextToken"))
                    object.nextToken = message.nextToken;
                if (message.finished != null && message.hasOwnProperty("finished"))
                    object.finished = message.finished;
                return object;
            };

            /**
             * Converts this GetGuildMemberListResponse to JSON.
             * @function toJSON
             * @memberof kritor.guild.GetGuildMemberListResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetGuildMemberListResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetGuildMemberListResponse
             * @function getTypeUrl
             * @memberof kritor.guild.GetGuildMemberListResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetGuildMemberListResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.GetGuildMemberListResponse";
            };

            return GetGuildMemberListResponse;
        })();

        guild.GetGuildMemberRequest = (function() {

            /**
             * Properties of a GetGuildMemberRequest.
             * @memberof kritor.guild
             * @interface IGetGuildMemberRequest
             * @property {number|Long|null} [guildId] GetGuildMemberRequest guildId
             * @property {number|Long|null} [tinyId] GetGuildMemberRequest tinyId
             */

            /**
             * Constructs a new GetGuildMemberRequest.
             * @memberof kritor.guild
             * @classdesc Represents a GetGuildMemberRequest.
             * @implements IGetGuildMemberRequest
             * @constructor
             * @param {kritor.guild.IGetGuildMemberRequest=} [properties] Properties to set
             */
            function GetGuildMemberRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetGuildMemberRequest guildId.
             * @member {number|Long} guildId
             * @memberof kritor.guild.GetGuildMemberRequest
             * @instance
             */
            GetGuildMemberRequest.prototype.guildId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GetGuildMemberRequest tinyId.
             * @member {number|Long} tinyId
             * @memberof kritor.guild.GetGuildMemberRequest
             * @instance
             */
            GetGuildMemberRequest.prototype.tinyId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new GetGuildMemberRequest instance using the specified properties.
             * @function create
             * @memberof kritor.guild.GetGuildMemberRequest
             * @static
             * @param {kritor.guild.IGetGuildMemberRequest=} [properties] Properties to set
             * @returns {kritor.guild.GetGuildMemberRequest} GetGuildMemberRequest instance
             */
            GetGuildMemberRequest.create = function create(properties) {
                return new GetGuildMemberRequest(properties);
            };

            /**
             * Encodes the specified GetGuildMemberRequest message. Does not implicitly {@link kritor.guild.GetGuildMemberRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.GetGuildMemberRequest
             * @static
             * @param {kritor.guild.IGetGuildMemberRequest} message GetGuildMemberRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGuildMemberRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.guildId != null && Object.hasOwnProperty.call(message, "guildId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.guildId);
                if (message.tinyId != null && Object.hasOwnProperty.call(message, "tinyId"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.tinyId);
                return writer;
            };

            /**
             * Encodes the specified GetGuildMemberRequest message, length delimited. Does not implicitly {@link kritor.guild.GetGuildMemberRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.GetGuildMemberRequest
             * @static
             * @param {kritor.guild.IGetGuildMemberRequest} message GetGuildMemberRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGuildMemberRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetGuildMemberRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.GetGuildMemberRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.GetGuildMemberRequest} GetGuildMemberRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGuildMemberRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.GetGuildMemberRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.guildId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.tinyId = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetGuildMemberRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.GetGuildMemberRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.GetGuildMemberRequest} GetGuildMemberRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGuildMemberRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetGuildMemberRequest message.
             * @function verify
             * @memberof kritor.guild.GetGuildMemberRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetGuildMemberRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.guildId != null && message.hasOwnProperty("guildId"))
                    if (!$util.isInteger(message.guildId) && !(message.guildId && $util.isInteger(message.guildId.low) && $util.isInteger(message.guildId.high)))
                        return "guildId: integer|Long expected";
                if (message.tinyId != null && message.hasOwnProperty("tinyId"))
                    if (!$util.isInteger(message.tinyId) && !(message.tinyId && $util.isInteger(message.tinyId.low) && $util.isInteger(message.tinyId.high)))
                        return "tinyId: integer|Long expected";
                return null;
            };

            /**
             * Creates a GetGuildMemberRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.GetGuildMemberRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.GetGuildMemberRequest} GetGuildMemberRequest
             */
            GetGuildMemberRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.GetGuildMemberRequest)
                    return object;
                let message = new $root.kritor.guild.GetGuildMemberRequest();
                if (object.guildId != null)
                    if ($util.Long)
                        (message.guildId = $util.Long.fromValue(object.guildId)).unsigned = true;
                    else if (typeof object.guildId === "string")
                        message.guildId = parseInt(object.guildId, 10);
                    else if (typeof object.guildId === "number")
                        message.guildId = object.guildId;
                    else if (typeof object.guildId === "object")
                        message.guildId = new $util.LongBits(object.guildId.low >>> 0, object.guildId.high >>> 0).toNumber(true);
                if (object.tinyId != null)
                    if ($util.Long)
                        (message.tinyId = $util.Long.fromValue(object.tinyId)).unsigned = true;
                    else if (typeof object.tinyId === "string")
                        message.tinyId = parseInt(object.tinyId, 10);
                    else if (typeof object.tinyId === "number")
                        message.tinyId = object.tinyId;
                    else if (typeof object.tinyId === "object")
                        message.tinyId = new $util.LongBits(object.tinyId.low >>> 0, object.tinyId.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a GetGuildMemberRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.GetGuildMemberRequest
             * @static
             * @param {kritor.guild.GetGuildMemberRequest} message GetGuildMemberRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetGuildMemberRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.guildId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.guildId = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.tinyId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.tinyId = options.longs === String ? "0" : 0;
                }
                if (message.guildId != null && message.hasOwnProperty("guildId"))
                    if (typeof message.guildId === "number")
                        object.guildId = options.longs === String ? String(message.guildId) : message.guildId;
                    else
                        object.guildId = options.longs === String ? $util.Long.prototype.toString.call(message.guildId) : options.longs === Number ? new $util.LongBits(message.guildId.low >>> 0, message.guildId.high >>> 0).toNumber(true) : message.guildId;
                if (message.tinyId != null && message.hasOwnProperty("tinyId"))
                    if (typeof message.tinyId === "number")
                        object.tinyId = options.longs === String ? String(message.tinyId) : message.tinyId;
                    else
                        object.tinyId = options.longs === String ? $util.Long.prototype.toString.call(message.tinyId) : options.longs === Number ? new $util.LongBits(message.tinyId.low >>> 0, message.tinyId.high >>> 0).toNumber(true) : message.tinyId;
                return object;
            };

            /**
             * Converts this GetGuildMemberRequest to JSON.
             * @function toJSON
             * @memberof kritor.guild.GetGuildMemberRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetGuildMemberRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetGuildMemberRequest
             * @function getTypeUrl
             * @memberof kritor.guild.GetGuildMemberRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetGuildMemberRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.GetGuildMemberRequest";
            };

            return GetGuildMemberRequest;
        })();

        guild.GetGuildMemberResponse = (function() {

            /**
             * Properties of a GetGuildMemberResponse.
             * @memberof kritor.guild
             * @interface IGetGuildMemberResponse
             * @property {kritor.guild.IMemberProfile|null} [memberInfo] GetGuildMemberResponse memberInfo
             */

            /**
             * Constructs a new GetGuildMemberResponse.
             * @memberof kritor.guild
             * @classdesc Represents a GetGuildMemberResponse.
             * @implements IGetGuildMemberResponse
             * @constructor
             * @param {kritor.guild.IGetGuildMemberResponse=} [properties] Properties to set
             */
            function GetGuildMemberResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetGuildMemberResponse memberInfo.
             * @member {kritor.guild.IMemberProfile|null|undefined} memberInfo
             * @memberof kritor.guild.GetGuildMemberResponse
             * @instance
             */
            GetGuildMemberResponse.prototype.memberInfo = null;

            /**
             * Creates a new GetGuildMemberResponse instance using the specified properties.
             * @function create
             * @memberof kritor.guild.GetGuildMemberResponse
             * @static
             * @param {kritor.guild.IGetGuildMemberResponse=} [properties] Properties to set
             * @returns {kritor.guild.GetGuildMemberResponse} GetGuildMemberResponse instance
             */
            GetGuildMemberResponse.create = function create(properties) {
                return new GetGuildMemberResponse(properties);
            };

            /**
             * Encodes the specified GetGuildMemberResponse message. Does not implicitly {@link kritor.guild.GetGuildMemberResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.GetGuildMemberResponse
             * @static
             * @param {kritor.guild.IGetGuildMemberResponse} message GetGuildMemberResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGuildMemberResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.memberInfo != null && Object.hasOwnProperty.call(message, "memberInfo"))
                    $root.kritor.guild.MemberProfile.encode(message.memberInfo, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetGuildMemberResponse message, length delimited. Does not implicitly {@link kritor.guild.GetGuildMemberResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.GetGuildMemberResponse
             * @static
             * @param {kritor.guild.IGetGuildMemberResponse} message GetGuildMemberResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGuildMemberResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetGuildMemberResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.GetGuildMemberResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.GetGuildMemberResponse} GetGuildMemberResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGuildMemberResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.GetGuildMemberResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.memberInfo = $root.kritor.guild.MemberProfile.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetGuildMemberResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.GetGuildMemberResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.GetGuildMemberResponse} GetGuildMemberResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGuildMemberResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetGuildMemberResponse message.
             * @function verify
             * @memberof kritor.guild.GetGuildMemberResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetGuildMemberResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.memberInfo != null && message.hasOwnProperty("memberInfo")) {
                    let error = $root.kritor.guild.MemberProfile.verify(message.memberInfo);
                    if (error)
                        return "memberInfo." + error;
                }
                return null;
            };

            /**
             * Creates a GetGuildMemberResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.GetGuildMemberResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.GetGuildMemberResponse} GetGuildMemberResponse
             */
            GetGuildMemberResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.GetGuildMemberResponse)
                    return object;
                let message = new $root.kritor.guild.GetGuildMemberResponse();
                if (object.memberInfo != null) {
                    if (typeof object.memberInfo !== "object")
                        throw TypeError(".kritor.guild.GetGuildMemberResponse.memberInfo: object expected");
                    message.memberInfo = $root.kritor.guild.MemberProfile.fromObject(object.memberInfo);
                }
                return message;
            };

            /**
             * Creates a plain object from a GetGuildMemberResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.GetGuildMemberResponse
             * @static
             * @param {kritor.guild.GetGuildMemberResponse} message GetGuildMemberResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetGuildMemberResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.memberInfo = null;
                if (message.memberInfo != null && message.hasOwnProperty("memberInfo"))
                    object.memberInfo = $root.kritor.guild.MemberProfile.toObject(message.memberInfo, options);
                return object;
            };

            /**
             * Converts this GetGuildMemberResponse to JSON.
             * @function toJSON
             * @memberof kritor.guild.GetGuildMemberResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetGuildMemberResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetGuildMemberResponse
             * @function getTypeUrl
             * @memberof kritor.guild.GetGuildMemberResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetGuildMemberResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.GetGuildMemberResponse";
            };

            return GetGuildMemberResponse;
        })();

        guild.SendChannelMessageRequest = (function() {

            /**
             * Properties of a SendChannelMessageRequest.
             * @memberof kritor.guild
             * @interface ISendChannelMessageRequest
             * @property {number|Long|null} [guildId] SendChannelMessageRequest guildId
             * @property {number|Long|null} [channelId] SendChannelMessageRequest channelId
             * @property {string|null} [message] SendChannelMessageRequest message
             * @property {number|null} [retryCnt] SendChannelMessageRequest retryCnt
             * @property {number|Long|null} [recallDuration] SendChannelMessageRequest recallDuration
             */

            /**
             * Constructs a new SendChannelMessageRequest.
             * @memberof kritor.guild
             * @classdesc Represents a SendChannelMessageRequest.
             * @implements ISendChannelMessageRequest
             * @constructor
             * @param {kritor.guild.ISendChannelMessageRequest=} [properties] Properties to set
             */
            function SendChannelMessageRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SendChannelMessageRequest guildId.
             * @member {number|Long} guildId
             * @memberof kritor.guild.SendChannelMessageRequest
             * @instance
             */
            SendChannelMessageRequest.prototype.guildId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * SendChannelMessageRequest channelId.
             * @member {number|Long} channelId
             * @memberof kritor.guild.SendChannelMessageRequest
             * @instance
             */
            SendChannelMessageRequest.prototype.channelId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * SendChannelMessageRequest message.
             * @member {string} message
             * @memberof kritor.guild.SendChannelMessageRequest
             * @instance
             */
            SendChannelMessageRequest.prototype.message = "";

            /**
             * SendChannelMessageRequest retryCnt.
             * @member {number} retryCnt
             * @memberof kritor.guild.SendChannelMessageRequest
             * @instance
             */
            SendChannelMessageRequest.prototype.retryCnt = 0;

            /**
             * SendChannelMessageRequest recallDuration.
             * @member {number|Long} recallDuration
             * @memberof kritor.guild.SendChannelMessageRequest
             * @instance
             */
            SendChannelMessageRequest.prototype.recallDuration = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new SendChannelMessageRequest instance using the specified properties.
             * @function create
             * @memberof kritor.guild.SendChannelMessageRequest
             * @static
             * @param {kritor.guild.ISendChannelMessageRequest=} [properties] Properties to set
             * @returns {kritor.guild.SendChannelMessageRequest} SendChannelMessageRequest instance
             */
            SendChannelMessageRequest.create = function create(properties) {
                return new SendChannelMessageRequest(properties);
            };

            /**
             * Encodes the specified SendChannelMessageRequest message. Does not implicitly {@link kritor.guild.SendChannelMessageRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.SendChannelMessageRequest
             * @static
             * @param {kritor.guild.ISendChannelMessageRequest} message SendChannelMessageRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SendChannelMessageRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.guildId != null && Object.hasOwnProperty.call(message, "guildId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.guildId);
                if (message.channelId != null && Object.hasOwnProperty.call(message, "channelId"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.channelId);
                if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.message);
                if (message.retryCnt != null && Object.hasOwnProperty.call(message, "retryCnt"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.retryCnt);
                if (message.recallDuration != null && Object.hasOwnProperty.call(message, "recallDuration"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int64(message.recallDuration);
                return writer;
            };

            /**
             * Encodes the specified SendChannelMessageRequest message, length delimited. Does not implicitly {@link kritor.guild.SendChannelMessageRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.SendChannelMessageRequest
             * @static
             * @param {kritor.guild.ISendChannelMessageRequest} message SendChannelMessageRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SendChannelMessageRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SendChannelMessageRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.SendChannelMessageRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.SendChannelMessageRequest} SendChannelMessageRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SendChannelMessageRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.SendChannelMessageRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.guildId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.channelId = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.message = reader.string();
                            break;
                        }
                    case 4: {
                            message.retryCnt = reader.int32();
                            break;
                        }
                    case 5: {
                            message.recallDuration = reader.int64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SendChannelMessageRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.SendChannelMessageRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.SendChannelMessageRequest} SendChannelMessageRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SendChannelMessageRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SendChannelMessageRequest message.
             * @function verify
             * @memberof kritor.guild.SendChannelMessageRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SendChannelMessageRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.guildId != null && message.hasOwnProperty("guildId"))
                    if (!$util.isInteger(message.guildId) && !(message.guildId && $util.isInteger(message.guildId.low) && $util.isInteger(message.guildId.high)))
                        return "guildId: integer|Long expected";
                if (message.channelId != null && message.hasOwnProperty("channelId"))
                    if (!$util.isInteger(message.channelId) && !(message.channelId && $util.isInteger(message.channelId.low) && $util.isInteger(message.channelId.high)))
                        return "channelId: integer|Long expected";
                if (message.message != null && message.hasOwnProperty("message"))
                    if (!$util.isString(message.message))
                        return "message: string expected";
                if (message.retryCnt != null && message.hasOwnProperty("retryCnt"))
                    if (!$util.isInteger(message.retryCnt))
                        return "retryCnt: integer expected";
                if (message.recallDuration != null && message.hasOwnProperty("recallDuration"))
                    if (!$util.isInteger(message.recallDuration) && !(message.recallDuration && $util.isInteger(message.recallDuration.low) && $util.isInteger(message.recallDuration.high)))
                        return "recallDuration: integer|Long expected";
                return null;
            };

            /**
             * Creates a SendChannelMessageRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.SendChannelMessageRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.SendChannelMessageRequest} SendChannelMessageRequest
             */
            SendChannelMessageRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.SendChannelMessageRequest)
                    return object;
                let message = new $root.kritor.guild.SendChannelMessageRequest();
                if (object.guildId != null)
                    if ($util.Long)
                        (message.guildId = $util.Long.fromValue(object.guildId)).unsigned = true;
                    else if (typeof object.guildId === "string")
                        message.guildId = parseInt(object.guildId, 10);
                    else if (typeof object.guildId === "number")
                        message.guildId = object.guildId;
                    else if (typeof object.guildId === "object")
                        message.guildId = new $util.LongBits(object.guildId.low >>> 0, object.guildId.high >>> 0).toNumber(true);
                if (object.channelId != null)
                    if ($util.Long)
                        (message.channelId = $util.Long.fromValue(object.channelId)).unsigned = true;
                    else if (typeof object.channelId === "string")
                        message.channelId = parseInt(object.channelId, 10);
                    else if (typeof object.channelId === "number")
                        message.channelId = object.channelId;
                    else if (typeof object.channelId === "object")
                        message.channelId = new $util.LongBits(object.channelId.low >>> 0, object.channelId.high >>> 0).toNumber(true);
                if (object.message != null)
                    message.message = String(object.message);
                if (object.retryCnt != null)
                    message.retryCnt = object.retryCnt | 0;
                if (object.recallDuration != null)
                    if ($util.Long)
                        (message.recallDuration = $util.Long.fromValue(object.recallDuration)).unsigned = false;
                    else if (typeof object.recallDuration === "string")
                        message.recallDuration = parseInt(object.recallDuration, 10);
                    else if (typeof object.recallDuration === "number")
                        message.recallDuration = object.recallDuration;
                    else if (typeof object.recallDuration === "object")
                        message.recallDuration = new $util.LongBits(object.recallDuration.low >>> 0, object.recallDuration.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a SendChannelMessageRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.SendChannelMessageRequest
             * @static
             * @param {kritor.guild.SendChannelMessageRequest} message SendChannelMessageRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SendChannelMessageRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.guildId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.guildId = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.channelId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.channelId = options.longs === String ? "0" : 0;
                    object.message = "";
                    object.retryCnt = 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.recallDuration = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.recallDuration = options.longs === String ? "0" : 0;
                }
                if (message.guildId != null && message.hasOwnProperty("guildId"))
                    if (typeof message.guildId === "number")
                        object.guildId = options.longs === String ? String(message.guildId) : message.guildId;
                    else
                        object.guildId = options.longs === String ? $util.Long.prototype.toString.call(message.guildId) : options.longs === Number ? new $util.LongBits(message.guildId.low >>> 0, message.guildId.high >>> 0).toNumber(true) : message.guildId;
                if (message.channelId != null && message.hasOwnProperty("channelId"))
                    if (typeof message.channelId === "number")
                        object.channelId = options.longs === String ? String(message.channelId) : message.channelId;
                    else
                        object.channelId = options.longs === String ? $util.Long.prototype.toString.call(message.channelId) : options.longs === Number ? new $util.LongBits(message.channelId.low >>> 0, message.channelId.high >>> 0).toNumber(true) : message.channelId;
                if (message.message != null && message.hasOwnProperty("message"))
                    object.message = message.message;
                if (message.retryCnt != null && message.hasOwnProperty("retryCnt"))
                    object.retryCnt = message.retryCnt;
                if (message.recallDuration != null && message.hasOwnProperty("recallDuration"))
                    if (typeof message.recallDuration === "number")
                        object.recallDuration = options.longs === String ? String(message.recallDuration) : message.recallDuration;
                    else
                        object.recallDuration = options.longs === String ? $util.Long.prototype.toString.call(message.recallDuration) : options.longs === Number ? new $util.LongBits(message.recallDuration.low >>> 0, message.recallDuration.high >>> 0).toNumber() : message.recallDuration;
                return object;
            };

            /**
             * Converts this SendChannelMessageRequest to JSON.
             * @function toJSON
             * @memberof kritor.guild.SendChannelMessageRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SendChannelMessageRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SendChannelMessageRequest
             * @function getTypeUrl
             * @memberof kritor.guild.SendChannelMessageRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SendChannelMessageRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.SendChannelMessageRequest";
            };

            return SendChannelMessageRequest;
        })();

        guild.SendChannelMessageResponse = (function() {

            /**
             * Properties of a SendChannelMessageResponse.
             * @memberof kritor.guild
             * @interface ISendChannelMessageResponse
             * @property {string|null} [messageId] SendChannelMessageResponse messageId
             * @property {number|Long|null} [time] SendChannelMessageResponse time
             */

            /**
             * Constructs a new SendChannelMessageResponse.
             * @memberof kritor.guild
             * @classdesc Represents a SendChannelMessageResponse.
             * @implements ISendChannelMessageResponse
             * @constructor
             * @param {kritor.guild.ISendChannelMessageResponse=} [properties] Properties to set
             */
            function SendChannelMessageResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SendChannelMessageResponse messageId.
             * @member {string} messageId
             * @memberof kritor.guild.SendChannelMessageResponse
             * @instance
             */
            SendChannelMessageResponse.prototype.messageId = "";

            /**
             * SendChannelMessageResponse time.
             * @member {number|Long} time
             * @memberof kritor.guild.SendChannelMessageResponse
             * @instance
             */
            SendChannelMessageResponse.prototype.time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new SendChannelMessageResponse instance using the specified properties.
             * @function create
             * @memberof kritor.guild.SendChannelMessageResponse
             * @static
             * @param {kritor.guild.ISendChannelMessageResponse=} [properties] Properties to set
             * @returns {kritor.guild.SendChannelMessageResponse} SendChannelMessageResponse instance
             */
            SendChannelMessageResponse.create = function create(properties) {
                return new SendChannelMessageResponse(properties);
            };

            /**
             * Encodes the specified SendChannelMessageResponse message. Does not implicitly {@link kritor.guild.SendChannelMessageResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.SendChannelMessageResponse
             * @static
             * @param {kritor.guild.ISendChannelMessageResponse} message SendChannelMessageResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SendChannelMessageResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.messageId != null && Object.hasOwnProperty.call(message, "messageId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.messageId);
                if (message.time != null && Object.hasOwnProperty.call(message, "time"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int64(message.time);
                return writer;
            };

            /**
             * Encodes the specified SendChannelMessageResponse message, length delimited. Does not implicitly {@link kritor.guild.SendChannelMessageResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.SendChannelMessageResponse
             * @static
             * @param {kritor.guild.ISendChannelMessageResponse} message SendChannelMessageResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SendChannelMessageResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SendChannelMessageResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.SendChannelMessageResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.SendChannelMessageResponse} SendChannelMessageResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SendChannelMessageResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.SendChannelMessageResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.messageId = reader.string();
                            break;
                        }
                    case 2: {
                            message.time = reader.int64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SendChannelMessageResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.SendChannelMessageResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.SendChannelMessageResponse} SendChannelMessageResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SendChannelMessageResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SendChannelMessageResponse message.
             * @function verify
             * @memberof kritor.guild.SendChannelMessageResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SendChannelMessageResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    if (!$util.isString(message.messageId))
                        return "messageId: string expected";
                if (message.time != null && message.hasOwnProperty("time"))
                    if (!$util.isInteger(message.time) && !(message.time && $util.isInteger(message.time.low) && $util.isInteger(message.time.high)))
                        return "time: integer|Long expected";
                return null;
            };

            /**
             * Creates a SendChannelMessageResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.SendChannelMessageResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.SendChannelMessageResponse} SendChannelMessageResponse
             */
            SendChannelMessageResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.SendChannelMessageResponse)
                    return object;
                let message = new $root.kritor.guild.SendChannelMessageResponse();
                if (object.messageId != null)
                    message.messageId = String(object.messageId);
                if (object.time != null)
                    if ($util.Long)
                        (message.time = $util.Long.fromValue(object.time)).unsigned = false;
                    else if (typeof object.time === "string")
                        message.time = parseInt(object.time, 10);
                    else if (typeof object.time === "number")
                        message.time = object.time;
                    else if (typeof object.time === "object")
                        message.time = new $util.LongBits(object.time.low >>> 0, object.time.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a SendChannelMessageResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.SendChannelMessageResponse
             * @static
             * @param {kritor.guild.SendChannelMessageResponse} message SendChannelMessageResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SendChannelMessageResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.messageId = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.time = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.time = options.longs === String ? "0" : 0;
                }
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    object.messageId = message.messageId;
                if (message.time != null && message.hasOwnProperty("time"))
                    if (typeof message.time === "number")
                        object.time = options.longs === String ? String(message.time) : message.time;
                    else
                        object.time = options.longs === String ? $util.Long.prototype.toString.call(message.time) : options.longs === Number ? new $util.LongBits(message.time.low >>> 0, message.time.high >>> 0).toNumber() : message.time;
                return object;
            };

            /**
             * Converts this SendChannelMessageResponse to JSON.
             * @function toJSON
             * @memberof kritor.guild.SendChannelMessageResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SendChannelMessageResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SendChannelMessageResponse
             * @function getTypeUrl
             * @memberof kritor.guild.SendChannelMessageResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SendChannelMessageResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.SendChannelMessageResponse";
            };

            return SendChannelMessageResponse;
        })();

        guild.GetGuildFeedListRequest = (function() {

            /**
             * Properties of a GetGuildFeedListRequest.
             * @memberof kritor.guild
             * @interface IGetGuildFeedListRequest
             * @property {number|Long|null} [guildId] GetGuildFeedListRequest guildId
             * @property {number|null} [from] GetGuildFeedListRequest from
             */

            /**
             * Constructs a new GetGuildFeedListRequest.
             * @memberof kritor.guild
             * @classdesc Represents a GetGuildFeedListRequest.
             * @implements IGetGuildFeedListRequest
             * @constructor
             * @param {kritor.guild.IGetGuildFeedListRequest=} [properties] Properties to set
             */
            function GetGuildFeedListRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetGuildFeedListRequest guildId.
             * @member {number|Long} guildId
             * @memberof kritor.guild.GetGuildFeedListRequest
             * @instance
             */
            GetGuildFeedListRequest.prototype.guildId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GetGuildFeedListRequest from.
             * @member {number} from
             * @memberof kritor.guild.GetGuildFeedListRequest
             * @instance
             */
            GetGuildFeedListRequest.prototype.from = 0;

            /**
             * Creates a new GetGuildFeedListRequest instance using the specified properties.
             * @function create
             * @memberof kritor.guild.GetGuildFeedListRequest
             * @static
             * @param {kritor.guild.IGetGuildFeedListRequest=} [properties] Properties to set
             * @returns {kritor.guild.GetGuildFeedListRequest} GetGuildFeedListRequest instance
             */
            GetGuildFeedListRequest.create = function create(properties) {
                return new GetGuildFeedListRequest(properties);
            };

            /**
             * Encodes the specified GetGuildFeedListRequest message. Does not implicitly {@link kritor.guild.GetGuildFeedListRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.GetGuildFeedListRequest
             * @static
             * @param {kritor.guild.IGetGuildFeedListRequest} message GetGuildFeedListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGuildFeedListRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.guildId != null && Object.hasOwnProperty.call(message, "guildId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.guildId);
                if (message.from != null && Object.hasOwnProperty.call(message, "from"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.from);
                return writer;
            };

            /**
             * Encodes the specified GetGuildFeedListRequest message, length delimited. Does not implicitly {@link kritor.guild.GetGuildFeedListRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.GetGuildFeedListRequest
             * @static
             * @param {kritor.guild.IGetGuildFeedListRequest} message GetGuildFeedListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGuildFeedListRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetGuildFeedListRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.GetGuildFeedListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.GetGuildFeedListRequest} GetGuildFeedListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGuildFeedListRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.GetGuildFeedListRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.guildId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.from = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetGuildFeedListRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.GetGuildFeedListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.GetGuildFeedListRequest} GetGuildFeedListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGuildFeedListRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetGuildFeedListRequest message.
             * @function verify
             * @memberof kritor.guild.GetGuildFeedListRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetGuildFeedListRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.guildId != null && message.hasOwnProperty("guildId"))
                    if (!$util.isInteger(message.guildId) && !(message.guildId && $util.isInteger(message.guildId.low) && $util.isInteger(message.guildId.high)))
                        return "guildId: integer|Long expected";
                if (message.from != null && message.hasOwnProperty("from"))
                    if (!$util.isInteger(message.from))
                        return "from: integer expected";
                return null;
            };

            /**
             * Creates a GetGuildFeedListRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.GetGuildFeedListRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.GetGuildFeedListRequest} GetGuildFeedListRequest
             */
            GetGuildFeedListRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.GetGuildFeedListRequest)
                    return object;
                let message = new $root.kritor.guild.GetGuildFeedListRequest();
                if (object.guildId != null)
                    if ($util.Long)
                        (message.guildId = $util.Long.fromValue(object.guildId)).unsigned = true;
                    else if (typeof object.guildId === "string")
                        message.guildId = parseInt(object.guildId, 10);
                    else if (typeof object.guildId === "number")
                        message.guildId = object.guildId;
                    else if (typeof object.guildId === "object")
                        message.guildId = new $util.LongBits(object.guildId.low >>> 0, object.guildId.high >>> 0).toNumber(true);
                if (object.from != null)
                    message.from = object.from >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a GetGuildFeedListRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.GetGuildFeedListRequest
             * @static
             * @param {kritor.guild.GetGuildFeedListRequest} message GetGuildFeedListRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetGuildFeedListRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.guildId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.guildId = options.longs === String ? "0" : 0;
                    object.from = 0;
                }
                if (message.guildId != null && message.hasOwnProperty("guildId"))
                    if (typeof message.guildId === "number")
                        object.guildId = options.longs === String ? String(message.guildId) : message.guildId;
                    else
                        object.guildId = options.longs === String ? $util.Long.prototype.toString.call(message.guildId) : options.longs === Number ? new $util.LongBits(message.guildId.low >>> 0, message.guildId.high >>> 0).toNumber(true) : message.guildId;
                if (message.from != null && message.hasOwnProperty("from"))
                    object.from = message.from;
                return object;
            };

            /**
             * Converts this GetGuildFeedListRequest to JSON.
             * @function toJSON
             * @memberof kritor.guild.GetGuildFeedListRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetGuildFeedListRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetGuildFeedListRequest
             * @function getTypeUrl
             * @memberof kritor.guild.GetGuildFeedListRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetGuildFeedListRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.GetGuildFeedListRequest";
            };

            return GetGuildFeedListRequest;
        })();

        guild.GetGuildFeedListResponse = (function() {

            /**
             * Properties of a GetGuildFeedListResponse.
             * @memberof kritor.guild
             * @interface IGetGuildFeedListResponse
             * @property {Uint8Array|null} [data] GetGuildFeedListResponse data
             */

            /**
             * Constructs a new GetGuildFeedListResponse.
             * @memberof kritor.guild
             * @classdesc Represents a GetGuildFeedListResponse.
             * @implements IGetGuildFeedListResponse
             * @constructor
             * @param {kritor.guild.IGetGuildFeedListResponse=} [properties] Properties to set
             */
            function GetGuildFeedListResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetGuildFeedListResponse data.
             * @member {Uint8Array} data
             * @memberof kritor.guild.GetGuildFeedListResponse
             * @instance
             */
            GetGuildFeedListResponse.prototype.data = $util.newBuffer([]);

            /**
             * Creates a new GetGuildFeedListResponse instance using the specified properties.
             * @function create
             * @memberof kritor.guild.GetGuildFeedListResponse
             * @static
             * @param {kritor.guild.IGetGuildFeedListResponse=} [properties] Properties to set
             * @returns {kritor.guild.GetGuildFeedListResponse} GetGuildFeedListResponse instance
             */
            GetGuildFeedListResponse.create = function create(properties) {
                return new GetGuildFeedListResponse(properties);
            };

            /**
             * Encodes the specified GetGuildFeedListResponse message. Does not implicitly {@link kritor.guild.GetGuildFeedListResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.GetGuildFeedListResponse
             * @static
             * @param {kritor.guild.IGetGuildFeedListResponse} message GetGuildFeedListResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGuildFeedListResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.data);
                return writer;
            };

            /**
             * Encodes the specified GetGuildFeedListResponse message, length delimited. Does not implicitly {@link kritor.guild.GetGuildFeedListResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.GetGuildFeedListResponse
             * @static
             * @param {kritor.guild.IGetGuildFeedListResponse} message GetGuildFeedListResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGuildFeedListResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetGuildFeedListResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.GetGuildFeedListResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.GetGuildFeedListResponse} GetGuildFeedListResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGuildFeedListResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.GetGuildFeedListResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.data = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetGuildFeedListResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.GetGuildFeedListResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.GetGuildFeedListResponse} GetGuildFeedListResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGuildFeedListResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetGuildFeedListResponse message.
             * @function verify
             * @memberof kritor.guild.GetGuildFeedListResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetGuildFeedListResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.data != null && message.hasOwnProperty("data"))
                    if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                        return "data: buffer expected";
                return null;
            };

            /**
             * Creates a GetGuildFeedListResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.GetGuildFeedListResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.GetGuildFeedListResponse} GetGuildFeedListResponse
             */
            GetGuildFeedListResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.GetGuildFeedListResponse)
                    return object;
                let message = new $root.kritor.guild.GetGuildFeedListResponse();
                if (object.data != null)
                    if (typeof object.data === "string")
                        $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                    else if (object.data.length >= 0)
                        message.data = object.data;
                return message;
            };

            /**
             * Creates a plain object from a GetGuildFeedListResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.GetGuildFeedListResponse
             * @static
             * @param {kritor.guild.GetGuildFeedListResponse} message GetGuildFeedListResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetGuildFeedListResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if (options.bytes === String)
                        object.data = "";
                    else {
                        object.data = [];
                        if (options.bytes !== Array)
                            object.data = $util.newBuffer(object.data);
                    }
                if (message.data != null && message.hasOwnProperty("data"))
                    object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
                return object;
            };

            /**
             * Converts this GetGuildFeedListResponse to JSON.
             * @function toJSON
             * @memberof kritor.guild.GetGuildFeedListResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetGuildFeedListResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetGuildFeedListResponse
             * @function getTypeUrl
             * @memberof kritor.guild.GetGuildFeedListResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetGuildFeedListResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.GetGuildFeedListResponse";
            };

            return GetGuildFeedListResponse;
        })();

        guild.GetGuildRoleListRequest = (function() {

            /**
             * Properties of a GetGuildRoleListRequest.
             * @memberof kritor.guild
             * @interface IGetGuildRoleListRequest
             * @property {number|Long|null} [guildId] GetGuildRoleListRequest guildId
             */

            /**
             * Constructs a new GetGuildRoleListRequest.
             * @memberof kritor.guild
             * @classdesc Represents a GetGuildRoleListRequest.
             * @implements IGetGuildRoleListRequest
             * @constructor
             * @param {kritor.guild.IGetGuildRoleListRequest=} [properties] Properties to set
             */
            function GetGuildRoleListRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetGuildRoleListRequest guildId.
             * @member {number|Long} guildId
             * @memberof kritor.guild.GetGuildRoleListRequest
             * @instance
             */
            GetGuildRoleListRequest.prototype.guildId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new GetGuildRoleListRequest instance using the specified properties.
             * @function create
             * @memberof kritor.guild.GetGuildRoleListRequest
             * @static
             * @param {kritor.guild.IGetGuildRoleListRequest=} [properties] Properties to set
             * @returns {kritor.guild.GetGuildRoleListRequest} GetGuildRoleListRequest instance
             */
            GetGuildRoleListRequest.create = function create(properties) {
                return new GetGuildRoleListRequest(properties);
            };

            /**
             * Encodes the specified GetGuildRoleListRequest message. Does not implicitly {@link kritor.guild.GetGuildRoleListRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.GetGuildRoleListRequest
             * @static
             * @param {kritor.guild.IGetGuildRoleListRequest} message GetGuildRoleListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGuildRoleListRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.guildId != null && Object.hasOwnProperty.call(message, "guildId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.guildId);
                return writer;
            };

            /**
             * Encodes the specified GetGuildRoleListRequest message, length delimited. Does not implicitly {@link kritor.guild.GetGuildRoleListRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.GetGuildRoleListRequest
             * @static
             * @param {kritor.guild.IGetGuildRoleListRequest} message GetGuildRoleListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGuildRoleListRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetGuildRoleListRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.GetGuildRoleListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.GetGuildRoleListRequest} GetGuildRoleListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGuildRoleListRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.GetGuildRoleListRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.guildId = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetGuildRoleListRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.GetGuildRoleListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.GetGuildRoleListRequest} GetGuildRoleListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGuildRoleListRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetGuildRoleListRequest message.
             * @function verify
             * @memberof kritor.guild.GetGuildRoleListRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetGuildRoleListRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.guildId != null && message.hasOwnProperty("guildId"))
                    if (!$util.isInteger(message.guildId) && !(message.guildId && $util.isInteger(message.guildId.low) && $util.isInteger(message.guildId.high)))
                        return "guildId: integer|Long expected";
                return null;
            };

            /**
             * Creates a GetGuildRoleListRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.GetGuildRoleListRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.GetGuildRoleListRequest} GetGuildRoleListRequest
             */
            GetGuildRoleListRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.GetGuildRoleListRequest)
                    return object;
                let message = new $root.kritor.guild.GetGuildRoleListRequest();
                if (object.guildId != null)
                    if ($util.Long)
                        (message.guildId = $util.Long.fromValue(object.guildId)).unsigned = true;
                    else if (typeof object.guildId === "string")
                        message.guildId = parseInt(object.guildId, 10);
                    else if (typeof object.guildId === "number")
                        message.guildId = object.guildId;
                    else if (typeof object.guildId === "object")
                        message.guildId = new $util.LongBits(object.guildId.low >>> 0, object.guildId.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a GetGuildRoleListRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.GetGuildRoleListRequest
             * @static
             * @param {kritor.guild.GetGuildRoleListRequest} message GetGuildRoleListRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetGuildRoleListRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.guildId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.guildId = options.longs === String ? "0" : 0;
                if (message.guildId != null && message.hasOwnProperty("guildId"))
                    if (typeof message.guildId === "number")
                        object.guildId = options.longs === String ? String(message.guildId) : message.guildId;
                    else
                        object.guildId = options.longs === String ? $util.Long.prototype.toString.call(message.guildId) : options.longs === Number ? new $util.LongBits(message.guildId.low >>> 0, message.guildId.high >>> 0).toNumber(true) : message.guildId;
                return object;
            };

            /**
             * Converts this GetGuildRoleListRequest to JSON.
             * @function toJSON
             * @memberof kritor.guild.GetGuildRoleListRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetGuildRoleListRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetGuildRoleListRequest
             * @function getTypeUrl
             * @memberof kritor.guild.GetGuildRoleListRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetGuildRoleListRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.GetGuildRoleListRequest";
            };

            return GetGuildRoleListRequest;
        })();

        guild.GetGuildRoleListResponse = (function() {

            /**
             * Properties of a GetGuildRoleListResponse.
             * @memberof kritor.guild
             * @interface IGetGuildRoleListResponse
             * @property {Array.<kritor.guild.IRoleInfo>|null} [rolesInfo] GetGuildRoleListResponse rolesInfo
             */

            /**
             * Constructs a new GetGuildRoleListResponse.
             * @memberof kritor.guild
             * @classdesc Represents a GetGuildRoleListResponse.
             * @implements IGetGuildRoleListResponse
             * @constructor
             * @param {kritor.guild.IGetGuildRoleListResponse=} [properties] Properties to set
             */
            function GetGuildRoleListResponse(properties) {
                this.rolesInfo = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetGuildRoleListResponse rolesInfo.
             * @member {Array.<kritor.guild.IRoleInfo>} rolesInfo
             * @memberof kritor.guild.GetGuildRoleListResponse
             * @instance
             */
            GetGuildRoleListResponse.prototype.rolesInfo = $util.emptyArray;

            /**
             * Creates a new GetGuildRoleListResponse instance using the specified properties.
             * @function create
             * @memberof kritor.guild.GetGuildRoleListResponse
             * @static
             * @param {kritor.guild.IGetGuildRoleListResponse=} [properties] Properties to set
             * @returns {kritor.guild.GetGuildRoleListResponse} GetGuildRoleListResponse instance
             */
            GetGuildRoleListResponse.create = function create(properties) {
                return new GetGuildRoleListResponse(properties);
            };

            /**
             * Encodes the specified GetGuildRoleListResponse message. Does not implicitly {@link kritor.guild.GetGuildRoleListResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.GetGuildRoleListResponse
             * @static
             * @param {kritor.guild.IGetGuildRoleListResponse} message GetGuildRoleListResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGuildRoleListResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.rolesInfo != null && message.rolesInfo.length)
                    for (let i = 0; i < message.rolesInfo.length; ++i)
                        $root.kritor.guild.RoleInfo.encode(message.rolesInfo[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetGuildRoleListResponse message, length delimited. Does not implicitly {@link kritor.guild.GetGuildRoleListResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.GetGuildRoleListResponse
             * @static
             * @param {kritor.guild.IGetGuildRoleListResponse} message GetGuildRoleListResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetGuildRoleListResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetGuildRoleListResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.GetGuildRoleListResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.GetGuildRoleListResponse} GetGuildRoleListResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGuildRoleListResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.GetGuildRoleListResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.rolesInfo && message.rolesInfo.length))
                                message.rolesInfo = [];
                            message.rolesInfo.push($root.kritor.guild.RoleInfo.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetGuildRoleListResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.GetGuildRoleListResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.GetGuildRoleListResponse} GetGuildRoleListResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetGuildRoleListResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetGuildRoleListResponse message.
             * @function verify
             * @memberof kritor.guild.GetGuildRoleListResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetGuildRoleListResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.rolesInfo != null && message.hasOwnProperty("rolesInfo")) {
                    if (!Array.isArray(message.rolesInfo))
                        return "rolesInfo: array expected";
                    for (let i = 0; i < message.rolesInfo.length; ++i) {
                        let error = $root.kritor.guild.RoleInfo.verify(message.rolesInfo[i]);
                        if (error)
                            return "rolesInfo." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a GetGuildRoleListResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.GetGuildRoleListResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.GetGuildRoleListResponse} GetGuildRoleListResponse
             */
            GetGuildRoleListResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.GetGuildRoleListResponse)
                    return object;
                let message = new $root.kritor.guild.GetGuildRoleListResponse();
                if (object.rolesInfo) {
                    if (!Array.isArray(object.rolesInfo))
                        throw TypeError(".kritor.guild.GetGuildRoleListResponse.rolesInfo: array expected");
                    message.rolesInfo = [];
                    for (let i = 0; i < object.rolesInfo.length; ++i) {
                        if (typeof object.rolesInfo[i] !== "object")
                            throw TypeError(".kritor.guild.GetGuildRoleListResponse.rolesInfo: object expected");
                        message.rolesInfo[i] = $root.kritor.guild.RoleInfo.fromObject(object.rolesInfo[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a GetGuildRoleListResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.GetGuildRoleListResponse
             * @static
             * @param {kritor.guild.GetGuildRoleListResponse} message GetGuildRoleListResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetGuildRoleListResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.rolesInfo = [];
                if (message.rolesInfo && message.rolesInfo.length) {
                    object.rolesInfo = [];
                    for (let j = 0; j < message.rolesInfo.length; ++j)
                        object.rolesInfo[j] = $root.kritor.guild.RoleInfo.toObject(message.rolesInfo[j], options);
                }
                return object;
            };

            /**
             * Converts this GetGuildRoleListResponse to JSON.
             * @function toJSON
             * @memberof kritor.guild.GetGuildRoleListResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetGuildRoleListResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetGuildRoleListResponse
             * @function getTypeUrl
             * @memberof kritor.guild.GetGuildRoleListResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetGuildRoleListResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.GetGuildRoleListResponse";
            };

            return GetGuildRoleListResponse;
        })();

        guild.DeleteGuildRoleRequest = (function() {

            /**
             * Properties of a DeleteGuildRoleRequest.
             * @memberof kritor.guild
             * @interface IDeleteGuildRoleRequest
             * @property {number|Long|null} [guildId] DeleteGuildRoleRequest guildId
             * @property {number|Long|null} [roleId] DeleteGuildRoleRequest roleId
             */

            /**
             * Constructs a new DeleteGuildRoleRequest.
             * @memberof kritor.guild
             * @classdesc Represents a DeleteGuildRoleRequest.
             * @implements IDeleteGuildRoleRequest
             * @constructor
             * @param {kritor.guild.IDeleteGuildRoleRequest=} [properties] Properties to set
             */
            function DeleteGuildRoleRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DeleteGuildRoleRequest guildId.
             * @member {number|Long} guildId
             * @memberof kritor.guild.DeleteGuildRoleRequest
             * @instance
             */
            DeleteGuildRoleRequest.prototype.guildId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * DeleteGuildRoleRequest roleId.
             * @member {number|Long} roleId
             * @memberof kritor.guild.DeleteGuildRoleRequest
             * @instance
             */
            DeleteGuildRoleRequest.prototype.roleId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new DeleteGuildRoleRequest instance using the specified properties.
             * @function create
             * @memberof kritor.guild.DeleteGuildRoleRequest
             * @static
             * @param {kritor.guild.IDeleteGuildRoleRequest=} [properties] Properties to set
             * @returns {kritor.guild.DeleteGuildRoleRequest} DeleteGuildRoleRequest instance
             */
            DeleteGuildRoleRequest.create = function create(properties) {
                return new DeleteGuildRoleRequest(properties);
            };

            /**
             * Encodes the specified DeleteGuildRoleRequest message. Does not implicitly {@link kritor.guild.DeleteGuildRoleRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.DeleteGuildRoleRequest
             * @static
             * @param {kritor.guild.IDeleteGuildRoleRequest} message DeleteGuildRoleRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteGuildRoleRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.guildId != null && Object.hasOwnProperty.call(message, "guildId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.guildId);
                if (message.roleId != null && Object.hasOwnProperty.call(message, "roleId"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roleId);
                return writer;
            };

            /**
             * Encodes the specified DeleteGuildRoleRequest message, length delimited. Does not implicitly {@link kritor.guild.DeleteGuildRoleRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.DeleteGuildRoleRequest
             * @static
             * @param {kritor.guild.IDeleteGuildRoleRequest} message DeleteGuildRoleRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteGuildRoleRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeleteGuildRoleRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.DeleteGuildRoleRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.DeleteGuildRoleRequest} DeleteGuildRoleRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteGuildRoleRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.DeleteGuildRoleRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.guildId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.roleId = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DeleteGuildRoleRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.DeleteGuildRoleRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.DeleteGuildRoleRequest} DeleteGuildRoleRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteGuildRoleRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeleteGuildRoleRequest message.
             * @function verify
             * @memberof kritor.guild.DeleteGuildRoleRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeleteGuildRoleRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.guildId != null && message.hasOwnProperty("guildId"))
                    if (!$util.isInteger(message.guildId) && !(message.guildId && $util.isInteger(message.guildId.low) && $util.isInteger(message.guildId.high)))
                        return "guildId: integer|Long expected";
                if (message.roleId != null && message.hasOwnProperty("roleId"))
                    if (!$util.isInteger(message.roleId) && !(message.roleId && $util.isInteger(message.roleId.low) && $util.isInteger(message.roleId.high)))
                        return "roleId: integer|Long expected";
                return null;
            };

            /**
             * Creates a DeleteGuildRoleRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.DeleteGuildRoleRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.DeleteGuildRoleRequest} DeleteGuildRoleRequest
             */
            DeleteGuildRoleRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.DeleteGuildRoleRequest)
                    return object;
                let message = new $root.kritor.guild.DeleteGuildRoleRequest();
                if (object.guildId != null)
                    if ($util.Long)
                        (message.guildId = $util.Long.fromValue(object.guildId)).unsigned = true;
                    else if (typeof object.guildId === "string")
                        message.guildId = parseInt(object.guildId, 10);
                    else if (typeof object.guildId === "number")
                        message.guildId = object.guildId;
                    else if (typeof object.guildId === "object")
                        message.guildId = new $util.LongBits(object.guildId.low >>> 0, object.guildId.high >>> 0).toNumber(true);
                if (object.roleId != null)
                    if ($util.Long)
                        (message.roleId = $util.Long.fromValue(object.roleId)).unsigned = true;
                    else if (typeof object.roleId === "string")
                        message.roleId = parseInt(object.roleId, 10);
                    else if (typeof object.roleId === "number")
                        message.roleId = object.roleId;
                    else if (typeof object.roleId === "object")
                        message.roleId = new $util.LongBits(object.roleId.low >>> 0, object.roleId.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a DeleteGuildRoleRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.DeleteGuildRoleRequest
             * @static
             * @param {kritor.guild.DeleteGuildRoleRequest} message DeleteGuildRoleRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeleteGuildRoleRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.guildId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.guildId = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.roleId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.roleId = options.longs === String ? "0" : 0;
                }
                if (message.guildId != null && message.hasOwnProperty("guildId"))
                    if (typeof message.guildId === "number")
                        object.guildId = options.longs === String ? String(message.guildId) : message.guildId;
                    else
                        object.guildId = options.longs === String ? $util.Long.prototype.toString.call(message.guildId) : options.longs === Number ? new $util.LongBits(message.guildId.low >>> 0, message.guildId.high >>> 0).toNumber(true) : message.guildId;
                if (message.roleId != null && message.hasOwnProperty("roleId"))
                    if (typeof message.roleId === "number")
                        object.roleId = options.longs === String ? String(message.roleId) : message.roleId;
                    else
                        object.roleId = options.longs === String ? $util.Long.prototype.toString.call(message.roleId) : options.longs === Number ? new $util.LongBits(message.roleId.low >>> 0, message.roleId.high >>> 0).toNumber(true) : message.roleId;
                return object;
            };

            /**
             * Converts this DeleteGuildRoleRequest to JSON.
             * @function toJSON
             * @memberof kritor.guild.DeleteGuildRoleRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeleteGuildRoleRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DeleteGuildRoleRequest
             * @function getTypeUrl
             * @memberof kritor.guild.DeleteGuildRoleRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DeleteGuildRoleRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.DeleteGuildRoleRequest";
            };

            return DeleteGuildRoleRequest;
        })();

        guild.DeleteGuildRoleResponse = (function() {

            /**
             * Properties of a DeleteGuildRoleResponse.
             * @memberof kritor.guild
             * @interface IDeleteGuildRoleResponse
             */

            /**
             * Constructs a new DeleteGuildRoleResponse.
             * @memberof kritor.guild
             * @classdesc Represents a DeleteGuildRoleResponse.
             * @implements IDeleteGuildRoleResponse
             * @constructor
             * @param {kritor.guild.IDeleteGuildRoleResponse=} [properties] Properties to set
             */
            function DeleteGuildRoleResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new DeleteGuildRoleResponse instance using the specified properties.
             * @function create
             * @memberof kritor.guild.DeleteGuildRoleResponse
             * @static
             * @param {kritor.guild.IDeleteGuildRoleResponse=} [properties] Properties to set
             * @returns {kritor.guild.DeleteGuildRoleResponse} DeleteGuildRoleResponse instance
             */
            DeleteGuildRoleResponse.create = function create(properties) {
                return new DeleteGuildRoleResponse(properties);
            };

            /**
             * Encodes the specified DeleteGuildRoleResponse message. Does not implicitly {@link kritor.guild.DeleteGuildRoleResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.DeleteGuildRoleResponse
             * @static
             * @param {kritor.guild.IDeleteGuildRoleResponse} message DeleteGuildRoleResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteGuildRoleResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified DeleteGuildRoleResponse message, length delimited. Does not implicitly {@link kritor.guild.DeleteGuildRoleResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.DeleteGuildRoleResponse
             * @static
             * @param {kritor.guild.IDeleteGuildRoleResponse} message DeleteGuildRoleResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteGuildRoleResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeleteGuildRoleResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.DeleteGuildRoleResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.DeleteGuildRoleResponse} DeleteGuildRoleResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteGuildRoleResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.DeleteGuildRoleResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DeleteGuildRoleResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.DeleteGuildRoleResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.DeleteGuildRoleResponse} DeleteGuildRoleResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteGuildRoleResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeleteGuildRoleResponse message.
             * @function verify
             * @memberof kritor.guild.DeleteGuildRoleResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeleteGuildRoleResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a DeleteGuildRoleResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.DeleteGuildRoleResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.DeleteGuildRoleResponse} DeleteGuildRoleResponse
             */
            DeleteGuildRoleResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.DeleteGuildRoleResponse)
                    return object;
                return new $root.kritor.guild.DeleteGuildRoleResponse();
            };

            /**
             * Creates a plain object from a DeleteGuildRoleResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.DeleteGuildRoleResponse
             * @static
             * @param {kritor.guild.DeleteGuildRoleResponse} message DeleteGuildRoleResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeleteGuildRoleResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this DeleteGuildRoleResponse to JSON.
             * @function toJSON
             * @memberof kritor.guild.DeleteGuildRoleResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeleteGuildRoleResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DeleteGuildRoleResponse
             * @function getTypeUrl
             * @memberof kritor.guild.DeleteGuildRoleResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DeleteGuildRoleResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.DeleteGuildRoleResponse";
            };

            return DeleteGuildRoleResponse;
        })();

        guild.SetGuildMemberRoleRequest = (function() {

            /**
             * Properties of a SetGuildMemberRoleRequest.
             * @memberof kritor.guild
             * @interface ISetGuildMemberRoleRequest
             * @property {number|Long|null} [guildId] SetGuildMemberRoleRequest guildId
             * @property {number|Long|null} [roleId] SetGuildMemberRoleRequest roleId
             * @property {boolean|null} [set] SetGuildMemberRoleRequest set
             * @property {Array.<string>|null} [tinyIds] SetGuildMemberRoleRequest tinyIds
             */

            /**
             * Constructs a new SetGuildMemberRoleRequest.
             * @memberof kritor.guild
             * @classdesc Represents a SetGuildMemberRoleRequest.
             * @implements ISetGuildMemberRoleRequest
             * @constructor
             * @param {kritor.guild.ISetGuildMemberRoleRequest=} [properties] Properties to set
             */
            function SetGuildMemberRoleRequest(properties) {
                this.tinyIds = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SetGuildMemberRoleRequest guildId.
             * @member {number|Long} guildId
             * @memberof kritor.guild.SetGuildMemberRoleRequest
             * @instance
             */
            SetGuildMemberRoleRequest.prototype.guildId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * SetGuildMemberRoleRequest roleId.
             * @member {number|Long} roleId
             * @memberof kritor.guild.SetGuildMemberRoleRequest
             * @instance
             */
            SetGuildMemberRoleRequest.prototype.roleId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * SetGuildMemberRoleRequest set.
             * @member {boolean} set
             * @memberof kritor.guild.SetGuildMemberRoleRequest
             * @instance
             */
            SetGuildMemberRoleRequest.prototype.set = false;

            /**
             * SetGuildMemberRoleRequest tinyIds.
             * @member {Array.<string>} tinyIds
             * @memberof kritor.guild.SetGuildMemberRoleRequest
             * @instance
             */
            SetGuildMemberRoleRequest.prototype.tinyIds = $util.emptyArray;

            /**
             * Creates a new SetGuildMemberRoleRequest instance using the specified properties.
             * @function create
             * @memberof kritor.guild.SetGuildMemberRoleRequest
             * @static
             * @param {kritor.guild.ISetGuildMemberRoleRequest=} [properties] Properties to set
             * @returns {kritor.guild.SetGuildMemberRoleRequest} SetGuildMemberRoleRequest instance
             */
            SetGuildMemberRoleRequest.create = function create(properties) {
                return new SetGuildMemberRoleRequest(properties);
            };

            /**
             * Encodes the specified SetGuildMemberRoleRequest message. Does not implicitly {@link kritor.guild.SetGuildMemberRoleRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.SetGuildMemberRoleRequest
             * @static
             * @param {kritor.guild.ISetGuildMemberRoleRequest} message SetGuildMemberRoleRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetGuildMemberRoleRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.guildId != null && Object.hasOwnProperty.call(message, "guildId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.guildId);
                if (message.roleId != null && Object.hasOwnProperty.call(message, "roleId"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roleId);
                if (message.set != null && Object.hasOwnProperty.call(message, "set"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.set);
                if (message.tinyIds != null && message.tinyIds.length)
                    for (let i = 0; i < message.tinyIds.length; ++i)
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.tinyIds[i]);
                return writer;
            };

            /**
             * Encodes the specified SetGuildMemberRoleRequest message, length delimited. Does not implicitly {@link kritor.guild.SetGuildMemberRoleRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.SetGuildMemberRoleRequest
             * @static
             * @param {kritor.guild.ISetGuildMemberRoleRequest} message SetGuildMemberRoleRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetGuildMemberRoleRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetGuildMemberRoleRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.SetGuildMemberRoleRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.SetGuildMemberRoleRequest} SetGuildMemberRoleRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetGuildMemberRoleRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.SetGuildMemberRoleRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.guildId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.roleId = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.set = reader.bool();
                            break;
                        }
                    case 4: {
                            if (!(message.tinyIds && message.tinyIds.length))
                                message.tinyIds = [];
                            message.tinyIds.push(reader.string());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetGuildMemberRoleRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.SetGuildMemberRoleRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.SetGuildMemberRoleRequest} SetGuildMemberRoleRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetGuildMemberRoleRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetGuildMemberRoleRequest message.
             * @function verify
             * @memberof kritor.guild.SetGuildMemberRoleRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetGuildMemberRoleRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.guildId != null && message.hasOwnProperty("guildId"))
                    if (!$util.isInteger(message.guildId) && !(message.guildId && $util.isInteger(message.guildId.low) && $util.isInteger(message.guildId.high)))
                        return "guildId: integer|Long expected";
                if (message.roleId != null && message.hasOwnProperty("roleId"))
                    if (!$util.isInteger(message.roleId) && !(message.roleId && $util.isInteger(message.roleId.low) && $util.isInteger(message.roleId.high)))
                        return "roleId: integer|Long expected";
                if (message.set != null && message.hasOwnProperty("set"))
                    if (typeof message.set !== "boolean")
                        return "set: boolean expected";
                if (message.tinyIds != null && message.hasOwnProperty("tinyIds")) {
                    if (!Array.isArray(message.tinyIds))
                        return "tinyIds: array expected";
                    for (let i = 0; i < message.tinyIds.length; ++i)
                        if (!$util.isString(message.tinyIds[i]))
                            return "tinyIds: string[] expected";
                }
                return null;
            };

            /**
             * Creates a SetGuildMemberRoleRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.SetGuildMemberRoleRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.SetGuildMemberRoleRequest} SetGuildMemberRoleRequest
             */
            SetGuildMemberRoleRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.SetGuildMemberRoleRequest)
                    return object;
                let message = new $root.kritor.guild.SetGuildMemberRoleRequest();
                if (object.guildId != null)
                    if ($util.Long)
                        (message.guildId = $util.Long.fromValue(object.guildId)).unsigned = true;
                    else if (typeof object.guildId === "string")
                        message.guildId = parseInt(object.guildId, 10);
                    else if (typeof object.guildId === "number")
                        message.guildId = object.guildId;
                    else if (typeof object.guildId === "object")
                        message.guildId = new $util.LongBits(object.guildId.low >>> 0, object.guildId.high >>> 0).toNumber(true);
                if (object.roleId != null)
                    if ($util.Long)
                        (message.roleId = $util.Long.fromValue(object.roleId)).unsigned = true;
                    else if (typeof object.roleId === "string")
                        message.roleId = parseInt(object.roleId, 10);
                    else if (typeof object.roleId === "number")
                        message.roleId = object.roleId;
                    else if (typeof object.roleId === "object")
                        message.roleId = new $util.LongBits(object.roleId.low >>> 0, object.roleId.high >>> 0).toNumber(true);
                if (object.set != null)
                    message.set = Boolean(object.set);
                if (object.tinyIds) {
                    if (!Array.isArray(object.tinyIds))
                        throw TypeError(".kritor.guild.SetGuildMemberRoleRequest.tinyIds: array expected");
                    message.tinyIds = [];
                    for (let i = 0; i < object.tinyIds.length; ++i)
                        message.tinyIds[i] = String(object.tinyIds[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a SetGuildMemberRoleRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.SetGuildMemberRoleRequest
             * @static
             * @param {kritor.guild.SetGuildMemberRoleRequest} message SetGuildMemberRoleRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetGuildMemberRoleRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.tinyIds = [];
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.guildId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.guildId = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.roleId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.roleId = options.longs === String ? "0" : 0;
                    object.set = false;
                }
                if (message.guildId != null && message.hasOwnProperty("guildId"))
                    if (typeof message.guildId === "number")
                        object.guildId = options.longs === String ? String(message.guildId) : message.guildId;
                    else
                        object.guildId = options.longs === String ? $util.Long.prototype.toString.call(message.guildId) : options.longs === Number ? new $util.LongBits(message.guildId.low >>> 0, message.guildId.high >>> 0).toNumber(true) : message.guildId;
                if (message.roleId != null && message.hasOwnProperty("roleId"))
                    if (typeof message.roleId === "number")
                        object.roleId = options.longs === String ? String(message.roleId) : message.roleId;
                    else
                        object.roleId = options.longs === String ? $util.Long.prototype.toString.call(message.roleId) : options.longs === Number ? new $util.LongBits(message.roleId.low >>> 0, message.roleId.high >>> 0).toNumber(true) : message.roleId;
                if (message.set != null && message.hasOwnProperty("set"))
                    object.set = message.set;
                if (message.tinyIds && message.tinyIds.length) {
                    object.tinyIds = [];
                    for (let j = 0; j < message.tinyIds.length; ++j)
                        object.tinyIds[j] = message.tinyIds[j];
                }
                return object;
            };

            /**
             * Converts this SetGuildMemberRoleRequest to JSON.
             * @function toJSON
             * @memberof kritor.guild.SetGuildMemberRoleRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetGuildMemberRoleRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetGuildMemberRoleRequest
             * @function getTypeUrl
             * @memberof kritor.guild.SetGuildMemberRoleRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetGuildMemberRoleRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.SetGuildMemberRoleRequest";
            };

            return SetGuildMemberRoleRequest;
        })();

        guild.SetGuildMemberRoleResponse = (function() {

            /**
             * Properties of a SetGuildMemberRoleResponse.
             * @memberof kritor.guild
             * @interface ISetGuildMemberRoleResponse
             */

            /**
             * Constructs a new SetGuildMemberRoleResponse.
             * @memberof kritor.guild
             * @classdesc Represents a SetGuildMemberRoleResponse.
             * @implements ISetGuildMemberRoleResponse
             * @constructor
             * @param {kritor.guild.ISetGuildMemberRoleResponse=} [properties] Properties to set
             */
            function SetGuildMemberRoleResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new SetGuildMemberRoleResponse instance using the specified properties.
             * @function create
             * @memberof kritor.guild.SetGuildMemberRoleResponse
             * @static
             * @param {kritor.guild.ISetGuildMemberRoleResponse=} [properties] Properties to set
             * @returns {kritor.guild.SetGuildMemberRoleResponse} SetGuildMemberRoleResponse instance
             */
            SetGuildMemberRoleResponse.create = function create(properties) {
                return new SetGuildMemberRoleResponse(properties);
            };

            /**
             * Encodes the specified SetGuildMemberRoleResponse message. Does not implicitly {@link kritor.guild.SetGuildMemberRoleResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.SetGuildMemberRoleResponse
             * @static
             * @param {kritor.guild.ISetGuildMemberRoleResponse} message SetGuildMemberRoleResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetGuildMemberRoleResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified SetGuildMemberRoleResponse message, length delimited. Does not implicitly {@link kritor.guild.SetGuildMemberRoleResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.SetGuildMemberRoleResponse
             * @static
             * @param {kritor.guild.ISetGuildMemberRoleResponse} message SetGuildMemberRoleResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetGuildMemberRoleResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetGuildMemberRoleResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.SetGuildMemberRoleResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.SetGuildMemberRoleResponse} SetGuildMemberRoleResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetGuildMemberRoleResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.SetGuildMemberRoleResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetGuildMemberRoleResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.SetGuildMemberRoleResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.SetGuildMemberRoleResponse} SetGuildMemberRoleResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetGuildMemberRoleResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetGuildMemberRoleResponse message.
             * @function verify
             * @memberof kritor.guild.SetGuildMemberRoleResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetGuildMemberRoleResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a SetGuildMemberRoleResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.SetGuildMemberRoleResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.SetGuildMemberRoleResponse} SetGuildMemberRoleResponse
             */
            SetGuildMemberRoleResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.SetGuildMemberRoleResponse)
                    return object;
                return new $root.kritor.guild.SetGuildMemberRoleResponse();
            };

            /**
             * Creates a plain object from a SetGuildMemberRoleResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.SetGuildMemberRoleResponse
             * @static
             * @param {kritor.guild.SetGuildMemberRoleResponse} message SetGuildMemberRoleResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetGuildMemberRoleResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this SetGuildMemberRoleResponse to JSON.
             * @function toJSON
             * @memberof kritor.guild.SetGuildMemberRoleResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetGuildMemberRoleResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetGuildMemberRoleResponse
             * @function getTypeUrl
             * @memberof kritor.guild.SetGuildMemberRoleResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetGuildMemberRoleResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.SetGuildMemberRoleResponse";
            };

            return SetGuildMemberRoleResponse;
        })();

        guild.UpdateGuildRoleRequest = (function() {

            /**
             * Properties of an UpdateGuildRoleRequest.
             * @memberof kritor.guild
             * @interface IUpdateGuildRoleRequest
             * @property {number|Long|null} [guildId] UpdateGuildRoleRequest guildId
             * @property {number|Long|null} [roleId] UpdateGuildRoleRequest roleId
             * @property {string|null} [name] UpdateGuildRoleRequest name
             * @property {number|Long|null} [color] UpdateGuildRoleRequest color
             */

            /**
             * Constructs a new UpdateGuildRoleRequest.
             * @memberof kritor.guild
             * @classdesc Represents an UpdateGuildRoleRequest.
             * @implements IUpdateGuildRoleRequest
             * @constructor
             * @param {kritor.guild.IUpdateGuildRoleRequest=} [properties] Properties to set
             */
            function UpdateGuildRoleRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * UpdateGuildRoleRequest guildId.
             * @member {number|Long} guildId
             * @memberof kritor.guild.UpdateGuildRoleRequest
             * @instance
             */
            UpdateGuildRoleRequest.prototype.guildId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * UpdateGuildRoleRequest roleId.
             * @member {number|Long} roleId
             * @memberof kritor.guild.UpdateGuildRoleRequest
             * @instance
             */
            UpdateGuildRoleRequest.prototype.roleId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * UpdateGuildRoleRequest name.
             * @member {string} name
             * @memberof kritor.guild.UpdateGuildRoleRequest
             * @instance
             */
            UpdateGuildRoleRequest.prototype.name = "";

            /**
             * UpdateGuildRoleRequest color.
             * @member {number|Long} color
             * @memberof kritor.guild.UpdateGuildRoleRequest
             * @instance
             */
            UpdateGuildRoleRequest.prototype.color = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new UpdateGuildRoleRequest instance using the specified properties.
             * @function create
             * @memberof kritor.guild.UpdateGuildRoleRequest
             * @static
             * @param {kritor.guild.IUpdateGuildRoleRequest=} [properties] Properties to set
             * @returns {kritor.guild.UpdateGuildRoleRequest} UpdateGuildRoleRequest instance
             */
            UpdateGuildRoleRequest.create = function create(properties) {
                return new UpdateGuildRoleRequest(properties);
            };

            /**
             * Encodes the specified UpdateGuildRoleRequest message. Does not implicitly {@link kritor.guild.UpdateGuildRoleRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.UpdateGuildRoleRequest
             * @static
             * @param {kritor.guild.IUpdateGuildRoleRequest} message UpdateGuildRoleRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UpdateGuildRoleRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.guildId != null && Object.hasOwnProperty.call(message, "guildId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.guildId);
                if (message.roleId != null && Object.hasOwnProperty.call(message, "roleId"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.roleId);
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
                if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int64(message.color);
                return writer;
            };

            /**
             * Encodes the specified UpdateGuildRoleRequest message, length delimited. Does not implicitly {@link kritor.guild.UpdateGuildRoleRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.UpdateGuildRoleRequest
             * @static
             * @param {kritor.guild.IUpdateGuildRoleRequest} message UpdateGuildRoleRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UpdateGuildRoleRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an UpdateGuildRoleRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.UpdateGuildRoleRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.UpdateGuildRoleRequest} UpdateGuildRoleRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UpdateGuildRoleRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.UpdateGuildRoleRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.guildId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.roleId = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.name = reader.string();
                            break;
                        }
                    case 4: {
                            message.color = reader.int64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an UpdateGuildRoleRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.UpdateGuildRoleRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.UpdateGuildRoleRequest} UpdateGuildRoleRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UpdateGuildRoleRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an UpdateGuildRoleRequest message.
             * @function verify
             * @memberof kritor.guild.UpdateGuildRoleRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UpdateGuildRoleRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.guildId != null && message.hasOwnProperty("guildId"))
                    if (!$util.isInteger(message.guildId) && !(message.guildId && $util.isInteger(message.guildId.low) && $util.isInteger(message.guildId.high)))
                        return "guildId: integer|Long expected";
                if (message.roleId != null && message.hasOwnProperty("roleId"))
                    if (!$util.isInteger(message.roleId) && !(message.roleId && $util.isInteger(message.roleId.low) && $util.isInteger(message.roleId.high)))
                        return "roleId: integer|Long expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.color != null && message.hasOwnProperty("color"))
                    if (!$util.isInteger(message.color) && !(message.color && $util.isInteger(message.color.low) && $util.isInteger(message.color.high)))
                        return "color: integer|Long expected";
                return null;
            };

            /**
             * Creates an UpdateGuildRoleRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.UpdateGuildRoleRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.UpdateGuildRoleRequest} UpdateGuildRoleRequest
             */
            UpdateGuildRoleRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.UpdateGuildRoleRequest)
                    return object;
                let message = new $root.kritor.guild.UpdateGuildRoleRequest();
                if (object.guildId != null)
                    if ($util.Long)
                        (message.guildId = $util.Long.fromValue(object.guildId)).unsigned = true;
                    else if (typeof object.guildId === "string")
                        message.guildId = parseInt(object.guildId, 10);
                    else if (typeof object.guildId === "number")
                        message.guildId = object.guildId;
                    else if (typeof object.guildId === "object")
                        message.guildId = new $util.LongBits(object.guildId.low >>> 0, object.guildId.high >>> 0).toNumber(true);
                if (object.roleId != null)
                    if ($util.Long)
                        (message.roleId = $util.Long.fromValue(object.roleId)).unsigned = true;
                    else if (typeof object.roleId === "string")
                        message.roleId = parseInt(object.roleId, 10);
                    else if (typeof object.roleId === "number")
                        message.roleId = object.roleId;
                    else if (typeof object.roleId === "object")
                        message.roleId = new $util.LongBits(object.roleId.low >>> 0, object.roleId.high >>> 0).toNumber(true);
                if (object.name != null)
                    message.name = String(object.name);
                if (object.color != null)
                    if ($util.Long)
                        (message.color = $util.Long.fromValue(object.color)).unsigned = false;
                    else if (typeof object.color === "string")
                        message.color = parseInt(object.color, 10);
                    else if (typeof object.color === "number")
                        message.color = object.color;
                    else if (typeof object.color === "object")
                        message.color = new $util.LongBits(object.color.low >>> 0, object.color.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from an UpdateGuildRoleRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.UpdateGuildRoleRequest
             * @static
             * @param {kritor.guild.UpdateGuildRoleRequest} message UpdateGuildRoleRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UpdateGuildRoleRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.guildId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.guildId = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.roleId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.roleId = options.longs === String ? "0" : 0;
                    object.name = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.color = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.color = options.longs === String ? "0" : 0;
                }
                if (message.guildId != null && message.hasOwnProperty("guildId"))
                    if (typeof message.guildId === "number")
                        object.guildId = options.longs === String ? String(message.guildId) : message.guildId;
                    else
                        object.guildId = options.longs === String ? $util.Long.prototype.toString.call(message.guildId) : options.longs === Number ? new $util.LongBits(message.guildId.low >>> 0, message.guildId.high >>> 0).toNumber(true) : message.guildId;
                if (message.roleId != null && message.hasOwnProperty("roleId"))
                    if (typeof message.roleId === "number")
                        object.roleId = options.longs === String ? String(message.roleId) : message.roleId;
                    else
                        object.roleId = options.longs === String ? $util.Long.prototype.toString.call(message.roleId) : options.longs === Number ? new $util.LongBits(message.roleId.low >>> 0, message.roleId.high >>> 0).toNumber(true) : message.roleId;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.color != null && message.hasOwnProperty("color"))
                    if (typeof message.color === "number")
                        object.color = options.longs === String ? String(message.color) : message.color;
                    else
                        object.color = options.longs === String ? $util.Long.prototype.toString.call(message.color) : options.longs === Number ? new $util.LongBits(message.color.low >>> 0, message.color.high >>> 0).toNumber() : message.color;
                return object;
            };

            /**
             * Converts this UpdateGuildRoleRequest to JSON.
             * @function toJSON
             * @memberof kritor.guild.UpdateGuildRoleRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UpdateGuildRoleRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for UpdateGuildRoleRequest
             * @function getTypeUrl
             * @memberof kritor.guild.UpdateGuildRoleRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            UpdateGuildRoleRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.UpdateGuildRoleRequest";
            };

            return UpdateGuildRoleRequest;
        })();

        guild.UpdateGuildRoleResponse = (function() {

            /**
             * Properties of an UpdateGuildRoleResponse.
             * @memberof kritor.guild
             * @interface IUpdateGuildRoleResponse
             */

            /**
             * Constructs a new UpdateGuildRoleResponse.
             * @memberof kritor.guild
             * @classdesc Represents an UpdateGuildRoleResponse.
             * @implements IUpdateGuildRoleResponse
             * @constructor
             * @param {kritor.guild.IUpdateGuildRoleResponse=} [properties] Properties to set
             */
            function UpdateGuildRoleResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new UpdateGuildRoleResponse instance using the specified properties.
             * @function create
             * @memberof kritor.guild.UpdateGuildRoleResponse
             * @static
             * @param {kritor.guild.IUpdateGuildRoleResponse=} [properties] Properties to set
             * @returns {kritor.guild.UpdateGuildRoleResponse} UpdateGuildRoleResponse instance
             */
            UpdateGuildRoleResponse.create = function create(properties) {
                return new UpdateGuildRoleResponse(properties);
            };

            /**
             * Encodes the specified UpdateGuildRoleResponse message. Does not implicitly {@link kritor.guild.UpdateGuildRoleResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.UpdateGuildRoleResponse
             * @static
             * @param {kritor.guild.IUpdateGuildRoleResponse} message UpdateGuildRoleResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UpdateGuildRoleResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified UpdateGuildRoleResponse message, length delimited. Does not implicitly {@link kritor.guild.UpdateGuildRoleResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.UpdateGuildRoleResponse
             * @static
             * @param {kritor.guild.IUpdateGuildRoleResponse} message UpdateGuildRoleResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UpdateGuildRoleResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an UpdateGuildRoleResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.UpdateGuildRoleResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.UpdateGuildRoleResponse} UpdateGuildRoleResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UpdateGuildRoleResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.UpdateGuildRoleResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an UpdateGuildRoleResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.UpdateGuildRoleResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.UpdateGuildRoleResponse} UpdateGuildRoleResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UpdateGuildRoleResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an UpdateGuildRoleResponse message.
             * @function verify
             * @memberof kritor.guild.UpdateGuildRoleResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UpdateGuildRoleResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates an UpdateGuildRoleResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.UpdateGuildRoleResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.UpdateGuildRoleResponse} UpdateGuildRoleResponse
             */
            UpdateGuildRoleResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.UpdateGuildRoleResponse)
                    return object;
                return new $root.kritor.guild.UpdateGuildRoleResponse();
            };

            /**
             * Creates a plain object from an UpdateGuildRoleResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.UpdateGuildRoleResponse
             * @static
             * @param {kritor.guild.UpdateGuildRoleResponse} message UpdateGuildRoleResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UpdateGuildRoleResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this UpdateGuildRoleResponse to JSON.
             * @function toJSON
             * @memberof kritor.guild.UpdateGuildRoleResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UpdateGuildRoleResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for UpdateGuildRoleResponse
             * @function getTypeUrl
             * @memberof kritor.guild.UpdateGuildRoleResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            UpdateGuildRoleResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.UpdateGuildRoleResponse";
            };

            return UpdateGuildRoleResponse;
        })();

        guild.CreateGuildRoleRequest = (function() {

            /**
             * Properties of a CreateGuildRoleRequest.
             * @memberof kritor.guild
             * @interface ICreateGuildRoleRequest
             * @property {number|Long|null} [guildId] CreateGuildRoleRequest guildId
             * @property {string|null} [name] CreateGuildRoleRequest name
             * @property {number|Long|null} [color] CreateGuildRoleRequest color
             */

            /**
             * Constructs a new CreateGuildRoleRequest.
             * @memberof kritor.guild
             * @classdesc Represents a CreateGuildRoleRequest.
             * @implements ICreateGuildRoleRequest
             * @constructor
             * @param {kritor.guild.ICreateGuildRoleRequest=} [properties] Properties to set
             */
            function CreateGuildRoleRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CreateGuildRoleRequest guildId.
             * @member {number|Long} guildId
             * @memberof kritor.guild.CreateGuildRoleRequest
             * @instance
             */
            CreateGuildRoleRequest.prototype.guildId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * CreateGuildRoleRequest name.
             * @member {string} name
             * @memberof kritor.guild.CreateGuildRoleRequest
             * @instance
             */
            CreateGuildRoleRequest.prototype.name = "";

            /**
             * CreateGuildRoleRequest color.
             * @member {number|Long} color
             * @memberof kritor.guild.CreateGuildRoleRequest
             * @instance
             */
            CreateGuildRoleRequest.prototype.color = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Creates a new CreateGuildRoleRequest instance using the specified properties.
             * @function create
             * @memberof kritor.guild.CreateGuildRoleRequest
             * @static
             * @param {kritor.guild.ICreateGuildRoleRequest=} [properties] Properties to set
             * @returns {kritor.guild.CreateGuildRoleRequest} CreateGuildRoleRequest instance
             */
            CreateGuildRoleRequest.create = function create(properties) {
                return new CreateGuildRoleRequest(properties);
            };

            /**
             * Encodes the specified CreateGuildRoleRequest message. Does not implicitly {@link kritor.guild.CreateGuildRoleRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.CreateGuildRoleRequest
             * @static
             * @param {kritor.guild.ICreateGuildRoleRequest} message CreateGuildRoleRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateGuildRoleRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.guildId != null && Object.hasOwnProperty.call(message, "guildId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.guildId);
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int64(message.color);
                return writer;
            };

            /**
             * Encodes the specified CreateGuildRoleRequest message, length delimited. Does not implicitly {@link kritor.guild.CreateGuildRoleRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.CreateGuildRoleRequest
             * @static
             * @param {kritor.guild.ICreateGuildRoleRequest} message CreateGuildRoleRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateGuildRoleRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CreateGuildRoleRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.CreateGuildRoleRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.CreateGuildRoleRequest} CreateGuildRoleRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateGuildRoleRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.CreateGuildRoleRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.guildId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.name = reader.string();
                            break;
                        }
                    case 3: {
                            message.color = reader.int64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CreateGuildRoleRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.CreateGuildRoleRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.CreateGuildRoleRequest} CreateGuildRoleRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateGuildRoleRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CreateGuildRoleRequest message.
             * @function verify
             * @memberof kritor.guild.CreateGuildRoleRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CreateGuildRoleRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.guildId != null && message.hasOwnProperty("guildId"))
                    if (!$util.isInteger(message.guildId) && !(message.guildId && $util.isInteger(message.guildId.low) && $util.isInteger(message.guildId.high)))
                        return "guildId: integer|Long expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.color != null && message.hasOwnProperty("color"))
                    if (!$util.isInteger(message.color) && !(message.color && $util.isInteger(message.color.low) && $util.isInteger(message.color.high)))
                        return "color: integer|Long expected";
                return null;
            };

            /**
             * Creates a CreateGuildRoleRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.CreateGuildRoleRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.CreateGuildRoleRequest} CreateGuildRoleRequest
             */
            CreateGuildRoleRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.CreateGuildRoleRequest)
                    return object;
                let message = new $root.kritor.guild.CreateGuildRoleRequest();
                if (object.guildId != null)
                    if ($util.Long)
                        (message.guildId = $util.Long.fromValue(object.guildId)).unsigned = true;
                    else if (typeof object.guildId === "string")
                        message.guildId = parseInt(object.guildId, 10);
                    else if (typeof object.guildId === "number")
                        message.guildId = object.guildId;
                    else if (typeof object.guildId === "object")
                        message.guildId = new $util.LongBits(object.guildId.low >>> 0, object.guildId.high >>> 0).toNumber(true);
                if (object.name != null)
                    message.name = String(object.name);
                if (object.color != null)
                    if ($util.Long)
                        (message.color = $util.Long.fromValue(object.color)).unsigned = false;
                    else if (typeof object.color === "string")
                        message.color = parseInt(object.color, 10);
                    else if (typeof object.color === "number")
                        message.color = object.color;
                    else if (typeof object.color === "object")
                        message.color = new $util.LongBits(object.color.low >>> 0, object.color.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from a CreateGuildRoleRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.CreateGuildRoleRequest
             * @static
             * @param {kritor.guild.CreateGuildRoleRequest} message CreateGuildRoleRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CreateGuildRoleRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.guildId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.guildId = options.longs === String ? "0" : 0;
                    object.name = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.color = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.color = options.longs === String ? "0" : 0;
                }
                if (message.guildId != null && message.hasOwnProperty("guildId"))
                    if (typeof message.guildId === "number")
                        object.guildId = options.longs === String ? String(message.guildId) : message.guildId;
                    else
                        object.guildId = options.longs === String ? $util.Long.prototype.toString.call(message.guildId) : options.longs === Number ? new $util.LongBits(message.guildId.low >>> 0, message.guildId.high >>> 0).toNumber(true) : message.guildId;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.color != null && message.hasOwnProperty("color"))
                    if (typeof message.color === "number")
                        object.color = options.longs === String ? String(message.color) : message.color;
                    else
                        object.color = options.longs === String ? $util.Long.prototype.toString.call(message.color) : options.longs === Number ? new $util.LongBits(message.color.low >>> 0, message.color.high >>> 0).toNumber() : message.color;
                return object;
            };

            /**
             * Converts this CreateGuildRoleRequest to JSON.
             * @function toJSON
             * @memberof kritor.guild.CreateGuildRoleRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CreateGuildRoleRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for CreateGuildRoleRequest
             * @function getTypeUrl
             * @memberof kritor.guild.CreateGuildRoleRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            CreateGuildRoleRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.CreateGuildRoleRequest";
            };

            return CreateGuildRoleRequest;
        })();

        guild.CreateGuildRoleResponse = (function() {

            /**
             * Properties of a CreateGuildRoleResponse.
             * @memberof kritor.guild
             * @interface ICreateGuildRoleResponse
             * @property {number|Long|null} [roleId] CreateGuildRoleResponse roleId
             */

            /**
             * Constructs a new CreateGuildRoleResponse.
             * @memberof kritor.guild
             * @classdesc Represents a CreateGuildRoleResponse.
             * @implements ICreateGuildRoleResponse
             * @constructor
             * @param {kritor.guild.ICreateGuildRoleResponse=} [properties] Properties to set
             */
            function CreateGuildRoleResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CreateGuildRoleResponse roleId.
             * @member {number|Long} roleId
             * @memberof kritor.guild.CreateGuildRoleResponse
             * @instance
             */
            CreateGuildRoleResponse.prototype.roleId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new CreateGuildRoleResponse instance using the specified properties.
             * @function create
             * @memberof kritor.guild.CreateGuildRoleResponse
             * @static
             * @param {kritor.guild.ICreateGuildRoleResponse=} [properties] Properties to set
             * @returns {kritor.guild.CreateGuildRoleResponse} CreateGuildRoleResponse instance
             */
            CreateGuildRoleResponse.create = function create(properties) {
                return new CreateGuildRoleResponse(properties);
            };

            /**
             * Encodes the specified CreateGuildRoleResponse message. Does not implicitly {@link kritor.guild.CreateGuildRoleResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.CreateGuildRoleResponse
             * @static
             * @param {kritor.guild.ICreateGuildRoleResponse} message CreateGuildRoleResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateGuildRoleResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.roleId != null && Object.hasOwnProperty.call(message, "roleId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.roleId);
                return writer;
            };

            /**
             * Encodes the specified CreateGuildRoleResponse message, length delimited. Does not implicitly {@link kritor.guild.CreateGuildRoleResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.CreateGuildRoleResponse
             * @static
             * @param {kritor.guild.ICreateGuildRoleResponse} message CreateGuildRoleResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateGuildRoleResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CreateGuildRoleResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.CreateGuildRoleResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.CreateGuildRoleResponse} CreateGuildRoleResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateGuildRoleResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.CreateGuildRoleResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.roleId = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CreateGuildRoleResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.CreateGuildRoleResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.CreateGuildRoleResponse} CreateGuildRoleResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateGuildRoleResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CreateGuildRoleResponse message.
             * @function verify
             * @memberof kritor.guild.CreateGuildRoleResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CreateGuildRoleResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.roleId != null && message.hasOwnProperty("roleId"))
                    if (!$util.isInteger(message.roleId) && !(message.roleId && $util.isInteger(message.roleId.low) && $util.isInteger(message.roleId.high)))
                        return "roleId: integer|Long expected";
                return null;
            };

            /**
             * Creates a CreateGuildRoleResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.CreateGuildRoleResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.CreateGuildRoleResponse} CreateGuildRoleResponse
             */
            CreateGuildRoleResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.CreateGuildRoleResponse)
                    return object;
                let message = new $root.kritor.guild.CreateGuildRoleResponse();
                if (object.roleId != null)
                    if ($util.Long)
                        (message.roleId = $util.Long.fromValue(object.roleId)).unsigned = true;
                    else if (typeof object.roleId === "string")
                        message.roleId = parseInt(object.roleId, 10);
                    else if (typeof object.roleId === "number")
                        message.roleId = object.roleId;
                    else if (typeof object.roleId === "object")
                        message.roleId = new $util.LongBits(object.roleId.low >>> 0, object.roleId.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a CreateGuildRoleResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.CreateGuildRoleResponse
             * @static
             * @param {kritor.guild.CreateGuildRoleResponse} message CreateGuildRoleResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CreateGuildRoleResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.roleId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.roleId = options.longs === String ? "0" : 0;
                if (message.roleId != null && message.hasOwnProperty("roleId"))
                    if (typeof message.roleId === "number")
                        object.roleId = options.longs === String ? String(message.roleId) : message.roleId;
                    else
                        object.roleId = options.longs === String ? $util.Long.prototype.toString.call(message.roleId) : options.longs === Number ? new $util.LongBits(message.roleId.low >>> 0, message.roleId.high >>> 0).toNumber(true) : message.roleId;
                return object;
            };

            /**
             * Converts this CreateGuildRoleResponse to JSON.
             * @function toJSON
             * @memberof kritor.guild.CreateGuildRoleResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CreateGuildRoleResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for CreateGuildRoleResponse
             * @function getTypeUrl
             * @memberof kritor.guild.CreateGuildRoleResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            CreateGuildRoleResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.CreateGuildRoleResponse";
            };

            return CreateGuildRoleResponse;
        })();

        guild.GuildInfo = (function() {

            /**
             * Properties of a GuildInfo.
             * @memberof kritor.guild
             * @interface IGuildInfo
             * @property {number|Long|null} [guildId] GuildInfo guildId
             * @property {string|null} [guildName] GuildInfo guildName
             * @property {string|null} [guildDisplayId] GuildInfo guildDisplayId
             * @property {string|null} [profile] GuildInfo profile
             * @property {boolean|null} [isEnable] GuildInfo isEnable
             * @property {boolean|null} [isBanned] GuildInfo isBanned
             * @property {boolean|null} [isFrozen] GuildInfo isFrozen
             * @property {number|Long|null} [ownerId] GuildInfo ownerId
             * @property {number|Long|null} [shutupExpireTime] GuildInfo shutupExpireTime
             * @property {boolean|null} [allowSearch] GuildInfo allowSearch
             */

            /**
             * Constructs a new GuildInfo.
             * @memberof kritor.guild
             * @classdesc Represents a GuildInfo.
             * @implements IGuildInfo
             * @constructor
             * @param {kritor.guild.IGuildInfo=} [properties] Properties to set
             */
            function GuildInfo(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GuildInfo guildId.
             * @member {number|Long} guildId
             * @memberof kritor.guild.GuildInfo
             * @instance
             */
            GuildInfo.prototype.guildId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GuildInfo guildName.
             * @member {string} guildName
             * @memberof kritor.guild.GuildInfo
             * @instance
             */
            GuildInfo.prototype.guildName = "";

            /**
             * GuildInfo guildDisplayId.
             * @member {string} guildDisplayId
             * @memberof kritor.guild.GuildInfo
             * @instance
             */
            GuildInfo.prototype.guildDisplayId = "";

            /**
             * GuildInfo profile.
             * @member {string} profile
             * @memberof kritor.guild.GuildInfo
             * @instance
             */
            GuildInfo.prototype.profile = "";

            /**
             * GuildInfo isEnable.
             * @member {boolean} isEnable
             * @memberof kritor.guild.GuildInfo
             * @instance
             */
            GuildInfo.prototype.isEnable = false;

            /**
             * GuildInfo isBanned.
             * @member {boolean} isBanned
             * @memberof kritor.guild.GuildInfo
             * @instance
             */
            GuildInfo.prototype.isBanned = false;

            /**
             * GuildInfo isFrozen.
             * @member {boolean} isFrozen
             * @memberof kritor.guild.GuildInfo
             * @instance
             */
            GuildInfo.prototype.isFrozen = false;

            /**
             * GuildInfo ownerId.
             * @member {number|Long} ownerId
             * @memberof kritor.guild.GuildInfo
             * @instance
             */
            GuildInfo.prototype.ownerId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GuildInfo shutupExpireTime.
             * @member {number|Long} shutupExpireTime
             * @memberof kritor.guild.GuildInfo
             * @instance
             */
            GuildInfo.prototype.shutupExpireTime = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GuildInfo allowSearch.
             * @member {boolean} allowSearch
             * @memberof kritor.guild.GuildInfo
             * @instance
             */
            GuildInfo.prototype.allowSearch = false;

            /**
             * Creates a new GuildInfo instance using the specified properties.
             * @function create
             * @memberof kritor.guild.GuildInfo
             * @static
             * @param {kritor.guild.IGuildInfo=} [properties] Properties to set
             * @returns {kritor.guild.GuildInfo} GuildInfo instance
             */
            GuildInfo.create = function create(properties) {
                return new GuildInfo(properties);
            };

            /**
             * Encodes the specified GuildInfo message. Does not implicitly {@link kritor.guild.GuildInfo.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.GuildInfo
             * @static
             * @param {kritor.guild.IGuildInfo} message GuildInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GuildInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.guildId != null && Object.hasOwnProperty.call(message, "guildId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.guildId);
                if (message.guildName != null && Object.hasOwnProperty.call(message, "guildName"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.guildName);
                if (message.guildDisplayId != null && Object.hasOwnProperty.call(message, "guildDisplayId"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.guildDisplayId);
                if (message.profile != null && Object.hasOwnProperty.call(message, "profile"))
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.profile);
                if (message.isEnable != null && Object.hasOwnProperty.call(message, "isEnable"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.isEnable);
                if (message.isBanned != null && Object.hasOwnProperty.call(message, "isBanned"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.isBanned);
                if (message.isFrozen != null && Object.hasOwnProperty.call(message, "isFrozen"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.isFrozen);
                if (message.ownerId != null && Object.hasOwnProperty.call(message, "ownerId"))
                    writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.ownerId);
                if (message.shutupExpireTime != null && Object.hasOwnProperty.call(message, "shutupExpireTime"))
                    writer.uint32(/* id 9, wireType 0 =*/72).uint64(message.shutupExpireTime);
                if (message.allowSearch != null && Object.hasOwnProperty.call(message, "allowSearch"))
                    writer.uint32(/* id 10, wireType 0 =*/80).bool(message.allowSearch);
                return writer;
            };

            /**
             * Encodes the specified GuildInfo message, length delimited. Does not implicitly {@link kritor.guild.GuildInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.GuildInfo
             * @static
             * @param {kritor.guild.IGuildInfo} message GuildInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GuildInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GuildInfo message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.GuildInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.GuildInfo} GuildInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GuildInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.GuildInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.guildId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.guildName = reader.string();
                            break;
                        }
                    case 3: {
                            message.guildDisplayId = reader.string();
                            break;
                        }
                    case 4: {
                            message.profile = reader.string();
                            break;
                        }
                    case 5: {
                            message.isEnable = reader.bool();
                            break;
                        }
                    case 6: {
                            message.isBanned = reader.bool();
                            break;
                        }
                    case 7: {
                            message.isFrozen = reader.bool();
                            break;
                        }
                    case 8: {
                            message.ownerId = reader.uint64();
                            break;
                        }
                    case 9: {
                            message.shutupExpireTime = reader.uint64();
                            break;
                        }
                    case 10: {
                            message.allowSearch = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GuildInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.GuildInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.GuildInfo} GuildInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GuildInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GuildInfo message.
             * @function verify
             * @memberof kritor.guild.GuildInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GuildInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.guildId != null && message.hasOwnProperty("guildId"))
                    if (!$util.isInteger(message.guildId) && !(message.guildId && $util.isInteger(message.guildId.low) && $util.isInteger(message.guildId.high)))
                        return "guildId: integer|Long expected";
                if (message.guildName != null && message.hasOwnProperty("guildName"))
                    if (!$util.isString(message.guildName))
                        return "guildName: string expected";
                if (message.guildDisplayId != null && message.hasOwnProperty("guildDisplayId"))
                    if (!$util.isString(message.guildDisplayId))
                        return "guildDisplayId: string expected";
                if (message.profile != null && message.hasOwnProperty("profile"))
                    if (!$util.isString(message.profile))
                        return "profile: string expected";
                if (message.isEnable != null && message.hasOwnProperty("isEnable"))
                    if (typeof message.isEnable !== "boolean")
                        return "isEnable: boolean expected";
                if (message.isBanned != null && message.hasOwnProperty("isBanned"))
                    if (typeof message.isBanned !== "boolean")
                        return "isBanned: boolean expected";
                if (message.isFrozen != null && message.hasOwnProperty("isFrozen"))
                    if (typeof message.isFrozen !== "boolean")
                        return "isFrozen: boolean expected";
                if (message.ownerId != null && message.hasOwnProperty("ownerId"))
                    if (!$util.isInteger(message.ownerId) && !(message.ownerId && $util.isInteger(message.ownerId.low) && $util.isInteger(message.ownerId.high)))
                        return "ownerId: integer|Long expected";
                if (message.shutupExpireTime != null && message.hasOwnProperty("shutupExpireTime"))
                    if (!$util.isInteger(message.shutupExpireTime) && !(message.shutupExpireTime && $util.isInteger(message.shutupExpireTime.low) && $util.isInteger(message.shutupExpireTime.high)))
                        return "shutupExpireTime: integer|Long expected";
                if (message.allowSearch != null && message.hasOwnProperty("allowSearch"))
                    if (typeof message.allowSearch !== "boolean")
                        return "allowSearch: boolean expected";
                return null;
            };

            /**
             * Creates a GuildInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.GuildInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.GuildInfo} GuildInfo
             */
            GuildInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.GuildInfo)
                    return object;
                let message = new $root.kritor.guild.GuildInfo();
                if (object.guildId != null)
                    if ($util.Long)
                        (message.guildId = $util.Long.fromValue(object.guildId)).unsigned = true;
                    else if (typeof object.guildId === "string")
                        message.guildId = parseInt(object.guildId, 10);
                    else if (typeof object.guildId === "number")
                        message.guildId = object.guildId;
                    else if (typeof object.guildId === "object")
                        message.guildId = new $util.LongBits(object.guildId.low >>> 0, object.guildId.high >>> 0).toNumber(true);
                if (object.guildName != null)
                    message.guildName = String(object.guildName);
                if (object.guildDisplayId != null)
                    message.guildDisplayId = String(object.guildDisplayId);
                if (object.profile != null)
                    message.profile = String(object.profile);
                if (object.isEnable != null)
                    message.isEnable = Boolean(object.isEnable);
                if (object.isBanned != null)
                    message.isBanned = Boolean(object.isBanned);
                if (object.isFrozen != null)
                    message.isFrozen = Boolean(object.isFrozen);
                if (object.ownerId != null)
                    if ($util.Long)
                        (message.ownerId = $util.Long.fromValue(object.ownerId)).unsigned = true;
                    else if (typeof object.ownerId === "string")
                        message.ownerId = parseInt(object.ownerId, 10);
                    else if (typeof object.ownerId === "number")
                        message.ownerId = object.ownerId;
                    else if (typeof object.ownerId === "object")
                        message.ownerId = new $util.LongBits(object.ownerId.low >>> 0, object.ownerId.high >>> 0).toNumber(true);
                if (object.shutupExpireTime != null)
                    if ($util.Long)
                        (message.shutupExpireTime = $util.Long.fromValue(object.shutupExpireTime)).unsigned = true;
                    else if (typeof object.shutupExpireTime === "string")
                        message.shutupExpireTime = parseInt(object.shutupExpireTime, 10);
                    else if (typeof object.shutupExpireTime === "number")
                        message.shutupExpireTime = object.shutupExpireTime;
                    else if (typeof object.shutupExpireTime === "object")
                        message.shutupExpireTime = new $util.LongBits(object.shutupExpireTime.low >>> 0, object.shutupExpireTime.high >>> 0).toNumber(true);
                if (object.allowSearch != null)
                    message.allowSearch = Boolean(object.allowSearch);
                return message;
            };

            /**
             * Creates a plain object from a GuildInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.GuildInfo
             * @static
             * @param {kritor.guild.GuildInfo} message GuildInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GuildInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.guildId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.guildId = options.longs === String ? "0" : 0;
                    object.guildName = "";
                    object.guildDisplayId = "";
                    object.profile = "";
                    object.isEnable = false;
                    object.isBanned = false;
                    object.isFrozen = false;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.ownerId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.ownerId = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.shutupExpireTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.shutupExpireTime = options.longs === String ? "0" : 0;
                    object.allowSearch = false;
                }
                if (message.guildId != null && message.hasOwnProperty("guildId"))
                    if (typeof message.guildId === "number")
                        object.guildId = options.longs === String ? String(message.guildId) : message.guildId;
                    else
                        object.guildId = options.longs === String ? $util.Long.prototype.toString.call(message.guildId) : options.longs === Number ? new $util.LongBits(message.guildId.low >>> 0, message.guildId.high >>> 0).toNumber(true) : message.guildId;
                if (message.guildName != null && message.hasOwnProperty("guildName"))
                    object.guildName = message.guildName;
                if (message.guildDisplayId != null && message.hasOwnProperty("guildDisplayId"))
                    object.guildDisplayId = message.guildDisplayId;
                if (message.profile != null && message.hasOwnProperty("profile"))
                    object.profile = message.profile;
                if (message.isEnable != null && message.hasOwnProperty("isEnable"))
                    object.isEnable = message.isEnable;
                if (message.isBanned != null && message.hasOwnProperty("isBanned"))
                    object.isBanned = message.isBanned;
                if (message.isFrozen != null && message.hasOwnProperty("isFrozen"))
                    object.isFrozen = message.isFrozen;
                if (message.ownerId != null && message.hasOwnProperty("ownerId"))
                    if (typeof message.ownerId === "number")
                        object.ownerId = options.longs === String ? String(message.ownerId) : message.ownerId;
                    else
                        object.ownerId = options.longs === String ? $util.Long.prototype.toString.call(message.ownerId) : options.longs === Number ? new $util.LongBits(message.ownerId.low >>> 0, message.ownerId.high >>> 0).toNumber(true) : message.ownerId;
                if (message.shutupExpireTime != null && message.hasOwnProperty("shutupExpireTime"))
                    if (typeof message.shutupExpireTime === "number")
                        object.shutupExpireTime = options.longs === String ? String(message.shutupExpireTime) : message.shutupExpireTime;
                    else
                        object.shutupExpireTime = options.longs === String ? $util.Long.prototype.toString.call(message.shutupExpireTime) : options.longs === Number ? new $util.LongBits(message.shutupExpireTime.low >>> 0, message.shutupExpireTime.high >>> 0).toNumber(true) : message.shutupExpireTime;
                if (message.allowSearch != null && message.hasOwnProperty("allowSearch"))
                    object.allowSearch = message.allowSearch;
                return object;
            };

            /**
             * Converts this GuildInfo to JSON.
             * @function toJSON
             * @memberof kritor.guild.GuildInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GuildInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GuildInfo
             * @function getTypeUrl
             * @memberof kritor.guild.GuildInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GuildInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.GuildInfo";
            };

            return GuildInfo;
        })();

        guild.ChannelInfo = (function() {

            /**
             * Properties of a ChannelInfo.
             * @memberof kritor.guild
             * @interface IChannelInfo
             * @property {number|Long|null} [channelId] ChannelInfo channelId
             * @property {number|Long|null} [guildId] ChannelInfo guildId
             * @property {string|null} [channelName] ChannelInfo channelName
             * @property {number|Long|null} [createTime] ChannelInfo createTime
             * @property {number|Long|null} [maxMemberCount] ChannelInfo maxMemberCount
             * @property {number|Long|null} [creatorTinyId] ChannelInfo creatorTinyId
             * @property {number|Long|null} [talkPermission] ChannelInfo talkPermission
             * @property {number|Long|null} [visibleType] ChannelInfo visibleType
             * @property {number|Long|null} [currentSlowMode] ChannelInfo currentSlowMode
             * @property {Array.<kritor.guild.ISlowModes>|null} [slowModes] ChannelInfo slowModes
             * @property {string|null} [iconUrl] ChannelInfo iconUrl
             * @property {number|Long|null} [jumpSwitch] ChannelInfo jumpSwitch
             * @property {number|Long|null} [jumpType] ChannelInfo jumpType
             * @property {string|null} [jumpUrl] ChannelInfo jumpUrl
             * @property {number|Long|null} [categoryId] ChannelInfo categoryId
             * @property {number|Long|null} [myTalkPermission] ChannelInfo myTalkPermission
             */

            /**
             * Constructs a new ChannelInfo.
             * @memberof kritor.guild
             * @classdesc Represents a ChannelInfo.
             * @implements IChannelInfo
             * @constructor
             * @param {kritor.guild.IChannelInfo=} [properties] Properties to set
             */
            function ChannelInfo(properties) {
                this.slowModes = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ChannelInfo channelId.
             * @member {number|Long} channelId
             * @memberof kritor.guild.ChannelInfo
             * @instance
             */
            ChannelInfo.prototype.channelId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * ChannelInfo guildId.
             * @member {number|Long} guildId
             * @memberof kritor.guild.ChannelInfo
             * @instance
             */
            ChannelInfo.prototype.guildId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * ChannelInfo channelName.
             * @member {string} channelName
             * @memberof kritor.guild.ChannelInfo
             * @instance
             */
            ChannelInfo.prototype.channelName = "";

            /**
             * ChannelInfo createTime.
             * @member {number|Long} createTime
             * @memberof kritor.guild.ChannelInfo
             * @instance
             */
            ChannelInfo.prototype.createTime = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * ChannelInfo maxMemberCount.
             * @member {number|Long} maxMemberCount
             * @memberof kritor.guild.ChannelInfo
             * @instance
             */
            ChannelInfo.prototype.maxMemberCount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * ChannelInfo creatorTinyId.
             * @member {number|Long} creatorTinyId
             * @memberof kritor.guild.ChannelInfo
             * @instance
             */
            ChannelInfo.prototype.creatorTinyId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * ChannelInfo talkPermission.
             * @member {number|Long} talkPermission
             * @memberof kritor.guild.ChannelInfo
             * @instance
             */
            ChannelInfo.prototype.talkPermission = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * ChannelInfo visibleType.
             * @member {number|Long} visibleType
             * @memberof kritor.guild.ChannelInfo
             * @instance
             */
            ChannelInfo.prototype.visibleType = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * ChannelInfo currentSlowMode.
             * @member {number|Long} currentSlowMode
             * @memberof kritor.guild.ChannelInfo
             * @instance
             */
            ChannelInfo.prototype.currentSlowMode = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * ChannelInfo slowModes.
             * @member {Array.<kritor.guild.ISlowModes>} slowModes
             * @memberof kritor.guild.ChannelInfo
             * @instance
             */
            ChannelInfo.prototype.slowModes = $util.emptyArray;

            /**
             * ChannelInfo iconUrl.
             * @member {string} iconUrl
             * @memberof kritor.guild.ChannelInfo
             * @instance
             */
            ChannelInfo.prototype.iconUrl = "";

            /**
             * ChannelInfo jumpSwitch.
             * @member {number|Long} jumpSwitch
             * @memberof kritor.guild.ChannelInfo
             * @instance
             */
            ChannelInfo.prototype.jumpSwitch = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * ChannelInfo jumpType.
             * @member {number|Long} jumpType
             * @memberof kritor.guild.ChannelInfo
             * @instance
             */
            ChannelInfo.prototype.jumpType = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * ChannelInfo jumpUrl.
             * @member {string} jumpUrl
             * @memberof kritor.guild.ChannelInfo
             * @instance
             */
            ChannelInfo.prototype.jumpUrl = "";

            /**
             * ChannelInfo categoryId.
             * @member {number|Long} categoryId
             * @memberof kritor.guild.ChannelInfo
             * @instance
             */
            ChannelInfo.prototype.categoryId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * ChannelInfo myTalkPermission.
             * @member {number|Long} myTalkPermission
             * @memberof kritor.guild.ChannelInfo
             * @instance
             */
            ChannelInfo.prototype.myTalkPermission = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new ChannelInfo instance using the specified properties.
             * @function create
             * @memberof kritor.guild.ChannelInfo
             * @static
             * @param {kritor.guild.IChannelInfo=} [properties] Properties to set
             * @returns {kritor.guild.ChannelInfo} ChannelInfo instance
             */
            ChannelInfo.create = function create(properties) {
                return new ChannelInfo(properties);
            };

            /**
             * Encodes the specified ChannelInfo message. Does not implicitly {@link kritor.guild.ChannelInfo.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.ChannelInfo
             * @static
             * @param {kritor.guild.IChannelInfo} message ChannelInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChannelInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.channelId != null && Object.hasOwnProperty.call(message, "channelId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.channelId);
                if (message.guildId != null && Object.hasOwnProperty.call(message, "guildId"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.guildId);
                if (message.channelName != null && Object.hasOwnProperty.call(message, "channelName"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.channelName);
                if (message.createTime != null && Object.hasOwnProperty.call(message, "createTime"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.createTime);
                if (message.maxMemberCount != null && Object.hasOwnProperty.call(message, "maxMemberCount"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.maxMemberCount);
                if (message.creatorTinyId != null && Object.hasOwnProperty.call(message, "creatorTinyId"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.creatorTinyId);
                if (message.talkPermission != null && Object.hasOwnProperty.call(message, "talkPermission"))
                    writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.talkPermission);
                if (message.visibleType != null && Object.hasOwnProperty.call(message, "visibleType"))
                    writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.visibleType);
                if (message.currentSlowMode != null && Object.hasOwnProperty.call(message, "currentSlowMode"))
                    writer.uint32(/* id 9, wireType 0 =*/72).uint64(message.currentSlowMode);
                if (message.slowModes != null && message.slowModes.length)
                    for (let i = 0; i < message.slowModes.length; ++i)
                        $root.kritor.guild.SlowModes.encode(message.slowModes[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                if (message.iconUrl != null && Object.hasOwnProperty.call(message, "iconUrl"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.iconUrl);
                if (message.jumpSwitch != null && Object.hasOwnProperty.call(message, "jumpSwitch"))
                    writer.uint32(/* id 12, wireType 0 =*/96).uint64(message.jumpSwitch);
                if (message.jumpType != null && Object.hasOwnProperty.call(message, "jumpType"))
                    writer.uint32(/* id 13, wireType 0 =*/104).uint64(message.jumpType);
                if (message.jumpUrl != null && Object.hasOwnProperty.call(message, "jumpUrl"))
                    writer.uint32(/* id 14, wireType 2 =*/114).string(message.jumpUrl);
                if (message.categoryId != null && Object.hasOwnProperty.call(message, "categoryId"))
                    writer.uint32(/* id 15, wireType 0 =*/120).uint64(message.categoryId);
                if (message.myTalkPermission != null && Object.hasOwnProperty.call(message, "myTalkPermission"))
                    writer.uint32(/* id 16, wireType 0 =*/128).uint64(message.myTalkPermission);
                return writer;
            };

            /**
             * Encodes the specified ChannelInfo message, length delimited. Does not implicitly {@link kritor.guild.ChannelInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.ChannelInfo
             * @static
             * @param {kritor.guild.IChannelInfo} message ChannelInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChannelInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ChannelInfo message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.ChannelInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.ChannelInfo} ChannelInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChannelInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.ChannelInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.channelId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.guildId = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.channelName = reader.string();
                            break;
                        }
                    case 4: {
                            message.createTime = reader.uint64();
                            break;
                        }
                    case 5: {
                            message.maxMemberCount = reader.uint64();
                            break;
                        }
                    case 6: {
                            message.creatorTinyId = reader.uint64();
                            break;
                        }
                    case 7: {
                            message.talkPermission = reader.uint64();
                            break;
                        }
                    case 8: {
                            message.visibleType = reader.uint64();
                            break;
                        }
                    case 9: {
                            message.currentSlowMode = reader.uint64();
                            break;
                        }
                    case 10: {
                            if (!(message.slowModes && message.slowModes.length))
                                message.slowModes = [];
                            message.slowModes.push($root.kritor.guild.SlowModes.decode(reader, reader.uint32()));
                            break;
                        }
                    case 11: {
                            message.iconUrl = reader.string();
                            break;
                        }
                    case 12: {
                            message.jumpSwitch = reader.uint64();
                            break;
                        }
                    case 13: {
                            message.jumpType = reader.uint64();
                            break;
                        }
                    case 14: {
                            message.jumpUrl = reader.string();
                            break;
                        }
                    case 15: {
                            message.categoryId = reader.uint64();
                            break;
                        }
                    case 16: {
                            message.myTalkPermission = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ChannelInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.ChannelInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.ChannelInfo} ChannelInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChannelInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ChannelInfo message.
             * @function verify
             * @memberof kritor.guild.ChannelInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChannelInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.channelId != null && message.hasOwnProperty("channelId"))
                    if (!$util.isInteger(message.channelId) && !(message.channelId && $util.isInteger(message.channelId.low) && $util.isInteger(message.channelId.high)))
                        return "channelId: integer|Long expected";
                if (message.guildId != null && message.hasOwnProperty("guildId"))
                    if (!$util.isInteger(message.guildId) && !(message.guildId && $util.isInteger(message.guildId.low) && $util.isInteger(message.guildId.high)))
                        return "guildId: integer|Long expected";
                if (message.channelName != null && message.hasOwnProperty("channelName"))
                    if (!$util.isString(message.channelName))
                        return "channelName: string expected";
                if (message.createTime != null && message.hasOwnProperty("createTime"))
                    if (!$util.isInteger(message.createTime) && !(message.createTime && $util.isInteger(message.createTime.low) && $util.isInteger(message.createTime.high)))
                        return "createTime: integer|Long expected";
                if (message.maxMemberCount != null && message.hasOwnProperty("maxMemberCount"))
                    if (!$util.isInteger(message.maxMemberCount) && !(message.maxMemberCount && $util.isInteger(message.maxMemberCount.low) && $util.isInteger(message.maxMemberCount.high)))
                        return "maxMemberCount: integer|Long expected";
                if (message.creatorTinyId != null && message.hasOwnProperty("creatorTinyId"))
                    if (!$util.isInteger(message.creatorTinyId) && !(message.creatorTinyId && $util.isInteger(message.creatorTinyId.low) && $util.isInteger(message.creatorTinyId.high)))
                        return "creatorTinyId: integer|Long expected";
                if (message.talkPermission != null && message.hasOwnProperty("talkPermission"))
                    if (!$util.isInteger(message.talkPermission) && !(message.talkPermission && $util.isInteger(message.talkPermission.low) && $util.isInteger(message.talkPermission.high)))
                        return "talkPermission: integer|Long expected";
                if (message.visibleType != null && message.hasOwnProperty("visibleType"))
                    if (!$util.isInteger(message.visibleType) && !(message.visibleType && $util.isInteger(message.visibleType.low) && $util.isInteger(message.visibleType.high)))
                        return "visibleType: integer|Long expected";
                if (message.currentSlowMode != null && message.hasOwnProperty("currentSlowMode"))
                    if (!$util.isInteger(message.currentSlowMode) && !(message.currentSlowMode && $util.isInteger(message.currentSlowMode.low) && $util.isInteger(message.currentSlowMode.high)))
                        return "currentSlowMode: integer|Long expected";
                if (message.slowModes != null && message.hasOwnProperty("slowModes")) {
                    if (!Array.isArray(message.slowModes))
                        return "slowModes: array expected";
                    for (let i = 0; i < message.slowModes.length; ++i) {
                        let error = $root.kritor.guild.SlowModes.verify(message.slowModes[i]);
                        if (error)
                            return "slowModes." + error;
                    }
                }
                if (message.iconUrl != null && message.hasOwnProperty("iconUrl"))
                    if (!$util.isString(message.iconUrl))
                        return "iconUrl: string expected";
                if (message.jumpSwitch != null && message.hasOwnProperty("jumpSwitch"))
                    if (!$util.isInteger(message.jumpSwitch) && !(message.jumpSwitch && $util.isInteger(message.jumpSwitch.low) && $util.isInteger(message.jumpSwitch.high)))
                        return "jumpSwitch: integer|Long expected";
                if (message.jumpType != null && message.hasOwnProperty("jumpType"))
                    if (!$util.isInteger(message.jumpType) && !(message.jumpType && $util.isInteger(message.jumpType.low) && $util.isInteger(message.jumpType.high)))
                        return "jumpType: integer|Long expected";
                if (message.jumpUrl != null && message.hasOwnProperty("jumpUrl"))
                    if (!$util.isString(message.jumpUrl))
                        return "jumpUrl: string expected";
                if (message.categoryId != null && message.hasOwnProperty("categoryId"))
                    if (!$util.isInteger(message.categoryId) && !(message.categoryId && $util.isInteger(message.categoryId.low) && $util.isInteger(message.categoryId.high)))
                        return "categoryId: integer|Long expected";
                if (message.myTalkPermission != null && message.hasOwnProperty("myTalkPermission"))
                    if (!$util.isInteger(message.myTalkPermission) && !(message.myTalkPermission && $util.isInteger(message.myTalkPermission.low) && $util.isInteger(message.myTalkPermission.high)))
                        return "myTalkPermission: integer|Long expected";
                return null;
            };

            /**
             * Creates a ChannelInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.ChannelInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.ChannelInfo} ChannelInfo
             */
            ChannelInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.ChannelInfo)
                    return object;
                let message = new $root.kritor.guild.ChannelInfo();
                if (object.channelId != null)
                    if ($util.Long)
                        (message.channelId = $util.Long.fromValue(object.channelId)).unsigned = true;
                    else if (typeof object.channelId === "string")
                        message.channelId = parseInt(object.channelId, 10);
                    else if (typeof object.channelId === "number")
                        message.channelId = object.channelId;
                    else if (typeof object.channelId === "object")
                        message.channelId = new $util.LongBits(object.channelId.low >>> 0, object.channelId.high >>> 0).toNumber(true);
                if (object.guildId != null)
                    if ($util.Long)
                        (message.guildId = $util.Long.fromValue(object.guildId)).unsigned = true;
                    else if (typeof object.guildId === "string")
                        message.guildId = parseInt(object.guildId, 10);
                    else if (typeof object.guildId === "number")
                        message.guildId = object.guildId;
                    else if (typeof object.guildId === "object")
                        message.guildId = new $util.LongBits(object.guildId.low >>> 0, object.guildId.high >>> 0).toNumber(true);
                if (object.channelName != null)
                    message.channelName = String(object.channelName);
                if (object.createTime != null)
                    if ($util.Long)
                        (message.createTime = $util.Long.fromValue(object.createTime)).unsigned = true;
                    else if (typeof object.createTime === "string")
                        message.createTime = parseInt(object.createTime, 10);
                    else if (typeof object.createTime === "number")
                        message.createTime = object.createTime;
                    else if (typeof object.createTime === "object")
                        message.createTime = new $util.LongBits(object.createTime.low >>> 0, object.createTime.high >>> 0).toNumber(true);
                if (object.maxMemberCount != null)
                    if ($util.Long)
                        (message.maxMemberCount = $util.Long.fromValue(object.maxMemberCount)).unsigned = true;
                    else if (typeof object.maxMemberCount === "string")
                        message.maxMemberCount = parseInt(object.maxMemberCount, 10);
                    else if (typeof object.maxMemberCount === "number")
                        message.maxMemberCount = object.maxMemberCount;
                    else if (typeof object.maxMemberCount === "object")
                        message.maxMemberCount = new $util.LongBits(object.maxMemberCount.low >>> 0, object.maxMemberCount.high >>> 0).toNumber(true);
                if (object.creatorTinyId != null)
                    if ($util.Long)
                        (message.creatorTinyId = $util.Long.fromValue(object.creatorTinyId)).unsigned = true;
                    else if (typeof object.creatorTinyId === "string")
                        message.creatorTinyId = parseInt(object.creatorTinyId, 10);
                    else if (typeof object.creatorTinyId === "number")
                        message.creatorTinyId = object.creatorTinyId;
                    else if (typeof object.creatorTinyId === "object")
                        message.creatorTinyId = new $util.LongBits(object.creatorTinyId.low >>> 0, object.creatorTinyId.high >>> 0).toNumber(true);
                if (object.talkPermission != null)
                    if ($util.Long)
                        (message.talkPermission = $util.Long.fromValue(object.talkPermission)).unsigned = true;
                    else if (typeof object.talkPermission === "string")
                        message.talkPermission = parseInt(object.talkPermission, 10);
                    else if (typeof object.talkPermission === "number")
                        message.talkPermission = object.talkPermission;
                    else if (typeof object.talkPermission === "object")
                        message.talkPermission = new $util.LongBits(object.talkPermission.low >>> 0, object.talkPermission.high >>> 0).toNumber(true);
                if (object.visibleType != null)
                    if ($util.Long)
                        (message.visibleType = $util.Long.fromValue(object.visibleType)).unsigned = true;
                    else if (typeof object.visibleType === "string")
                        message.visibleType = parseInt(object.visibleType, 10);
                    else if (typeof object.visibleType === "number")
                        message.visibleType = object.visibleType;
                    else if (typeof object.visibleType === "object")
                        message.visibleType = new $util.LongBits(object.visibleType.low >>> 0, object.visibleType.high >>> 0).toNumber(true);
                if (object.currentSlowMode != null)
                    if ($util.Long)
                        (message.currentSlowMode = $util.Long.fromValue(object.currentSlowMode)).unsigned = true;
                    else if (typeof object.currentSlowMode === "string")
                        message.currentSlowMode = parseInt(object.currentSlowMode, 10);
                    else if (typeof object.currentSlowMode === "number")
                        message.currentSlowMode = object.currentSlowMode;
                    else if (typeof object.currentSlowMode === "object")
                        message.currentSlowMode = new $util.LongBits(object.currentSlowMode.low >>> 0, object.currentSlowMode.high >>> 0).toNumber(true);
                if (object.slowModes) {
                    if (!Array.isArray(object.slowModes))
                        throw TypeError(".kritor.guild.ChannelInfo.slowModes: array expected");
                    message.slowModes = [];
                    for (let i = 0; i < object.slowModes.length; ++i) {
                        if (typeof object.slowModes[i] !== "object")
                            throw TypeError(".kritor.guild.ChannelInfo.slowModes: object expected");
                        message.slowModes[i] = $root.kritor.guild.SlowModes.fromObject(object.slowModes[i]);
                    }
                }
                if (object.iconUrl != null)
                    message.iconUrl = String(object.iconUrl);
                if (object.jumpSwitch != null)
                    if ($util.Long)
                        (message.jumpSwitch = $util.Long.fromValue(object.jumpSwitch)).unsigned = true;
                    else if (typeof object.jumpSwitch === "string")
                        message.jumpSwitch = parseInt(object.jumpSwitch, 10);
                    else if (typeof object.jumpSwitch === "number")
                        message.jumpSwitch = object.jumpSwitch;
                    else if (typeof object.jumpSwitch === "object")
                        message.jumpSwitch = new $util.LongBits(object.jumpSwitch.low >>> 0, object.jumpSwitch.high >>> 0).toNumber(true);
                if (object.jumpType != null)
                    if ($util.Long)
                        (message.jumpType = $util.Long.fromValue(object.jumpType)).unsigned = true;
                    else if (typeof object.jumpType === "string")
                        message.jumpType = parseInt(object.jumpType, 10);
                    else if (typeof object.jumpType === "number")
                        message.jumpType = object.jumpType;
                    else if (typeof object.jumpType === "object")
                        message.jumpType = new $util.LongBits(object.jumpType.low >>> 0, object.jumpType.high >>> 0).toNumber(true);
                if (object.jumpUrl != null)
                    message.jumpUrl = String(object.jumpUrl);
                if (object.categoryId != null)
                    if ($util.Long)
                        (message.categoryId = $util.Long.fromValue(object.categoryId)).unsigned = true;
                    else if (typeof object.categoryId === "string")
                        message.categoryId = parseInt(object.categoryId, 10);
                    else if (typeof object.categoryId === "number")
                        message.categoryId = object.categoryId;
                    else if (typeof object.categoryId === "object")
                        message.categoryId = new $util.LongBits(object.categoryId.low >>> 0, object.categoryId.high >>> 0).toNumber(true);
                if (object.myTalkPermission != null)
                    if ($util.Long)
                        (message.myTalkPermission = $util.Long.fromValue(object.myTalkPermission)).unsigned = true;
                    else if (typeof object.myTalkPermission === "string")
                        message.myTalkPermission = parseInt(object.myTalkPermission, 10);
                    else if (typeof object.myTalkPermission === "number")
                        message.myTalkPermission = object.myTalkPermission;
                    else if (typeof object.myTalkPermission === "object")
                        message.myTalkPermission = new $util.LongBits(object.myTalkPermission.low >>> 0, object.myTalkPermission.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a ChannelInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.ChannelInfo
             * @static
             * @param {kritor.guild.ChannelInfo} message ChannelInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChannelInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.slowModes = [];
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.channelId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.channelId = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.guildId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.guildId = options.longs === String ? "0" : 0;
                    object.channelName = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.createTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.createTime = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.maxMemberCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.maxMemberCount = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.creatorTinyId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.creatorTinyId = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.talkPermission = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.talkPermission = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.visibleType = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.visibleType = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.currentSlowMode = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.currentSlowMode = options.longs === String ? "0" : 0;
                    object.iconUrl = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.jumpSwitch = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.jumpSwitch = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.jumpType = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.jumpType = options.longs === String ? "0" : 0;
                    object.jumpUrl = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.categoryId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.categoryId = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.myTalkPermission = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.myTalkPermission = options.longs === String ? "0" : 0;
                }
                if (message.channelId != null && message.hasOwnProperty("channelId"))
                    if (typeof message.channelId === "number")
                        object.channelId = options.longs === String ? String(message.channelId) : message.channelId;
                    else
                        object.channelId = options.longs === String ? $util.Long.prototype.toString.call(message.channelId) : options.longs === Number ? new $util.LongBits(message.channelId.low >>> 0, message.channelId.high >>> 0).toNumber(true) : message.channelId;
                if (message.guildId != null && message.hasOwnProperty("guildId"))
                    if (typeof message.guildId === "number")
                        object.guildId = options.longs === String ? String(message.guildId) : message.guildId;
                    else
                        object.guildId = options.longs === String ? $util.Long.prototype.toString.call(message.guildId) : options.longs === Number ? new $util.LongBits(message.guildId.low >>> 0, message.guildId.high >>> 0).toNumber(true) : message.guildId;
                if (message.channelName != null && message.hasOwnProperty("channelName"))
                    object.channelName = message.channelName;
                if (message.createTime != null && message.hasOwnProperty("createTime"))
                    if (typeof message.createTime === "number")
                        object.createTime = options.longs === String ? String(message.createTime) : message.createTime;
                    else
                        object.createTime = options.longs === String ? $util.Long.prototype.toString.call(message.createTime) : options.longs === Number ? new $util.LongBits(message.createTime.low >>> 0, message.createTime.high >>> 0).toNumber(true) : message.createTime;
                if (message.maxMemberCount != null && message.hasOwnProperty("maxMemberCount"))
                    if (typeof message.maxMemberCount === "number")
                        object.maxMemberCount = options.longs === String ? String(message.maxMemberCount) : message.maxMemberCount;
                    else
                        object.maxMemberCount = options.longs === String ? $util.Long.prototype.toString.call(message.maxMemberCount) : options.longs === Number ? new $util.LongBits(message.maxMemberCount.low >>> 0, message.maxMemberCount.high >>> 0).toNumber(true) : message.maxMemberCount;
                if (message.creatorTinyId != null && message.hasOwnProperty("creatorTinyId"))
                    if (typeof message.creatorTinyId === "number")
                        object.creatorTinyId = options.longs === String ? String(message.creatorTinyId) : message.creatorTinyId;
                    else
                        object.creatorTinyId = options.longs === String ? $util.Long.prototype.toString.call(message.creatorTinyId) : options.longs === Number ? new $util.LongBits(message.creatorTinyId.low >>> 0, message.creatorTinyId.high >>> 0).toNumber(true) : message.creatorTinyId;
                if (message.talkPermission != null && message.hasOwnProperty("talkPermission"))
                    if (typeof message.talkPermission === "number")
                        object.talkPermission = options.longs === String ? String(message.talkPermission) : message.talkPermission;
                    else
                        object.talkPermission = options.longs === String ? $util.Long.prototype.toString.call(message.talkPermission) : options.longs === Number ? new $util.LongBits(message.talkPermission.low >>> 0, message.talkPermission.high >>> 0).toNumber(true) : message.talkPermission;
                if (message.visibleType != null && message.hasOwnProperty("visibleType"))
                    if (typeof message.visibleType === "number")
                        object.visibleType = options.longs === String ? String(message.visibleType) : message.visibleType;
                    else
                        object.visibleType = options.longs === String ? $util.Long.prototype.toString.call(message.visibleType) : options.longs === Number ? new $util.LongBits(message.visibleType.low >>> 0, message.visibleType.high >>> 0).toNumber(true) : message.visibleType;
                if (message.currentSlowMode != null && message.hasOwnProperty("currentSlowMode"))
                    if (typeof message.currentSlowMode === "number")
                        object.currentSlowMode = options.longs === String ? String(message.currentSlowMode) : message.currentSlowMode;
                    else
                        object.currentSlowMode = options.longs === String ? $util.Long.prototype.toString.call(message.currentSlowMode) : options.longs === Number ? new $util.LongBits(message.currentSlowMode.low >>> 0, message.currentSlowMode.high >>> 0).toNumber(true) : message.currentSlowMode;
                if (message.slowModes && message.slowModes.length) {
                    object.slowModes = [];
                    for (let j = 0; j < message.slowModes.length; ++j)
                        object.slowModes[j] = $root.kritor.guild.SlowModes.toObject(message.slowModes[j], options);
                }
                if (message.iconUrl != null && message.hasOwnProperty("iconUrl"))
                    object.iconUrl = message.iconUrl;
                if (message.jumpSwitch != null && message.hasOwnProperty("jumpSwitch"))
                    if (typeof message.jumpSwitch === "number")
                        object.jumpSwitch = options.longs === String ? String(message.jumpSwitch) : message.jumpSwitch;
                    else
                        object.jumpSwitch = options.longs === String ? $util.Long.prototype.toString.call(message.jumpSwitch) : options.longs === Number ? new $util.LongBits(message.jumpSwitch.low >>> 0, message.jumpSwitch.high >>> 0).toNumber(true) : message.jumpSwitch;
                if (message.jumpType != null && message.hasOwnProperty("jumpType"))
                    if (typeof message.jumpType === "number")
                        object.jumpType = options.longs === String ? String(message.jumpType) : message.jumpType;
                    else
                        object.jumpType = options.longs === String ? $util.Long.prototype.toString.call(message.jumpType) : options.longs === Number ? new $util.LongBits(message.jumpType.low >>> 0, message.jumpType.high >>> 0).toNumber(true) : message.jumpType;
                if (message.jumpUrl != null && message.hasOwnProperty("jumpUrl"))
                    object.jumpUrl = message.jumpUrl;
                if (message.categoryId != null && message.hasOwnProperty("categoryId"))
                    if (typeof message.categoryId === "number")
                        object.categoryId = options.longs === String ? String(message.categoryId) : message.categoryId;
                    else
                        object.categoryId = options.longs === String ? $util.Long.prototype.toString.call(message.categoryId) : options.longs === Number ? new $util.LongBits(message.categoryId.low >>> 0, message.categoryId.high >>> 0).toNumber(true) : message.categoryId;
                if (message.myTalkPermission != null && message.hasOwnProperty("myTalkPermission"))
                    if (typeof message.myTalkPermission === "number")
                        object.myTalkPermission = options.longs === String ? String(message.myTalkPermission) : message.myTalkPermission;
                    else
                        object.myTalkPermission = options.longs === String ? $util.Long.prototype.toString.call(message.myTalkPermission) : options.longs === Number ? new $util.LongBits(message.myTalkPermission.low >>> 0, message.myTalkPermission.high >>> 0).toNumber(true) : message.myTalkPermission;
                return object;
            };

            /**
             * Converts this ChannelInfo to JSON.
             * @function toJSON
             * @memberof kritor.guild.ChannelInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChannelInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ChannelInfo
             * @function getTypeUrl
             * @memberof kritor.guild.ChannelInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ChannelInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.ChannelInfo";
            };

            return ChannelInfo;
        })();

        guild.SlowModes = (function() {

            /**
             * Properties of a SlowModes.
             * @memberof kritor.guild
             * @interface ISlowModes
             * @property {number|Long|null} [slowModeKey] SlowModes slowModeKey
             * @property {string|null} [slowModeText] SlowModes slowModeText
             * @property {number|Long|null} [speakFrequency] SlowModes speakFrequency
             * @property {number|Long|null} [slowModeCircle] SlowModes slowModeCircle
             */

            /**
             * Constructs a new SlowModes.
             * @memberof kritor.guild
             * @classdesc Represents a SlowModes.
             * @implements ISlowModes
             * @constructor
             * @param {kritor.guild.ISlowModes=} [properties] Properties to set
             */
            function SlowModes(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SlowModes slowModeKey.
             * @member {number|Long} slowModeKey
             * @memberof kritor.guild.SlowModes
             * @instance
             */
            SlowModes.prototype.slowModeKey = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * SlowModes slowModeText.
             * @member {string} slowModeText
             * @memberof kritor.guild.SlowModes
             * @instance
             */
            SlowModes.prototype.slowModeText = "";

            /**
             * SlowModes speakFrequency.
             * @member {number|Long} speakFrequency
             * @memberof kritor.guild.SlowModes
             * @instance
             */
            SlowModes.prototype.speakFrequency = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * SlowModes slowModeCircle.
             * @member {number|Long} slowModeCircle
             * @memberof kritor.guild.SlowModes
             * @instance
             */
            SlowModes.prototype.slowModeCircle = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new SlowModes instance using the specified properties.
             * @function create
             * @memberof kritor.guild.SlowModes
             * @static
             * @param {kritor.guild.ISlowModes=} [properties] Properties to set
             * @returns {kritor.guild.SlowModes} SlowModes instance
             */
            SlowModes.create = function create(properties) {
                return new SlowModes(properties);
            };

            /**
             * Encodes the specified SlowModes message. Does not implicitly {@link kritor.guild.SlowModes.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.SlowModes
             * @static
             * @param {kritor.guild.ISlowModes} message SlowModes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SlowModes.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.slowModeKey != null && Object.hasOwnProperty.call(message, "slowModeKey"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.slowModeKey);
                if (message.slowModeText != null && Object.hasOwnProperty.call(message, "slowModeText"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.slowModeText);
                if (message.speakFrequency != null && Object.hasOwnProperty.call(message, "speakFrequency"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.speakFrequency);
                if (message.slowModeCircle != null && Object.hasOwnProperty.call(message, "slowModeCircle"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.slowModeCircle);
                return writer;
            };

            /**
             * Encodes the specified SlowModes message, length delimited. Does not implicitly {@link kritor.guild.SlowModes.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.SlowModes
             * @static
             * @param {kritor.guild.ISlowModes} message SlowModes message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SlowModes.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SlowModes message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.SlowModes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.SlowModes} SlowModes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SlowModes.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.SlowModes();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.slowModeKey = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.slowModeText = reader.string();
                            break;
                        }
                    case 3: {
                            message.speakFrequency = reader.uint64();
                            break;
                        }
                    case 4: {
                            message.slowModeCircle = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SlowModes message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.SlowModes
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.SlowModes} SlowModes
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SlowModes.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SlowModes message.
             * @function verify
             * @memberof kritor.guild.SlowModes
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SlowModes.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.slowModeKey != null && message.hasOwnProperty("slowModeKey"))
                    if (!$util.isInteger(message.slowModeKey) && !(message.slowModeKey && $util.isInteger(message.slowModeKey.low) && $util.isInteger(message.slowModeKey.high)))
                        return "slowModeKey: integer|Long expected";
                if (message.slowModeText != null && message.hasOwnProperty("slowModeText"))
                    if (!$util.isString(message.slowModeText))
                        return "slowModeText: string expected";
                if (message.speakFrequency != null && message.hasOwnProperty("speakFrequency"))
                    if (!$util.isInteger(message.speakFrequency) && !(message.speakFrequency && $util.isInteger(message.speakFrequency.low) && $util.isInteger(message.speakFrequency.high)))
                        return "speakFrequency: integer|Long expected";
                if (message.slowModeCircle != null && message.hasOwnProperty("slowModeCircle"))
                    if (!$util.isInteger(message.slowModeCircle) && !(message.slowModeCircle && $util.isInteger(message.slowModeCircle.low) && $util.isInteger(message.slowModeCircle.high)))
                        return "slowModeCircle: integer|Long expected";
                return null;
            };

            /**
             * Creates a SlowModes message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.SlowModes
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.SlowModes} SlowModes
             */
            SlowModes.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.SlowModes)
                    return object;
                let message = new $root.kritor.guild.SlowModes();
                if (object.slowModeKey != null)
                    if ($util.Long)
                        (message.slowModeKey = $util.Long.fromValue(object.slowModeKey)).unsigned = true;
                    else if (typeof object.slowModeKey === "string")
                        message.slowModeKey = parseInt(object.slowModeKey, 10);
                    else if (typeof object.slowModeKey === "number")
                        message.slowModeKey = object.slowModeKey;
                    else if (typeof object.slowModeKey === "object")
                        message.slowModeKey = new $util.LongBits(object.slowModeKey.low >>> 0, object.slowModeKey.high >>> 0).toNumber(true);
                if (object.slowModeText != null)
                    message.slowModeText = String(object.slowModeText);
                if (object.speakFrequency != null)
                    if ($util.Long)
                        (message.speakFrequency = $util.Long.fromValue(object.speakFrequency)).unsigned = true;
                    else if (typeof object.speakFrequency === "string")
                        message.speakFrequency = parseInt(object.speakFrequency, 10);
                    else if (typeof object.speakFrequency === "number")
                        message.speakFrequency = object.speakFrequency;
                    else if (typeof object.speakFrequency === "object")
                        message.speakFrequency = new $util.LongBits(object.speakFrequency.low >>> 0, object.speakFrequency.high >>> 0).toNumber(true);
                if (object.slowModeCircle != null)
                    if ($util.Long)
                        (message.slowModeCircle = $util.Long.fromValue(object.slowModeCircle)).unsigned = true;
                    else if (typeof object.slowModeCircle === "string")
                        message.slowModeCircle = parseInt(object.slowModeCircle, 10);
                    else if (typeof object.slowModeCircle === "number")
                        message.slowModeCircle = object.slowModeCircle;
                    else if (typeof object.slowModeCircle === "object")
                        message.slowModeCircle = new $util.LongBits(object.slowModeCircle.low >>> 0, object.slowModeCircle.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a SlowModes message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.SlowModes
             * @static
             * @param {kritor.guild.SlowModes} message SlowModes
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SlowModes.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.slowModeKey = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.slowModeKey = options.longs === String ? "0" : 0;
                    object.slowModeText = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.speakFrequency = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.speakFrequency = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.slowModeCircle = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.slowModeCircle = options.longs === String ? "0" : 0;
                }
                if (message.slowModeKey != null && message.hasOwnProperty("slowModeKey"))
                    if (typeof message.slowModeKey === "number")
                        object.slowModeKey = options.longs === String ? String(message.slowModeKey) : message.slowModeKey;
                    else
                        object.slowModeKey = options.longs === String ? $util.Long.prototype.toString.call(message.slowModeKey) : options.longs === Number ? new $util.LongBits(message.slowModeKey.low >>> 0, message.slowModeKey.high >>> 0).toNumber(true) : message.slowModeKey;
                if (message.slowModeText != null && message.hasOwnProperty("slowModeText"))
                    object.slowModeText = message.slowModeText;
                if (message.speakFrequency != null && message.hasOwnProperty("speakFrequency"))
                    if (typeof message.speakFrequency === "number")
                        object.speakFrequency = options.longs === String ? String(message.speakFrequency) : message.speakFrequency;
                    else
                        object.speakFrequency = options.longs === String ? $util.Long.prototype.toString.call(message.speakFrequency) : options.longs === Number ? new $util.LongBits(message.speakFrequency.low >>> 0, message.speakFrequency.high >>> 0).toNumber(true) : message.speakFrequency;
                if (message.slowModeCircle != null && message.hasOwnProperty("slowModeCircle"))
                    if (typeof message.slowModeCircle === "number")
                        object.slowModeCircle = options.longs === String ? String(message.slowModeCircle) : message.slowModeCircle;
                    else
                        object.slowModeCircle = options.longs === String ? $util.Long.prototype.toString.call(message.slowModeCircle) : options.longs === Number ? new $util.LongBits(message.slowModeCircle.low >>> 0, message.slowModeCircle.high >>> 0).toNumber(true) : message.slowModeCircle;
                return object;
            };

            /**
             * Converts this SlowModes to JSON.
             * @function toJSON
             * @memberof kritor.guild.SlowModes
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SlowModes.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SlowModes
             * @function getTypeUrl
             * @memberof kritor.guild.SlowModes
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SlowModes.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.SlowModes";
            };

            return SlowModes;
        })();

        guild.MemberInfo = (function() {

            /**
             * Properties of a MemberInfo.
             * @memberof kritor.guild
             * @interface IMemberInfo
             * @property {number|Long|null} [tinyId] MemberInfo tinyId
             * @property {string|null} [title] MemberInfo title
             * @property {string|null} [nickname] MemberInfo nickname
             * @property {number|Long|null} [roleId] MemberInfo roleId
             * @property {string|null} [roleName] MemberInfo roleName
             * @property {number|Long|null} [roleColor] MemberInfo roleColor
             * @property {number|Long|null} [joinTime] MemberInfo joinTime
             * @property {number|Long|null} [robotType] MemberInfo robotType
             * @property {number|Long|null} [type] MemberInfo type
             * @property {boolean|null} [inBlack] MemberInfo inBlack
             * @property {number|Long|null} [platform] MemberInfo platform
             */

            /**
             * Constructs a new MemberInfo.
             * @memberof kritor.guild
             * @classdesc Represents a MemberInfo.
             * @implements IMemberInfo
             * @constructor
             * @param {kritor.guild.IMemberInfo=} [properties] Properties to set
             */
            function MemberInfo(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MemberInfo tinyId.
             * @member {number|Long} tinyId
             * @memberof kritor.guild.MemberInfo
             * @instance
             */
            MemberInfo.prototype.tinyId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * MemberInfo title.
             * @member {string} title
             * @memberof kritor.guild.MemberInfo
             * @instance
             */
            MemberInfo.prototype.title = "";

            /**
             * MemberInfo nickname.
             * @member {string} nickname
             * @memberof kritor.guild.MemberInfo
             * @instance
             */
            MemberInfo.prototype.nickname = "";

            /**
             * MemberInfo roleId.
             * @member {number|Long} roleId
             * @memberof kritor.guild.MemberInfo
             * @instance
             */
            MemberInfo.prototype.roleId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * MemberInfo roleName.
             * @member {string} roleName
             * @memberof kritor.guild.MemberInfo
             * @instance
             */
            MemberInfo.prototype.roleName = "";

            /**
             * MemberInfo roleColor.
             * @member {number|Long} roleColor
             * @memberof kritor.guild.MemberInfo
             * @instance
             */
            MemberInfo.prototype.roleColor = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * MemberInfo joinTime.
             * @member {number|Long} joinTime
             * @memberof kritor.guild.MemberInfo
             * @instance
             */
            MemberInfo.prototype.joinTime = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * MemberInfo robotType.
             * @member {number|Long} robotType
             * @memberof kritor.guild.MemberInfo
             * @instance
             */
            MemberInfo.prototype.robotType = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * MemberInfo type.
             * @member {number|Long} type
             * @memberof kritor.guild.MemberInfo
             * @instance
             */
            MemberInfo.prototype.type = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * MemberInfo inBlack.
             * @member {boolean} inBlack
             * @memberof kritor.guild.MemberInfo
             * @instance
             */
            MemberInfo.prototype.inBlack = false;

            /**
             * MemberInfo platform.
             * @member {number|Long} platform
             * @memberof kritor.guild.MemberInfo
             * @instance
             */
            MemberInfo.prototype.platform = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new MemberInfo instance using the specified properties.
             * @function create
             * @memberof kritor.guild.MemberInfo
             * @static
             * @param {kritor.guild.IMemberInfo=} [properties] Properties to set
             * @returns {kritor.guild.MemberInfo} MemberInfo instance
             */
            MemberInfo.create = function create(properties) {
                return new MemberInfo(properties);
            };

            /**
             * Encodes the specified MemberInfo message. Does not implicitly {@link kritor.guild.MemberInfo.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.MemberInfo
             * @static
             * @param {kritor.guild.IMemberInfo} message MemberInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MemberInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.tinyId != null && Object.hasOwnProperty.call(message, "tinyId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.tinyId);
                if (message.title != null && Object.hasOwnProperty.call(message, "title"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.title);
                if (message.nickname != null && Object.hasOwnProperty.call(message, "nickname"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.nickname);
                if (message.roleId != null && Object.hasOwnProperty.call(message, "roleId"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.roleId);
                if (message.roleName != null && Object.hasOwnProperty.call(message, "roleName"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.roleName);
                if (message.roleColor != null && Object.hasOwnProperty.call(message, "roleColor"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.roleColor);
                if (message.joinTime != null && Object.hasOwnProperty.call(message, "joinTime"))
                    writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.joinTime);
                if (message.robotType != null && Object.hasOwnProperty.call(message, "robotType"))
                    writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.robotType);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 9, wireType 0 =*/72).uint64(message.type);
                if (message.inBlack != null && Object.hasOwnProperty.call(message, "inBlack"))
                    writer.uint32(/* id 10, wireType 0 =*/80).bool(message.inBlack);
                if (message.platform != null && Object.hasOwnProperty.call(message, "platform"))
                    writer.uint32(/* id 11, wireType 0 =*/88).uint64(message.platform);
                return writer;
            };

            /**
             * Encodes the specified MemberInfo message, length delimited. Does not implicitly {@link kritor.guild.MemberInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.MemberInfo
             * @static
             * @param {kritor.guild.IMemberInfo} message MemberInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MemberInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MemberInfo message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.MemberInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.MemberInfo} MemberInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MemberInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.MemberInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.tinyId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.title = reader.string();
                            break;
                        }
                    case 3: {
                            message.nickname = reader.string();
                            break;
                        }
                    case 4: {
                            message.roleId = reader.uint64();
                            break;
                        }
                    case 5: {
                            message.roleName = reader.string();
                            break;
                        }
                    case 6: {
                            message.roleColor = reader.uint64();
                            break;
                        }
                    case 7: {
                            message.joinTime = reader.uint64();
                            break;
                        }
                    case 8: {
                            message.robotType = reader.uint64();
                            break;
                        }
                    case 9: {
                            message.type = reader.uint64();
                            break;
                        }
                    case 10: {
                            message.inBlack = reader.bool();
                            break;
                        }
                    case 11: {
                            message.platform = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MemberInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.MemberInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.MemberInfo} MemberInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MemberInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MemberInfo message.
             * @function verify
             * @memberof kritor.guild.MemberInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MemberInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.tinyId != null && message.hasOwnProperty("tinyId"))
                    if (!$util.isInteger(message.tinyId) && !(message.tinyId && $util.isInteger(message.tinyId.low) && $util.isInteger(message.tinyId.high)))
                        return "tinyId: integer|Long expected";
                if (message.title != null && message.hasOwnProperty("title"))
                    if (!$util.isString(message.title))
                        return "title: string expected";
                if (message.nickname != null && message.hasOwnProperty("nickname"))
                    if (!$util.isString(message.nickname))
                        return "nickname: string expected";
                if (message.roleId != null && message.hasOwnProperty("roleId"))
                    if (!$util.isInteger(message.roleId) && !(message.roleId && $util.isInteger(message.roleId.low) && $util.isInteger(message.roleId.high)))
                        return "roleId: integer|Long expected";
                if (message.roleName != null && message.hasOwnProperty("roleName"))
                    if (!$util.isString(message.roleName))
                        return "roleName: string expected";
                if (message.roleColor != null && message.hasOwnProperty("roleColor"))
                    if (!$util.isInteger(message.roleColor) && !(message.roleColor && $util.isInteger(message.roleColor.low) && $util.isInteger(message.roleColor.high)))
                        return "roleColor: integer|Long expected";
                if (message.joinTime != null && message.hasOwnProperty("joinTime"))
                    if (!$util.isInteger(message.joinTime) && !(message.joinTime && $util.isInteger(message.joinTime.low) && $util.isInteger(message.joinTime.high)))
                        return "joinTime: integer|Long expected";
                if (message.robotType != null && message.hasOwnProperty("robotType"))
                    if (!$util.isInteger(message.robotType) && !(message.robotType && $util.isInteger(message.robotType.low) && $util.isInteger(message.robotType.high)))
                        return "robotType: integer|Long expected";
                if (message.type != null && message.hasOwnProperty("type"))
                    if (!$util.isInteger(message.type) && !(message.type && $util.isInteger(message.type.low) && $util.isInteger(message.type.high)))
                        return "type: integer|Long expected";
                if (message.inBlack != null && message.hasOwnProperty("inBlack"))
                    if (typeof message.inBlack !== "boolean")
                        return "inBlack: boolean expected";
                if (message.platform != null && message.hasOwnProperty("platform"))
                    if (!$util.isInteger(message.platform) && !(message.platform && $util.isInteger(message.platform.low) && $util.isInteger(message.platform.high)))
                        return "platform: integer|Long expected";
                return null;
            };

            /**
             * Creates a MemberInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.MemberInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.MemberInfo} MemberInfo
             */
            MemberInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.MemberInfo)
                    return object;
                let message = new $root.kritor.guild.MemberInfo();
                if (object.tinyId != null)
                    if ($util.Long)
                        (message.tinyId = $util.Long.fromValue(object.tinyId)).unsigned = true;
                    else if (typeof object.tinyId === "string")
                        message.tinyId = parseInt(object.tinyId, 10);
                    else if (typeof object.tinyId === "number")
                        message.tinyId = object.tinyId;
                    else if (typeof object.tinyId === "object")
                        message.tinyId = new $util.LongBits(object.tinyId.low >>> 0, object.tinyId.high >>> 0).toNumber(true);
                if (object.title != null)
                    message.title = String(object.title);
                if (object.nickname != null)
                    message.nickname = String(object.nickname);
                if (object.roleId != null)
                    if ($util.Long)
                        (message.roleId = $util.Long.fromValue(object.roleId)).unsigned = true;
                    else if (typeof object.roleId === "string")
                        message.roleId = parseInt(object.roleId, 10);
                    else if (typeof object.roleId === "number")
                        message.roleId = object.roleId;
                    else if (typeof object.roleId === "object")
                        message.roleId = new $util.LongBits(object.roleId.low >>> 0, object.roleId.high >>> 0).toNumber(true);
                if (object.roleName != null)
                    message.roleName = String(object.roleName);
                if (object.roleColor != null)
                    if ($util.Long)
                        (message.roleColor = $util.Long.fromValue(object.roleColor)).unsigned = true;
                    else if (typeof object.roleColor === "string")
                        message.roleColor = parseInt(object.roleColor, 10);
                    else if (typeof object.roleColor === "number")
                        message.roleColor = object.roleColor;
                    else if (typeof object.roleColor === "object")
                        message.roleColor = new $util.LongBits(object.roleColor.low >>> 0, object.roleColor.high >>> 0).toNumber(true);
                if (object.joinTime != null)
                    if ($util.Long)
                        (message.joinTime = $util.Long.fromValue(object.joinTime)).unsigned = true;
                    else if (typeof object.joinTime === "string")
                        message.joinTime = parseInt(object.joinTime, 10);
                    else if (typeof object.joinTime === "number")
                        message.joinTime = object.joinTime;
                    else if (typeof object.joinTime === "object")
                        message.joinTime = new $util.LongBits(object.joinTime.low >>> 0, object.joinTime.high >>> 0).toNumber(true);
                if (object.robotType != null)
                    if ($util.Long)
                        (message.robotType = $util.Long.fromValue(object.robotType)).unsigned = true;
                    else if (typeof object.robotType === "string")
                        message.robotType = parseInt(object.robotType, 10);
                    else if (typeof object.robotType === "number")
                        message.robotType = object.robotType;
                    else if (typeof object.robotType === "object")
                        message.robotType = new $util.LongBits(object.robotType.low >>> 0, object.robotType.high >>> 0).toNumber(true);
                if (object.type != null)
                    if ($util.Long)
                        (message.type = $util.Long.fromValue(object.type)).unsigned = true;
                    else if (typeof object.type === "string")
                        message.type = parseInt(object.type, 10);
                    else if (typeof object.type === "number")
                        message.type = object.type;
                    else if (typeof object.type === "object")
                        message.type = new $util.LongBits(object.type.low >>> 0, object.type.high >>> 0).toNumber(true);
                if (object.inBlack != null)
                    message.inBlack = Boolean(object.inBlack);
                if (object.platform != null)
                    if ($util.Long)
                        (message.platform = $util.Long.fromValue(object.platform)).unsigned = true;
                    else if (typeof object.platform === "string")
                        message.platform = parseInt(object.platform, 10);
                    else if (typeof object.platform === "number")
                        message.platform = object.platform;
                    else if (typeof object.platform === "object")
                        message.platform = new $util.LongBits(object.platform.low >>> 0, object.platform.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a MemberInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.MemberInfo
             * @static
             * @param {kritor.guild.MemberInfo} message MemberInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MemberInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.tinyId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.tinyId = options.longs === String ? "0" : 0;
                    object.title = "";
                    object.nickname = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.roleId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.roleId = options.longs === String ? "0" : 0;
                    object.roleName = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.roleColor = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.roleColor = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.joinTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.joinTime = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.robotType = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.robotType = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.type = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.type = options.longs === String ? "0" : 0;
                    object.inBlack = false;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.platform = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.platform = options.longs === String ? "0" : 0;
                }
                if (message.tinyId != null && message.hasOwnProperty("tinyId"))
                    if (typeof message.tinyId === "number")
                        object.tinyId = options.longs === String ? String(message.tinyId) : message.tinyId;
                    else
                        object.tinyId = options.longs === String ? $util.Long.prototype.toString.call(message.tinyId) : options.longs === Number ? new $util.LongBits(message.tinyId.low >>> 0, message.tinyId.high >>> 0).toNumber(true) : message.tinyId;
                if (message.title != null && message.hasOwnProperty("title"))
                    object.title = message.title;
                if (message.nickname != null && message.hasOwnProperty("nickname"))
                    object.nickname = message.nickname;
                if (message.roleId != null && message.hasOwnProperty("roleId"))
                    if (typeof message.roleId === "number")
                        object.roleId = options.longs === String ? String(message.roleId) : message.roleId;
                    else
                        object.roleId = options.longs === String ? $util.Long.prototype.toString.call(message.roleId) : options.longs === Number ? new $util.LongBits(message.roleId.low >>> 0, message.roleId.high >>> 0).toNumber(true) : message.roleId;
                if (message.roleName != null && message.hasOwnProperty("roleName"))
                    object.roleName = message.roleName;
                if (message.roleColor != null && message.hasOwnProperty("roleColor"))
                    if (typeof message.roleColor === "number")
                        object.roleColor = options.longs === String ? String(message.roleColor) : message.roleColor;
                    else
                        object.roleColor = options.longs === String ? $util.Long.prototype.toString.call(message.roleColor) : options.longs === Number ? new $util.LongBits(message.roleColor.low >>> 0, message.roleColor.high >>> 0).toNumber(true) : message.roleColor;
                if (message.joinTime != null && message.hasOwnProperty("joinTime"))
                    if (typeof message.joinTime === "number")
                        object.joinTime = options.longs === String ? String(message.joinTime) : message.joinTime;
                    else
                        object.joinTime = options.longs === String ? $util.Long.prototype.toString.call(message.joinTime) : options.longs === Number ? new $util.LongBits(message.joinTime.low >>> 0, message.joinTime.high >>> 0).toNumber(true) : message.joinTime;
                if (message.robotType != null && message.hasOwnProperty("robotType"))
                    if (typeof message.robotType === "number")
                        object.robotType = options.longs === String ? String(message.robotType) : message.robotType;
                    else
                        object.robotType = options.longs === String ? $util.Long.prototype.toString.call(message.robotType) : options.longs === Number ? new $util.LongBits(message.robotType.low >>> 0, message.robotType.high >>> 0).toNumber(true) : message.robotType;
                if (message.type != null && message.hasOwnProperty("type"))
                    if (typeof message.type === "number")
                        object.type = options.longs === String ? String(message.type) : message.type;
                    else
                        object.type = options.longs === String ? $util.Long.prototype.toString.call(message.type) : options.longs === Number ? new $util.LongBits(message.type.low >>> 0, message.type.high >>> 0).toNumber(true) : message.type;
                if (message.inBlack != null && message.hasOwnProperty("inBlack"))
                    object.inBlack = message.inBlack;
                if (message.platform != null && message.hasOwnProperty("platform"))
                    if (typeof message.platform === "number")
                        object.platform = options.longs === String ? String(message.platform) : message.platform;
                    else
                        object.platform = options.longs === String ? $util.Long.prototype.toString.call(message.platform) : options.longs === Number ? new $util.LongBits(message.platform.low >>> 0, message.platform.high >>> 0).toNumber(true) : message.platform;
                return object;
            };

            /**
             * Converts this MemberInfo to JSON.
             * @function toJSON
             * @memberof kritor.guild.MemberInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MemberInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MemberInfo
             * @function getTypeUrl
             * @memberof kritor.guild.MemberInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MemberInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.MemberInfo";
            };

            return MemberInfo;
        })();

        guild.MemberProfile = (function() {

            /**
             * Properties of a MemberProfile.
             * @memberof kritor.guild
             * @interface IMemberProfile
             * @property {number|Long|null} [tinyId] MemberProfile tinyId
             * @property {string|null} [nickname] MemberProfile nickname
             * @property {string|null} [avatarUrl] MemberProfile avatarUrl
             * @property {number|Long|null} [joinTime] MemberProfile joinTime
             * @property {Array.<kritor.guild.IMemberRoleInfo>|null} [rolesInfo] MemberProfile rolesInfo
             */

            /**
             * Constructs a new MemberProfile.
             * @memberof kritor.guild
             * @classdesc Represents a MemberProfile.
             * @implements IMemberProfile
             * @constructor
             * @param {kritor.guild.IMemberProfile=} [properties] Properties to set
             */
            function MemberProfile(properties) {
                this.rolesInfo = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MemberProfile tinyId.
             * @member {number|Long} tinyId
             * @memberof kritor.guild.MemberProfile
             * @instance
             */
            MemberProfile.prototype.tinyId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * MemberProfile nickname.
             * @member {string} nickname
             * @memberof kritor.guild.MemberProfile
             * @instance
             */
            MemberProfile.prototype.nickname = "";

            /**
             * MemberProfile avatarUrl.
             * @member {string} avatarUrl
             * @memberof kritor.guild.MemberProfile
             * @instance
             */
            MemberProfile.prototype.avatarUrl = "";

            /**
             * MemberProfile joinTime.
             * @member {number|Long} joinTime
             * @memberof kritor.guild.MemberProfile
             * @instance
             */
            MemberProfile.prototype.joinTime = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * MemberProfile rolesInfo.
             * @member {Array.<kritor.guild.IMemberRoleInfo>} rolesInfo
             * @memberof kritor.guild.MemberProfile
             * @instance
             */
            MemberProfile.prototype.rolesInfo = $util.emptyArray;

            /**
             * Creates a new MemberProfile instance using the specified properties.
             * @function create
             * @memberof kritor.guild.MemberProfile
             * @static
             * @param {kritor.guild.IMemberProfile=} [properties] Properties to set
             * @returns {kritor.guild.MemberProfile} MemberProfile instance
             */
            MemberProfile.create = function create(properties) {
                return new MemberProfile(properties);
            };

            /**
             * Encodes the specified MemberProfile message. Does not implicitly {@link kritor.guild.MemberProfile.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.MemberProfile
             * @static
             * @param {kritor.guild.IMemberProfile} message MemberProfile message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MemberProfile.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.tinyId != null && Object.hasOwnProperty.call(message, "tinyId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.tinyId);
                if (message.nickname != null && Object.hasOwnProperty.call(message, "nickname"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.nickname);
                if (message.avatarUrl != null && Object.hasOwnProperty.call(message, "avatarUrl"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.avatarUrl);
                if (message.joinTime != null && Object.hasOwnProperty.call(message, "joinTime"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.joinTime);
                if (message.rolesInfo != null && message.rolesInfo.length)
                    for (let i = 0; i < message.rolesInfo.length; ++i)
                        $root.kritor.guild.MemberRoleInfo.encode(message.rolesInfo[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified MemberProfile message, length delimited. Does not implicitly {@link kritor.guild.MemberProfile.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.MemberProfile
             * @static
             * @param {kritor.guild.IMemberProfile} message MemberProfile message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MemberProfile.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MemberProfile message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.MemberProfile
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.MemberProfile} MemberProfile
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MemberProfile.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.MemberProfile();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.tinyId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.nickname = reader.string();
                            break;
                        }
                    case 3: {
                            message.avatarUrl = reader.string();
                            break;
                        }
                    case 4: {
                            message.joinTime = reader.uint64();
                            break;
                        }
                    case 5: {
                            if (!(message.rolesInfo && message.rolesInfo.length))
                                message.rolesInfo = [];
                            message.rolesInfo.push($root.kritor.guild.MemberRoleInfo.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MemberProfile message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.MemberProfile
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.MemberProfile} MemberProfile
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MemberProfile.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MemberProfile message.
             * @function verify
             * @memberof kritor.guild.MemberProfile
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MemberProfile.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.tinyId != null && message.hasOwnProperty("tinyId"))
                    if (!$util.isInteger(message.tinyId) && !(message.tinyId && $util.isInteger(message.tinyId.low) && $util.isInteger(message.tinyId.high)))
                        return "tinyId: integer|Long expected";
                if (message.nickname != null && message.hasOwnProperty("nickname"))
                    if (!$util.isString(message.nickname))
                        return "nickname: string expected";
                if (message.avatarUrl != null && message.hasOwnProperty("avatarUrl"))
                    if (!$util.isString(message.avatarUrl))
                        return "avatarUrl: string expected";
                if (message.joinTime != null && message.hasOwnProperty("joinTime"))
                    if (!$util.isInteger(message.joinTime) && !(message.joinTime && $util.isInteger(message.joinTime.low) && $util.isInteger(message.joinTime.high)))
                        return "joinTime: integer|Long expected";
                if (message.rolesInfo != null && message.hasOwnProperty("rolesInfo")) {
                    if (!Array.isArray(message.rolesInfo))
                        return "rolesInfo: array expected";
                    for (let i = 0; i < message.rolesInfo.length; ++i) {
                        let error = $root.kritor.guild.MemberRoleInfo.verify(message.rolesInfo[i]);
                        if (error)
                            return "rolesInfo." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a MemberProfile message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.MemberProfile
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.MemberProfile} MemberProfile
             */
            MemberProfile.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.MemberProfile)
                    return object;
                let message = new $root.kritor.guild.MemberProfile();
                if (object.tinyId != null)
                    if ($util.Long)
                        (message.tinyId = $util.Long.fromValue(object.tinyId)).unsigned = true;
                    else if (typeof object.tinyId === "string")
                        message.tinyId = parseInt(object.tinyId, 10);
                    else if (typeof object.tinyId === "number")
                        message.tinyId = object.tinyId;
                    else if (typeof object.tinyId === "object")
                        message.tinyId = new $util.LongBits(object.tinyId.low >>> 0, object.tinyId.high >>> 0).toNumber(true);
                if (object.nickname != null)
                    message.nickname = String(object.nickname);
                if (object.avatarUrl != null)
                    message.avatarUrl = String(object.avatarUrl);
                if (object.joinTime != null)
                    if ($util.Long)
                        (message.joinTime = $util.Long.fromValue(object.joinTime)).unsigned = true;
                    else if (typeof object.joinTime === "string")
                        message.joinTime = parseInt(object.joinTime, 10);
                    else if (typeof object.joinTime === "number")
                        message.joinTime = object.joinTime;
                    else if (typeof object.joinTime === "object")
                        message.joinTime = new $util.LongBits(object.joinTime.low >>> 0, object.joinTime.high >>> 0).toNumber(true);
                if (object.rolesInfo) {
                    if (!Array.isArray(object.rolesInfo))
                        throw TypeError(".kritor.guild.MemberProfile.rolesInfo: array expected");
                    message.rolesInfo = [];
                    for (let i = 0; i < object.rolesInfo.length; ++i) {
                        if (typeof object.rolesInfo[i] !== "object")
                            throw TypeError(".kritor.guild.MemberProfile.rolesInfo: object expected");
                        message.rolesInfo[i] = $root.kritor.guild.MemberRoleInfo.fromObject(object.rolesInfo[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a MemberProfile message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.MemberProfile
             * @static
             * @param {kritor.guild.MemberProfile} message MemberProfile
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MemberProfile.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.rolesInfo = [];
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.tinyId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.tinyId = options.longs === String ? "0" : 0;
                    object.nickname = "";
                    object.avatarUrl = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.joinTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.joinTime = options.longs === String ? "0" : 0;
                }
                if (message.tinyId != null && message.hasOwnProperty("tinyId"))
                    if (typeof message.tinyId === "number")
                        object.tinyId = options.longs === String ? String(message.tinyId) : message.tinyId;
                    else
                        object.tinyId = options.longs === String ? $util.Long.prototype.toString.call(message.tinyId) : options.longs === Number ? new $util.LongBits(message.tinyId.low >>> 0, message.tinyId.high >>> 0).toNumber(true) : message.tinyId;
                if (message.nickname != null && message.hasOwnProperty("nickname"))
                    object.nickname = message.nickname;
                if (message.avatarUrl != null && message.hasOwnProperty("avatarUrl"))
                    object.avatarUrl = message.avatarUrl;
                if (message.joinTime != null && message.hasOwnProperty("joinTime"))
                    if (typeof message.joinTime === "number")
                        object.joinTime = options.longs === String ? String(message.joinTime) : message.joinTime;
                    else
                        object.joinTime = options.longs === String ? $util.Long.prototype.toString.call(message.joinTime) : options.longs === Number ? new $util.LongBits(message.joinTime.low >>> 0, message.joinTime.high >>> 0).toNumber(true) : message.joinTime;
                if (message.rolesInfo && message.rolesInfo.length) {
                    object.rolesInfo = [];
                    for (let j = 0; j < message.rolesInfo.length; ++j)
                        object.rolesInfo[j] = $root.kritor.guild.MemberRoleInfo.toObject(message.rolesInfo[j], options);
                }
                return object;
            };

            /**
             * Converts this MemberProfile to JSON.
             * @function toJSON
             * @memberof kritor.guild.MemberProfile
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MemberProfile.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MemberProfile
             * @function getTypeUrl
             * @memberof kritor.guild.MemberProfile
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MemberProfile.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.MemberProfile";
            };

            return MemberProfile;
        })();

        guild.PermissionInfo = (function() {

            /**
             * Properties of a PermissionInfo.
             * @memberof kritor.guild
             * @interface IPermissionInfo
             * @property {number|Long|null} [rootId] PermissionInfo rootId
             * @property {Array.<number|Long>|null} [childIds] PermissionInfo childIds
             */

            /**
             * Constructs a new PermissionInfo.
             * @memberof kritor.guild
             * @classdesc Represents a PermissionInfo.
             * @implements IPermissionInfo
             * @constructor
             * @param {kritor.guild.IPermissionInfo=} [properties] Properties to set
             */
            function PermissionInfo(properties) {
                this.childIds = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * PermissionInfo rootId.
             * @member {number|Long} rootId
             * @memberof kritor.guild.PermissionInfo
             * @instance
             */
            PermissionInfo.prototype.rootId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * PermissionInfo childIds.
             * @member {Array.<number|Long>} childIds
             * @memberof kritor.guild.PermissionInfo
             * @instance
             */
            PermissionInfo.prototype.childIds = $util.emptyArray;

            /**
             * Creates a new PermissionInfo instance using the specified properties.
             * @function create
             * @memberof kritor.guild.PermissionInfo
             * @static
             * @param {kritor.guild.IPermissionInfo=} [properties] Properties to set
             * @returns {kritor.guild.PermissionInfo} PermissionInfo instance
             */
            PermissionInfo.create = function create(properties) {
                return new PermissionInfo(properties);
            };

            /**
             * Encodes the specified PermissionInfo message. Does not implicitly {@link kritor.guild.PermissionInfo.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.PermissionInfo
             * @static
             * @param {kritor.guild.IPermissionInfo} message PermissionInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PermissionInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.rootId != null && Object.hasOwnProperty.call(message, "rootId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.rootId);
                if (message.childIds != null && message.childIds.length) {
                    writer.uint32(/* id 2, wireType 2 =*/18).fork();
                    for (let i = 0; i < message.childIds.length; ++i)
                        writer.uint64(message.childIds[i]);
                    writer.ldelim();
                }
                return writer;
            };

            /**
             * Encodes the specified PermissionInfo message, length delimited. Does not implicitly {@link kritor.guild.PermissionInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.PermissionInfo
             * @static
             * @param {kritor.guild.IPermissionInfo} message PermissionInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            PermissionInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a PermissionInfo message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.PermissionInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.PermissionInfo} PermissionInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PermissionInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.PermissionInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.rootId = reader.uint64();
                            break;
                        }
                    case 2: {
                            if (!(message.childIds && message.childIds.length))
                                message.childIds = [];
                            if ((tag & 7) === 2) {
                                let end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.childIds.push(reader.uint64());
                            } else
                                message.childIds.push(reader.uint64());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a PermissionInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.PermissionInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.PermissionInfo} PermissionInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            PermissionInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a PermissionInfo message.
             * @function verify
             * @memberof kritor.guild.PermissionInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            PermissionInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.rootId != null && message.hasOwnProperty("rootId"))
                    if (!$util.isInteger(message.rootId) && !(message.rootId && $util.isInteger(message.rootId.low) && $util.isInteger(message.rootId.high)))
                        return "rootId: integer|Long expected";
                if (message.childIds != null && message.hasOwnProperty("childIds")) {
                    if (!Array.isArray(message.childIds))
                        return "childIds: array expected";
                    for (let i = 0; i < message.childIds.length; ++i)
                        if (!$util.isInteger(message.childIds[i]) && !(message.childIds[i] && $util.isInteger(message.childIds[i].low) && $util.isInteger(message.childIds[i].high)))
                            return "childIds: integer|Long[] expected";
                }
                return null;
            };

            /**
             * Creates a PermissionInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.PermissionInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.PermissionInfo} PermissionInfo
             */
            PermissionInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.PermissionInfo)
                    return object;
                let message = new $root.kritor.guild.PermissionInfo();
                if (object.rootId != null)
                    if ($util.Long)
                        (message.rootId = $util.Long.fromValue(object.rootId)).unsigned = true;
                    else if (typeof object.rootId === "string")
                        message.rootId = parseInt(object.rootId, 10);
                    else if (typeof object.rootId === "number")
                        message.rootId = object.rootId;
                    else if (typeof object.rootId === "object")
                        message.rootId = new $util.LongBits(object.rootId.low >>> 0, object.rootId.high >>> 0).toNumber(true);
                if (object.childIds) {
                    if (!Array.isArray(object.childIds))
                        throw TypeError(".kritor.guild.PermissionInfo.childIds: array expected");
                    message.childIds = [];
                    for (let i = 0; i < object.childIds.length; ++i)
                        if ($util.Long)
                            (message.childIds[i] = $util.Long.fromValue(object.childIds[i])).unsigned = true;
                        else if (typeof object.childIds[i] === "string")
                            message.childIds[i] = parseInt(object.childIds[i], 10);
                        else if (typeof object.childIds[i] === "number")
                            message.childIds[i] = object.childIds[i];
                        else if (typeof object.childIds[i] === "object")
                            message.childIds[i] = new $util.LongBits(object.childIds[i].low >>> 0, object.childIds[i].high >>> 0).toNumber(true);
                }
                return message;
            };

            /**
             * Creates a plain object from a PermissionInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.PermissionInfo
             * @static
             * @param {kritor.guild.PermissionInfo} message PermissionInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            PermissionInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.childIds = [];
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.rootId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.rootId = options.longs === String ? "0" : 0;
                if (message.rootId != null && message.hasOwnProperty("rootId"))
                    if (typeof message.rootId === "number")
                        object.rootId = options.longs === String ? String(message.rootId) : message.rootId;
                    else
                        object.rootId = options.longs === String ? $util.Long.prototype.toString.call(message.rootId) : options.longs === Number ? new $util.LongBits(message.rootId.low >>> 0, message.rootId.high >>> 0).toNumber(true) : message.rootId;
                if (message.childIds && message.childIds.length) {
                    object.childIds = [];
                    for (let j = 0; j < message.childIds.length; ++j)
                        if (typeof message.childIds[j] === "number")
                            object.childIds[j] = options.longs === String ? String(message.childIds[j]) : message.childIds[j];
                        else
                            object.childIds[j] = options.longs === String ? $util.Long.prototype.toString.call(message.childIds[j]) : options.longs === Number ? new $util.LongBits(message.childIds[j].low >>> 0, message.childIds[j].high >>> 0).toNumber(true) : message.childIds[j];
                }
                return object;
            };

            /**
             * Converts this PermissionInfo to JSON.
             * @function toJSON
             * @memberof kritor.guild.PermissionInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            PermissionInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for PermissionInfo
             * @function getTypeUrl
             * @memberof kritor.guild.PermissionInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            PermissionInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.PermissionInfo";
            };

            return PermissionInfo;
        })();

        guild.MemberRoleInfo = (function() {

            /**
             * Properties of a MemberRoleInfo.
             * @memberof kritor.guild
             * @interface IMemberRoleInfo
             * @property {number|Long|null} [roleId] MemberRoleInfo roleId
             * @property {string|null} [roleName] MemberRoleInfo roleName
             * @property {number|Long|null} [color] MemberRoleInfo color
             * @property {Array.<kritor.guild.IPermissionInfo>|null} [permissions] MemberRoleInfo permissions
             * @property {number|Long|null} [type] MemberRoleInfo type
             * @property {string|null} [displayName] MemberRoleInfo displayName
             */

            /**
             * Constructs a new MemberRoleInfo.
             * @memberof kritor.guild
             * @classdesc Represents a MemberRoleInfo.
             * @implements IMemberRoleInfo
             * @constructor
             * @param {kritor.guild.IMemberRoleInfo=} [properties] Properties to set
             */
            function MemberRoleInfo(properties) {
                this.permissions = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MemberRoleInfo roleId.
             * @member {number|Long} roleId
             * @memberof kritor.guild.MemberRoleInfo
             * @instance
             */
            MemberRoleInfo.prototype.roleId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * MemberRoleInfo roleName.
             * @member {string} roleName
             * @memberof kritor.guild.MemberRoleInfo
             * @instance
             */
            MemberRoleInfo.prototype.roleName = "";

            /**
             * MemberRoleInfo color.
             * @member {number|Long} color
             * @memberof kritor.guild.MemberRoleInfo
             * @instance
             */
            MemberRoleInfo.prototype.color = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * MemberRoleInfo permissions.
             * @member {Array.<kritor.guild.IPermissionInfo>} permissions
             * @memberof kritor.guild.MemberRoleInfo
             * @instance
             */
            MemberRoleInfo.prototype.permissions = $util.emptyArray;

            /**
             * MemberRoleInfo type.
             * @member {number|Long} type
             * @memberof kritor.guild.MemberRoleInfo
             * @instance
             */
            MemberRoleInfo.prototype.type = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * MemberRoleInfo displayName.
             * @member {string} displayName
             * @memberof kritor.guild.MemberRoleInfo
             * @instance
             */
            MemberRoleInfo.prototype.displayName = "";

            /**
             * Creates a new MemberRoleInfo instance using the specified properties.
             * @function create
             * @memberof kritor.guild.MemberRoleInfo
             * @static
             * @param {kritor.guild.IMemberRoleInfo=} [properties] Properties to set
             * @returns {kritor.guild.MemberRoleInfo} MemberRoleInfo instance
             */
            MemberRoleInfo.create = function create(properties) {
                return new MemberRoleInfo(properties);
            };

            /**
             * Encodes the specified MemberRoleInfo message. Does not implicitly {@link kritor.guild.MemberRoleInfo.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.MemberRoleInfo
             * @static
             * @param {kritor.guild.IMemberRoleInfo} message MemberRoleInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MemberRoleInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.roleId != null && Object.hasOwnProperty.call(message, "roleId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.roleId);
                if (message.roleName != null && Object.hasOwnProperty.call(message, "roleName"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.roleName);
                if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.color);
                if (message.permissions != null && message.permissions.length)
                    for (let i = 0; i < message.permissions.length; ++i)
                        $root.kritor.guild.PermissionInfo.encode(message.permissions[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.type);
                if (message.displayName != null && Object.hasOwnProperty.call(message, "displayName"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.displayName);
                return writer;
            };

            /**
             * Encodes the specified MemberRoleInfo message, length delimited. Does not implicitly {@link kritor.guild.MemberRoleInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.MemberRoleInfo
             * @static
             * @param {kritor.guild.IMemberRoleInfo} message MemberRoleInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MemberRoleInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MemberRoleInfo message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.MemberRoleInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.MemberRoleInfo} MemberRoleInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MemberRoleInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.MemberRoleInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.roleId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.roleName = reader.string();
                            break;
                        }
                    case 3: {
                            message.color = reader.uint64();
                            break;
                        }
                    case 4: {
                            if (!(message.permissions && message.permissions.length))
                                message.permissions = [];
                            message.permissions.push($root.kritor.guild.PermissionInfo.decode(reader, reader.uint32()));
                            break;
                        }
                    case 5: {
                            message.type = reader.uint64();
                            break;
                        }
                    case 6: {
                            message.displayName = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MemberRoleInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.MemberRoleInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.MemberRoleInfo} MemberRoleInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MemberRoleInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MemberRoleInfo message.
             * @function verify
             * @memberof kritor.guild.MemberRoleInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MemberRoleInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.roleId != null && message.hasOwnProperty("roleId"))
                    if (!$util.isInteger(message.roleId) && !(message.roleId && $util.isInteger(message.roleId.low) && $util.isInteger(message.roleId.high)))
                        return "roleId: integer|Long expected";
                if (message.roleName != null && message.hasOwnProperty("roleName"))
                    if (!$util.isString(message.roleName))
                        return "roleName: string expected";
                if (message.color != null && message.hasOwnProperty("color"))
                    if (!$util.isInteger(message.color) && !(message.color && $util.isInteger(message.color.low) && $util.isInteger(message.color.high)))
                        return "color: integer|Long expected";
                if (message.permissions != null && message.hasOwnProperty("permissions")) {
                    if (!Array.isArray(message.permissions))
                        return "permissions: array expected";
                    for (let i = 0; i < message.permissions.length; ++i) {
                        let error = $root.kritor.guild.PermissionInfo.verify(message.permissions[i]);
                        if (error)
                            return "permissions." + error;
                    }
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    if (!$util.isInteger(message.type) && !(message.type && $util.isInteger(message.type.low) && $util.isInteger(message.type.high)))
                        return "type: integer|Long expected";
                if (message.displayName != null && message.hasOwnProperty("displayName"))
                    if (!$util.isString(message.displayName))
                        return "displayName: string expected";
                return null;
            };

            /**
             * Creates a MemberRoleInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.MemberRoleInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.MemberRoleInfo} MemberRoleInfo
             */
            MemberRoleInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.MemberRoleInfo)
                    return object;
                let message = new $root.kritor.guild.MemberRoleInfo();
                if (object.roleId != null)
                    if ($util.Long)
                        (message.roleId = $util.Long.fromValue(object.roleId)).unsigned = true;
                    else if (typeof object.roleId === "string")
                        message.roleId = parseInt(object.roleId, 10);
                    else if (typeof object.roleId === "number")
                        message.roleId = object.roleId;
                    else if (typeof object.roleId === "object")
                        message.roleId = new $util.LongBits(object.roleId.low >>> 0, object.roleId.high >>> 0).toNumber(true);
                if (object.roleName != null)
                    message.roleName = String(object.roleName);
                if (object.color != null)
                    if ($util.Long)
                        (message.color = $util.Long.fromValue(object.color)).unsigned = true;
                    else if (typeof object.color === "string")
                        message.color = parseInt(object.color, 10);
                    else if (typeof object.color === "number")
                        message.color = object.color;
                    else if (typeof object.color === "object")
                        message.color = new $util.LongBits(object.color.low >>> 0, object.color.high >>> 0).toNumber(true);
                if (object.permissions) {
                    if (!Array.isArray(object.permissions))
                        throw TypeError(".kritor.guild.MemberRoleInfo.permissions: array expected");
                    message.permissions = [];
                    for (let i = 0; i < object.permissions.length; ++i) {
                        if (typeof object.permissions[i] !== "object")
                            throw TypeError(".kritor.guild.MemberRoleInfo.permissions: object expected");
                        message.permissions[i] = $root.kritor.guild.PermissionInfo.fromObject(object.permissions[i]);
                    }
                }
                if (object.type != null)
                    if ($util.Long)
                        (message.type = $util.Long.fromValue(object.type)).unsigned = true;
                    else if (typeof object.type === "string")
                        message.type = parseInt(object.type, 10);
                    else if (typeof object.type === "number")
                        message.type = object.type;
                    else if (typeof object.type === "object")
                        message.type = new $util.LongBits(object.type.low >>> 0, object.type.high >>> 0).toNumber(true);
                if (object.displayName != null)
                    message.displayName = String(object.displayName);
                return message;
            };

            /**
             * Creates a plain object from a MemberRoleInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.MemberRoleInfo
             * @static
             * @param {kritor.guild.MemberRoleInfo} message MemberRoleInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MemberRoleInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.permissions = [];
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.roleId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.roleId = options.longs === String ? "0" : 0;
                    object.roleName = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.color = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.color = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.type = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.type = options.longs === String ? "0" : 0;
                    object.displayName = "";
                }
                if (message.roleId != null && message.hasOwnProperty("roleId"))
                    if (typeof message.roleId === "number")
                        object.roleId = options.longs === String ? String(message.roleId) : message.roleId;
                    else
                        object.roleId = options.longs === String ? $util.Long.prototype.toString.call(message.roleId) : options.longs === Number ? new $util.LongBits(message.roleId.low >>> 0, message.roleId.high >>> 0).toNumber(true) : message.roleId;
                if (message.roleName != null && message.hasOwnProperty("roleName"))
                    object.roleName = message.roleName;
                if (message.color != null && message.hasOwnProperty("color"))
                    if (typeof message.color === "number")
                        object.color = options.longs === String ? String(message.color) : message.color;
                    else
                        object.color = options.longs === String ? $util.Long.prototype.toString.call(message.color) : options.longs === Number ? new $util.LongBits(message.color.low >>> 0, message.color.high >>> 0).toNumber(true) : message.color;
                if (message.permissions && message.permissions.length) {
                    object.permissions = [];
                    for (let j = 0; j < message.permissions.length; ++j)
                        object.permissions[j] = $root.kritor.guild.PermissionInfo.toObject(message.permissions[j], options);
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    if (typeof message.type === "number")
                        object.type = options.longs === String ? String(message.type) : message.type;
                    else
                        object.type = options.longs === String ? $util.Long.prototype.toString.call(message.type) : options.longs === Number ? new $util.LongBits(message.type.low >>> 0, message.type.high >>> 0).toNumber(true) : message.type;
                if (message.displayName != null && message.hasOwnProperty("displayName"))
                    object.displayName = message.displayName;
                return object;
            };

            /**
             * Converts this MemberRoleInfo to JSON.
             * @function toJSON
             * @memberof kritor.guild.MemberRoleInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MemberRoleInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for MemberRoleInfo
             * @function getTypeUrl
             * @memberof kritor.guild.MemberRoleInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            MemberRoleInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.MemberRoleInfo";
            };

            return MemberRoleInfo;
        })();

        guild.RoleInfo = (function() {

            /**
             * Properties of a RoleInfo.
             * @memberof kritor.guild
             * @interface IRoleInfo
             * @property {number|Long|null} [roleId] RoleInfo roleId
             * @property {string|null} [roleName] RoleInfo roleName
             * @property {number|Long|null} [color] RoleInfo color
             * @property {Array.<kritor.guild.IPermissionInfo>|null} [permissions] RoleInfo permissions
             * @property {boolean|null} [disabled] RoleInfo disabled
             * @property {boolean|null} [independent] RoleInfo independent
             * @property {number|Long|null} [maxCount] RoleInfo maxCount
             * @property {number|Long|null} [memberCount] RoleInfo memberCount
             * @property {boolean|null} [owned] RoleInfo owned
             */

            /**
             * Constructs a new RoleInfo.
             * @memberof kritor.guild
             * @classdesc Represents a RoleInfo.
             * @implements IRoleInfo
             * @constructor
             * @param {kritor.guild.IRoleInfo=} [properties] Properties to set
             */
            function RoleInfo(properties) {
                this.permissions = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RoleInfo roleId.
             * @member {number|Long} roleId
             * @memberof kritor.guild.RoleInfo
             * @instance
             */
            RoleInfo.prototype.roleId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * RoleInfo roleName.
             * @member {string} roleName
             * @memberof kritor.guild.RoleInfo
             * @instance
             */
            RoleInfo.prototype.roleName = "";

            /**
             * RoleInfo color.
             * @member {number|Long} color
             * @memberof kritor.guild.RoleInfo
             * @instance
             */
            RoleInfo.prototype.color = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * RoleInfo permissions.
             * @member {Array.<kritor.guild.IPermissionInfo>} permissions
             * @memberof kritor.guild.RoleInfo
             * @instance
             */
            RoleInfo.prototype.permissions = $util.emptyArray;

            /**
             * RoleInfo disabled.
             * @member {boolean} disabled
             * @memberof kritor.guild.RoleInfo
             * @instance
             */
            RoleInfo.prototype.disabled = false;

            /**
             * RoleInfo independent.
             * @member {boolean} independent
             * @memberof kritor.guild.RoleInfo
             * @instance
             */
            RoleInfo.prototype.independent = false;

            /**
             * RoleInfo maxCount.
             * @member {number|Long} maxCount
             * @memberof kritor.guild.RoleInfo
             * @instance
             */
            RoleInfo.prototype.maxCount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * RoleInfo memberCount.
             * @member {number|Long} memberCount
             * @memberof kritor.guild.RoleInfo
             * @instance
             */
            RoleInfo.prototype.memberCount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * RoleInfo owned.
             * @member {boolean} owned
             * @memberof kritor.guild.RoleInfo
             * @instance
             */
            RoleInfo.prototype.owned = false;

            /**
             * Creates a new RoleInfo instance using the specified properties.
             * @function create
             * @memberof kritor.guild.RoleInfo
             * @static
             * @param {kritor.guild.IRoleInfo=} [properties] Properties to set
             * @returns {kritor.guild.RoleInfo} RoleInfo instance
             */
            RoleInfo.create = function create(properties) {
                return new RoleInfo(properties);
            };

            /**
             * Encodes the specified RoleInfo message. Does not implicitly {@link kritor.guild.RoleInfo.verify|verify} messages.
             * @function encode
             * @memberof kritor.guild.RoleInfo
             * @static
             * @param {kritor.guild.IRoleInfo} message RoleInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RoleInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.roleId != null && Object.hasOwnProperty.call(message, "roleId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.roleId);
                if (message.roleName != null && Object.hasOwnProperty.call(message, "roleName"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.roleName);
                if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.color);
                if (message.permissions != null && message.permissions.length)
                    for (let i = 0; i < message.permissions.length; ++i)
                        $root.kritor.guild.PermissionInfo.encode(message.permissions[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.disabled != null && Object.hasOwnProperty.call(message, "disabled"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.disabled);
                if (message.independent != null && Object.hasOwnProperty.call(message, "independent"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.independent);
                if (message.maxCount != null && Object.hasOwnProperty.call(message, "maxCount"))
                    writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.maxCount);
                if (message.memberCount != null && Object.hasOwnProperty.call(message, "memberCount"))
                    writer.uint32(/* id 8, wireType 0 =*/64).uint64(message.memberCount);
                if (message.owned != null && Object.hasOwnProperty.call(message, "owned"))
                    writer.uint32(/* id 9, wireType 0 =*/72).bool(message.owned);
                return writer;
            };

            /**
             * Encodes the specified RoleInfo message, length delimited. Does not implicitly {@link kritor.guild.RoleInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.guild.RoleInfo
             * @static
             * @param {kritor.guild.IRoleInfo} message RoleInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RoleInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RoleInfo message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.guild.RoleInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.guild.RoleInfo} RoleInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RoleInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.guild.RoleInfo();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.roleId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.roleName = reader.string();
                            break;
                        }
                    case 3: {
                            message.color = reader.uint64();
                            break;
                        }
                    case 4: {
                            if (!(message.permissions && message.permissions.length))
                                message.permissions = [];
                            message.permissions.push($root.kritor.guild.PermissionInfo.decode(reader, reader.uint32()));
                            break;
                        }
                    case 5: {
                            message.disabled = reader.bool();
                            break;
                        }
                    case 6: {
                            message.independent = reader.bool();
                            break;
                        }
                    case 7: {
                            message.maxCount = reader.uint64();
                            break;
                        }
                    case 8: {
                            message.memberCount = reader.uint64();
                            break;
                        }
                    case 9: {
                            message.owned = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RoleInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.guild.RoleInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.guild.RoleInfo} RoleInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RoleInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RoleInfo message.
             * @function verify
             * @memberof kritor.guild.RoleInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RoleInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.roleId != null && message.hasOwnProperty("roleId"))
                    if (!$util.isInteger(message.roleId) && !(message.roleId && $util.isInteger(message.roleId.low) && $util.isInteger(message.roleId.high)))
                        return "roleId: integer|Long expected";
                if (message.roleName != null && message.hasOwnProperty("roleName"))
                    if (!$util.isString(message.roleName))
                        return "roleName: string expected";
                if (message.color != null && message.hasOwnProperty("color"))
                    if (!$util.isInteger(message.color) && !(message.color && $util.isInteger(message.color.low) && $util.isInteger(message.color.high)))
                        return "color: integer|Long expected";
                if (message.permissions != null && message.hasOwnProperty("permissions")) {
                    if (!Array.isArray(message.permissions))
                        return "permissions: array expected";
                    for (let i = 0; i < message.permissions.length; ++i) {
                        let error = $root.kritor.guild.PermissionInfo.verify(message.permissions[i]);
                        if (error)
                            return "permissions." + error;
                    }
                }
                if (message.disabled != null && message.hasOwnProperty("disabled"))
                    if (typeof message.disabled !== "boolean")
                        return "disabled: boolean expected";
                if (message.independent != null && message.hasOwnProperty("independent"))
                    if (typeof message.independent !== "boolean")
                        return "independent: boolean expected";
                if (message.maxCount != null && message.hasOwnProperty("maxCount"))
                    if (!$util.isInteger(message.maxCount) && !(message.maxCount && $util.isInteger(message.maxCount.low) && $util.isInteger(message.maxCount.high)))
                        return "maxCount: integer|Long expected";
                if (message.memberCount != null && message.hasOwnProperty("memberCount"))
                    if (!$util.isInteger(message.memberCount) && !(message.memberCount && $util.isInteger(message.memberCount.low) && $util.isInteger(message.memberCount.high)))
                        return "memberCount: integer|Long expected";
                if (message.owned != null && message.hasOwnProperty("owned"))
                    if (typeof message.owned !== "boolean")
                        return "owned: boolean expected";
                return null;
            };

            /**
             * Creates a RoleInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.guild.RoleInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.guild.RoleInfo} RoleInfo
             */
            RoleInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.guild.RoleInfo)
                    return object;
                let message = new $root.kritor.guild.RoleInfo();
                if (object.roleId != null)
                    if ($util.Long)
                        (message.roleId = $util.Long.fromValue(object.roleId)).unsigned = true;
                    else if (typeof object.roleId === "string")
                        message.roleId = parseInt(object.roleId, 10);
                    else if (typeof object.roleId === "number")
                        message.roleId = object.roleId;
                    else if (typeof object.roleId === "object")
                        message.roleId = new $util.LongBits(object.roleId.low >>> 0, object.roleId.high >>> 0).toNumber(true);
                if (object.roleName != null)
                    message.roleName = String(object.roleName);
                if (object.color != null)
                    if ($util.Long)
                        (message.color = $util.Long.fromValue(object.color)).unsigned = true;
                    else if (typeof object.color === "string")
                        message.color = parseInt(object.color, 10);
                    else if (typeof object.color === "number")
                        message.color = object.color;
                    else if (typeof object.color === "object")
                        message.color = new $util.LongBits(object.color.low >>> 0, object.color.high >>> 0).toNumber(true);
                if (object.permissions) {
                    if (!Array.isArray(object.permissions))
                        throw TypeError(".kritor.guild.RoleInfo.permissions: array expected");
                    message.permissions = [];
                    for (let i = 0; i < object.permissions.length; ++i) {
                        if (typeof object.permissions[i] !== "object")
                            throw TypeError(".kritor.guild.RoleInfo.permissions: object expected");
                        message.permissions[i] = $root.kritor.guild.PermissionInfo.fromObject(object.permissions[i]);
                    }
                }
                if (object.disabled != null)
                    message.disabled = Boolean(object.disabled);
                if (object.independent != null)
                    message.independent = Boolean(object.independent);
                if (object.maxCount != null)
                    if ($util.Long)
                        (message.maxCount = $util.Long.fromValue(object.maxCount)).unsigned = true;
                    else if (typeof object.maxCount === "string")
                        message.maxCount = parseInt(object.maxCount, 10);
                    else if (typeof object.maxCount === "number")
                        message.maxCount = object.maxCount;
                    else if (typeof object.maxCount === "object")
                        message.maxCount = new $util.LongBits(object.maxCount.low >>> 0, object.maxCount.high >>> 0).toNumber(true);
                if (object.memberCount != null)
                    if ($util.Long)
                        (message.memberCount = $util.Long.fromValue(object.memberCount)).unsigned = true;
                    else if (typeof object.memberCount === "string")
                        message.memberCount = parseInt(object.memberCount, 10);
                    else if (typeof object.memberCount === "number")
                        message.memberCount = object.memberCount;
                    else if (typeof object.memberCount === "object")
                        message.memberCount = new $util.LongBits(object.memberCount.low >>> 0, object.memberCount.high >>> 0).toNumber(true);
                if (object.owned != null)
                    message.owned = Boolean(object.owned);
                return message;
            };

            /**
             * Creates a plain object from a RoleInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.guild.RoleInfo
             * @static
             * @param {kritor.guild.RoleInfo} message RoleInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RoleInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.permissions = [];
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.roleId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.roleId = options.longs === String ? "0" : 0;
                    object.roleName = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.color = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.color = options.longs === String ? "0" : 0;
                    object.disabled = false;
                    object.independent = false;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.maxCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.maxCount = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.memberCount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.memberCount = options.longs === String ? "0" : 0;
                    object.owned = false;
                }
                if (message.roleId != null && message.hasOwnProperty("roleId"))
                    if (typeof message.roleId === "number")
                        object.roleId = options.longs === String ? String(message.roleId) : message.roleId;
                    else
                        object.roleId = options.longs === String ? $util.Long.prototype.toString.call(message.roleId) : options.longs === Number ? new $util.LongBits(message.roleId.low >>> 0, message.roleId.high >>> 0).toNumber(true) : message.roleId;
                if (message.roleName != null && message.hasOwnProperty("roleName"))
                    object.roleName = message.roleName;
                if (message.color != null && message.hasOwnProperty("color"))
                    if (typeof message.color === "number")
                        object.color = options.longs === String ? String(message.color) : message.color;
                    else
                        object.color = options.longs === String ? $util.Long.prototype.toString.call(message.color) : options.longs === Number ? new $util.LongBits(message.color.low >>> 0, message.color.high >>> 0).toNumber(true) : message.color;
                if (message.permissions && message.permissions.length) {
                    object.permissions = [];
                    for (let j = 0; j < message.permissions.length; ++j)
                        object.permissions[j] = $root.kritor.guild.PermissionInfo.toObject(message.permissions[j], options);
                }
                if (message.disabled != null && message.hasOwnProperty("disabled"))
                    object.disabled = message.disabled;
                if (message.independent != null && message.hasOwnProperty("independent"))
                    object.independent = message.independent;
                if (message.maxCount != null && message.hasOwnProperty("maxCount"))
                    if (typeof message.maxCount === "number")
                        object.maxCount = options.longs === String ? String(message.maxCount) : message.maxCount;
                    else
                        object.maxCount = options.longs === String ? $util.Long.prototype.toString.call(message.maxCount) : options.longs === Number ? new $util.LongBits(message.maxCount.low >>> 0, message.maxCount.high >>> 0).toNumber(true) : message.maxCount;
                if (message.memberCount != null && message.hasOwnProperty("memberCount"))
                    if (typeof message.memberCount === "number")
                        object.memberCount = options.longs === String ? String(message.memberCount) : message.memberCount;
                    else
                        object.memberCount = options.longs === String ? $util.Long.prototype.toString.call(message.memberCount) : options.longs === Number ? new $util.LongBits(message.memberCount.low >>> 0, message.memberCount.high >>> 0).toNumber(true) : message.memberCount;
                if (message.owned != null && message.hasOwnProperty("owned"))
                    object.owned = message.owned;
                return object;
            };

            /**
             * Converts this RoleInfo to JSON.
             * @function toJSON
             * @memberof kritor.guild.RoleInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RoleInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for RoleInfo
             * @function getTypeUrl
             * @memberof kritor.guild.RoleInfo
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            RoleInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.guild.RoleInfo";
            };

            return RoleInfo;
        })();

        return guild;
    })();

    kritor.message = (function() {

        /**
         * Namespace message.
         * @memberof kritor
         * @namespace
         */
        const message = {};

        message.MessageService = (function() {

            /**
             * Constructs a new MessageService service.
             * @memberof kritor.message
             * @classdesc Represents a MessageService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function MessageService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (MessageService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = MessageService;

            /**
             * Creates new MessageService service using the specified rpc implementation.
             * @function create
             * @memberof kritor.message.MessageService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {MessageService} RPC service. Useful where requests and/or responses are streamed.
             */
            MessageService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link kritor.message.MessageService#sendMessage}.
             * @memberof kritor.message.MessageService
             * @typedef SendMessageCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.message.SendMessageResponse} [response] SendMessageResponse
             */

            /**
             * Calls SendMessage.
             * @function sendMessage
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.ISendMessageRequest} request SendMessageRequest message or plain object
             * @param {kritor.message.MessageService.SendMessageCallback} callback Node-style callback called with the error, if any, and SendMessageResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MessageService.prototype.sendMessage = function sendMessage(request, callback) {
                return this.rpcCall(sendMessage, $root.kritor.message.SendMessageRequest, $root.kritor.message.SendMessageResponse, request, callback);
            }, "name", { value: "SendMessage" });

            /**
             * Calls SendMessage.
             * @function sendMessage
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.ISendMessageRequest} request SendMessageRequest message or plain object
             * @returns {Promise<kritor.message.SendMessageResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.message.MessageService#sendMessageByResId}.
             * @memberof kritor.message.MessageService
             * @typedef SendMessageByResIdCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.message.SendMessageByResIdResponse} [response] SendMessageByResIdResponse
             */

            /**
             * Calls SendMessageByResId.
             * @function sendMessageByResId
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.ISendMessageByResIdRequest} request SendMessageByResIdRequest message or plain object
             * @param {kritor.message.MessageService.SendMessageByResIdCallback} callback Node-style callback called with the error, if any, and SendMessageByResIdResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MessageService.prototype.sendMessageByResId = function sendMessageByResId(request, callback) {
                return this.rpcCall(sendMessageByResId, $root.kritor.message.SendMessageByResIdRequest, $root.kritor.message.SendMessageByResIdResponse, request, callback);
            }, "name", { value: "SendMessageByResId" });

            /**
             * Calls SendMessageByResId.
             * @function sendMessageByResId
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.ISendMessageByResIdRequest} request SendMessageByResIdRequest message or plain object
             * @returns {Promise<kritor.message.SendMessageByResIdResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.message.MessageService#setMessageReaded}.
             * @memberof kritor.message.MessageService
             * @typedef SetMessageReadedCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.message.SetMessageReadResponse} [response] SetMessageReadResponse
             */

            /**
             * Calls SetMessageReaded.
             * @function setMessageReaded
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.ISetMessageReadRequest} request SetMessageReadRequest message or plain object
             * @param {kritor.message.MessageService.SetMessageReadedCallback} callback Node-style callback called with the error, if any, and SetMessageReadResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MessageService.prototype.setMessageReaded = function setMessageReaded(request, callback) {
                return this.rpcCall(setMessageReaded, $root.kritor.message.SetMessageReadRequest, $root.kritor.message.SetMessageReadResponse, request, callback);
            }, "name", { value: "SetMessageReaded" });

            /**
             * Calls SetMessageReaded.
             * @function setMessageReaded
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.ISetMessageReadRequest} request SetMessageReadRequest message or plain object
             * @returns {Promise<kritor.message.SetMessageReadResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.message.MessageService#recallMessage}.
             * @memberof kritor.message.MessageService
             * @typedef RecallMessageCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.message.RecallMessageResponse} [response] RecallMessageResponse
             */

            /**
             * Calls RecallMessage.
             * @function recallMessage
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.IRecallMessageRequest} request RecallMessageRequest message or plain object
             * @param {kritor.message.MessageService.RecallMessageCallback} callback Node-style callback called with the error, if any, and RecallMessageResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MessageService.prototype.recallMessage = function recallMessage(request, callback) {
                return this.rpcCall(recallMessage, $root.kritor.message.RecallMessageRequest, $root.kritor.message.RecallMessageResponse, request, callback);
            }, "name", { value: "RecallMessage" });

            /**
             * Calls RecallMessage.
             * @function recallMessage
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.IRecallMessageRequest} request RecallMessageRequest message or plain object
             * @returns {Promise<kritor.message.RecallMessageResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.message.MessageService#reactMessageWithEmoji}.
             * @memberof kritor.message.MessageService
             * @typedef ReactMessageWithEmojiCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.message.ReactMessageWithEmojiResponse} [response] ReactMessageWithEmojiResponse
             */

            /**
             * Calls ReactMessageWithEmoji.
             * @function reactMessageWithEmoji
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.IReactMessageWithEmojiRequest} request ReactMessageWithEmojiRequest message or plain object
             * @param {kritor.message.MessageService.ReactMessageWithEmojiCallback} callback Node-style callback called with the error, if any, and ReactMessageWithEmojiResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MessageService.prototype.reactMessageWithEmoji = function reactMessageWithEmoji(request, callback) {
                return this.rpcCall(reactMessageWithEmoji, $root.kritor.message.ReactMessageWithEmojiRequest, $root.kritor.message.ReactMessageWithEmojiResponse, request, callback);
            }, "name", { value: "ReactMessageWithEmoji" });

            /**
             * Calls ReactMessageWithEmoji.
             * @function reactMessageWithEmoji
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.IReactMessageWithEmojiRequest} request ReactMessageWithEmojiRequest message or plain object
             * @returns {Promise<kritor.message.ReactMessageWithEmojiResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.message.MessageService#getMessage}.
             * @memberof kritor.message.MessageService
             * @typedef GetMessageCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.message.GetMessageResponse} [response] GetMessageResponse
             */

            /**
             * Calls GetMessage.
             * @function getMessage
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.IGetMessageRequest} request GetMessageRequest message or plain object
             * @param {kritor.message.MessageService.GetMessageCallback} callback Node-style callback called with the error, if any, and GetMessageResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MessageService.prototype.getMessage = function getMessage(request, callback) {
                return this.rpcCall(getMessage, $root.kritor.message.GetMessageRequest, $root.kritor.message.GetMessageResponse, request, callback);
            }, "name", { value: "GetMessage" });

            /**
             * Calls GetMessage.
             * @function getMessage
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.IGetMessageRequest} request GetMessageRequest message or plain object
             * @returns {Promise<kritor.message.GetMessageResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.message.MessageService#getMessageBySeq}.
             * @memberof kritor.message.MessageService
             * @typedef GetMessageBySeqCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.message.GetMessageBySeqResponse} [response] GetMessageBySeqResponse
             */

            /**
             * Calls GetMessageBySeq.
             * @function getMessageBySeq
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.IGetMessageBySeqRequest} request GetMessageBySeqRequest message or plain object
             * @param {kritor.message.MessageService.GetMessageBySeqCallback} callback Node-style callback called with the error, if any, and GetMessageBySeqResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MessageService.prototype.getMessageBySeq = function getMessageBySeq(request, callback) {
                return this.rpcCall(getMessageBySeq, $root.kritor.message.GetMessageBySeqRequest, $root.kritor.message.GetMessageBySeqResponse, request, callback);
            }, "name", { value: "GetMessageBySeq" });

            /**
             * Calls GetMessageBySeq.
             * @function getMessageBySeq
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.IGetMessageBySeqRequest} request GetMessageBySeqRequest message or plain object
             * @returns {Promise<kritor.message.GetMessageBySeqResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.message.MessageService#getHistoryMessage}.
             * @memberof kritor.message.MessageService
             * @typedef GetHistoryMessageCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.message.GetHistoryMessageResponse} [response] GetHistoryMessageResponse
             */

            /**
             * Calls GetHistoryMessage.
             * @function getHistoryMessage
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.IGetHistoryMessageRequest} request GetHistoryMessageRequest message or plain object
             * @param {kritor.message.MessageService.GetHistoryMessageCallback} callback Node-style callback called with the error, if any, and GetHistoryMessageResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MessageService.prototype.getHistoryMessage = function getHistoryMessage(request, callback) {
                return this.rpcCall(getHistoryMessage, $root.kritor.message.GetHistoryMessageRequest, $root.kritor.message.GetHistoryMessageResponse, request, callback);
            }, "name", { value: "GetHistoryMessage" });

            /**
             * Calls GetHistoryMessage.
             * @function getHistoryMessage
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.IGetHistoryMessageRequest} request GetHistoryMessageRequest message or plain object
             * @returns {Promise<kritor.message.GetHistoryMessageResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.message.MessageService#getHistoryMessageBySeq}.
             * @memberof kritor.message.MessageService
             * @typedef GetHistoryMessageBySeqCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.message.GetHistoryMessageBySeqResponse} [response] GetHistoryMessageBySeqResponse
             */

            /**
             * Calls GetHistoryMessageBySeq.
             * @function getHistoryMessageBySeq
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.IGetHistoryMessageBySeqRequest} request GetHistoryMessageBySeqRequest message or plain object
             * @param {kritor.message.MessageService.GetHistoryMessageBySeqCallback} callback Node-style callback called with the error, if any, and GetHistoryMessageBySeqResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MessageService.prototype.getHistoryMessageBySeq = function getHistoryMessageBySeq(request, callback) {
                return this.rpcCall(getHistoryMessageBySeq, $root.kritor.message.GetHistoryMessageBySeqRequest, $root.kritor.message.GetHistoryMessageBySeqResponse, request, callback);
            }, "name", { value: "GetHistoryMessageBySeq" });

            /**
             * Calls GetHistoryMessageBySeq.
             * @function getHistoryMessageBySeq
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.IGetHistoryMessageBySeqRequest} request GetHistoryMessageBySeqRequest message or plain object
             * @returns {Promise<kritor.message.GetHistoryMessageBySeqResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.message.MessageService#uploadForwardMessage}.
             * @memberof kritor.message.MessageService
             * @typedef UploadForwardMessageCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.message.UploadForwardMessageResponse} [response] UploadForwardMessageResponse
             */

            /**
             * Calls UploadForwardMessage.
             * @function uploadForwardMessage
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.IUploadForwardMessageRequest} request UploadForwardMessageRequest message or plain object
             * @param {kritor.message.MessageService.UploadForwardMessageCallback} callback Node-style callback called with the error, if any, and UploadForwardMessageResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MessageService.prototype.uploadForwardMessage = function uploadForwardMessage(request, callback) {
                return this.rpcCall(uploadForwardMessage, $root.kritor.message.UploadForwardMessageRequest, $root.kritor.message.UploadForwardMessageResponse, request, callback);
            }, "name", { value: "UploadForwardMessage" });

            /**
             * Calls UploadForwardMessage.
             * @function uploadForwardMessage
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.IUploadForwardMessageRequest} request UploadForwardMessageRequest message or plain object
             * @returns {Promise<kritor.message.UploadForwardMessageResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.message.MessageService#downloadForwardMessage}.
             * @memberof kritor.message.MessageService
             * @typedef DownloadForwardMessageCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.message.DownloadForwardMessageResponse} [response] DownloadForwardMessageResponse
             */

            /**
             * Calls DownloadForwardMessage.
             * @function downloadForwardMessage
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.IDownloadForwardMessageRequest} request DownloadForwardMessageRequest message or plain object
             * @param {kritor.message.MessageService.DownloadForwardMessageCallback} callback Node-style callback called with the error, if any, and DownloadForwardMessageResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MessageService.prototype.downloadForwardMessage = function downloadForwardMessage(request, callback) {
                return this.rpcCall(downloadForwardMessage, $root.kritor.message.DownloadForwardMessageRequest, $root.kritor.message.DownloadForwardMessageResponse, request, callback);
            }, "name", { value: "DownloadForwardMessage" });

            /**
             * Calls DownloadForwardMessage.
             * @function downloadForwardMessage
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.IDownloadForwardMessageRequest} request DownloadForwardMessageRequest message or plain object
             * @returns {Promise<kritor.message.DownloadForwardMessageResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.message.MessageService#getEssenceMessageList}.
             * @memberof kritor.message.MessageService
             * @typedef GetEssenceMessageListCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.message.GetEssenceMessageListResponse} [response] GetEssenceMessageListResponse
             */

            /**
             * Calls GetEssenceMessageList.
             * @function getEssenceMessageList
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.IGetEssenceMessageListRequest} request GetEssenceMessageListRequest message or plain object
             * @param {kritor.message.MessageService.GetEssenceMessageListCallback} callback Node-style callback called with the error, if any, and GetEssenceMessageListResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MessageService.prototype.getEssenceMessageList = function getEssenceMessageList(request, callback) {
                return this.rpcCall(getEssenceMessageList, $root.kritor.message.GetEssenceMessageListRequest, $root.kritor.message.GetEssenceMessageListResponse, request, callback);
            }, "name", { value: "GetEssenceMessageList" });

            /**
             * Calls GetEssenceMessageList.
             * @function getEssenceMessageList
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.IGetEssenceMessageListRequest} request GetEssenceMessageListRequest message or plain object
             * @returns {Promise<kritor.message.GetEssenceMessageListResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.message.MessageService#setEssenceMessage}.
             * @memberof kritor.message.MessageService
             * @typedef SetEssenceMessageCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.message.SetEssenceMessageResponse} [response] SetEssenceMessageResponse
             */

            /**
             * Calls SetEssenceMessage.
             * @function setEssenceMessage
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.ISetEssenceMessageRequest} request SetEssenceMessageRequest message or plain object
             * @param {kritor.message.MessageService.SetEssenceMessageCallback} callback Node-style callback called with the error, if any, and SetEssenceMessageResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MessageService.prototype.setEssenceMessage = function setEssenceMessage(request, callback) {
                return this.rpcCall(setEssenceMessage, $root.kritor.message.SetEssenceMessageRequest, $root.kritor.message.SetEssenceMessageResponse, request, callback);
            }, "name", { value: "SetEssenceMessage" });

            /**
             * Calls SetEssenceMessage.
             * @function setEssenceMessage
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.ISetEssenceMessageRequest} request SetEssenceMessageRequest message or plain object
             * @returns {Promise<kritor.message.SetEssenceMessageResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.message.MessageService#deleteEssenceMessage}.
             * @memberof kritor.message.MessageService
             * @typedef DeleteEssenceMessageCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.message.DeleteEssenceMessageResponse} [response] DeleteEssenceMessageResponse
             */

            /**
             * Calls DeleteEssenceMessage.
             * @function deleteEssenceMessage
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.IDeleteEssenceMessageRequest} request DeleteEssenceMessageRequest message or plain object
             * @param {kritor.message.MessageService.DeleteEssenceMessageCallback} callback Node-style callback called with the error, if any, and DeleteEssenceMessageResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(MessageService.prototype.deleteEssenceMessage = function deleteEssenceMessage(request, callback) {
                return this.rpcCall(deleteEssenceMessage, $root.kritor.message.DeleteEssenceMessageRequest, $root.kritor.message.DeleteEssenceMessageResponse, request, callback);
            }, "name", { value: "DeleteEssenceMessage" });

            /**
             * Calls DeleteEssenceMessage.
             * @function deleteEssenceMessage
             * @memberof kritor.message.MessageService
             * @instance
             * @param {kritor.message.IDeleteEssenceMessageRequest} request DeleteEssenceMessageRequest message or plain object
             * @returns {Promise<kritor.message.DeleteEssenceMessageResponse>} Promise
             * @variation 2
             */

            return MessageService;
        })();

        message.SendMessageRequest = (function() {

            /**
             * Properties of a SendMessageRequest.
             * @memberof kritor.message
             * @interface ISendMessageRequest
             * @property {kritor.common.IContact|null} [contact] SendMessageRequest contact
             * @property {Array.<kritor.common.IElement>|null} [elements] SendMessageRequest elements
             * @property {number|null} [retryCount] SendMessageRequest retryCount
             */

            /**
             * Constructs a new SendMessageRequest.
             * @memberof kritor.message
             * @classdesc Represents a SendMessageRequest.
             * @implements ISendMessageRequest
             * @constructor
             * @param {kritor.message.ISendMessageRequest=} [properties] Properties to set
             */
            function SendMessageRequest(properties) {
                this.elements = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SendMessageRequest contact.
             * @member {kritor.common.IContact|null|undefined} contact
             * @memberof kritor.message.SendMessageRequest
             * @instance
             */
            SendMessageRequest.prototype.contact = null;

            /**
             * SendMessageRequest elements.
             * @member {Array.<kritor.common.IElement>} elements
             * @memberof kritor.message.SendMessageRequest
             * @instance
             */
            SendMessageRequest.prototype.elements = $util.emptyArray;

            /**
             * SendMessageRequest retryCount.
             * @member {number|null|undefined} retryCount
             * @memberof kritor.message.SendMessageRequest
             * @instance
             */
            SendMessageRequest.prototype.retryCount = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * SendMessageRequest _retryCount.
             * @member {"retryCount"|undefined} _retryCount
             * @memberof kritor.message.SendMessageRequest
             * @instance
             */
            Object.defineProperty(SendMessageRequest.prototype, "_retryCount", {
                get: $util.oneOfGetter($oneOfFields = ["retryCount"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new SendMessageRequest instance using the specified properties.
             * @function create
             * @memberof kritor.message.SendMessageRequest
             * @static
             * @param {kritor.message.ISendMessageRequest=} [properties] Properties to set
             * @returns {kritor.message.SendMessageRequest} SendMessageRequest instance
             */
            SendMessageRequest.create = function create(properties) {
                return new SendMessageRequest(properties);
            };

            /**
             * Encodes the specified SendMessageRequest message. Does not implicitly {@link kritor.message.SendMessageRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.SendMessageRequest
             * @static
             * @param {kritor.message.ISendMessageRequest} message SendMessageRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SendMessageRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.contact != null && Object.hasOwnProperty.call(message, "contact"))
                    $root.kritor.common.Contact.encode(message.contact, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.elements != null && message.elements.length)
                    for (let i = 0; i < message.elements.length; ++i)
                        $root.kritor.common.Element.encode(message.elements[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.retryCount != null && Object.hasOwnProperty.call(message, "retryCount"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.retryCount);
                return writer;
            };

            /**
             * Encodes the specified SendMessageRequest message, length delimited. Does not implicitly {@link kritor.message.SendMessageRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.SendMessageRequest
             * @static
             * @param {kritor.message.ISendMessageRequest} message SendMessageRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SendMessageRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SendMessageRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.SendMessageRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.SendMessageRequest} SendMessageRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SendMessageRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.SendMessageRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.contact = $root.kritor.common.Contact.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            if (!(message.elements && message.elements.length))
                                message.elements = [];
                            message.elements.push($root.kritor.common.Element.decode(reader, reader.uint32()));
                            break;
                        }
                    case 3: {
                            message.retryCount = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SendMessageRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.SendMessageRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.SendMessageRequest} SendMessageRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SendMessageRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SendMessageRequest message.
             * @function verify
             * @memberof kritor.message.SendMessageRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SendMessageRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.contact != null && message.hasOwnProperty("contact")) {
                    let error = $root.kritor.common.Contact.verify(message.contact);
                    if (error)
                        return "contact." + error;
                }
                if (message.elements != null && message.hasOwnProperty("elements")) {
                    if (!Array.isArray(message.elements))
                        return "elements: array expected";
                    for (let i = 0; i < message.elements.length; ++i) {
                        let error = $root.kritor.common.Element.verify(message.elements[i]);
                        if (error)
                            return "elements." + error;
                    }
                }
                if (message.retryCount != null && message.hasOwnProperty("retryCount")) {
                    properties._retryCount = 1;
                    if (!$util.isInteger(message.retryCount))
                        return "retryCount: integer expected";
                }
                return null;
            };

            /**
             * Creates a SendMessageRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.SendMessageRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.SendMessageRequest} SendMessageRequest
             */
            SendMessageRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.SendMessageRequest)
                    return object;
                let message = new $root.kritor.message.SendMessageRequest();
                if (object.contact != null) {
                    if (typeof object.contact !== "object")
                        throw TypeError(".kritor.message.SendMessageRequest.contact: object expected");
                    message.contact = $root.kritor.common.Contact.fromObject(object.contact);
                }
                if (object.elements) {
                    if (!Array.isArray(object.elements))
                        throw TypeError(".kritor.message.SendMessageRequest.elements: array expected");
                    message.elements = [];
                    for (let i = 0; i < object.elements.length; ++i) {
                        if (typeof object.elements[i] !== "object")
                            throw TypeError(".kritor.message.SendMessageRequest.elements: object expected");
                        message.elements[i] = $root.kritor.common.Element.fromObject(object.elements[i]);
                    }
                }
                if (object.retryCount != null)
                    message.retryCount = object.retryCount >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a SendMessageRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.SendMessageRequest
             * @static
             * @param {kritor.message.SendMessageRequest} message SendMessageRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SendMessageRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.elements = [];
                if (options.defaults)
                    object.contact = null;
                if (message.contact != null && message.hasOwnProperty("contact"))
                    object.contact = $root.kritor.common.Contact.toObject(message.contact, options);
                if (message.elements && message.elements.length) {
                    object.elements = [];
                    for (let j = 0; j < message.elements.length; ++j)
                        object.elements[j] = $root.kritor.common.Element.toObject(message.elements[j], options);
                }
                if (message.retryCount != null && message.hasOwnProperty("retryCount")) {
                    object.retryCount = message.retryCount;
                    if (options.oneofs)
                        object._retryCount = "retryCount";
                }
                return object;
            };

            /**
             * Converts this SendMessageRequest to JSON.
             * @function toJSON
             * @memberof kritor.message.SendMessageRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SendMessageRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SendMessageRequest
             * @function getTypeUrl
             * @memberof kritor.message.SendMessageRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SendMessageRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.SendMessageRequest";
            };

            return SendMessageRequest;
        })();

        message.SendMessageResponse = (function() {

            /**
             * Properties of a SendMessageResponse.
             * @memberof kritor.message
             * @interface ISendMessageResponse
             * @property {string|null} [messageId] SendMessageResponse messageId
             * @property {number|null} [messageTime] SendMessageResponse messageTime
             */

            /**
             * Constructs a new SendMessageResponse.
             * @memberof kritor.message
             * @classdesc Represents a SendMessageResponse.
             * @implements ISendMessageResponse
             * @constructor
             * @param {kritor.message.ISendMessageResponse=} [properties] Properties to set
             */
            function SendMessageResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SendMessageResponse messageId.
             * @member {string} messageId
             * @memberof kritor.message.SendMessageResponse
             * @instance
             */
            SendMessageResponse.prototype.messageId = "";

            /**
             * SendMessageResponse messageTime.
             * @member {number} messageTime
             * @memberof kritor.message.SendMessageResponse
             * @instance
             */
            SendMessageResponse.prototype.messageTime = 0;

            /**
             * Creates a new SendMessageResponse instance using the specified properties.
             * @function create
             * @memberof kritor.message.SendMessageResponse
             * @static
             * @param {kritor.message.ISendMessageResponse=} [properties] Properties to set
             * @returns {kritor.message.SendMessageResponse} SendMessageResponse instance
             */
            SendMessageResponse.create = function create(properties) {
                return new SendMessageResponse(properties);
            };

            /**
             * Encodes the specified SendMessageResponse message. Does not implicitly {@link kritor.message.SendMessageResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.SendMessageResponse
             * @static
             * @param {kritor.message.ISendMessageResponse} message SendMessageResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SendMessageResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.messageId != null && Object.hasOwnProperty.call(message, "messageId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.messageId);
                if (message.messageTime != null && Object.hasOwnProperty.call(message, "messageTime"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.messageTime);
                return writer;
            };

            /**
             * Encodes the specified SendMessageResponse message, length delimited. Does not implicitly {@link kritor.message.SendMessageResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.SendMessageResponse
             * @static
             * @param {kritor.message.ISendMessageResponse} message SendMessageResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SendMessageResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SendMessageResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.SendMessageResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.SendMessageResponse} SendMessageResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SendMessageResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.SendMessageResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.messageId = reader.string();
                            break;
                        }
                    case 2: {
                            message.messageTime = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SendMessageResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.SendMessageResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.SendMessageResponse} SendMessageResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SendMessageResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SendMessageResponse message.
             * @function verify
             * @memberof kritor.message.SendMessageResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SendMessageResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    if (!$util.isString(message.messageId))
                        return "messageId: string expected";
                if (message.messageTime != null && message.hasOwnProperty("messageTime"))
                    if (!$util.isInteger(message.messageTime))
                        return "messageTime: integer expected";
                return null;
            };

            /**
             * Creates a SendMessageResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.SendMessageResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.SendMessageResponse} SendMessageResponse
             */
            SendMessageResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.SendMessageResponse)
                    return object;
                let message = new $root.kritor.message.SendMessageResponse();
                if (object.messageId != null)
                    message.messageId = String(object.messageId);
                if (object.messageTime != null)
                    message.messageTime = object.messageTime >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a SendMessageResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.SendMessageResponse
             * @static
             * @param {kritor.message.SendMessageResponse} message SendMessageResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SendMessageResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.messageId = "";
                    object.messageTime = 0;
                }
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    object.messageId = message.messageId;
                if (message.messageTime != null && message.hasOwnProperty("messageTime"))
                    object.messageTime = message.messageTime;
                return object;
            };

            /**
             * Converts this SendMessageResponse to JSON.
             * @function toJSON
             * @memberof kritor.message.SendMessageResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SendMessageResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SendMessageResponse
             * @function getTypeUrl
             * @memberof kritor.message.SendMessageResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SendMessageResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.SendMessageResponse";
            };

            return SendMessageResponse;
        })();

        message.SendMessageByResIdRequest = (function() {

            /**
             * Properties of a SendMessageByResIdRequest.
             * @memberof kritor.message
             * @interface ISendMessageByResIdRequest
             * @property {kritor.common.IContact|null} [contact] SendMessageByResIdRequest contact
             * @property {string|null} [resId] SendMessageByResIdRequest resId
             * @property {number|null} [retryCount] SendMessageByResIdRequest retryCount
             */

            /**
             * Constructs a new SendMessageByResIdRequest.
             * @memberof kritor.message
             * @classdesc Represents a SendMessageByResIdRequest.
             * @implements ISendMessageByResIdRequest
             * @constructor
             * @param {kritor.message.ISendMessageByResIdRequest=} [properties] Properties to set
             */
            function SendMessageByResIdRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SendMessageByResIdRequest contact.
             * @member {kritor.common.IContact|null|undefined} contact
             * @memberof kritor.message.SendMessageByResIdRequest
             * @instance
             */
            SendMessageByResIdRequest.prototype.contact = null;

            /**
             * SendMessageByResIdRequest resId.
             * @member {string} resId
             * @memberof kritor.message.SendMessageByResIdRequest
             * @instance
             */
            SendMessageByResIdRequest.prototype.resId = "";

            /**
             * SendMessageByResIdRequest retryCount.
             * @member {number|null|undefined} retryCount
             * @memberof kritor.message.SendMessageByResIdRequest
             * @instance
             */
            SendMessageByResIdRequest.prototype.retryCount = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * SendMessageByResIdRequest _retryCount.
             * @member {"retryCount"|undefined} _retryCount
             * @memberof kritor.message.SendMessageByResIdRequest
             * @instance
             */
            Object.defineProperty(SendMessageByResIdRequest.prototype, "_retryCount", {
                get: $util.oneOfGetter($oneOfFields = ["retryCount"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new SendMessageByResIdRequest instance using the specified properties.
             * @function create
             * @memberof kritor.message.SendMessageByResIdRequest
             * @static
             * @param {kritor.message.ISendMessageByResIdRequest=} [properties] Properties to set
             * @returns {kritor.message.SendMessageByResIdRequest} SendMessageByResIdRequest instance
             */
            SendMessageByResIdRequest.create = function create(properties) {
                return new SendMessageByResIdRequest(properties);
            };

            /**
             * Encodes the specified SendMessageByResIdRequest message. Does not implicitly {@link kritor.message.SendMessageByResIdRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.SendMessageByResIdRequest
             * @static
             * @param {kritor.message.ISendMessageByResIdRequest} message SendMessageByResIdRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SendMessageByResIdRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.contact != null && Object.hasOwnProperty.call(message, "contact"))
                    $root.kritor.common.Contact.encode(message.contact, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.resId != null && Object.hasOwnProperty.call(message, "resId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.resId);
                if (message.retryCount != null && Object.hasOwnProperty.call(message, "retryCount"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.retryCount);
                return writer;
            };

            /**
             * Encodes the specified SendMessageByResIdRequest message, length delimited. Does not implicitly {@link kritor.message.SendMessageByResIdRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.SendMessageByResIdRequest
             * @static
             * @param {kritor.message.ISendMessageByResIdRequest} message SendMessageByResIdRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SendMessageByResIdRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SendMessageByResIdRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.SendMessageByResIdRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.SendMessageByResIdRequest} SendMessageByResIdRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SendMessageByResIdRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.SendMessageByResIdRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.contact = $root.kritor.common.Contact.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.resId = reader.string();
                            break;
                        }
                    case 3: {
                            message.retryCount = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SendMessageByResIdRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.SendMessageByResIdRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.SendMessageByResIdRequest} SendMessageByResIdRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SendMessageByResIdRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SendMessageByResIdRequest message.
             * @function verify
             * @memberof kritor.message.SendMessageByResIdRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SendMessageByResIdRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.contact != null && message.hasOwnProperty("contact")) {
                    let error = $root.kritor.common.Contact.verify(message.contact);
                    if (error)
                        return "contact." + error;
                }
                if (message.resId != null && message.hasOwnProperty("resId"))
                    if (!$util.isString(message.resId))
                        return "resId: string expected";
                if (message.retryCount != null && message.hasOwnProperty("retryCount")) {
                    properties._retryCount = 1;
                    if (!$util.isInteger(message.retryCount))
                        return "retryCount: integer expected";
                }
                return null;
            };

            /**
             * Creates a SendMessageByResIdRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.SendMessageByResIdRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.SendMessageByResIdRequest} SendMessageByResIdRequest
             */
            SendMessageByResIdRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.SendMessageByResIdRequest)
                    return object;
                let message = new $root.kritor.message.SendMessageByResIdRequest();
                if (object.contact != null) {
                    if (typeof object.contact !== "object")
                        throw TypeError(".kritor.message.SendMessageByResIdRequest.contact: object expected");
                    message.contact = $root.kritor.common.Contact.fromObject(object.contact);
                }
                if (object.resId != null)
                    message.resId = String(object.resId);
                if (object.retryCount != null)
                    message.retryCount = object.retryCount >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a SendMessageByResIdRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.SendMessageByResIdRequest
             * @static
             * @param {kritor.message.SendMessageByResIdRequest} message SendMessageByResIdRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SendMessageByResIdRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.contact = null;
                    object.resId = "";
                }
                if (message.contact != null && message.hasOwnProperty("contact"))
                    object.contact = $root.kritor.common.Contact.toObject(message.contact, options);
                if (message.resId != null && message.hasOwnProperty("resId"))
                    object.resId = message.resId;
                if (message.retryCount != null && message.hasOwnProperty("retryCount")) {
                    object.retryCount = message.retryCount;
                    if (options.oneofs)
                        object._retryCount = "retryCount";
                }
                return object;
            };

            /**
             * Converts this SendMessageByResIdRequest to JSON.
             * @function toJSON
             * @memberof kritor.message.SendMessageByResIdRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SendMessageByResIdRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SendMessageByResIdRequest
             * @function getTypeUrl
             * @memberof kritor.message.SendMessageByResIdRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SendMessageByResIdRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.SendMessageByResIdRequest";
            };

            return SendMessageByResIdRequest;
        })();

        message.SendMessageByResIdResponse = (function() {

            /**
             * Properties of a SendMessageByResIdResponse.
             * @memberof kritor.message
             * @interface ISendMessageByResIdResponse
             * @property {string|null} [messageId] SendMessageByResIdResponse messageId
             * @property {number|null} [messageTime] SendMessageByResIdResponse messageTime
             */

            /**
             * Constructs a new SendMessageByResIdResponse.
             * @memberof kritor.message
             * @classdesc Represents a SendMessageByResIdResponse.
             * @implements ISendMessageByResIdResponse
             * @constructor
             * @param {kritor.message.ISendMessageByResIdResponse=} [properties] Properties to set
             */
            function SendMessageByResIdResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SendMessageByResIdResponse messageId.
             * @member {string} messageId
             * @memberof kritor.message.SendMessageByResIdResponse
             * @instance
             */
            SendMessageByResIdResponse.prototype.messageId = "";

            /**
             * SendMessageByResIdResponse messageTime.
             * @member {number} messageTime
             * @memberof kritor.message.SendMessageByResIdResponse
             * @instance
             */
            SendMessageByResIdResponse.prototype.messageTime = 0;

            /**
             * Creates a new SendMessageByResIdResponse instance using the specified properties.
             * @function create
             * @memberof kritor.message.SendMessageByResIdResponse
             * @static
             * @param {kritor.message.ISendMessageByResIdResponse=} [properties] Properties to set
             * @returns {kritor.message.SendMessageByResIdResponse} SendMessageByResIdResponse instance
             */
            SendMessageByResIdResponse.create = function create(properties) {
                return new SendMessageByResIdResponse(properties);
            };

            /**
             * Encodes the specified SendMessageByResIdResponse message. Does not implicitly {@link kritor.message.SendMessageByResIdResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.SendMessageByResIdResponse
             * @static
             * @param {kritor.message.ISendMessageByResIdResponse} message SendMessageByResIdResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SendMessageByResIdResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.messageId != null && Object.hasOwnProperty.call(message, "messageId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.messageId);
                if (message.messageTime != null && Object.hasOwnProperty.call(message, "messageTime"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.messageTime);
                return writer;
            };

            /**
             * Encodes the specified SendMessageByResIdResponse message, length delimited. Does not implicitly {@link kritor.message.SendMessageByResIdResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.SendMessageByResIdResponse
             * @static
             * @param {kritor.message.ISendMessageByResIdResponse} message SendMessageByResIdResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SendMessageByResIdResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SendMessageByResIdResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.SendMessageByResIdResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.SendMessageByResIdResponse} SendMessageByResIdResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SendMessageByResIdResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.SendMessageByResIdResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.messageId = reader.string();
                            break;
                        }
                    case 2: {
                            message.messageTime = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SendMessageByResIdResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.SendMessageByResIdResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.SendMessageByResIdResponse} SendMessageByResIdResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SendMessageByResIdResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SendMessageByResIdResponse message.
             * @function verify
             * @memberof kritor.message.SendMessageByResIdResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SendMessageByResIdResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    if (!$util.isString(message.messageId))
                        return "messageId: string expected";
                if (message.messageTime != null && message.hasOwnProperty("messageTime"))
                    if (!$util.isInteger(message.messageTime))
                        return "messageTime: integer expected";
                return null;
            };

            /**
             * Creates a SendMessageByResIdResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.SendMessageByResIdResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.SendMessageByResIdResponse} SendMessageByResIdResponse
             */
            SendMessageByResIdResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.SendMessageByResIdResponse)
                    return object;
                let message = new $root.kritor.message.SendMessageByResIdResponse();
                if (object.messageId != null)
                    message.messageId = String(object.messageId);
                if (object.messageTime != null)
                    message.messageTime = object.messageTime >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a SendMessageByResIdResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.SendMessageByResIdResponse
             * @static
             * @param {kritor.message.SendMessageByResIdResponse} message SendMessageByResIdResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SendMessageByResIdResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.messageId = "";
                    object.messageTime = 0;
                }
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    object.messageId = message.messageId;
                if (message.messageTime != null && message.hasOwnProperty("messageTime"))
                    object.messageTime = message.messageTime;
                return object;
            };

            /**
             * Converts this SendMessageByResIdResponse to JSON.
             * @function toJSON
             * @memberof kritor.message.SendMessageByResIdResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SendMessageByResIdResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SendMessageByResIdResponse
             * @function getTypeUrl
             * @memberof kritor.message.SendMessageByResIdResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SendMessageByResIdResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.SendMessageByResIdResponse";
            };

            return SendMessageByResIdResponse;
        })();

        message.SetMessageReadRequest = (function() {

            /**
             * Properties of a SetMessageReadRequest.
             * @memberof kritor.message
             * @interface ISetMessageReadRequest
             * @property {kritor.common.IContact|null} [contact] SetMessageReadRequest contact
             */

            /**
             * Constructs a new SetMessageReadRequest.
             * @memberof kritor.message
             * @classdesc Represents a SetMessageReadRequest.
             * @implements ISetMessageReadRequest
             * @constructor
             * @param {kritor.message.ISetMessageReadRequest=} [properties] Properties to set
             */
            function SetMessageReadRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SetMessageReadRequest contact.
             * @member {kritor.common.IContact|null|undefined} contact
             * @memberof kritor.message.SetMessageReadRequest
             * @instance
             */
            SetMessageReadRequest.prototype.contact = null;

            /**
             * Creates a new SetMessageReadRequest instance using the specified properties.
             * @function create
             * @memberof kritor.message.SetMessageReadRequest
             * @static
             * @param {kritor.message.ISetMessageReadRequest=} [properties] Properties to set
             * @returns {kritor.message.SetMessageReadRequest} SetMessageReadRequest instance
             */
            SetMessageReadRequest.create = function create(properties) {
                return new SetMessageReadRequest(properties);
            };

            /**
             * Encodes the specified SetMessageReadRequest message. Does not implicitly {@link kritor.message.SetMessageReadRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.SetMessageReadRequest
             * @static
             * @param {kritor.message.ISetMessageReadRequest} message SetMessageReadRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetMessageReadRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.contact != null && Object.hasOwnProperty.call(message, "contact"))
                    $root.kritor.common.Contact.encode(message.contact, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified SetMessageReadRequest message, length delimited. Does not implicitly {@link kritor.message.SetMessageReadRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.SetMessageReadRequest
             * @static
             * @param {kritor.message.ISetMessageReadRequest} message SetMessageReadRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetMessageReadRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetMessageReadRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.SetMessageReadRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.SetMessageReadRequest} SetMessageReadRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetMessageReadRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.SetMessageReadRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.contact = $root.kritor.common.Contact.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetMessageReadRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.SetMessageReadRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.SetMessageReadRequest} SetMessageReadRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetMessageReadRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetMessageReadRequest message.
             * @function verify
             * @memberof kritor.message.SetMessageReadRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetMessageReadRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.contact != null && message.hasOwnProperty("contact")) {
                    let error = $root.kritor.common.Contact.verify(message.contact);
                    if (error)
                        return "contact." + error;
                }
                return null;
            };

            /**
             * Creates a SetMessageReadRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.SetMessageReadRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.SetMessageReadRequest} SetMessageReadRequest
             */
            SetMessageReadRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.SetMessageReadRequest)
                    return object;
                let message = new $root.kritor.message.SetMessageReadRequest();
                if (object.contact != null) {
                    if (typeof object.contact !== "object")
                        throw TypeError(".kritor.message.SetMessageReadRequest.contact: object expected");
                    message.contact = $root.kritor.common.Contact.fromObject(object.contact);
                }
                return message;
            };

            /**
             * Creates a plain object from a SetMessageReadRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.SetMessageReadRequest
             * @static
             * @param {kritor.message.SetMessageReadRequest} message SetMessageReadRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetMessageReadRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.contact = null;
                if (message.contact != null && message.hasOwnProperty("contact"))
                    object.contact = $root.kritor.common.Contact.toObject(message.contact, options);
                return object;
            };

            /**
             * Converts this SetMessageReadRequest to JSON.
             * @function toJSON
             * @memberof kritor.message.SetMessageReadRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetMessageReadRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetMessageReadRequest
             * @function getTypeUrl
             * @memberof kritor.message.SetMessageReadRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetMessageReadRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.SetMessageReadRequest";
            };

            return SetMessageReadRequest;
        })();

        message.SetMessageReadResponse = (function() {

            /**
             * Properties of a SetMessageReadResponse.
             * @memberof kritor.message
             * @interface ISetMessageReadResponse
             */

            /**
             * Constructs a new SetMessageReadResponse.
             * @memberof kritor.message
             * @classdesc Represents a SetMessageReadResponse.
             * @implements ISetMessageReadResponse
             * @constructor
             * @param {kritor.message.ISetMessageReadResponse=} [properties] Properties to set
             */
            function SetMessageReadResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new SetMessageReadResponse instance using the specified properties.
             * @function create
             * @memberof kritor.message.SetMessageReadResponse
             * @static
             * @param {kritor.message.ISetMessageReadResponse=} [properties] Properties to set
             * @returns {kritor.message.SetMessageReadResponse} SetMessageReadResponse instance
             */
            SetMessageReadResponse.create = function create(properties) {
                return new SetMessageReadResponse(properties);
            };

            /**
             * Encodes the specified SetMessageReadResponse message. Does not implicitly {@link kritor.message.SetMessageReadResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.SetMessageReadResponse
             * @static
             * @param {kritor.message.ISetMessageReadResponse} message SetMessageReadResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetMessageReadResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified SetMessageReadResponse message, length delimited. Does not implicitly {@link kritor.message.SetMessageReadResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.SetMessageReadResponse
             * @static
             * @param {kritor.message.ISetMessageReadResponse} message SetMessageReadResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetMessageReadResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetMessageReadResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.SetMessageReadResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.SetMessageReadResponse} SetMessageReadResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetMessageReadResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.SetMessageReadResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetMessageReadResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.SetMessageReadResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.SetMessageReadResponse} SetMessageReadResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetMessageReadResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetMessageReadResponse message.
             * @function verify
             * @memberof kritor.message.SetMessageReadResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetMessageReadResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a SetMessageReadResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.SetMessageReadResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.SetMessageReadResponse} SetMessageReadResponse
             */
            SetMessageReadResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.SetMessageReadResponse)
                    return object;
                return new $root.kritor.message.SetMessageReadResponse();
            };

            /**
             * Creates a plain object from a SetMessageReadResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.SetMessageReadResponse
             * @static
             * @param {kritor.message.SetMessageReadResponse} message SetMessageReadResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetMessageReadResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this SetMessageReadResponse to JSON.
             * @function toJSON
             * @memberof kritor.message.SetMessageReadResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetMessageReadResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetMessageReadResponse
             * @function getTypeUrl
             * @memberof kritor.message.SetMessageReadResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetMessageReadResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.SetMessageReadResponse";
            };

            return SetMessageReadResponse;
        })();

        message.RecallMessageRequest = (function() {

            /**
             * Properties of a RecallMessageRequest.
             * @memberof kritor.message
             * @interface IRecallMessageRequest
             * @property {kritor.common.IContact|null} [contact] RecallMessageRequest contact
             * @property {string|null} [messageId] RecallMessageRequest messageId
             */

            /**
             * Constructs a new RecallMessageRequest.
             * @memberof kritor.message
             * @classdesc Represents a RecallMessageRequest.
             * @implements IRecallMessageRequest
             * @constructor
             * @param {kritor.message.IRecallMessageRequest=} [properties] Properties to set
             */
            function RecallMessageRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RecallMessageRequest contact.
             * @member {kritor.common.IContact|null|undefined} contact
             * @memberof kritor.message.RecallMessageRequest
             * @instance
             */
            RecallMessageRequest.prototype.contact = null;

            /**
             * RecallMessageRequest messageId.
             * @member {string} messageId
             * @memberof kritor.message.RecallMessageRequest
             * @instance
             */
            RecallMessageRequest.prototype.messageId = "";

            /**
             * Creates a new RecallMessageRequest instance using the specified properties.
             * @function create
             * @memberof kritor.message.RecallMessageRequest
             * @static
             * @param {kritor.message.IRecallMessageRequest=} [properties] Properties to set
             * @returns {kritor.message.RecallMessageRequest} RecallMessageRequest instance
             */
            RecallMessageRequest.create = function create(properties) {
                return new RecallMessageRequest(properties);
            };

            /**
             * Encodes the specified RecallMessageRequest message. Does not implicitly {@link kritor.message.RecallMessageRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.RecallMessageRequest
             * @static
             * @param {kritor.message.IRecallMessageRequest} message RecallMessageRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RecallMessageRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.contact != null && Object.hasOwnProperty.call(message, "contact"))
                    $root.kritor.common.Contact.encode(message.contact, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.messageId != null && Object.hasOwnProperty.call(message, "messageId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.messageId);
                return writer;
            };

            /**
             * Encodes the specified RecallMessageRequest message, length delimited. Does not implicitly {@link kritor.message.RecallMessageRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.RecallMessageRequest
             * @static
             * @param {kritor.message.IRecallMessageRequest} message RecallMessageRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RecallMessageRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RecallMessageRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.RecallMessageRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.RecallMessageRequest} RecallMessageRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RecallMessageRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.RecallMessageRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.contact = $root.kritor.common.Contact.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.messageId = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RecallMessageRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.RecallMessageRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.RecallMessageRequest} RecallMessageRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RecallMessageRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RecallMessageRequest message.
             * @function verify
             * @memberof kritor.message.RecallMessageRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RecallMessageRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.contact != null && message.hasOwnProperty("contact")) {
                    let error = $root.kritor.common.Contact.verify(message.contact);
                    if (error)
                        return "contact." + error;
                }
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    if (!$util.isString(message.messageId))
                        return "messageId: string expected";
                return null;
            };

            /**
             * Creates a RecallMessageRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.RecallMessageRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.RecallMessageRequest} RecallMessageRequest
             */
            RecallMessageRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.RecallMessageRequest)
                    return object;
                let message = new $root.kritor.message.RecallMessageRequest();
                if (object.contact != null) {
                    if (typeof object.contact !== "object")
                        throw TypeError(".kritor.message.RecallMessageRequest.contact: object expected");
                    message.contact = $root.kritor.common.Contact.fromObject(object.contact);
                }
                if (object.messageId != null)
                    message.messageId = String(object.messageId);
                return message;
            };

            /**
             * Creates a plain object from a RecallMessageRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.RecallMessageRequest
             * @static
             * @param {kritor.message.RecallMessageRequest} message RecallMessageRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RecallMessageRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.contact = null;
                    object.messageId = "";
                }
                if (message.contact != null && message.hasOwnProperty("contact"))
                    object.contact = $root.kritor.common.Contact.toObject(message.contact, options);
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    object.messageId = message.messageId;
                return object;
            };

            /**
             * Converts this RecallMessageRequest to JSON.
             * @function toJSON
             * @memberof kritor.message.RecallMessageRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RecallMessageRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for RecallMessageRequest
             * @function getTypeUrl
             * @memberof kritor.message.RecallMessageRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            RecallMessageRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.RecallMessageRequest";
            };

            return RecallMessageRequest;
        })();

        message.RecallMessageResponse = (function() {

            /**
             * Properties of a RecallMessageResponse.
             * @memberof kritor.message
             * @interface IRecallMessageResponse
             */

            /**
             * Constructs a new RecallMessageResponse.
             * @memberof kritor.message
             * @classdesc Represents a RecallMessageResponse.
             * @implements IRecallMessageResponse
             * @constructor
             * @param {kritor.message.IRecallMessageResponse=} [properties] Properties to set
             */
            function RecallMessageResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new RecallMessageResponse instance using the specified properties.
             * @function create
             * @memberof kritor.message.RecallMessageResponse
             * @static
             * @param {kritor.message.IRecallMessageResponse=} [properties] Properties to set
             * @returns {kritor.message.RecallMessageResponse} RecallMessageResponse instance
             */
            RecallMessageResponse.create = function create(properties) {
                return new RecallMessageResponse(properties);
            };

            /**
             * Encodes the specified RecallMessageResponse message. Does not implicitly {@link kritor.message.RecallMessageResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.RecallMessageResponse
             * @static
             * @param {kritor.message.IRecallMessageResponse} message RecallMessageResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RecallMessageResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified RecallMessageResponse message, length delimited. Does not implicitly {@link kritor.message.RecallMessageResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.RecallMessageResponse
             * @static
             * @param {kritor.message.IRecallMessageResponse} message RecallMessageResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RecallMessageResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RecallMessageResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.RecallMessageResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.RecallMessageResponse} RecallMessageResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RecallMessageResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.RecallMessageResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RecallMessageResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.RecallMessageResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.RecallMessageResponse} RecallMessageResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RecallMessageResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RecallMessageResponse message.
             * @function verify
             * @memberof kritor.message.RecallMessageResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RecallMessageResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a RecallMessageResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.RecallMessageResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.RecallMessageResponse} RecallMessageResponse
             */
            RecallMessageResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.RecallMessageResponse)
                    return object;
                return new $root.kritor.message.RecallMessageResponse();
            };

            /**
             * Creates a plain object from a RecallMessageResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.RecallMessageResponse
             * @static
             * @param {kritor.message.RecallMessageResponse} message RecallMessageResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RecallMessageResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this RecallMessageResponse to JSON.
             * @function toJSON
             * @memberof kritor.message.RecallMessageResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RecallMessageResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for RecallMessageResponse
             * @function getTypeUrl
             * @memberof kritor.message.RecallMessageResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            RecallMessageResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.RecallMessageResponse";
            };

            return RecallMessageResponse;
        })();

        message.ReactMessageWithEmojiRequest = (function() {

            /**
             * Properties of a ReactMessageWithEmojiRequest.
             * @memberof kritor.message
             * @interface IReactMessageWithEmojiRequest
             * @property {kritor.common.IContact|null} [contact] ReactMessageWithEmojiRequest contact
             * @property {string|null} [messageId] ReactMessageWithEmojiRequest messageId
             * @property {number|null} [faceId] ReactMessageWithEmojiRequest faceId
             * @property {boolean|null} [isSet] ReactMessageWithEmojiRequest isSet
             */

            /**
             * Constructs a new ReactMessageWithEmojiRequest.
             * @memberof kritor.message
             * @classdesc Represents a ReactMessageWithEmojiRequest.
             * @implements IReactMessageWithEmojiRequest
             * @constructor
             * @param {kritor.message.IReactMessageWithEmojiRequest=} [properties] Properties to set
             */
            function ReactMessageWithEmojiRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ReactMessageWithEmojiRequest contact.
             * @member {kritor.common.IContact|null|undefined} contact
             * @memberof kritor.message.ReactMessageWithEmojiRequest
             * @instance
             */
            ReactMessageWithEmojiRequest.prototype.contact = null;

            /**
             * ReactMessageWithEmojiRequest messageId.
             * @member {string} messageId
             * @memberof kritor.message.ReactMessageWithEmojiRequest
             * @instance
             */
            ReactMessageWithEmojiRequest.prototype.messageId = "";

            /**
             * ReactMessageWithEmojiRequest faceId.
             * @member {number} faceId
             * @memberof kritor.message.ReactMessageWithEmojiRequest
             * @instance
             */
            ReactMessageWithEmojiRequest.prototype.faceId = 0;

            /**
             * ReactMessageWithEmojiRequest isSet.
             * @member {boolean} isSet
             * @memberof kritor.message.ReactMessageWithEmojiRequest
             * @instance
             */
            ReactMessageWithEmojiRequest.prototype.isSet = false;

            /**
             * Creates a new ReactMessageWithEmojiRequest instance using the specified properties.
             * @function create
             * @memberof kritor.message.ReactMessageWithEmojiRequest
             * @static
             * @param {kritor.message.IReactMessageWithEmojiRequest=} [properties] Properties to set
             * @returns {kritor.message.ReactMessageWithEmojiRequest} ReactMessageWithEmojiRequest instance
             */
            ReactMessageWithEmojiRequest.create = function create(properties) {
                return new ReactMessageWithEmojiRequest(properties);
            };

            /**
             * Encodes the specified ReactMessageWithEmojiRequest message. Does not implicitly {@link kritor.message.ReactMessageWithEmojiRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.ReactMessageWithEmojiRequest
             * @static
             * @param {kritor.message.IReactMessageWithEmojiRequest} message ReactMessageWithEmojiRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReactMessageWithEmojiRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.contact != null && Object.hasOwnProperty.call(message, "contact"))
                    $root.kritor.common.Contact.encode(message.contact, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.messageId != null && Object.hasOwnProperty.call(message, "messageId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.messageId);
                if (message.faceId != null && Object.hasOwnProperty.call(message, "faceId"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.faceId);
                if (message.isSet != null && Object.hasOwnProperty.call(message, "isSet"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.isSet);
                return writer;
            };

            /**
             * Encodes the specified ReactMessageWithEmojiRequest message, length delimited. Does not implicitly {@link kritor.message.ReactMessageWithEmojiRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.ReactMessageWithEmojiRequest
             * @static
             * @param {kritor.message.IReactMessageWithEmojiRequest} message ReactMessageWithEmojiRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReactMessageWithEmojiRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReactMessageWithEmojiRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.ReactMessageWithEmojiRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.ReactMessageWithEmojiRequest} ReactMessageWithEmojiRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReactMessageWithEmojiRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.ReactMessageWithEmojiRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.contact = $root.kritor.common.Contact.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.messageId = reader.string();
                            break;
                        }
                    case 3: {
                            message.faceId = reader.uint32();
                            break;
                        }
                    case 4: {
                            message.isSet = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReactMessageWithEmojiRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.ReactMessageWithEmojiRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.ReactMessageWithEmojiRequest} ReactMessageWithEmojiRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReactMessageWithEmojiRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReactMessageWithEmojiRequest message.
             * @function verify
             * @memberof kritor.message.ReactMessageWithEmojiRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReactMessageWithEmojiRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.contact != null && message.hasOwnProperty("contact")) {
                    let error = $root.kritor.common.Contact.verify(message.contact);
                    if (error)
                        return "contact." + error;
                }
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    if (!$util.isString(message.messageId))
                        return "messageId: string expected";
                if (message.faceId != null && message.hasOwnProperty("faceId"))
                    if (!$util.isInteger(message.faceId))
                        return "faceId: integer expected";
                if (message.isSet != null && message.hasOwnProperty("isSet"))
                    if (typeof message.isSet !== "boolean")
                        return "isSet: boolean expected";
                return null;
            };

            /**
             * Creates a ReactMessageWithEmojiRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.ReactMessageWithEmojiRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.ReactMessageWithEmojiRequest} ReactMessageWithEmojiRequest
             */
            ReactMessageWithEmojiRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.ReactMessageWithEmojiRequest)
                    return object;
                let message = new $root.kritor.message.ReactMessageWithEmojiRequest();
                if (object.contact != null) {
                    if (typeof object.contact !== "object")
                        throw TypeError(".kritor.message.ReactMessageWithEmojiRequest.contact: object expected");
                    message.contact = $root.kritor.common.Contact.fromObject(object.contact);
                }
                if (object.messageId != null)
                    message.messageId = String(object.messageId);
                if (object.faceId != null)
                    message.faceId = object.faceId >>> 0;
                if (object.isSet != null)
                    message.isSet = Boolean(object.isSet);
                return message;
            };

            /**
             * Creates a plain object from a ReactMessageWithEmojiRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.ReactMessageWithEmojiRequest
             * @static
             * @param {kritor.message.ReactMessageWithEmojiRequest} message ReactMessageWithEmojiRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReactMessageWithEmojiRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.contact = null;
                    object.messageId = "";
                    object.faceId = 0;
                    object.isSet = false;
                }
                if (message.contact != null && message.hasOwnProperty("contact"))
                    object.contact = $root.kritor.common.Contact.toObject(message.contact, options);
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    object.messageId = message.messageId;
                if (message.faceId != null && message.hasOwnProperty("faceId"))
                    object.faceId = message.faceId;
                if (message.isSet != null && message.hasOwnProperty("isSet"))
                    object.isSet = message.isSet;
                return object;
            };

            /**
             * Converts this ReactMessageWithEmojiRequest to JSON.
             * @function toJSON
             * @memberof kritor.message.ReactMessageWithEmojiRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReactMessageWithEmojiRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ReactMessageWithEmojiRequest
             * @function getTypeUrl
             * @memberof kritor.message.ReactMessageWithEmojiRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ReactMessageWithEmojiRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.ReactMessageWithEmojiRequest";
            };

            return ReactMessageWithEmojiRequest;
        })();

        message.ReactMessageWithEmojiResponse = (function() {

            /**
             * Properties of a ReactMessageWithEmojiResponse.
             * @memberof kritor.message
             * @interface IReactMessageWithEmojiResponse
             */

            /**
             * Constructs a new ReactMessageWithEmojiResponse.
             * @memberof kritor.message
             * @classdesc Represents a ReactMessageWithEmojiResponse.
             * @implements IReactMessageWithEmojiResponse
             * @constructor
             * @param {kritor.message.IReactMessageWithEmojiResponse=} [properties] Properties to set
             */
            function ReactMessageWithEmojiResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new ReactMessageWithEmojiResponse instance using the specified properties.
             * @function create
             * @memberof kritor.message.ReactMessageWithEmojiResponse
             * @static
             * @param {kritor.message.IReactMessageWithEmojiResponse=} [properties] Properties to set
             * @returns {kritor.message.ReactMessageWithEmojiResponse} ReactMessageWithEmojiResponse instance
             */
            ReactMessageWithEmojiResponse.create = function create(properties) {
                return new ReactMessageWithEmojiResponse(properties);
            };

            /**
             * Encodes the specified ReactMessageWithEmojiResponse message. Does not implicitly {@link kritor.message.ReactMessageWithEmojiResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.ReactMessageWithEmojiResponse
             * @static
             * @param {kritor.message.IReactMessageWithEmojiResponse} message ReactMessageWithEmojiResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReactMessageWithEmojiResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified ReactMessageWithEmojiResponse message, length delimited. Does not implicitly {@link kritor.message.ReactMessageWithEmojiResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.ReactMessageWithEmojiResponse
             * @static
             * @param {kritor.message.IReactMessageWithEmojiResponse} message ReactMessageWithEmojiResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ReactMessageWithEmojiResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ReactMessageWithEmojiResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.ReactMessageWithEmojiResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.ReactMessageWithEmojiResponse} ReactMessageWithEmojiResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReactMessageWithEmojiResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.ReactMessageWithEmojiResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ReactMessageWithEmojiResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.ReactMessageWithEmojiResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.ReactMessageWithEmojiResponse} ReactMessageWithEmojiResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ReactMessageWithEmojiResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ReactMessageWithEmojiResponse message.
             * @function verify
             * @memberof kritor.message.ReactMessageWithEmojiResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ReactMessageWithEmojiResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a ReactMessageWithEmojiResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.ReactMessageWithEmojiResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.ReactMessageWithEmojiResponse} ReactMessageWithEmojiResponse
             */
            ReactMessageWithEmojiResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.ReactMessageWithEmojiResponse)
                    return object;
                return new $root.kritor.message.ReactMessageWithEmojiResponse();
            };

            /**
             * Creates a plain object from a ReactMessageWithEmojiResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.ReactMessageWithEmojiResponse
             * @static
             * @param {kritor.message.ReactMessageWithEmojiResponse} message ReactMessageWithEmojiResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ReactMessageWithEmojiResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this ReactMessageWithEmojiResponse to JSON.
             * @function toJSON
             * @memberof kritor.message.ReactMessageWithEmojiResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ReactMessageWithEmojiResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for ReactMessageWithEmojiResponse
             * @function getTypeUrl
             * @memberof kritor.message.ReactMessageWithEmojiResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            ReactMessageWithEmojiResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.ReactMessageWithEmojiResponse";
            };

            return ReactMessageWithEmojiResponse;
        })();

        message.GetMessageRequest = (function() {

            /**
             * Properties of a GetMessageRequest.
             * @memberof kritor.message
             * @interface IGetMessageRequest
             * @property {kritor.common.IContact|null} [contact] GetMessageRequest contact
             * @property {string|null} [messageId] GetMessageRequest messageId
             */

            /**
             * Constructs a new GetMessageRequest.
             * @memberof kritor.message
             * @classdesc Represents a GetMessageRequest.
             * @implements IGetMessageRequest
             * @constructor
             * @param {kritor.message.IGetMessageRequest=} [properties] Properties to set
             */
            function GetMessageRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetMessageRequest contact.
             * @member {kritor.common.IContact|null|undefined} contact
             * @memberof kritor.message.GetMessageRequest
             * @instance
             */
            GetMessageRequest.prototype.contact = null;

            /**
             * GetMessageRequest messageId.
             * @member {string} messageId
             * @memberof kritor.message.GetMessageRequest
             * @instance
             */
            GetMessageRequest.prototype.messageId = "";

            /**
             * Creates a new GetMessageRequest instance using the specified properties.
             * @function create
             * @memberof kritor.message.GetMessageRequest
             * @static
             * @param {kritor.message.IGetMessageRequest=} [properties] Properties to set
             * @returns {kritor.message.GetMessageRequest} GetMessageRequest instance
             */
            GetMessageRequest.create = function create(properties) {
                return new GetMessageRequest(properties);
            };

            /**
             * Encodes the specified GetMessageRequest message. Does not implicitly {@link kritor.message.GetMessageRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.GetMessageRequest
             * @static
             * @param {kritor.message.IGetMessageRequest} message GetMessageRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetMessageRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.contact != null && Object.hasOwnProperty.call(message, "contact"))
                    $root.kritor.common.Contact.encode(message.contact, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.messageId != null && Object.hasOwnProperty.call(message, "messageId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.messageId);
                return writer;
            };

            /**
             * Encodes the specified GetMessageRequest message, length delimited. Does not implicitly {@link kritor.message.GetMessageRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.GetMessageRequest
             * @static
             * @param {kritor.message.IGetMessageRequest} message GetMessageRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetMessageRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetMessageRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.GetMessageRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.GetMessageRequest} GetMessageRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetMessageRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.GetMessageRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.contact = $root.kritor.common.Contact.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.messageId = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetMessageRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.GetMessageRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.GetMessageRequest} GetMessageRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetMessageRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetMessageRequest message.
             * @function verify
             * @memberof kritor.message.GetMessageRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetMessageRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.contact != null && message.hasOwnProperty("contact")) {
                    let error = $root.kritor.common.Contact.verify(message.contact);
                    if (error)
                        return "contact." + error;
                }
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    if (!$util.isString(message.messageId))
                        return "messageId: string expected";
                return null;
            };

            /**
             * Creates a GetMessageRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.GetMessageRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.GetMessageRequest} GetMessageRequest
             */
            GetMessageRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.GetMessageRequest)
                    return object;
                let message = new $root.kritor.message.GetMessageRequest();
                if (object.contact != null) {
                    if (typeof object.contact !== "object")
                        throw TypeError(".kritor.message.GetMessageRequest.contact: object expected");
                    message.contact = $root.kritor.common.Contact.fromObject(object.contact);
                }
                if (object.messageId != null)
                    message.messageId = String(object.messageId);
                return message;
            };

            /**
             * Creates a plain object from a GetMessageRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.GetMessageRequest
             * @static
             * @param {kritor.message.GetMessageRequest} message GetMessageRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetMessageRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.contact = null;
                    object.messageId = "";
                }
                if (message.contact != null && message.hasOwnProperty("contact"))
                    object.contact = $root.kritor.common.Contact.toObject(message.contact, options);
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    object.messageId = message.messageId;
                return object;
            };

            /**
             * Converts this GetMessageRequest to JSON.
             * @function toJSON
             * @memberof kritor.message.GetMessageRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetMessageRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetMessageRequest
             * @function getTypeUrl
             * @memberof kritor.message.GetMessageRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetMessageRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.GetMessageRequest";
            };

            return GetMessageRequest;
        })();

        message.GetMessageResponse = (function() {

            /**
             * Properties of a GetMessageResponse.
             * @memberof kritor.message
             * @interface IGetMessageResponse
             * @property {kritor.common.IPushMessageBody|null} [message] GetMessageResponse message
             */

            /**
             * Constructs a new GetMessageResponse.
             * @memberof kritor.message
             * @classdesc Represents a GetMessageResponse.
             * @implements IGetMessageResponse
             * @constructor
             * @param {kritor.message.IGetMessageResponse=} [properties] Properties to set
             */
            function GetMessageResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetMessageResponse message.
             * @member {kritor.common.IPushMessageBody|null|undefined} message
             * @memberof kritor.message.GetMessageResponse
             * @instance
             */
            GetMessageResponse.prototype.message = null;

            /**
             * Creates a new GetMessageResponse instance using the specified properties.
             * @function create
             * @memberof kritor.message.GetMessageResponse
             * @static
             * @param {kritor.message.IGetMessageResponse=} [properties] Properties to set
             * @returns {kritor.message.GetMessageResponse} GetMessageResponse instance
             */
            GetMessageResponse.create = function create(properties) {
                return new GetMessageResponse(properties);
            };

            /**
             * Encodes the specified GetMessageResponse message. Does not implicitly {@link kritor.message.GetMessageResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.GetMessageResponse
             * @static
             * @param {kritor.message.IGetMessageResponse} message GetMessageResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetMessageResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                    $root.kritor.common.PushMessageBody.encode(message.message, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetMessageResponse message, length delimited. Does not implicitly {@link kritor.message.GetMessageResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.GetMessageResponse
             * @static
             * @param {kritor.message.IGetMessageResponse} message GetMessageResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetMessageResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetMessageResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.GetMessageResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.GetMessageResponse} GetMessageResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetMessageResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.GetMessageResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.message = $root.kritor.common.PushMessageBody.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetMessageResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.GetMessageResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.GetMessageResponse} GetMessageResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetMessageResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetMessageResponse message.
             * @function verify
             * @memberof kritor.message.GetMessageResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetMessageResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.message != null && message.hasOwnProperty("message")) {
                    let error = $root.kritor.common.PushMessageBody.verify(message.message);
                    if (error)
                        return "message." + error;
                }
                return null;
            };

            /**
             * Creates a GetMessageResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.GetMessageResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.GetMessageResponse} GetMessageResponse
             */
            GetMessageResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.GetMessageResponse)
                    return object;
                let message = new $root.kritor.message.GetMessageResponse();
                if (object.message != null) {
                    if (typeof object.message !== "object")
                        throw TypeError(".kritor.message.GetMessageResponse.message: object expected");
                    message.message = $root.kritor.common.PushMessageBody.fromObject(object.message);
                }
                return message;
            };

            /**
             * Creates a plain object from a GetMessageResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.GetMessageResponse
             * @static
             * @param {kritor.message.GetMessageResponse} message GetMessageResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetMessageResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.message = null;
                if (message.message != null && message.hasOwnProperty("message"))
                    object.message = $root.kritor.common.PushMessageBody.toObject(message.message, options);
                return object;
            };

            /**
             * Converts this GetMessageResponse to JSON.
             * @function toJSON
             * @memberof kritor.message.GetMessageResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetMessageResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetMessageResponse
             * @function getTypeUrl
             * @memberof kritor.message.GetMessageResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetMessageResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.GetMessageResponse";
            };

            return GetMessageResponse;
        })();

        message.GetMessageBySeqRequest = (function() {

            /**
             * Properties of a GetMessageBySeqRequest.
             * @memberof kritor.message
             * @interface IGetMessageBySeqRequest
             * @property {kritor.common.IContact|null} [contact] GetMessageBySeqRequest contact
             * @property {number|Long|null} [messageSeq] GetMessageBySeqRequest messageSeq
             */

            /**
             * Constructs a new GetMessageBySeqRequest.
             * @memberof kritor.message
             * @classdesc Represents a GetMessageBySeqRequest.
             * @implements IGetMessageBySeqRequest
             * @constructor
             * @param {kritor.message.IGetMessageBySeqRequest=} [properties] Properties to set
             */
            function GetMessageBySeqRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetMessageBySeqRequest contact.
             * @member {kritor.common.IContact|null|undefined} contact
             * @memberof kritor.message.GetMessageBySeqRequest
             * @instance
             */
            GetMessageBySeqRequest.prototype.contact = null;

            /**
             * GetMessageBySeqRequest messageSeq.
             * @member {number|Long} messageSeq
             * @memberof kritor.message.GetMessageBySeqRequest
             * @instance
             */
            GetMessageBySeqRequest.prototype.messageSeq = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new GetMessageBySeqRequest instance using the specified properties.
             * @function create
             * @memberof kritor.message.GetMessageBySeqRequest
             * @static
             * @param {kritor.message.IGetMessageBySeqRequest=} [properties] Properties to set
             * @returns {kritor.message.GetMessageBySeqRequest} GetMessageBySeqRequest instance
             */
            GetMessageBySeqRequest.create = function create(properties) {
                return new GetMessageBySeqRequest(properties);
            };

            /**
             * Encodes the specified GetMessageBySeqRequest message. Does not implicitly {@link kritor.message.GetMessageBySeqRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.GetMessageBySeqRequest
             * @static
             * @param {kritor.message.IGetMessageBySeqRequest} message GetMessageBySeqRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetMessageBySeqRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.contact != null && Object.hasOwnProperty.call(message, "contact"))
                    $root.kritor.common.Contact.encode(message.contact, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.messageSeq != null && Object.hasOwnProperty.call(message, "messageSeq"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.messageSeq);
                return writer;
            };

            /**
             * Encodes the specified GetMessageBySeqRequest message, length delimited. Does not implicitly {@link kritor.message.GetMessageBySeqRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.GetMessageBySeqRequest
             * @static
             * @param {kritor.message.IGetMessageBySeqRequest} message GetMessageBySeqRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetMessageBySeqRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetMessageBySeqRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.GetMessageBySeqRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.GetMessageBySeqRequest} GetMessageBySeqRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetMessageBySeqRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.GetMessageBySeqRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.contact = $root.kritor.common.Contact.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.messageSeq = reader.uint64();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetMessageBySeqRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.GetMessageBySeqRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.GetMessageBySeqRequest} GetMessageBySeqRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetMessageBySeqRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetMessageBySeqRequest message.
             * @function verify
             * @memberof kritor.message.GetMessageBySeqRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetMessageBySeqRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.contact != null && message.hasOwnProperty("contact")) {
                    let error = $root.kritor.common.Contact.verify(message.contact);
                    if (error)
                        return "contact." + error;
                }
                if (message.messageSeq != null && message.hasOwnProperty("messageSeq"))
                    if (!$util.isInteger(message.messageSeq) && !(message.messageSeq && $util.isInteger(message.messageSeq.low) && $util.isInteger(message.messageSeq.high)))
                        return "messageSeq: integer|Long expected";
                return null;
            };

            /**
             * Creates a GetMessageBySeqRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.GetMessageBySeqRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.GetMessageBySeqRequest} GetMessageBySeqRequest
             */
            GetMessageBySeqRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.GetMessageBySeqRequest)
                    return object;
                let message = new $root.kritor.message.GetMessageBySeqRequest();
                if (object.contact != null) {
                    if (typeof object.contact !== "object")
                        throw TypeError(".kritor.message.GetMessageBySeqRequest.contact: object expected");
                    message.contact = $root.kritor.common.Contact.fromObject(object.contact);
                }
                if (object.messageSeq != null)
                    if ($util.Long)
                        (message.messageSeq = $util.Long.fromValue(object.messageSeq)).unsigned = true;
                    else if (typeof object.messageSeq === "string")
                        message.messageSeq = parseInt(object.messageSeq, 10);
                    else if (typeof object.messageSeq === "number")
                        message.messageSeq = object.messageSeq;
                    else if (typeof object.messageSeq === "object")
                        message.messageSeq = new $util.LongBits(object.messageSeq.low >>> 0, object.messageSeq.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a GetMessageBySeqRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.GetMessageBySeqRequest
             * @static
             * @param {kritor.message.GetMessageBySeqRequest} message GetMessageBySeqRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetMessageBySeqRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.contact = null;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.messageSeq = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.messageSeq = options.longs === String ? "0" : 0;
                }
                if (message.contact != null && message.hasOwnProperty("contact"))
                    object.contact = $root.kritor.common.Contact.toObject(message.contact, options);
                if (message.messageSeq != null && message.hasOwnProperty("messageSeq"))
                    if (typeof message.messageSeq === "number")
                        object.messageSeq = options.longs === String ? String(message.messageSeq) : message.messageSeq;
                    else
                        object.messageSeq = options.longs === String ? $util.Long.prototype.toString.call(message.messageSeq) : options.longs === Number ? new $util.LongBits(message.messageSeq.low >>> 0, message.messageSeq.high >>> 0).toNumber(true) : message.messageSeq;
                return object;
            };

            /**
             * Converts this GetMessageBySeqRequest to JSON.
             * @function toJSON
             * @memberof kritor.message.GetMessageBySeqRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetMessageBySeqRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetMessageBySeqRequest
             * @function getTypeUrl
             * @memberof kritor.message.GetMessageBySeqRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetMessageBySeqRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.GetMessageBySeqRequest";
            };

            return GetMessageBySeqRequest;
        })();

        message.GetMessageBySeqResponse = (function() {

            /**
             * Properties of a GetMessageBySeqResponse.
             * @memberof kritor.message
             * @interface IGetMessageBySeqResponse
             * @property {kritor.common.IPushMessageBody|null} [message] GetMessageBySeqResponse message
             */

            /**
             * Constructs a new GetMessageBySeqResponse.
             * @memberof kritor.message
             * @classdesc Represents a GetMessageBySeqResponse.
             * @implements IGetMessageBySeqResponse
             * @constructor
             * @param {kritor.message.IGetMessageBySeqResponse=} [properties] Properties to set
             */
            function GetMessageBySeqResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetMessageBySeqResponse message.
             * @member {kritor.common.IPushMessageBody|null|undefined} message
             * @memberof kritor.message.GetMessageBySeqResponse
             * @instance
             */
            GetMessageBySeqResponse.prototype.message = null;

            /**
             * Creates a new GetMessageBySeqResponse instance using the specified properties.
             * @function create
             * @memberof kritor.message.GetMessageBySeqResponse
             * @static
             * @param {kritor.message.IGetMessageBySeqResponse=} [properties] Properties to set
             * @returns {kritor.message.GetMessageBySeqResponse} GetMessageBySeqResponse instance
             */
            GetMessageBySeqResponse.create = function create(properties) {
                return new GetMessageBySeqResponse(properties);
            };

            /**
             * Encodes the specified GetMessageBySeqResponse message. Does not implicitly {@link kritor.message.GetMessageBySeqResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.GetMessageBySeqResponse
             * @static
             * @param {kritor.message.IGetMessageBySeqResponse} message GetMessageBySeqResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetMessageBySeqResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                    $root.kritor.common.PushMessageBody.encode(message.message, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetMessageBySeqResponse message, length delimited. Does not implicitly {@link kritor.message.GetMessageBySeqResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.GetMessageBySeqResponse
             * @static
             * @param {kritor.message.IGetMessageBySeqResponse} message GetMessageBySeqResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetMessageBySeqResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetMessageBySeqResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.GetMessageBySeqResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.GetMessageBySeqResponse} GetMessageBySeqResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetMessageBySeqResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.GetMessageBySeqResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.message = $root.kritor.common.PushMessageBody.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetMessageBySeqResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.GetMessageBySeqResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.GetMessageBySeqResponse} GetMessageBySeqResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetMessageBySeqResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetMessageBySeqResponse message.
             * @function verify
             * @memberof kritor.message.GetMessageBySeqResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetMessageBySeqResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.message != null && message.hasOwnProperty("message")) {
                    let error = $root.kritor.common.PushMessageBody.verify(message.message);
                    if (error)
                        return "message." + error;
                }
                return null;
            };

            /**
             * Creates a GetMessageBySeqResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.GetMessageBySeqResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.GetMessageBySeqResponse} GetMessageBySeqResponse
             */
            GetMessageBySeqResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.GetMessageBySeqResponse)
                    return object;
                let message = new $root.kritor.message.GetMessageBySeqResponse();
                if (object.message != null) {
                    if (typeof object.message !== "object")
                        throw TypeError(".kritor.message.GetMessageBySeqResponse.message: object expected");
                    message.message = $root.kritor.common.PushMessageBody.fromObject(object.message);
                }
                return message;
            };

            /**
             * Creates a plain object from a GetMessageBySeqResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.GetMessageBySeqResponse
             * @static
             * @param {kritor.message.GetMessageBySeqResponse} message GetMessageBySeqResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetMessageBySeqResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.message = null;
                if (message.message != null && message.hasOwnProperty("message"))
                    object.message = $root.kritor.common.PushMessageBody.toObject(message.message, options);
                return object;
            };

            /**
             * Converts this GetMessageBySeqResponse to JSON.
             * @function toJSON
             * @memberof kritor.message.GetMessageBySeqResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetMessageBySeqResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetMessageBySeqResponse
             * @function getTypeUrl
             * @memberof kritor.message.GetMessageBySeqResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetMessageBySeqResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.GetMessageBySeqResponse";
            };

            return GetMessageBySeqResponse;
        })();

        message.GetHistoryMessageRequest = (function() {

            /**
             * Properties of a GetHistoryMessageRequest.
             * @memberof kritor.message
             * @interface IGetHistoryMessageRequest
             * @property {kritor.common.IContact|null} [contact] GetHistoryMessageRequest contact
             * @property {string|null} [startMessageId] GetHistoryMessageRequest startMessageId
             * @property {number|null} [count] GetHistoryMessageRequest count
             */

            /**
             * Constructs a new GetHistoryMessageRequest.
             * @memberof kritor.message
             * @classdesc Represents a GetHistoryMessageRequest.
             * @implements IGetHistoryMessageRequest
             * @constructor
             * @param {kritor.message.IGetHistoryMessageRequest=} [properties] Properties to set
             */
            function GetHistoryMessageRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetHistoryMessageRequest contact.
             * @member {kritor.common.IContact|null|undefined} contact
             * @memberof kritor.message.GetHistoryMessageRequest
             * @instance
             */
            GetHistoryMessageRequest.prototype.contact = null;

            /**
             * GetHistoryMessageRequest startMessageId.
             * @member {string|null|undefined} startMessageId
             * @memberof kritor.message.GetHistoryMessageRequest
             * @instance
             */
            GetHistoryMessageRequest.prototype.startMessageId = null;

            /**
             * GetHistoryMessageRequest count.
             * @member {number|null|undefined} count
             * @memberof kritor.message.GetHistoryMessageRequest
             * @instance
             */
            GetHistoryMessageRequest.prototype.count = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * GetHistoryMessageRequest _startMessageId.
             * @member {"startMessageId"|undefined} _startMessageId
             * @memberof kritor.message.GetHistoryMessageRequest
             * @instance
             */
            Object.defineProperty(GetHistoryMessageRequest.prototype, "_startMessageId", {
                get: $util.oneOfGetter($oneOfFields = ["startMessageId"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * GetHistoryMessageRequest _count.
             * @member {"count"|undefined} _count
             * @memberof kritor.message.GetHistoryMessageRequest
             * @instance
             */
            Object.defineProperty(GetHistoryMessageRequest.prototype, "_count", {
                get: $util.oneOfGetter($oneOfFields = ["count"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new GetHistoryMessageRequest instance using the specified properties.
             * @function create
             * @memberof kritor.message.GetHistoryMessageRequest
             * @static
             * @param {kritor.message.IGetHistoryMessageRequest=} [properties] Properties to set
             * @returns {kritor.message.GetHistoryMessageRequest} GetHistoryMessageRequest instance
             */
            GetHistoryMessageRequest.create = function create(properties) {
                return new GetHistoryMessageRequest(properties);
            };

            /**
             * Encodes the specified GetHistoryMessageRequest message. Does not implicitly {@link kritor.message.GetHistoryMessageRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.GetHistoryMessageRequest
             * @static
             * @param {kritor.message.IGetHistoryMessageRequest} message GetHistoryMessageRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetHistoryMessageRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.contact != null && Object.hasOwnProperty.call(message, "contact"))
                    $root.kritor.common.Contact.encode(message.contact, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.startMessageId != null && Object.hasOwnProperty.call(message, "startMessageId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.startMessageId);
                if (message.count != null && Object.hasOwnProperty.call(message, "count"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.count);
                return writer;
            };

            /**
             * Encodes the specified GetHistoryMessageRequest message, length delimited. Does not implicitly {@link kritor.message.GetHistoryMessageRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.GetHistoryMessageRequest
             * @static
             * @param {kritor.message.IGetHistoryMessageRequest} message GetHistoryMessageRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetHistoryMessageRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetHistoryMessageRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.GetHistoryMessageRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.GetHistoryMessageRequest} GetHistoryMessageRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetHistoryMessageRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.GetHistoryMessageRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.contact = $root.kritor.common.Contact.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.startMessageId = reader.string();
                            break;
                        }
                    case 3: {
                            message.count = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetHistoryMessageRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.GetHistoryMessageRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.GetHistoryMessageRequest} GetHistoryMessageRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetHistoryMessageRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetHistoryMessageRequest message.
             * @function verify
             * @memberof kritor.message.GetHistoryMessageRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetHistoryMessageRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.contact != null && message.hasOwnProperty("contact")) {
                    let error = $root.kritor.common.Contact.verify(message.contact);
                    if (error)
                        return "contact." + error;
                }
                if (message.startMessageId != null && message.hasOwnProperty("startMessageId")) {
                    properties._startMessageId = 1;
                    if (!$util.isString(message.startMessageId))
                        return "startMessageId: string expected";
                }
                if (message.count != null && message.hasOwnProperty("count")) {
                    properties._count = 1;
                    if (!$util.isInteger(message.count))
                        return "count: integer expected";
                }
                return null;
            };

            /**
             * Creates a GetHistoryMessageRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.GetHistoryMessageRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.GetHistoryMessageRequest} GetHistoryMessageRequest
             */
            GetHistoryMessageRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.GetHistoryMessageRequest)
                    return object;
                let message = new $root.kritor.message.GetHistoryMessageRequest();
                if (object.contact != null) {
                    if (typeof object.contact !== "object")
                        throw TypeError(".kritor.message.GetHistoryMessageRequest.contact: object expected");
                    message.contact = $root.kritor.common.Contact.fromObject(object.contact);
                }
                if (object.startMessageId != null)
                    message.startMessageId = String(object.startMessageId);
                if (object.count != null)
                    message.count = object.count >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a GetHistoryMessageRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.GetHistoryMessageRequest
             * @static
             * @param {kritor.message.GetHistoryMessageRequest} message GetHistoryMessageRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetHistoryMessageRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.contact = null;
                if (message.contact != null && message.hasOwnProperty("contact"))
                    object.contact = $root.kritor.common.Contact.toObject(message.contact, options);
                if (message.startMessageId != null && message.hasOwnProperty("startMessageId")) {
                    object.startMessageId = message.startMessageId;
                    if (options.oneofs)
                        object._startMessageId = "startMessageId";
                }
                if (message.count != null && message.hasOwnProperty("count")) {
                    object.count = message.count;
                    if (options.oneofs)
                        object._count = "count";
                }
                return object;
            };

            /**
             * Converts this GetHistoryMessageRequest to JSON.
             * @function toJSON
             * @memberof kritor.message.GetHistoryMessageRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetHistoryMessageRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetHistoryMessageRequest
             * @function getTypeUrl
             * @memberof kritor.message.GetHistoryMessageRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetHistoryMessageRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.GetHistoryMessageRequest";
            };

            return GetHistoryMessageRequest;
        })();

        message.GetHistoryMessageResponse = (function() {

            /**
             * Properties of a GetHistoryMessageResponse.
             * @memberof kritor.message
             * @interface IGetHistoryMessageResponse
             * @property {Array.<kritor.common.IPushMessageBody>|null} [messages] GetHistoryMessageResponse messages
             */

            /**
             * Constructs a new GetHistoryMessageResponse.
             * @memberof kritor.message
             * @classdesc Represents a GetHistoryMessageResponse.
             * @implements IGetHistoryMessageResponse
             * @constructor
             * @param {kritor.message.IGetHistoryMessageResponse=} [properties] Properties to set
             */
            function GetHistoryMessageResponse(properties) {
                this.messages = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetHistoryMessageResponse messages.
             * @member {Array.<kritor.common.IPushMessageBody>} messages
             * @memberof kritor.message.GetHistoryMessageResponse
             * @instance
             */
            GetHistoryMessageResponse.prototype.messages = $util.emptyArray;

            /**
             * Creates a new GetHistoryMessageResponse instance using the specified properties.
             * @function create
             * @memberof kritor.message.GetHistoryMessageResponse
             * @static
             * @param {kritor.message.IGetHistoryMessageResponse=} [properties] Properties to set
             * @returns {kritor.message.GetHistoryMessageResponse} GetHistoryMessageResponse instance
             */
            GetHistoryMessageResponse.create = function create(properties) {
                return new GetHistoryMessageResponse(properties);
            };

            /**
             * Encodes the specified GetHistoryMessageResponse message. Does not implicitly {@link kritor.message.GetHistoryMessageResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.GetHistoryMessageResponse
             * @static
             * @param {kritor.message.IGetHistoryMessageResponse} message GetHistoryMessageResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetHistoryMessageResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.messages != null && message.messages.length)
                    for (let i = 0; i < message.messages.length; ++i)
                        $root.kritor.common.PushMessageBody.encode(message.messages[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetHistoryMessageResponse message, length delimited. Does not implicitly {@link kritor.message.GetHistoryMessageResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.GetHistoryMessageResponse
             * @static
             * @param {kritor.message.IGetHistoryMessageResponse} message GetHistoryMessageResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetHistoryMessageResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetHistoryMessageResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.GetHistoryMessageResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.GetHistoryMessageResponse} GetHistoryMessageResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetHistoryMessageResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.GetHistoryMessageResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.messages && message.messages.length))
                                message.messages = [];
                            message.messages.push($root.kritor.common.PushMessageBody.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetHistoryMessageResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.GetHistoryMessageResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.GetHistoryMessageResponse} GetHistoryMessageResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetHistoryMessageResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetHistoryMessageResponse message.
             * @function verify
             * @memberof kritor.message.GetHistoryMessageResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetHistoryMessageResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.messages != null && message.hasOwnProperty("messages")) {
                    if (!Array.isArray(message.messages))
                        return "messages: array expected";
                    for (let i = 0; i < message.messages.length; ++i) {
                        let error = $root.kritor.common.PushMessageBody.verify(message.messages[i]);
                        if (error)
                            return "messages." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a GetHistoryMessageResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.GetHistoryMessageResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.GetHistoryMessageResponse} GetHistoryMessageResponse
             */
            GetHistoryMessageResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.GetHistoryMessageResponse)
                    return object;
                let message = new $root.kritor.message.GetHistoryMessageResponse();
                if (object.messages) {
                    if (!Array.isArray(object.messages))
                        throw TypeError(".kritor.message.GetHistoryMessageResponse.messages: array expected");
                    message.messages = [];
                    for (let i = 0; i < object.messages.length; ++i) {
                        if (typeof object.messages[i] !== "object")
                            throw TypeError(".kritor.message.GetHistoryMessageResponse.messages: object expected");
                        message.messages[i] = $root.kritor.common.PushMessageBody.fromObject(object.messages[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a GetHistoryMessageResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.GetHistoryMessageResponse
             * @static
             * @param {kritor.message.GetHistoryMessageResponse} message GetHistoryMessageResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetHistoryMessageResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.messages = [];
                if (message.messages && message.messages.length) {
                    object.messages = [];
                    for (let j = 0; j < message.messages.length; ++j)
                        object.messages[j] = $root.kritor.common.PushMessageBody.toObject(message.messages[j], options);
                }
                return object;
            };

            /**
             * Converts this GetHistoryMessageResponse to JSON.
             * @function toJSON
             * @memberof kritor.message.GetHistoryMessageResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetHistoryMessageResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetHistoryMessageResponse
             * @function getTypeUrl
             * @memberof kritor.message.GetHistoryMessageResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetHistoryMessageResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.GetHistoryMessageResponse";
            };

            return GetHistoryMessageResponse;
        })();

        message.GetHistoryMessageBySeqRequest = (function() {

            /**
             * Properties of a GetHistoryMessageBySeqRequest.
             * @memberof kritor.message
             * @interface IGetHistoryMessageBySeqRequest
             * @property {kritor.common.IContact|null} [contact] GetHistoryMessageBySeqRequest contact
             * @property {number|Long|null} [startMessageSeq] GetHistoryMessageBySeqRequest startMessageSeq
             * @property {number|null} [count] GetHistoryMessageBySeqRequest count
             */

            /**
             * Constructs a new GetHistoryMessageBySeqRequest.
             * @memberof kritor.message
             * @classdesc Represents a GetHistoryMessageBySeqRequest.
             * @implements IGetHistoryMessageBySeqRequest
             * @constructor
             * @param {kritor.message.IGetHistoryMessageBySeqRequest=} [properties] Properties to set
             */
            function GetHistoryMessageBySeqRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetHistoryMessageBySeqRequest contact.
             * @member {kritor.common.IContact|null|undefined} contact
             * @memberof kritor.message.GetHistoryMessageBySeqRequest
             * @instance
             */
            GetHistoryMessageBySeqRequest.prototype.contact = null;

            /**
             * GetHistoryMessageBySeqRequest startMessageSeq.
             * @member {number|Long|null|undefined} startMessageSeq
             * @memberof kritor.message.GetHistoryMessageBySeqRequest
             * @instance
             */
            GetHistoryMessageBySeqRequest.prototype.startMessageSeq = null;

            /**
             * GetHistoryMessageBySeqRequest count.
             * @member {number|null|undefined} count
             * @memberof kritor.message.GetHistoryMessageBySeqRequest
             * @instance
             */
            GetHistoryMessageBySeqRequest.prototype.count = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * GetHistoryMessageBySeqRequest _startMessageSeq.
             * @member {"startMessageSeq"|undefined} _startMessageSeq
             * @memberof kritor.message.GetHistoryMessageBySeqRequest
             * @instance
             */
            Object.defineProperty(GetHistoryMessageBySeqRequest.prototype, "_startMessageSeq", {
                get: $util.oneOfGetter($oneOfFields = ["startMessageSeq"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * GetHistoryMessageBySeqRequest _count.
             * @member {"count"|undefined} _count
             * @memberof kritor.message.GetHistoryMessageBySeqRequest
             * @instance
             */
            Object.defineProperty(GetHistoryMessageBySeqRequest.prototype, "_count", {
                get: $util.oneOfGetter($oneOfFields = ["count"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new GetHistoryMessageBySeqRequest instance using the specified properties.
             * @function create
             * @memberof kritor.message.GetHistoryMessageBySeqRequest
             * @static
             * @param {kritor.message.IGetHistoryMessageBySeqRequest=} [properties] Properties to set
             * @returns {kritor.message.GetHistoryMessageBySeqRequest} GetHistoryMessageBySeqRequest instance
             */
            GetHistoryMessageBySeqRequest.create = function create(properties) {
                return new GetHistoryMessageBySeqRequest(properties);
            };

            /**
             * Encodes the specified GetHistoryMessageBySeqRequest message. Does not implicitly {@link kritor.message.GetHistoryMessageBySeqRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.GetHistoryMessageBySeqRequest
             * @static
             * @param {kritor.message.IGetHistoryMessageBySeqRequest} message GetHistoryMessageBySeqRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetHistoryMessageBySeqRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.contact != null && Object.hasOwnProperty.call(message, "contact"))
                    $root.kritor.common.Contact.encode(message.contact, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.startMessageSeq != null && Object.hasOwnProperty.call(message, "startMessageSeq"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.startMessageSeq);
                if (message.count != null && Object.hasOwnProperty.call(message, "count"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.count);
                return writer;
            };

            /**
             * Encodes the specified GetHistoryMessageBySeqRequest message, length delimited. Does not implicitly {@link kritor.message.GetHistoryMessageBySeqRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.GetHistoryMessageBySeqRequest
             * @static
             * @param {kritor.message.IGetHistoryMessageBySeqRequest} message GetHistoryMessageBySeqRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetHistoryMessageBySeqRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetHistoryMessageBySeqRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.GetHistoryMessageBySeqRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.GetHistoryMessageBySeqRequest} GetHistoryMessageBySeqRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetHistoryMessageBySeqRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.GetHistoryMessageBySeqRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.contact = $root.kritor.common.Contact.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.startMessageSeq = reader.uint64();
                            break;
                        }
                    case 3: {
                            message.count = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetHistoryMessageBySeqRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.GetHistoryMessageBySeqRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.GetHistoryMessageBySeqRequest} GetHistoryMessageBySeqRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetHistoryMessageBySeqRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetHistoryMessageBySeqRequest message.
             * @function verify
             * @memberof kritor.message.GetHistoryMessageBySeqRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetHistoryMessageBySeqRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.contact != null && message.hasOwnProperty("contact")) {
                    let error = $root.kritor.common.Contact.verify(message.contact);
                    if (error)
                        return "contact." + error;
                }
                if (message.startMessageSeq != null && message.hasOwnProperty("startMessageSeq")) {
                    properties._startMessageSeq = 1;
                    if (!$util.isInteger(message.startMessageSeq) && !(message.startMessageSeq && $util.isInteger(message.startMessageSeq.low) && $util.isInteger(message.startMessageSeq.high)))
                        return "startMessageSeq: integer|Long expected";
                }
                if (message.count != null && message.hasOwnProperty("count")) {
                    properties._count = 1;
                    if (!$util.isInteger(message.count))
                        return "count: integer expected";
                }
                return null;
            };

            /**
             * Creates a GetHistoryMessageBySeqRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.GetHistoryMessageBySeqRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.GetHistoryMessageBySeqRequest} GetHistoryMessageBySeqRequest
             */
            GetHistoryMessageBySeqRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.GetHistoryMessageBySeqRequest)
                    return object;
                let message = new $root.kritor.message.GetHistoryMessageBySeqRequest();
                if (object.contact != null) {
                    if (typeof object.contact !== "object")
                        throw TypeError(".kritor.message.GetHistoryMessageBySeqRequest.contact: object expected");
                    message.contact = $root.kritor.common.Contact.fromObject(object.contact);
                }
                if (object.startMessageSeq != null)
                    if ($util.Long)
                        (message.startMessageSeq = $util.Long.fromValue(object.startMessageSeq)).unsigned = true;
                    else if (typeof object.startMessageSeq === "string")
                        message.startMessageSeq = parseInt(object.startMessageSeq, 10);
                    else if (typeof object.startMessageSeq === "number")
                        message.startMessageSeq = object.startMessageSeq;
                    else if (typeof object.startMessageSeq === "object")
                        message.startMessageSeq = new $util.LongBits(object.startMessageSeq.low >>> 0, object.startMessageSeq.high >>> 0).toNumber(true);
                if (object.count != null)
                    message.count = object.count >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a GetHistoryMessageBySeqRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.GetHistoryMessageBySeqRequest
             * @static
             * @param {kritor.message.GetHistoryMessageBySeqRequest} message GetHistoryMessageBySeqRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetHistoryMessageBySeqRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.contact = null;
                if (message.contact != null && message.hasOwnProperty("contact"))
                    object.contact = $root.kritor.common.Contact.toObject(message.contact, options);
                if (message.startMessageSeq != null && message.hasOwnProperty("startMessageSeq")) {
                    if (typeof message.startMessageSeq === "number")
                        object.startMessageSeq = options.longs === String ? String(message.startMessageSeq) : message.startMessageSeq;
                    else
                        object.startMessageSeq = options.longs === String ? $util.Long.prototype.toString.call(message.startMessageSeq) : options.longs === Number ? new $util.LongBits(message.startMessageSeq.low >>> 0, message.startMessageSeq.high >>> 0).toNumber(true) : message.startMessageSeq;
                    if (options.oneofs)
                        object._startMessageSeq = "startMessageSeq";
                }
                if (message.count != null && message.hasOwnProperty("count")) {
                    object.count = message.count;
                    if (options.oneofs)
                        object._count = "count";
                }
                return object;
            };

            /**
             * Converts this GetHistoryMessageBySeqRequest to JSON.
             * @function toJSON
             * @memberof kritor.message.GetHistoryMessageBySeqRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetHistoryMessageBySeqRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetHistoryMessageBySeqRequest
             * @function getTypeUrl
             * @memberof kritor.message.GetHistoryMessageBySeqRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetHistoryMessageBySeqRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.GetHistoryMessageBySeqRequest";
            };

            return GetHistoryMessageBySeqRequest;
        })();

        message.GetHistoryMessageBySeqResponse = (function() {

            /**
             * Properties of a GetHistoryMessageBySeqResponse.
             * @memberof kritor.message
             * @interface IGetHistoryMessageBySeqResponse
             * @property {Array.<kritor.common.IPushMessageBody>|null} [messages] GetHistoryMessageBySeqResponse messages
             */

            /**
             * Constructs a new GetHistoryMessageBySeqResponse.
             * @memberof kritor.message
             * @classdesc Represents a GetHistoryMessageBySeqResponse.
             * @implements IGetHistoryMessageBySeqResponse
             * @constructor
             * @param {kritor.message.IGetHistoryMessageBySeqResponse=} [properties] Properties to set
             */
            function GetHistoryMessageBySeqResponse(properties) {
                this.messages = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetHistoryMessageBySeqResponse messages.
             * @member {Array.<kritor.common.IPushMessageBody>} messages
             * @memberof kritor.message.GetHistoryMessageBySeqResponse
             * @instance
             */
            GetHistoryMessageBySeqResponse.prototype.messages = $util.emptyArray;

            /**
             * Creates a new GetHistoryMessageBySeqResponse instance using the specified properties.
             * @function create
             * @memberof kritor.message.GetHistoryMessageBySeqResponse
             * @static
             * @param {kritor.message.IGetHistoryMessageBySeqResponse=} [properties] Properties to set
             * @returns {kritor.message.GetHistoryMessageBySeqResponse} GetHistoryMessageBySeqResponse instance
             */
            GetHistoryMessageBySeqResponse.create = function create(properties) {
                return new GetHistoryMessageBySeqResponse(properties);
            };

            /**
             * Encodes the specified GetHistoryMessageBySeqResponse message. Does not implicitly {@link kritor.message.GetHistoryMessageBySeqResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.GetHistoryMessageBySeqResponse
             * @static
             * @param {kritor.message.IGetHistoryMessageBySeqResponse} message GetHistoryMessageBySeqResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetHistoryMessageBySeqResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.messages != null && message.messages.length)
                    for (let i = 0; i < message.messages.length; ++i)
                        $root.kritor.common.PushMessageBody.encode(message.messages[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetHistoryMessageBySeqResponse message, length delimited. Does not implicitly {@link kritor.message.GetHistoryMessageBySeqResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.GetHistoryMessageBySeqResponse
             * @static
             * @param {kritor.message.IGetHistoryMessageBySeqResponse} message GetHistoryMessageBySeqResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetHistoryMessageBySeqResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetHistoryMessageBySeqResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.GetHistoryMessageBySeqResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.GetHistoryMessageBySeqResponse} GetHistoryMessageBySeqResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetHistoryMessageBySeqResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.GetHistoryMessageBySeqResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.messages && message.messages.length))
                                message.messages = [];
                            message.messages.push($root.kritor.common.PushMessageBody.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetHistoryMessageBySeqResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.GetHistoryMessageBySeqResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.GetHistoryMessageBySeqResponse} GetHistoryMessageBySeqResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetHistoryMessageBySeqResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetHistoryMessageBySeqResponse message.
             * @function verify
             * @memberof kritor.message.GetHistoryMessageBySeqResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetHistoryMessageBySeqResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.messages != null && message.hasOwnProperty("messages")) {
                    if (!Array.isArray(message.messages))
                        return "messages: array expected";
                    for (let i = 0; i < message.messages.length; ++i) {
                        let error = $root.kritor.common.PushMessageBody.verify(message.messages[i]);
                        if (error)
                            return "messages." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a GetHistoryMessageBySeqResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.GetHistoryMessageBySeqResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.GetHistoryMessageBySeqResponse} GetHistoryMessageBySeqResponse
             */
            GetHistoryMessageBySeqResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.GetHistoryMessageBySeqResponse)
                    return object;
                let message = new $root.kritor.message.GetHistoryMessageBySeqResponse();
                if (object.messages) {
                    if (!Array.isArray(object.messages))
                        throw TypeError(".kritor.message.GetHistoryMessageBySeqResponse.messages: array expected");
                    message.messages = [];
                    for (let i = 0; i < object.messages.length; ++i) {
                        if (typeof object.messages[i] !== "object")
                            throw TypeError(".kritor.message.GetHistoryMessageBySeqResponse.messages: object expected");
                        message.messages[i] = $root.kritor.common.PushMessageBody.fromObject(object.messages[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a GetHistoryMessageBySeqResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.GetHistoryMessageBySeqResponse
             * @static
             * @param {kritor.message.GetHistoryMessageBySeqResponse} message GetHistoryMessageBySeqResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetHistoryMessageBySeqResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.messages = [];
                if (message.messages && message.messages.length) {
                    object.messages = [];
                    for (let j = 0; j < message.messages.length; ++j)
                        object.messages[j] = $root.kritor.common.PushMessageBody.toObject(message.messages[j], options);
                }
                return object;
            };

            /**
             * Converts this GetHistoryMessageBySeqResponse to JSON.
             * @function toJSON
             * @memberof kritor.message.GetHistoryMessageBySeqResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetHistoryMessageBySeqResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetHistoryMessageBySeqResponse
             * @function getTypeUrl
             * @memberof kritor.message.GetHistoryMessageBySeqResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetHistoryMessageBySeqResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.GetHistoryMessageBySeqResponse";
            };

            return GetHistoryMessageBySeqResponse;
        })();

        message.UploadForwardMessageRequest = (function() {

            /**
             * Properties of an UploadForwardMessageRequest.
             * @memberof kritor.message
             * @interface IUploadForwardMessageRequest
             * @property {kritor.common.IContact|null} [contact] UploadForwardMessageRequest contact
             * @property {Array.<kritor.common.IForwardMessageBody>|null} [messages] UploadForwardMessageRequest messages
             * @property {number|null} [retryCount] UploadForwardMessageRequest retryCount
             */

            /**
             * Constructs a new UploadForwardMessageRequest.
             * @memberof kritor.message
             * @classdesc Represents an UploadForwardMessageRequest.
             * @implements IUploadForwardMessageRequest
             * @constructor
             * @param {kritor.message.IUploadForwardMessageRequest=} [properties] Properties to set
             */
            function UploadForwardMessageRequest(properties) {
                this.messages = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * UploadForwardMessageRequest contact.
             * @member {kritor.common.IContact|null|undefined} contact
             * @memberof kritor.message.UploadForwardMessageRequest
             * @instance
             */
            UploadForwardMessageRequest.prototype.contact = null;

            /**
             * UploadForwardMessageRequest messages.
             * @member {Array.<kritor.common.IForwardMessageBody>} messages
             * @memberof kritor.message.UploadForwardMessageRequest
             * @instance
             */
            UploadForwardMessageRequest.prototype.messages = $util.emptyArray;

            /**
             * UploadForwardMessageRequest retryCount.
             * @member {number|null|undefined} retryCount
             * @memberof kritor.message.UploadForwardMessageRequest
             * @instance
             */
            UploadForwardMessageRequest.prototype.retryCount = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * UploadForwardMessageRequest _retryCount.
             * @member {"retryCount"|undefined} _retryCount
             * @memberof kritor.message.UploadForwardMessageRequest
             * @instance
             */
            Object.defineProperty(UploadForwardMessageRequest.prototype, "_retryCount", {
                get: $util.oneOfGetter($oneOfFields = ["retryCount"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new UploadForwardMessageRequest instance using the specified properties.
             * @function create
             * @memberof kritor.message.UploadForwardMessageRequest
             * @static
             * @param {kritor.message.IUploadForwardMessageRequest=} [properties] Properties to set
             * @returns {kritor.message.UploadForwardMessageRequest} UploadForwardMessageRequest instance
             */
            UploadForwardMessageRequest.create = function create(properties) {
                return new UploadForwardMessageRequest(properties);
            };

            /**
             * Encodes the specified UploadForwardMessageRequest message. Does not implicitly {@link kritor.message.UploadForwardMessageRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.UploadForwardMessageRequest
             * @static
             * @param {kritor.message.IUploadForwardMessageRequest} message UploadForwardMessageRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UploadForwardMessageRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.contact != null && Object.hasOwnProperty.call(message, "contact"))
                    $root.kritor.common.Contact.encode(message.contact, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.messages != null && message.messages.length)
                    for (let i = 0; i < message.messages.length; ++i)
                        $root.kritor.common.ForwardMessageBody.encode(message.messages[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.retryCount != null && Object.hasOwnProperty.call(message, "retryCount"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.retryCount);
                return writer;
            };

            /**
             * Encodes the specified UploadForwardMessageRequest message, length delimited. Does not implicitly {@link kritor.message.UploadForwardMessageRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.UploadForwardMessageRequest
             * @static
             * @param {kritor.message.IUploadForwardMessageRequest} message UploadForwardMessageRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UploadForwardMessageRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an UploadForwardMessageRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.UploadForwardMessageRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.UploadForwardMessageRequest} UploadForwardMessageRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UploadForwardMessageRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.UploadForwardMessageRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.contact = $root.kritor.common.Contact.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            if (!(message.messages && message.messages.length))
                                message.messages = [];
                            message.messages.push($root.kritor.common.ForwardMessageBody.decode(reader, reader.uint32()));
                            break;
                        }
                    case 3: {
                            message.retryCount = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an UploadForwardMessageRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.UploadForwardMessageRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.UploadForwardMessageRequest} UploadForwardMessageRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UploadForwardMessageRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an UploadForwardMessageRequest message.
             * @function verify
             * @memberof kritor.message.UploadForwardMessageRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UploadForwardMessageRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.contact != null && message.hasOwnProperty("contact")) {
                    let error = $root.kritor.common.Contact.verify(message.contact);
                    if (error)
                        return "contact." + error;
                }
                if (message.messages != null && message.hasOwnProperty("messages")) {
                    if (!Array.isArray(message.messages))
                        return "messages: array expected";
                    for (let i = 0; i < message.messages.length; ++i) {
                        let error = $root.kritor.common.ForwardMessageBody.verify(message.messages[i]);
                        if (error)
                            return "messages." + error;
                    }
                }
                if (message.retryCount != null && message.hasOwnProperty("retryCount")) {
                    properties._retryCount = 1;
                    if (!$util.isInteger(message.retryCount))
                        return "retryCount: integer expected";
                }
                return null;
            };

            /**
             * Creates an UploadForwardMessageRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.UploadForwardMessageRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.UploadForwardMessageRequest} UploadForwardMessageRequest
             */
            UploadForwardMessageRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.UploadForwardMessageRequest)
                    return object;
                let message = new $root.kritor.message.UploadForwardMessageRequest();
                if (object.contact != null) {
                    if (typeof object.contact !== "object")
                        throw TypeError(".kritor.message.UploadForwardMessageRequest.contact: object expected");
                    message.contact = $root.kritor.common.Contact.fromObject(object.contact);
                }
                if (object.messages) {
                    if (!Array.isArray(object.messages))
                        throw TypeError(".kritor.message.UploadForwardMessageRequest.messages: array expected");
                    message.messages = [];
                    for (let i = 0; i < object.messages.length; ++i) {
                        if (typeof object.messages[i] !== "object")
                            throw TypeError(".kritor.message.UploadForwardMessageRequest.messages: object expected");
                        message.messages[i] = $root.kritor.common.ForwardMessageBody.fromObject(object.messages[i]);
                    }
                }
                if (object.retryCount != null)
                    message.retryCount = object.retryCount >>> 0;
                return message;
            };

            /**
             * Creates a plain object from an UploadForwardMessageRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.UploadForwardMessageRequest
             * @static
             * @param {kritor.message.UploadForwardMessageRequest} message UploadForwardMessageRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UploadForwardMessageRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.messages = [];
                if (options.defaults)
                    object.contact = null;
                if (message.contact != null && message.hasOwnProperty("contact"))
                    object.contact = $root.kritor.common.Contact.toObject(message.contact, options);
                if (message.messages && message.messages.length) {
                    object.messages = [];
                    for (let j = 0; j < message.messages.length; ++j)
                        object.messages[j] = $root.kritor.common.ForwardMessageBody.toObject(message.messages[j], options);
                }
                if (message.retryCount != null && message.hasOwnProperty("retryCount")) {
                    object.retryCount = message.retryCount;
                    if (options.oneofs)
                        object._retryCount = "retryCount";
                }
                return object;
            };

            /**
             * Converts this UploadForwardMessageRequest to JSON.
             * @function toJSON
             * @memberof kritor.message.UploadForwardMessageRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UploadForwardMessageRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for UploadForwardMessageRequest
             * @function getTypeUrl
             * @memberof kritor.message.UploadForwardMessageRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            UploadForwardMessageRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.UploadForwardMessageRequest";
            };

            return UploadForwardMessageRequest;
        })();

        message.UploadForwardMessageResponse = (function() {

            /**
             * Properties of an UploadForwardMessageResponse.
             * @memberof kritor.message
             * @interface IUploadForwardMessageResponse
             * @property {string|null} [resId] UploadForwardMessageResponse resId
             */

            /**
             * Constructs a new UploadForwardMessageResponse.
             * @memberof kritor.message
             * @classdesc Represents an UploadForwardMessageResponse.
             * @implements IUploadForwardMessageResponse
             * @constructor
             * @param {kritor.message.IUploadForwardMessageResponse=} [properties] Properties to set
             */
            function UploadForwardMessageResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * UploadForwardMessageResponse resId.
             * @member {string} resId
             * @memberof kritor.message.UploadForwardMessageResponse
             * @instance
             */
            UploadForwardMessageResponse.prototype.resId = "";

            /**
             * Creates a new UploadForwardMessageResponse instance using the specified properties.
             * @function create
             * @memberof kritor.message.UploadForwardMessageResponse
             * @static
             * @param {kritor.message.IUploadForwardMessageResponse=} [properties] Properties to set
             * @returns {kritor.message.UploadForwardMessageResponse} UploadForwardMessageResponse instance
             */
            UploadForwardMessageResponse.create = function create(properties) {
                return new UploadForwardMessageResponse(properties);
            };

            /**
             * Encodes the specified UploadForwardMessageResponse message. Does not implicitly {@link kritor.message.UploadForwardMessageResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.UploadForwardMessageResponse
             * @static
             * @param {kritor.message.IUploadForwardMessageResponse} message UploadForwardMessageResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UploadForwardMessageResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.resId != null && Object.hasOwnProperty.call(message, "resId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.resId);
                return writer;
            };

            /**
             * Encodes the specified UploadForwardMessageResponse message, length delimited. Does not implicitly {@link kritor.message.UploadForwardMessageResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.UploadForwardMessageResponse
             * @static
             * @param {kritor.message.IUploadForwardMessageResponse} message UploadForwardMessageResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UploadForwardMessageResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an UploadForwardMessageResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.UploadForwardMessageResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.UploadForwardMessageResponse} UploadForwardMessageResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UploadForwardMessageResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.UploadForwardMessageResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.resId = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an UploadForwardMessageResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.UploadForwardMessageResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.UploadForwardMessageResponse} UploadForwardMessageResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UploadForwardMessageResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an UploadForwardMessageResponse message.
             * @function verify
             * @memberof kritor.message.UploadForwardMessageResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UploadForwardMessageResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.resId != null && message.hasOwnProperty("resId"))
                    if (!$util.isString(message.resId))
                        return "resId: string expected";
                return null;
            };

            /**
             * Creates an UploadForwardMessageResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.UploadForwardMessageResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.UploadForwardMessageResponse} UploadForwardMessageResponse
             */
            UploadForwardMessageResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.UploadForwardMessageResponse)
                    return object;
                let message = new $root.kritor.message.UploadForwardMessageResponse();
                if (object.resId != null)
                    message.resId = String(object.resId);
                return message;
            };

            /**
             * Creates a plain object from an UploadForwardMessageResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.UploadForwardMessageResponse
             * @static
             * @param {kritor.message.UploadForwardMessageResponse} message UploadForwardMessageResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UploadForwardMessageResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.resId = "";
                if (message.resId != null && message.hasOwnProperty("resId"))
                    object.resId = message.resId;
                return object;
            };

            /**
             * Converts this UploadForwardMessageResponse to JSON.
             * @function toJSON
             * @memberof kritor.message.UploadForwardMessageResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UploadForwardMessageResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for UploadForwardMessageResponse
             * @function getTypeUrl
             * @memberof kritor.message.UploadForwardMessageResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            UploadForwardMessageResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.UploadForwardMessageResponse";
            };

            return UploadForwardMessageResponse;
        })();

        message.DownloadForwardMessageRequest = (function() {

            /**
             * Properties of a DownloadForwardMessageRequest.
             * @memberof kritor.message
             * @interface IDownloadForwardMessageRequest
             * @property {string|null} [resId] DownloadForwardMessageRequest resId
             */

            /**
             * Constructs a new DownloadForwardMessageRequest.
             * @memberof kritor.message
             * @classdesc Represents a DownloadForwardMessageRequest.
             * @implements IDownloadForwardMessageRequest
             * @constructor
             * @param {kritor.message.IDownloadForwardMessageRequest=} [properties] Properties to set
             */
            function DownloadForwardMessageRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DownloadForwardMessageRequest resId.
             * @member {string} resId
             * @memberof kritor.message.DownloadForwardMessageRequest
             * @instance
             */
            DownloadForwardMessageRequest.prototype.resId = "";

            /**
             * Creates a new DownloadForwardMessageRequest instance using the specified properties.
             * @function create
             * @memberof kritor.message.DownloadForwardMessageRequest
             * @static
             * @param {kritor.message.IDownloadForwardMessageRequest=} [properties] Properties to set
             * @returns {kritor.message.DownloadForwardMessageRequest} DownloadForwardMessageRequest instance
             */
            DownloadForwardMessageRequest.create = function create(properties) {
                return new DownloadForwardMessageRequest(properties);
            };

            /**
             * Encodes the specified DownloadForwardMessageRequest message. Does not implicitly {@link kritor.message.DownloadForwardMessageRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.DownloadForwardMessageRequest
             * @static
             * @param {kritor.message.IDownloadForwardMessageRequest} message DownloadForwardMessageRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DownloadForwardMessageRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.resId != null && Object.hasOwnProperty.call(message, "resId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.resId);
                return writer;
            };

            /**
             * Encodes the specified DownloadForwardMessageRequest message, length delimited. Does not implicitly {@link kritor.message.DownloadForwardMessageRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.DownloadForwardMessageRequest
             * @static
             * @param {kritor.message.IDownloadForwardMessageRequest} message DownloadForwardMessageRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DownloadForwardMessageRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DownloadForwardMessageRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.DownloadForwardMessageRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.DownloadForwardMessageRequest} DownloadForwardMessageRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DownloadForwardMessageRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.DownloadForwardMessageRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.resId = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DownloadForwardMessageRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.DownloadForwardMessageRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.DownloadForwardMessageRequest} DownloadForwardMessageRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DownloadForwardMessageRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DownloadForwardMessageRequest message.
             * @function verify
             * @memberof kritor.message.DownloadForwardMessageRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DownloadForwardMessageRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.resId != null && message.hasOwnProperty("resId"))
                    if (!$util.isString(message.resId))
                        return "resId: string expected";
                return null;
            };

            /**
             * Creates a DownloadForwardMessageRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.DownloadForwardMessageRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.DownloadForwardMessageRequest} DownloadForwardMessageRequest
             */
            DownloadForwardMessageRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.DownloadForwardMessageRequest)
                    return object;
                let message = new $root.kritor.message.DownloadForwardMessageRequest();
                if (object.resId != null)
                    message.resId = String(object.resId);
                return message;
            };

            /**
             * Creates a plain object from a DownloadForwardMessageRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.DownloadForwardMessageRequest
             * @static
             * @param {kritor.message.DownloadForwardMessageRequest} message DownloadForwardMessageRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DownloadForwardMessageRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.resId = "";
                if (message.resId != null && message.hasOwnProperty("resId"))
                    object.resId = message.resId;
                return object;
            };

            /**
             * Converts this DownloadForwardMessageRequest to JSON.
             * @function toJSON
             * @memberof kritor.message.DownloadForwardMessageRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DownloadForwardMessageRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DownloadForwardMessageRequest
             * @function getTypeUrl
             * @memberof kritor.message.DownloadForwardMessageRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DownloadForwardMessageRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.DownloadForwardMessageRequest";
            };

            return DownloadForwardMessageRequest;
        })();

        message.DownloadForwardMessageResponse = (function() {

            /**
             * Properties of a DownloadForwardMessageResponse.
             * @memberof kritor.message
             * @interface IDownloadForwardMessageResponse
             * @property {Array.<kritor.common.IPushMessageBody>|null} [messages] DownloadForwardMessageResponse messages
             */

            /**
             * Constructs a new DownloadForwardMessageResponse.
             * @memberof kritor.message
             * @classdesc Represents a DownloadForwardMessageResponse.
             * @implements IDownloadForwardMessageResponse
             * @constructor
             * @param {kritor.message.IDownloadForwardMessageResponse=} [properties] Properties to set
             */
            function DownloadForwardMessageResponse(properties) {
                this.messages = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DownloadForwardMessageResponse messages.
             * @member {Array.<kritor.common.IPushMessageBody>} messages
             * @memberof kritor.message.DownloadForwardMessageResponse
             * @instance
             */
            DownloadForwardMessageResponse.prototype.messages = $util.emptyArray;

            /**
             * Creates a new DownloadForwardMessageResponse instance using the specified properties.
             * @function create
             * @memberof kritor.message.DownloadForwardMessageResponse
             * @static
             * @param {kritor.message.IDownloadForwardMessageResponse=} [properties] Properties to set
             * @returns {kritor.message.DownloadForwardMessageResponse} DownloadForwardMessageResponse instance
             */
            DownloadForwardMessageResponse.create = function create(properties) {
                return new DownloadForwardMessageResponse(properties);
            };

            /**
             * Encodes the specified DownloadForwardMessageResponse message. Does not implicitly {@link kritor.message.DownloadForwardMessageResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.DownloadForwardMessageResponse
             * @static
             * @param {kritor.message.IDownloadForwardMessageResponse} message DownloadForwardMessageResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DownloadForwardMessageResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.messages != null && message.messages.length)
                    for (let i = 0; i < message.messages.length; ++i)
                        $root.kritor.common.PushMessageBody.encode(message.messages[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DownloadForwardMessageResponse message, length delimited. Does not implicitly {@link kritor.message.DownloadForwardMessageResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.DownloadForwardMessageResponse
             * @static
             * @param {kritor.message.IDownloadForwardMessageResponse} message DownloadForwardMessageResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DownloadForwardMessageResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DownloadForwardMessageResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.DownloadForwardMessageResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.DownloadForwardMessageResponse} DownloadForwardMessageResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DownloadForwardMessageResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.DownloadForwardMessageResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.messages && message.messages.length))
                                message.messages = [];
                            message.messages.push($root.kritor.common.PushMessageBody.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DownloadForwardMessageResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.DownloadForwardMessageResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.DownloadForwardMessageResponse} DownloadForwardMessageResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DownloadForwardMessageResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DownloadForwardMessageResponse message.
             * @function verify
             * @memberof kritor.message.DownloadForwardMessageResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DownloadForwardMessageResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.messages != null && message.hasOwnProperty("messages")) {
                    if (!Array.isArray(message.messages))
                        return "messages: array expected";
                    for (let i = 0; i < message.messages.length; ++i) {
                        let error = $root.kritor.common.PushMessageBody.verify(message.messages[i]);
                        if (error)
                            return "messages." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a DownloadForwardMessageResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.DownloadForwardMessageResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.DownloadForwardMessageResponse} DownloadForwardMessageResponse
             */
            DownloadForwardMessageResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.DownloadForwardMessageResponse)
                    return object;
                let message = new $root.kritor.message.DownloadForwardMessageResponse();
                if (object.messages) {
                    if (!Array.isArray(object.messages))
                        throw TypeError(".kritor.message.DownloadForwardMessageResponse.messages: array expected");
                    message.messages = [];
                    for (let i = 0; i < object.messages.length; ++i) {
                        if (typeof object.messages[i] !== "object")
                            throw TypeError(".kritor.message.DownloadForwardMessageResponse.messages: object expected");
                        message.messages[i] = $root.kritor.common.PushMessageBody.fromObject(object.messages[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a DownloadForwardMessageResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.DownloadForwardMessageResponse
             * @static
             * @param {kritor.message.DownloadForwardMessageResponse} message DownloadForwardMessageResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DownloadForwardMessageResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.messages = [];
                if (message.messages && message.messages.length) {
                    object.messages = [];
                    for (let j = 0; j < message.messages.length; ++j)
                        object.messages[j] = $root.kritor.common.PushMessageBody.toObject(message.messages[j], options);
                }
                return object;
            };

            /**
             * Converts this DownloadForwardMessageResponse to JSON.
             * @function toJSON
             * @memberof kritor.message.DownloadForwardMessageResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DownloadForwardMessageResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DownloadForwardMessageResponse
             * @function getTypeUrl
             * @memberof kritor.message.DownloadForwardMessageResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DownloadForwardMessageResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.DownloadForwardMessageResponse";
            };

            return DownloadForwardMessageResponse;
        })();

        message.GetEssenceMessageListRequest = (function() {

            /**
             * Properties of a GetEssenceMessageListRequest.
             * @memberof kritor.message
             * @interface IGetEssenceMessageListRequest
             * @property {number|Long|null} [groupId] GetEssenceMessageListRequest groupId
             * @property {number|null} [page] GetEssenceMessageListRequest page
             * @property {number|null} [pageSize] GetEssenceMessageListRequest pageSize
             */

            /**
             * Constructs a new GetEssenceMessageListRequest.
             * @memberof kritor.message
             * @classdesc Represents a GetEssenceMessageListRequest.
             * @implements IGetEssenceMessageListRequest
             * @constructor
             * @param {kritor.message.IGetEssenceMessageListRequest=} [properties] Properties to set
             */
            function GetEssenceMessageListRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetEssenceMessageListRequest groupId.
             * @member {number|Long} groupId
             * @memberof kritor.message.GetEssenceMessageListRequest
             * @instance
             */
            GetEssenceMessageListRequest.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GetEssenceMessageListRequest page.
             * @member {number} page
             * @memberof kritor.message.GetEssenceMessageListRequest
             * @instance
             */
            GetEssenceMessageListRequest.prototype.page = 0;

            /**
             * GetEssenceMessageListRequest pageSize.
             * @member {number} pageSize
             * @memberof kritor.message.GetEssenceMessageListRequest
             * @instance
             */
            GetEssenceMessageListRequest.prototype.pageSize = 0;

            /**
             * Creates a new GetEssenceMessageListRequest instance using the specified properties.
             * @function create
             * @memberof kritor.message.GetEssenceMessageListRequest
             * @static
             * @param {kritor.message.IGetEssenceMessageListRequest=} [properties] Properties to set
             * @returns {kritor.message.GetEssenceMessageListRequest} GetEssenceMessageListRequest instance
             */
            GetEssenceMessageListRequest.create = function create(properties) {
                return new GetEssenceMessageListRequest(properties);
            };

            /**
             * Encodes the specified GetEssenceMessageListRequest message. Does not implicitly {@link kritor.message.GetEssenceMessageListRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.GetEssenceMessageListRequest
             * @static
             * @param {kritor.message.IGetEssenceMessageListRequest} message GetEssenceMessageListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetEssenceMessageListRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                if (message.page != null && Object.hasOwnProperty.call(message, "page"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.page);
                if (message.pageSize != null && Object.hasOwnProperty.call(message, "pageSize"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.pageSize);
                return writer;
            };

            /**
             * Encodes the specified GetEssenceMessageListRequest message, length delimited. Does not implicitly {@link kritor.message.GetEssenceMessageListRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.GetEssenceMessageListRequest
             * @static
             * @param {kritor.message.IGetEssenceMessageListRequest} message GetEssenceMessageListRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetEssenceMessageListRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetEssenceMessageListRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.GetEssenceMessageListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.GetEssenceMessageListRequest} GetEssenceMessageListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetEssenceMessageListRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.GetEssenceMessageListRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.page = reader.uint32();
                            break;
                        }
                    case 3: {
                            message.pageSize = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetEssenceMessageListRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.GetEssenceMessageListRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.GetEssenceMessageListRequest} GetEssenceMessageListRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetEssenceMessageListRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetEssenceMessageListRequest message.
             * @function verify
             * @memberof kritor.message.GetEssenceMessageListRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetEssenceMessageListRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                if (message.page != null && message.hasOwnProperty("page"))
                    if (!$util.isInteger(message.page))
                        return "page: integer expected";
                if (message.pageSize != null && message.hasOwnProperty("pageSize"))
                    if (!$util.isInteger(message.pageSize))
                        return "pageSize: integer expected";
                return null;
            };

            /**
             * Creates a GetEssenceMessageListRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.GetEssenceMessageListRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.GetEssenceMessageListRequest} GetEssenceMessageListRequest
             */
            GetEssenceMessageListRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.GetEssenceMessageListRequest)
                    return object;
                let message = new $root.kritor.message.GetEssenceMessageListRequest();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                if (object.page != null)
                    message.page = object.page >>> 0;
                if (object.pageSize != null)
                    message.pageSize = object.pageSize >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a GetEssenceMessageListRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.GetEssenceMessageListRequest
             * @static
             * @param {kritor.message.GetEssenceMessageListRequest} message GetEssenceMessageListRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetEssenceMessageListRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                    object.page = 0;
                    object.pageSize = 0;
                }
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                if (message.page != null && message.hasOwnProperty("page"))
                    object.page = message.page;
                if (message.pageSize != null && message.hasOwnProperty("pageSize"))
                    object.pageSize = message.pageSize;
                return object;
            };

            /**
             * Converts this GetEssenceMessageListRequest to JSON.
             * @function toJSON
             * @memberof kritor.message.GetEssenceMessageListRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetEssenceMessageListRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetEssenceMessageListRequest
             * @function getTypeUrl
             * @memberof kritor.message.GetEssenceMessageListRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetEssenceMessageListRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.GetEssenceMessageListRequest";
            };

            return GetEssenceMessageListRequest;
        })();

        message.GetEssenceMessageListResponse = (function() {

            /**
             * Properties of a GetEssenceMessageListResponse.
             * @memberof kritor.message
             * @interface IGetEssenceMessageListResponse
             * @property {Array.<kritor.common.IEssenceMessageBody>|null} [messages] GetEssenceMessageListResponse messages
             */

            /**
             * Constructs a new GetEssenceMessageListResponse.
             * @memberof kritor.message
             * @classdesc Represents a GetEssenceMessageListResponse.
             * @implements IGetEssenceMessageListResponse
             * @constructor
             * @param {kritor.message.IGetEssenceMessageListResponse=} [properties] Properties to set
             */
            function GetEssenceMessageListResponse(properties) {
                this.messages = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetEssenceMessageListResponse messages.
             * @member {Array.<kritor.common.IEssenceMessageBody>} messages
             * @memberof kritor.message.GetEssenceMessageListResponse
             * @instance
             */
            GetEssenceMessageListResponse.prototype.messages = $util.emptyArray;

            /**
             * Creates a new GetEssenceMessageListResponse instance using the specified properties.
             * @function create
             * @memberof kritor.message.GetEssenceMessageListResponse
             * @static
             * @param {kritor.message.IGetEssenceMessageListResponse=} [properties] Properties to set
             * @returns {kritor.message.GetEssenceMessageListResponse} GetEssenceMessageListResponse instance
             */
            GetEssenceMessageListResponse.create = function create(properties) {
                return new GetEssenceMessageListResponse(properties);
            };

            /**
             * Encodes the specified GetEssenceMessageListResponse message. Does not implicitly {@link kritor.message.GetEssenceMessageListResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.GetEssenceMessageListResponse
             * @static
             * @param {kritor.message.IGetEssenceMessageListResponse} message GetEssenceMessageListResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetEssenceMessageListResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.messages != null && message.messages.length)
                    for (let i = 0; i < message.messages.length; ++i)
                        $root.kritor.common.EssenceMessageBody.encode(message.messages[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GetEssenceMessageListResponse message, length delimited. Does not implicitly {@link kritor.message.GetEssenceMessageListResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.GetEssenceMessageListResponse
             * @static
             * @param {kritor.message.IGetEssenceMessageListResponse} message GetEssenceMessageListResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetEssenceMessageListResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetEssenceMessageListResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.GetEssenceMessageListResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.GetEssenceMessageListResponse} GetEssenceMessageListResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetEssenceMessageListResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.GetEssenceMessageListResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.messages && message.messages.length))
                                message.messages = [];
                            message.messages.push($root.kritor.common.EssenceMessageBody.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetEssenceMessageListResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.GetEssenceMessageListResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.GetEssenceMessageListResponse} GetEssenceMessageListResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetEssenceMessageListResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetEssenceMessageListResponse message.
             * @function verify
             * @memberof kritor.message.GetEssenceMessageListResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetEssenceMessageListResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.messages != null && message.hasOwnProperty("messages")) {
                    if (!Array.isArray(message.messages))
                        return "messages: array expected";
                    for (let i = 0; i < message.messages.length; ++i) {
                        let error = $root.kritor.common.EssenceMessageBody.verify(message.messages[i]);
                        if (error)
                            return "messages." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a GetEssenceMessageListResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.GetEssenceMessageListResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.GetEssenceMessageListResponse} GetEssenceMessageListResponse
             */
            GetEssenceMessageListResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.GetEssenceMessageListResponse)
                    return object;
                let message = new $root.kritor.message.GetEssenceMessageListResponse();
                if (object.messages) {
                    if (!Array.isArray(object.messages))
                        throw TypeError(".kritor.message.GetEssenceMessageListResponse.messages: array expected");
                    message.messages = [];
                    for (let i = 0; i < object.messages.length; ++i) {
                        if (typeof object.messages[i] !== "object")
                            throw TypeError(".kritor.message.GetEssenceMessageListResponse.messages: object expected");
                        message.messages[i] = $root.kritor.common.EssenceMessageBody.fromObject(object.messages[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a GetEssenceMessageListResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.GetEssenceMessageListResponse
             * @static
             * @param {kritor.message.GetEssenceMessageListResponse} message GetEssenceMessageListResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetEssenceMessageListResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.messages = [];
                if (message.messages && message.messages.length) {
                    object.messages = [];
                    for (let j = 0; j < message.messages.length; ++j)
                        object.messages[j] = $root.kritor.common.EssenceMessageBody.toObject(message.messages[j], options);
                }
                return object;
            };

            /**
             * Converts this GetEssenceMessageListResponse to JSON.
             * @function toJSON
             * @memberof kritor.message.GetEssenceMessageListResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetEssenceMessageListResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetEssenceMessageListResponse
             * @function getTypeUrl
             * @memberof kritor.message.GetEssenceMessageListResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetEssenceMessageListResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.GetEssenceMessageListResponse";
            };

            return GetEssenceMessageListResponse;
        })();

        message.SetEssenceMessageRequest = (function() {

            /**
             * Properties of a SetEssenceMessageRequest.
             * @memberof kritor.message
             * @interface ISetEssenceMessageRequest
             * @property {number|Long|null} [groupId] SetEssenceMessageRequest groupId
             * @property {string|null} [messageId] SetEssenceMessageRequest messageId
             */

            /**
             * Constructs a new SetEssenceMessageRequest.
             * @memberof kritor.message
             * @classdesc Represents a SetEssenceMessageRequest.
             * @implements ISetEssenceMessageRequest
             * @constructor
             * @param {kritor.message.ISetEssenceMessageRequest=} [properties] Properties to set
             */
            function SetEssenceMessageRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SetEssenceMessageRequest groupId.
             * @member {number|Long} groupId
             * @memberof kritor.message.SetEssenceMessageRequest
             * @instance
             */
            SetEssenceMessageRequest.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * SetEssenceMessageRequest messageId.
             * @member {string} messageId
             * @memberof kritor.message.SetEssenceMessageRequest
             * @instance
             */
            SetEssenceMessageRequest.prototype.messageId = "";

            /**
             * Creates a new SetEssenceMessageRequest instance using the specified properties.
             * @function create
             * @memberof kritor.message.SetEssenceMessageRequest
             * @static
             * @param {kritor.message.ISetEssenceMessageRequest=} [properties] Properties to set
             * @returns {kritor.message.SetEssenceMessageRequest} SetEssenceMessageRequest instance
             */
            SetEssenceMessageRequest.create = function create(properties) {
                return new SetEssenceMessageRequest(properties);
            };

            /**
             * Encodes the specified SetEssenceMessageRequest message. Does not implicitly {@link kritor.message.SetEssenceMessageRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.SetEssenceMessageRequest
             * @static
             * @param {kritor.message.ISetEssenceMessageRequest} message SetEssenceMessageRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetEssenceMessageRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                if (message.messageId != null && Object.hasOwnProperty.call(message, "messageId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.messageId);
                return writer;
            };

            /**
             * Encodes the specified SetEssenceMessageRequest message, length delimited. Does not implicitly {@link kritor.message.SetEssenceMessageRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.SetEssenceMessageRequest
             * @static
             * @param {kritor.message.ISetEssenceMessageRequest} message SetEssenceMessageRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetEssenceMessageRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetEssenceMessageRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.SetEssenceMessageRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.SetEssenceMessageRequest} SetEssenceMessageRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetEssenceMessageRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.SetEssenceMessageRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.messageId = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetEssenceMessageRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.SetEssenceMessageRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.SetEssenceMessageRequest} SetEssenceMessageRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetEssenceMessageRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetEssenceMessageRequest message.
             * @function verify
             * @memberof kritor.message.SetEssenceMessageRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetEssenceMessageRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    if (!$util.isString(message.messageId))
                        return "messageId: string expected";
                return null;
            };

            /**
             * Creates a SetEssenceMessageRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.SetEssenceMessageRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.SetEssenceMessageRequest} SetEssenceMessageRequest
             */
            SetEssenceMessageRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.SetEssenceMessageRequest)
                    return object;
                let message = new $root.kritor.message.SetEssenceMessageRequest();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                if (object.messageId != null)
                    message.messageId = String(object.messageId);
                return message;
            };

            /**
             * Creates a plain object from a SetEssenceMessageRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.SetEssenceMessageRequest
             * @static
             * @param {kritor.message.SetEssenceMessageRequest} message SetEssenceMessageRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetEssenceMessageRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                    object.messageId = "";
                }
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    object.messageId = message.messageId;
                return object;
            };

            /**
             * Converts this SetEssenceMessageRequest to JSON.
             * @function toJSON
             * @memberof kritor.message.SetEssenceMessageRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetEssenceMessageRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetEssenceMessageRequest
             * @function getTypeUrl
             * @memberof kritor.message.SetEssenceMessageRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetEssenceMessageRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.SetEssenceMessageRequest";
            };

            return SetEssenceMessageRequest;
        })();

        message.SetEssenceMessageResponse = (function() {

            /**
             * Properties of a SetEssenceMessageResponse.
             * @memberof kritor.message
             * @interface ISetEssenceMessageResponse
             */

            /**
             * Constructs a new SetEssenceMessageResponse.
             * @memberof kritor.message
             * @classdesc Represents a SetEssenceMessageResponse.
             * @implements ISetEssenceMessageResponse
             * @constructor
             * @param {kritor.message.ISetEssenceMessageResponse=} [properties] Properties to set
             */
            function SetEssenceMessageResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new SetEssenceMessageResponse instance using the specified properties.
             * @function create
             * @memberof kritor.message.SetEssenceMessageResponse
             * @static
             * @param {kritor.message.ISetEssenceMessageResponse=} [properties] Properties to set
             * @returns {kritor.message.SetEssenceMessageResponse} SetEssenceMessageResponse instance
             */
            SetEssenceMessageResponse.create = function create(properties) {
                return new SetEssenceMessageResponse(properties);
            };

            /**
             * Encodes the specified SetEssenceMessageResponse message. Does not implicitly {@link kritor.message.SetEssenceMessageResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.SetEssenceMessageResponse
             * @static
             * @param {kritor.message.ISetEssenceMessageResponse} message SetEssenceMessageResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetEssenceMessageResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified SetEssenceMessageResponse message, length delimited. Does not implicitly {@link kritor.message.SetEssenceMessageResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.SetEssenceMessageResponse
             * @static
             * @param {kritor.message.ISetEssenceMessageResponse} message SetEssenceMessageResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SetEssenceMessageResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SetEssenceMessageResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.SetEssenceMessageResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.SetEssenceMessageResponse} SetEssenceMessageResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetEssenceMessageResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.SetEssenceMessageResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SetEssenceMessageResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.SetEssenceMessageResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.SetEssenceMessageResponse} SetEssenceMessageResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SetEssenceMessageResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SetEssenceMessageResponse message.
             * @function verify
             * @memberof kritor.message.SetEssenceMessageResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SetEssenceMessageResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a SetEssenceMessageResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.SetEssenceMessageResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.SetEssenceMessageResponse} SetEssenceMessageResponse
             */
            SetEssenceMessageResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.SetEssenceMessageResponse)
                    return object;
                return new $root.kritor.message.SetEssenceMessageResponse();
            };

            /**
             * Creates a plain object from a SetEssenceMessageResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.SetEssenceMessageResponse
             * @static
             * @param {kritor.message.SetEssenceMessageResponse} message SetEssenceMessageResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SetEssenceMessageResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this SetEssenceMessageResponse to JSON.
             * @function toJSON
             * @memberof kritor.message.SetEssenceMessageResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SetEssenceMessageResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SetEssenceMessageResponse
             * @function getTypeUrl
             * @memberof kritor.message.SetEssenceMessageResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SetEssenceMessageResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.SetEssenceMessageResponse";
            };

            return SetEssenceMessageResponse;
        })();

        message.DeleteEssenceMessageRequest = (function() {

            /**
             * Properties of a DeleteEssenceMessageRequest.
             * @memberof kritor.message
             * @interface IDeleteEssenceMessageRequest
             * @property {number|Long|null} [groupId] DeleteEssenceMessageRequest groupId
             * @property {string|null} [messageId] DeleteEssenceMessageRequest messageId
             */

            /**
             * Constructs a new DeleteEssenceMessageRequest.
             * @memberof kritor.message
             * @classdesc Represents a DeleteEssenceMessageRequest.
             * @implements IDeleteEssenceMessageRequest
             * @constructor
             * @param {kritor.message.IDeleteEssenceMessageRequest=} [properties] Properties to set
             */
            function DeleteEssenceMessageRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DeleteEssenceMessageRequest groupId.
             * @member {number|Long} groupId
             * @memberof kritor.message.DeleteEssenceMessageRequest
             * @instance
             */
            DeleteEssenceMessageRequest.prototype.groupId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * DeleteEssenceMessageRequest messageId.
             * @member {string} messageId
             * @memberof kritor.message.DeleteEssenceMessageRequest
             * @instance
             */
            DeleteEssenceMessageRequest.prototype.messageId = "";

            /**
             * Creates a new DeleteEssenceMessageRequest instance using the specified properties.
             * @function create
             * @memberof kritor.message.DeleteEssenceMessageRequest
             * @static
             * @param {kritor.message.IDeleteEssenceMessageRequest=} [properties] Properties to set
             * @returns {kritor.message.DeleteEssenceMessageRequest} DeleteEssenceMessageRequest instance
             */
            DeleteEssenceMessageRequest.create = function create(properties) {
                return new DeleteEssenceMessageRequest(properties);
            };

            /**
             * Encodes the specified DeleteEssenceMessageRequest message. Does not implicitly {@link kritor.message.DeleteEssenceMessageRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.DeleteEssenceMessageRequest
             * @static
             * @param {kritor.message.IDeleteEssenceMessageRequest} message DeleteEssenceMessageRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteEssenceMessageRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groupId != null && Object.hasOwnProperty.call(message, "groupId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.groupId);
                if (message.messageId != null && Object.hasOwnProperty.call(message, "messageId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.messageId);
                return writer;
            };

            /**
             * Encodes the specified DeleteEssenceMessageRequest message, length delimited. Does not implicitly {@link kritor.message.DeleteEssenceMessageRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.DeleteEssenceMessageRequest
             * @static
             * @param {kritor.message.IDeleteEssenceMessageRequest} message DeleteEssenceMessageRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteEssenceMessageRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeleteEssenceMessageRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.DeleteEssenceMessageRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.DeleteEssenceMessageRequest} DeleteEssenceMessageRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteEssenceMessageRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.DeleteEssenceMessageRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.groupId = reader.uint64();
                            break;
                        }
                    case 2: {
                            message.messageId = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DeleteEssenceMessageRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.DeleteEssenceMessageRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.DeleteEssenceMessageRequest} DeleteEssenceMessageRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteEssenceMessageRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeleteEssenceMessageRequest message.
             * @function verify
             * @memberof kritor.message.DeleteEssenceMessageRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeleteEssenceMessageRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (!$util.isInteger(message.groupId) && !(message.groupId && $util.isInteger(message.groupId.low) && $util.isInteger(message.groupId.high)))
                        return "groupId: integer|Long expected";
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    if (!$util.isString(message.messageId))
                        return "messageId: string expected";
                return null;
            };

            /**
             * Creates a DeleteEssenceMessageRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.DeleteEssenceMessageRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.DeleteEssenceMessageRequest} DeleteEssenceMessageRequest
             */
            DeleteEssenceMessageRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.DeleteEssenceMessageRequest)
                    return object;
                let message = new $root.kritor.message.DeleteEssenceMessageRequest();
                if (object.groupId != null)
                    if ($util.Long)
                        (message.groupId = $util.Long.fromValue(object.groupId)).unsigned = true;
                    else if (typeof object.groupId === "string")
                        message.groupId = parseInt(object.groupId, 10);
                    else if (typeof object.groupId === "number")
                        message.groupId = object.groupId;
                    else if (typeof object.groupId === "object")
                        message.groupId = new $util.LongBits(object.groupId.low >>> 0, object.groupId.high >>> 0).toNumber(true);
                if (object.messageId != null)
                    message.messageId = String(object.messageId);
                return message;
            };

            /**
             * Creates a plain object from a DeleteEssenceMessageRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.DeleteEssenceMessageRequest
             * @static
             * @param {kritor.message.DeleteEssenceMessageRequest} message DeleteEssenceMessageRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeleteEssenceMessageRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.groupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.groupId = options.longs === String ? "0" : 0;
                    object.messageId = "";
                }
                if (message.groupId != null && message.hasOwnProperty("groupId"))
                    if (typeof message.groupId === "number")
                        object.groupId = options.longs === String ? String(message.groupId) : message.groupId;
                    else
                        object.groupId = options.longs === String ? $util.Long.prototype.toString.call(message.groupId) : options.longs === Number ? new $util.LongBits(message.groupId.low >>> 0, message.groupId.high >>> 0).toNumber(true) : message.groupId;
                if (message.messageId != null && message.hasOwnProperty("messageId"))
                    object.messageId = message.messageId;
                return object;
            };

            /**
             * Converts this DeleteEssenceMessageRequest to JSON.
             * @function toJSON
             * @memberof kritor.message.DeleteEssenceMessageRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeleteEssenceMessageRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DeleteEssenceMessageRequest
             * @function getTypeUrl
             * @memberof kritor.message.DeleteEssenceMessageRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DeleteEssenceMessageRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.DeleteEssenceMessageRequest";
            };

            return DeleteEssenceMessageRequest;
        })();

        message.DeleteEssenceMessageResponse = (function() {

            /**
             * Properties of a DeleteEssenceMessageResponse.
             * @memberof kritor.message
             * @interface IDeleteEssenceMessageResponse
             */

            /**
             * Constructs a new DeleteEssenceMessageResponse.
             * @memberof kritor.message
             * @classdesc Represents a DeleteEssenceMessageResponse.
             * @implements IDeleteEssenceMessageResponse
             * @constructor
             * @param {kritor.message.IDeleteEssenceMessageResponse=} [properties] Properties to set
             */
            function DeleteEssenceMessageResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new DeleteEssenceMessageResponse instance using the specified properties.
             * @function create
             * @memberof kritor.message.DeleteEssenceMessageResponse
             * @static
             * @param {kritor.message.IDeleteEssenceMessageResponse=} [properties] Properties to set
             * @returns {kritor.message.DeleteEssenceMessageResponse} DeleteEssenceMessageResponse instance
             */
            DeleteEssenceMessageResponse.create = function create(properties) {
                return new DeleteEssenceMessageResponse(properties);
            };

            /**
             * Encodes the specified DeleteEssenceMessageResponse message. Does not implicitly {@link kritor.message.DeleteEssenceMessageResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.message.DeleteEssenceMessageResponse
             * @static
             * @param {kritor.message.IDeleteEssenceMessageResponse} message DeleteEssenceMessageResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteEssenceMessageResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified DeleteEssenceMessageResponse message, length delimited. Does not implicitly {@link kritor.message.DeleteEssenceMessageResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.message.DeleteEssenceMessageResponse
             * @static
             * @param {kritor.message.IDeleteEssenceMessageResponse} message DeleteEssenceMessageResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DeleteEssenceMessageResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DeleteEssenceMessageResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.message.DeleteEssenceMessageResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.message.DeleteEssenceMessageResponse} DeleteEssenceMessageResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteEssenceMessageResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.message.DeleteEssenceMessageResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DeleteEssenceMessageResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.message.DeleteEssenceMessageResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.message.DeleteEssenceMessageResponse} DeleteEssenceMessageResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DeleteEssenceMessageResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DeleteEssenceMessageResponse message.
             * @function verify
             * @memberof kritor.message.DeleteEssenceMessageResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DeleteEssenceMessageResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates a DeleteEssenceMessageResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.message.DeleteEssenceMessageResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.message.DeleteEssenceMessageResponse} DeleteEssenceMessageResponse
             */
            DeleteEssenceMessageResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.message.DeleteEssenceMessageResponse)
                    return object;
                return new $root.kritor.message.DeleteEssenceMessageResponse();
            };

            /**
             * Creates a plain object from a DeleteEssenceMessageResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.message.DeleteEssenceMessageResponse
             * @static
             * @param {kritor.message.DeleteEssenceMessageResponse} message DeleteEssenceMessageResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DeleteEssenceMessageResponse.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this DeleteEssenceMessageResponse to JSON.
             * @function toJSON
             * @memberof kritor.message.DeleteEssenceMessageResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DeleteEssenceMessageResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for DeleteEssenceMessageResponse
             * @function getTypeUrl
             * @memberof kritor.message.DeleteEssenceMessageResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            DeleteEssenceMessageResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.message.DeleteEssenceMessageResponse";
            };

            return DeleteEssenceMessageResponse;
        })();

        return message;
    })();

    kritor.reverse = (function() {

        /**
         * Namespace reverse.
         * @memberof kritor
         * @namespace
         */
        const reverse = {};

        reverse.ReverseService = (function() {

            /**
             * Constructs a new ReverseService service.
             * @memberof kritor.reverse
             * @classdesc Represents a ReverseService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function ReverseService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (ReverseService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = ReverseService;

            /**
             * Creates new ReverseService service using the specified rpc implementation.
             * @function create
             * @memberof kritor.reverse.ReverseService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {ReverseService} RPC service. Useful where requests and/or responses are streamed.
             */
            ReverseService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link kritor.reverse.ReverseService#reverseStream}.
             * @memberof kritor.reverse.ReverseService
             * @typedef ReverseStreamCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.common.Request} [response] Request
             */

            /**
             * Calls ReverseStream.
             * @function reverseStream
             * @memberof kritor.reverse.ReverseService
             * @instance
             * @param {kritor.common.IResponse} request Response message or plain object
             * @param {kritor.reverse.ReverseService.ReverseStreamCallback} callback Node-style callback called with the error, if any, and Request
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(ReverseService.prototype.reverseStream = function reverseStream(request, callback) {
                return this.rpcCall(reverseStream, $root.kritor.common.Response, $root.kritor.common.Request, request, callback);
            }, "name", { value: "ReverseStream" });

            /**
             * Calls ReverseStream.
             * @function reverseStream
             * @memberof kritor.reverse.ReverseService
             * @instance
             * @param {kritor.common.IResponse} request Response message or plain object
             * @returns {Promise<kritor.common.Request>} Promise
             * @variation 2
             */

            return ReverseService;
        })();

        return reverse;
    })();

    kritor.web = (function() {

        /**
         * Namespace web.
         * @memberof kritor
         * @namespace
         */
        const web = {};

        web.WebService = (function() {

            /**
             * Constructs a new WebService service.
             * @memberof kritor.web
             * @classdesc Represents a WebService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function WebService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (WebService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = WebService;

            /**
             * Creates new WebService service using the specified rpc implementation.
             * @function create
             * @memberof kritor.web.WebService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {WebService} RPC service. Useful where requests and/or responses are streamed.
             */
            WebService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link kritor.web.WebService#getCookies}.
             * @memberof kritor.web.WebService
             * @typedef GetCookiesCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.web.GetCookiesResponse} [response] GetCookiesResponse
             */

            /**
             * Calls GetCookies.
             * @function getCookies
             * @memberof kritor.web.WebService
             * @instance
             * @param {kritor.web.IGetCookiesRequest} request GetCookiesRequest message or plain object
             * @param {kritor.web.WebService.GetCookiesCallback} callback Node-style callback called with the error, if any, and GetCookiesResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(WebService.prototype.getCookies = function getCookies(request, callback) {
                return this.rpcCall(getCookies, $root.kritor.web.GetCookiesRequest, $root.kritor.web.GetCookiesResponse, request, callback);
            }, "name", { value: "GetCookies" });

            /**
             * Calls GetCookies.
             * @function getCookies
             * @memberof kritor.web.WebService
             * @instance
             * @param {kritor.web.IGetCookiesRequest} request GetCookiesRequest message or plain object
             * @returns {Promise<kritor.web.GetCookiesResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.web.WebService#getCredentials}.
             * @memberof kritor.web.WebService
             * @typedef GetCredentialsCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.web.GetCredentialsResponse} [response] GetCredentialsResponse
             */

            /**
             * Calls GetCredentials.
             * @function getCredentials
             * @memberof kritor.web.WebService
             * @instance
             * @param {kritor.web.IGetCredentialsRequest} request GetCredentialsRequest message or plain object
             * @param {kritor.web.WebService.GetCredentialsCallback} callback Node-style callback called with the error, if any, and GetCredentialsResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(WebService.prototype.getCredentials = function getCredentials(request, callback) {
                return this.rpcCall(getCredentials, $root.kritor.web.GetCredentialsRequest, $root.kritor.web.GetCredentialsResponse, request, callback);
            }, "name", { value: "GetCredentials" });

            /**
             * Calls GetCredentials.
             * @function getCredentials
             * @memberof kritor.web.WebService
             * @instance
             * @param {kritor.web.IGetCredentialsRequest} request GetCredentialsRequest message or plain object
             * @returns {Promise<kritor.web.GetCredentialsResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.web.WebService#getCSRFToken}.
             * @memberof kritor.web.WebService
             * @typedef GetCSRFTokenCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.web.GetCSRFTokenResponse} [response] GetCSRFTokenResponse
             */

            /**
             * Calls GetCSRFToken.
             * @function getCSRFToken
             * @memberof kritor.web.WebService
             * @instance
             * @param {kritor.web.IGetCSRFTokenRequest} request GetCSRFTokenRequest message or plain object
             * @param {kritor.web.WebService.GetCSRFTokenCallback} callback Node-style callback called with the error, if any, and GetCSRFTokenResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(WebService.prototype.getCSRFToken = function getCSRFToken(request, callback) {
                return this.rpcCall(getCSRFToken, $root.kritor.web.GetCSRFTokenRequest, $root.kritor.web.GetCSRFTokenResponse, request, callback);
            }, "name", { value: "GetCSRFToken" });

            /**
             * Calls GetCSRFToken.
             * @function getCSRFToken
             * @memberof kritor.web.WebService
             * @instance
             * @param {kritor.web.IGetCSRFTokenRequest} request GetCSRFTokenRequest message or plain object
             * @returns {Promise<kritor.web.GetCSRFTokenResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link kritor.web.WebService#getHttpCookies}.
             * @memberof kritor.web.WebService
             * @typedef GetHttpCookiesCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {kritor.web.GetHttpCookiesResponse} [response] GetHttpCookiesResponse
             */

            /**
             * Calls GetHttpCookies.
             * @function getHttpCookies
             * @memberof kritor.web.WebService
             * @instance
             * @param {kritor.web.IGetHttpCookiesRequest} request GetHttpCookiesRequest message or plain object
             * @param {kritor.web.WebService.GetHttpCookiesCallback} callback Node-style callback called with the error, if any, and GetHttpCookiesResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(WebService.prototype.getHttpCookies = function getHttpCookies(request, callback) {
                return this.rpcCall(getHttpCookies, $root.kritor.web.GetHttpCookiesRequest, $root.kritor.web.GetHttpCookiesResponse, request, callback);
            }, "name", { value: "GetHttpCookies" });

            /**
             * Calls GetHttpCookies.
             * @function getHttpCookies
             * @memberof kritor.web.WebService
             * @instance
             * @param {kritor.web.IGetHttpCookiesRequest} request GetHttpCookiesRequest message or plain object
             * @returns {Promise<kritor.web.GetHttpCookiesResponse>} Promise
             * @variation 2
             */

            return WebService;
        })();

        web.GetCookiesRequest = (function() {

            /**
             * Properties of a GetCookiesRequest.
             * @memberof kritor.web
             * @interface IGetCookiesRequest
             * @property {string|null} [domain] GetCookiesRequest domain
             */

            /**
             * Constructs a new GetCookiesRequest.
             * @memberof kritor.web
             * @classdesc Represents a GetCookiesRequest.
             * @implements IGetCookiesRequest
             * @constructor
             * @param {kritor.web.IGetCookiesRequest=} [properties] Properties to set
             */
            function GetCookiesRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetCookiesRequest domain.
             * @member {string|null|undefined} domain
             * @memberof kritor.web.GetCookiesRequest
             * @instance
             */
            GetCookiesRequest.prototype.domain = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * GetCookiesRequest _domain.
             * @member {"domain"|undefined} _domain
             * @memberof kritor.web.GetCookiesRequest
             * @instance
             */
            Object.defineProperty(GetCookiesRequest.prototype, "_domain", {
                get: $util.oneOfGetter($oneOfFields = ["domain"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new GetCookiesRequest instance using the specified properties.
             * @function create
             * @memberof kritor.web.GetCookiesRequest
             * @static
             * @param {kritor.web.IGetCookiesRequest=} [properties] Properties to set
             * @returns {kritor.web.GetCookiesRequest} GetCookiesRequest instance
             */
            GetCookiesRequest.create = function create(properties) {
                return new GetCookiesRequest(properties);
            };

            /**
             * Encodes the specified GetCookiesRequest message. Does not implicitly {@link kritor.web.GetCookiesRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.web.GetCookiesRequest
             * @static
             * @param {kritor.web.IGetCookiesRequest} message GetCookiesRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetCookiesRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.domain != null && Object.hasOwnProperty.call(message, "domain"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.domain);
                return writer;
            };

            /**
             * Encodes the specified GetCookiesRequest message, length delimited. Does not implicitly {@link kritor.web.GetCookiesRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.web.GetCookiesRequest
             * @static
             * @param {kritor.web.IGetCookiesRequest} message GetCookiesRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetCookiesRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetCookiesRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.web.GetCookiesRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.web.GetCookiesRequest} GetCookiesRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetCookiesRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.web.GetCookiesRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.domain = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetCookiesRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.web.GetCookiesRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.web.GetCookiesRequest} GetCookiesRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetCookiesRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetCookiesRequest message.
             * @function verify
             * @memberof kritor.web.GetCookiesRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetCookiesRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.domain != null && message.hasOwnProperty("domain")) {
                    properties._domain = 1;
                    if (!$util.isString(message.domain))
                        return "domain: string expected";
                }
                return null;
            };

            /**
             * Creates a GetCookiesRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.web.GetCookiesRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.web.GetCookiesRequest} GetCookiesRequest
             */
            GetCookiesRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.web.GetCookiesRequest)
                    return object;
                let message = new $root.kritor.web.GetCookiesRequest();
                if (object.domain != null)
                    message.domain = String(object.domain);
                return message;
            };

            /**
             * Creates a plain object from a GetCookiesRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.web.GetCookiesRequest
             * @static
             * @param {kritor.web.GetCookiesRequest} message GetCookiesRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetCookiesRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (message.domain != null && message.hasOwnProperty("domain")) {
                    object.domain = message.domain;
                    if (options.oneofs)
                        object._domain = "domain";
                }
                return object;
            };

            /**
             * Converts this GetCookiesRequest to JSON.
             * @function toJSON
             * @memberof kritor.web.GetCookiesRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetCookiesRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetCookiesRequest
             * @function getTypeUrl
             * @memberof kritor.web.GetCookiesRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetCookiesRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.web.GetCookiesRequest";
            };

            return GetCookiesRequest;
        })();

        web.GetCookiesResponse = (function() {

            /**
             * Properties of a GetCookiesResponse.
             * @memberof kritor.web
             * @interface IGetCookiesResponse
             * @property {string|null} [cookie] GetCookiesResponse cookie
             */

            /**
             * Constructs a new GetCookiesResponse.
             * @memberof kritor.web
             * @classdesc Represents a GetCookiesResponse.
             * @implements IGetCookiesResponse
             * @constructor
             * @param {kritor.web.IGetCookiesResponse=} [properties] Properties to set
             */
            function GetCookiesResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetCookiesResponse cookie.
             * @member {string} cookie
             * @memberof kritor.web.GetCookiesResponse
             * @instance
             */
            GetCookiesResponse.prototype.cookie = "";

            /**
             * Creates a new GetCookiesResponse instance using the specified properties.
             * @function create
             * @memberof kritor.web.GetCookiesResponse
             * @static
             * @param {kritor.web.IGetCookiesResponse=} [properties] Properties to set
             * @returns {kritor.web.GetCookiesResponse} GetCookiesResponse instance
             */
            GetCookiesResponse.create = function create(properties) {
                return new GetCookiesResponse(properties);
            };

            /**
             * Encodes the specified GetCookiesResponse message. Does not implicitly {@link kritor.web.GetCookiesResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.web.GetCookiesResponse
             * @static
             * @param {kritor.web.IGetCookiesResponse} message GetCookiesResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetCookiesResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.cookie != null && Object.hasOwnProperty.call(message, "cookie"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.cookie);
                return writer;
            };

            /**
             * Encodes the specified GetCookiesResponse message, length delimited. Does not implicitly {@link kritor.web.GetCookiesResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.web.GetCookiesResponse
             * @static
             * @param {kritor.web.IGetCookiesResponse} message GetCookiesResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetCookiesResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetCookiesResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.web.GetCookiesResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.web.GetCookiesResponse} GetCookiesResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetCookiesResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.web.GetCookiesResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.cookie = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetCookiesResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.web.GetCookiesResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.web.GetCookiesResponse} GetCookiesResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetCookiesResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetCookiesResponse message.
             * @function verify
             * @memberof kritor.web.GetCookiesResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetCookiesResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.cookie != null && message.hasOwnProperty("cookie"))
                    if (!$util.isString(message.cookie))
                        return "cookie: string expected";
                return null;
            };

            /**
             * Creates a GetCookiesResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.web.GetCookiesResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.web.GetCookiesResponse} GetCookiesResponse
             */
            GetCookiesResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.web.GetCookiesResponse)
                    return object;
                let message = new $root.kritor.web.GetCookiesResponse();
                if (object.cookie != null)
                    message.cookie = String(object.cookie);
                return message;
            };

            /**
             * Creates a plain object from a GetCookiesResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.web.GetCookiesResponse
             * @static
             * @param {kritor.web.GetCookiesResponse} message GetCookiesResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetCookiesResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.cookie = "";
                if (message.cookie != null && message.hasOwnProperty("cookie"))
                    object.cookie = message.cookie;
                return object;
            };

            /**
             * Converts this GetCookiesResponse to JSON.
             * @function toJSON
             * @memberof kritor.web.GetCookiesResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetCookiesResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetCookiesResponse
             * @function getTypeUrl
             * @memberof kritor.web.GetCookiesResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetCookiesResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.web.GetCookiesResponse";
            };

            return GetCookiesResponse;
        })();

        web.GetCredentialsRequest = (function() {

            /**
             * Properties of a GetCredentialsRequest.
             * @memberof kritor.web
             * @interface IGetCredentialsRequest
             * @property {string|null} [domain] GetCredentialsRequest domain
             */

            /**
             * Constructs a new GetCredentialsRequest.
             * @memberof kritor.web
             * @classdesc Represents a GetCredentialsRequest.
             * @implements IGetCredentialsRequest
             * @constructor
             * @param {kritor.web.IGetCredentialsRequest=} [properties] Properties to set
             */
            function GetCredentialsRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetCredentialsRequest domain.
             * @member {string|null|undefined} domain
             * @memberof kritor.web.GetCredentialsRequest
             * @instance
             */
            GetCredentialsRequest.prototype.domain = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * GetCredentialsRequest _domain.
             * @member {"domain"|undefined} _domain
             * @memberof kritor.web.GetCredentialsRequest
             * @instance
             */
            Object.defineProperty(GetCredentialsRequest.prototype, "_domain", {
                get: $util.oneOfGetter($oneOfFields = ["domain"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new GetCredentialsRequest instance using the specified properties.
             * @function create
             * @memberof kritor.web.GetCredentialsRequest
             * @static
             * @param {kritor.web.IGetCredentialsRequest=} [properties] Properties to set
             * @returns {kritor.web.GetCredentialsRequest} GetCredentialsRequest instance
             */
            GetCredentialsRequest.create = function create(properties) {
                return new GetCredentialsRequest(properties);
            };

            /**
             * Encodes the specified GetCredentialsRequest message. Does not implicitly {@link kritor.web.GetCredentialsRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.web.GetCredentialsRequest
             * @static
             * @param {kritor.web.IGetCredentialsRequest} message GetCredentialsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetCredentialsRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.domain != null && Object.hasOwnProperty.call(message, "domain"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.domain);
                return writer;
            };

            /**
             * Encodes the specified GetCredentialsRequest message, length delimited. Does not implicitly {@link kritor.web.GetCredentialsRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.web.GetCredentialsRequest
             * @static
             * @param {kritor.web.IGetCredentialsRequest} message GetCredentialsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetCredentialsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetCredentialsRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.web.GetCredentialsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.web.GetCredentialsRequest} GetCredentialsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetCredentialsRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.web.GetCredentialsRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.domain = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetCredentialsRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.web.GetCredentialsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.web.GetCredentialsRequest} GetCredentialsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetCredentialsRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetCredentialsRequest message.
             * @function verify
             * @memberof kritor.web.GetCredentialsRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetCredentialsRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.domain != null && message.hasOwnProperty("domain")) {
                    properties._domain = 1;
                    if (!$util.isString(message.domain))
                        return "domain: string expected";
                }
                return null;
            };

            /**
             * Creates a GetCredentialsRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.web.GetCredentialsRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.web.GetCredentialsRequest} GetCredentialsRequest
             */
            GetCredentialsRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.web.GetCredentialsRequest)
                    return object;
                let message = new $root.kritor.web.GetCredentialsRequest();
                if (object.domain != null)
                    message.domain = String(object.domain);
                return message;
            };

            /**
             * Creates a plain object from a GetCredentialsRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.web.GetCredentialsRequest
             * @static
             * @param {kritor.web.GetCredentialsRequest} message GetCredentialsRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetCredentialsRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (message.domain != null && message.hasOwnProperty("domain")) {
                    object.domain = message.domain;
                    if (options.oneofs)
                        object._domain = "domain";
                }
                return object;
            };

            /**
             * Converts this GetCredentialsRequest to JSON.
             * @function toJSON
             * @memberof kritor.web.GetCredentialsRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetCredentialsRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetCredentialsRequest
             * @function getTypeUrl
             * @memberof kritor.web.GetCredentialsRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetCredentialsRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.web.GetCredentialsRequest";
            };

            return GetCredentialsRequest;
        })();

        web.GetCredentialsResponse = (function() {

            /**
             * Properties of a GetCredentialsResponse.
             * @memberof kritor.web
             * @interface IGetCredentialsResponse
             * @property {string|null} [bkn] GetCredentialsResponse bkn
             * @property {string|null} [cookie] GetCredentialsResponse cookie
             */

            /**
             * Constructs a new GetCredentialsResponse.
             * @memberof kritor.web
             * @classdesc Represents a GetCredentialsResponse.
             * @implements IGetCredentialsResponse
             * @constructor
             * @param {kritor.web.IGetCredentialsResponse=} [properties] Properties to set
             */
            function GetCredentialsResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetCredentialsResponse bkn.
             * @member {string} bkn
             * @memberof kritor.web.GetCredentialsResponse
             * @instance
             */
            GetCredentialsResponse.prototype.bkn = "";

            /**
             * GetCredentialsResponse cookie.
             * @member {string} cookie
             * @memberof kritor.web.GetCredentialsResponse
             * @instance
             */
            GetCredentialsResponse.prototype.cookie = "";

            /**
             * Creates a new GetCredentialsResponse instance using the specified properties.
             * @function create
             * @memberof kritor.web.GetCredentialsResponse
             * @static
             * @param {kritor.web.IGetCredentialsResponse=} [properties] Properties to set
             * @returns {kritor.web.GetCredentialsResponse} GetCredentialsResponse instance
             */
            GetCredentialsResponse.create = function create(properties) {
                return new GetCredentialsResponse(properties);
            };

            /**
             * Encodes the specified GetCredentialsResponse message. Does not implicitly {@link kritor.web.GetCredentialsResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.web.GetCredentialsResponse
             * @static
             * @param {kritor.web.IGetCredentialsResponse} message GetCredentialsResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetCredentialsResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.bkn != null && Object.hasOwnProperty.call(message, "bkn"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.bkn);
                if (message.cookie != null && Object.hasOwnProperty.call(message, "cookie"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.cookie);
                return writer;
            };

            /**
             * Encodes the specified GetCredentialsResponse message, length delimited. Does not implicitly {@link kritor.web.GetCredentialsResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.web.GetCredentialsResponse
             * @static
             * @param {kritor.web.IGetCredentialsResponse} message GetCredentialsResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetCredentialsResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetCredentialsResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.web.GetCredentialsResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.web.GetCredentialsResponse} GetCredentialsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetCredentialsResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.web.GetCredentialsResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.bkn = reader.string();
                            break;
                        }
                    case 2: {
                            message.cookie = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetCredentialsResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.web.GetCredentialsResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.web.GetCredentialsResponse} GetCredentialsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetCredentialsResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetCredentialsResponse message.
             * @function verify
             * @memberof kritor.web.GetCredentialsResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetCredentialsResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.bkn != null && message.hasOwnProperty("bkn"))
                    if (!$util.isString(message.bkn))
                        return "bkn: string expected";
                if (message.cookie != null && message.hasOwnProperty("cookie"))
                    if (!$util.isString(message.cookie))
                        return "cookie: string expected";
                return null;
            };

            /**
             * Creates a GetCredentialsResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.web.GetCredentialsResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.web.GetCredentialsResponse} GetCredentialsResponse
             */
            GetCredentialsResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.web.GetCredentialsResponse)
                    return object;
                let message = new $root.kritor.web.GetCredentialsResponse();
                if (object.bkn != null)
                    message.bkn = String(object.bkn);
                if (object.cookie != null)
                    message.cookie = String(object.cookie);
                return message;
            };

            /**
             * Creates a plain object from a GetCredentialsResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.web.GetCredentialsResponse
             * @static
             * @param {kritor.web.GetCredentialsResponse} message GetCredentialsResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetCredentialsResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.bkn = "";
                    object.cookie = "";
                }
                if (message.bkn != null && message.hasOwnProperty("bkn"))
                    object.bkn = message.bkn;
                if (message.cookie != null && message.hasOwnProperty("cookie"))
                    object.cookie = message.cookie;
                return object;
            };

            /**
             * Converts this GetCredentialsResponse to JSON.
             * @function toJSON
             * @memberof kritor.web.GetCredentialsResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetCredentialsResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetCredentialsResponse
             * @function getTypeUrl
             * @memberof kritor.web.GetCredentialsResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetCredentialsResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.web.GetCredentialsResponse";
            };

            return GetCredentialsResponse;
        })();

        web.GetCSRFTokenRequest = (function() {

            /**
             * Properties of a GetCSRFTokenRequest.
             * @memberof kritor.web
             * @interface IGetCSRFTokenRequest
             * @property {string|null} [domain] GetCSRFTokenRequest domain
             */

            /**
             * Constructs a new GetCSRFTokenRequest.
             * @memberof kritor.web
             * @classdesc Represents a GetCSRFTokenRequest.
             * @implements IGetCSRFTokenRequest
             * @constructor
             * @param {kritor.web.IGetCSRFTokenRequest=} [properties] Properties to set
             */
            function GetCSRFTokenRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetCSRFTokenRequest domain.
             * @member {string|null|undefined} domain
             * @memberof kritor.web.GetCSRFTokenRequest
             * @instance
             */
            GetCSRFTokenRequest.prototype.domain = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * GetCSRFTokenRequest _domain.
             * @member {"domain"|undefined} _domain
             * @memberof kritor.web.GetCSRFTokenRequest
             * @instance
             */
            Object.defineProperty(GetCSRFTokenRequest.prototype, "_domain", {
                get: $util.oneOfGetter($oneOfFields = ["domain"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new GetCSRFTokenRequest instance using the specified properties.
             * @function create
             * @memberof kritor.web.GetCSRFTokenRequest
             * @static
             * @param {kritor.web.IGetCSRFTokenRequest=} [properties] Properties to set
             * @returns {kritor.web.GetCSRFTokenRequest} GetCSRFTokenRequest instance
             */
            GetCSRFTokenRequest.create = function create(properties) {
                return new GetCSRFTokenRequest(properties);
            };

            /**
             * Encodes the specified GetCSRFTokenRequest message. Does not implicitly {@link kritor.web.GetCSRFTokenRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.web.GetCSRFTokenRequest
             * @static
             * @param {kritor.web.IGetCSRFTokenRequest} message GetCSRFTokenRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetCSRFTokenRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.domain != null && Object.hasOwnProperty.call(message, "domain"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.domain);
                return writer;
            };

            /**
             * Encodes the specified GetCSRFTokenRequest message, length delimited. Does not implicitly {@link kritor.web.GetCSRFTokenRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.web.GetCSRFTokenRequest
             * @static
             * @param {kritor.web.IGetCSRFTokenRequest} message GetCSRFTokenRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetCSRFTokenRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetCSRFTokenRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.web.GetCSRFTokenRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.web.GetCSRFTokenRequest} GetCSRFTokenRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetCSRFTokenRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.web.GetCSRFTokenRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.domain = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetCSRFTokenRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.web.GetCSRFTokenRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.web.GetCSRFTokenRequest} GetCSRFTokenRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetCSRFTokenRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetCSRFTokenRequest message.
             * @function verify
             * @memberof kritor.web.GetCSRFTokenRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetCSRFTokenRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.domain != null && message.hasOwnProperty("domain")) {
                    properties._domain = 1;
                    if (!$util.isString(message.domain))
                        return "domain: string expected";
                }
                return null;
            };

            /**
             * Creates a GetCSRFTokenRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.web.GetCSRFTokenRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.web.GetCSRFTokenRequest} GetCSRFTokenRequest
             */
            GetCSRFTokenRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.web.GetCSRFTokenRequest)
                    return object;
                let message = new $root.kritor.web.GetCSRFTokenRequest();
                if (object.domain != null)
                    message.domain = String(object.domain);
                return message;
            };

            /**
             * Creates a plain object from a GetCSRFTokenRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.web.GetCSRFTokenRequest
             * @static
             * @param {kritor.web.GetCSRFTokenRequest} message GetCSRFTokenRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetCSRFTokenRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (message.domain != null && message.hasOwnProperty("domain")) {
                    object.domain = message.domain;
                    if (options.oneofs)
                        object._domain = "domain";
                }
                return object;
            };

            /**
             * Converts this GetCSRFTokenRequest to JSON.
             * @function toJSON
             * @memberof kritor.web.GetCSRFTokenRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetCSRFTokenRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetCSRFTokenRequest
             * @function getTypeUrl
             * @memberof kritor.web.GetCSRFTokenRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetCSRFTokenRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.web.GetCSRFTokenRequest";
            };

            return GetCSRFTokenRequest;
        })();

        web.GetCSRFTokenResponse = (function() {

            /**
             * Properties of a GetCSRFTokenResponse.
             * @memberof kritor.web
             * @interface IGetCSRFTokenResponse
             * @property {string|null} [bkn] GetCSRFTokenResponse bkn
             */

            /**
             * Constructs a new GetCSRFTokenResponse.
             * @memberof kritor.web
             * @classdesc Represents a GetCSRFTokenResponse.
             * @implements IGetCSRFTokenResponse
             * @constructor
             * @param {kritor.web.IGetCSRFTokenResponse=} [properties] Properties to set
             */
            function GetCSRFTokenResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetCSRFTokenResponse bkn.
             * @member {string} bkn
             * @memberof kritor.web.GetCSRFTokenResponse
             * @instance
             */
            GetCSRFTokenResponse.prototype.bkn = "";

            /**
             * Creates a new GetCSRFTokenResponse instance using the specified properties.
             * @function create
             * @memberof kritor.web.GetCSRFTokenResponse
             * @static
             * @param {kritor.web.IGetCSRFTokenResponse=} [properties] Properties to set
             * @returns {kritor.web.GetCSRFTokenResponse} GetCSRFTokenResponse instance
             */
            GetCSRFTokenResponse.create = function create(properties) {
                return new GetCSRFTokenResponse(properties);
            };

            /**
             * Encodes the specified GetCSRFTokenResponse message. Does not implicitly {@link kritor.web.GetCSRFTokenResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.web.GetCSRFTokenResponse
             * @static
             * @param {kritor.web.IGetCSRFTokenResponse} message GetCSRFTokenResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetCSRFTokenResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.bkn != null && Object.hasOwnProperty.call(message, "bkn"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.bkn);
                return writer;
            };

            /**
             * Encodes the specified GetCSRFTokenResponse message, length delimited. Does not implicitly {@link kritor.web.GetCSRFTokenResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.web.GetCSRFTokenResponse
             * @static
             * @param {kritor.web.IGetCSRFTokenResponse} message GetCSRFTokenResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetCSRFTokenResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetCSRFTokenResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.web.GetCSRFTokenResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.web.GetCSRFTokenResponse} GetCSRFTokenResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetCSRFTokenResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.web.GetCSRFTokenResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.bkn = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetCSRFTokenResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.web.GetCSRFTokenResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.web.GetCSRFTokenResponse} GetCSRFTokenResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetCSRFTokenResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetCSRFTokenResponse message.
             * @function verify
             * @memberof kritor.web.GetCSRFTokenResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetCSRFTokenResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.bkn != null && message.hasOwnProperty("bkn"))
                    if (!$util.isString(message.bkn))
                        return "bkn: string expected";
                return null;
            };

            /**
             * Creates a GetCSRFTokenResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.web.GetCSRFTokenResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.web.GetCSRFTokenResponse} GetCSRFTokenResponse
             */
            GetCSRFTokenResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.web.GetCSRFTokenResponse)
                    return object;
                let message = new $root.kritor.web.GetCSRFTokenResponse();
                if (object.bkn != null)
                    message.bkn = String(object.bkn);
                return message;
            };

            /**
             * Creates a plain object from a GetCSRFTokenResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.web.GetCSRFTokenResponse
             * @static
             * @param {kritor.web.GetCSRFTokenResponse} message GetCSRFTokenResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetCSRFTokenResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.bkn = "";
                if (message.bkn != null && message.hasOwnProperty("bkn"))
                    object.bkn = message.bkn;
                return object;
            };

            /**
             * Converts this GetCSRFTokenResponse to JSON.
             * @function toJSON
             * @memberof kritor.web.GetCSRFTokenResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetCSRFTokenResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetCSRFTokenResponse
             * @function getTypeUrl
             * @memberof kritor.web.GetCSRFTokenResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetCSRFTokenResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.web.GetCSRFTokenResponse";
            };

            return GetCSRFTokenResponse;
        })();

        web.GetHttpCookiesRequest = (function() {

            /**
             * Properties of a GetHttpCookiesRequest.
             * @memberof kritor.web
             * @interface IGetHttpCookiesRequest
             * @property {string|null} [appid] GetHttpCookiesRequest appid
             * @property {string|null} [daid] GetHttpCookiesRequest daid
             * @property {string|null} [jumpUrl] GetHttpCookiesRequest jumpUrl
             */

            /**
             * Constructs a new GetHttpCookiesRequest.
             * @memberof kritor.web
             * @classdesc Represents a GetHttpCookiesRequest.
             * @implements IGetHttpCookiesRequest
             * @constructor
             * @param {kritor.web.IGetHttpCookiesRequest=} [properties] Properties to set
             */
            function GetHttpCookiesRequest(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetHttpCookiesRequest appid.
             * @member {string} appid
             * @memberof kritor.web.GetHttpCookiesRequest
             * @instance
             */
            GetHttpCookiesRequest.prototype.appid = "";

            /**
             * GetHttpCookiesRequest daid.
             * @member {string} daid
             * @memberof kritor.web.GetHttpCookiesRequest
             * @instance
             */
            GetHttpCookiesRequest.prototype.daid = "";

            /**
             * GetHttpCookiesRequest jumpUrl.
             * @member {string} jumpUrl
             * @memberof kritor.web.GetHttpCookiesRequest
             * @instance
             */
            GetHttpCookiesRequest.prototype.jumpUrl = "";

            /**
             * Creates a new GetHttpCookiesRequest instance using the specified properties.
             * @function create
             * @memberof kritor.web.GetHttpCookiesRequest
             * @static
             * @param {kritor.web.IGetHttpCookiesRequest=} [properties] Properties to set
             * @returns {kritor.web.GetHttpCookiesRequest} GetHttpCookiesRequest instance
             */
            GetHttpCookiesRequest.create = function create(properties) {
                return new GetHttpCookiesRequest(properties);
            };

            /**
             * Encodes the specified GetHttpCookiesRequest message. Does not implicitly {@link kritor.web.GetHttpCookiesRequest.verify|verify} messages.
             * @function encode
             * @memberof kritor.web.GetHttpCookiesRequest
             * @static
             * @param {kritor.web.IGetHttpCookiesRequest} message GetHttpCookiesRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetHttpCookiesRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.appid != null && Object.hasOwnProperty.call(message, "appid"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.appid);
                if (message.daid != null && Object.hasOwnProperty.call(message, "daid"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.daid);
                if (message.jumpUrl != null && Object.hasOwnProperty.call(message, "jumpUrl"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.jumpUrl);
                return writer;
            };

            /**
             * Encodes the specified GetHttpCookiesRequest message, length delimited. Does not implicitly {@link kritor.web.GetHttpCookiesRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.web.GetHttpCookiesRequest
             * @static
             * @param {kritor.web.IGetHttpCookiesRequest} message GetHttpCookiesRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetHttpCookiesRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetHttpCookiesRequest message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.web.GetHttpCookiesRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.web.GetHttpCookiesRequest} GetHttpCookiesRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetHttpCookiesRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.web.GetHttpCookiesRequest();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.appid = reader.string();
                            break;
                        }
                    case 2: {
                            message.daid = reader.string();
                            break;
                        }
                    case 3: {
                            message.jumpUrl = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetHttpCookiesRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.web.GetHttpCookiesRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.web.GetHttpCookiesRequest} GetHttpCookiesRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetHttpCookiesRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetHttpCookiesRequest message.
             * @function verify
             * @memberof kritor.web.GetHttpCookiesRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetHttpCookiesRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.appid != null && message.hasOwnProperty("appid"))
                    if (!$util.isString(message.appid))
                        return "appid: string expected";
                if (message.daid != null && message.hasOwnProperty("daid"))
                    if (!$util.isString(message.daid))
                        return "daid: string expected";
                if (message.jumpUrl != null && message.hasOwnProperty("jumpUrl"))
                    if (!$util.isString(message.jumpUrl))
                        return "jumpUrl: string expected";
                return null;
            };

            /**
             * Creates a GetHttpCookiesRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.web.GetHttpCookiesRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.web.GetHttpCookiesRequest} GetHttpCookiesRequest
             */
            GetHttpCookiesRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.web.GetHttpCookiesRequest)
                    return object;
                let message = new $root.kritor.web.GetHttpCookiesRequest();
                if (object.appid != null)
                    message.appid = String(object.appid);
                if (object.daid != null)
                    message.daid = String(object.daid);
                if (object.jumpUrl != null)
                    message.jumpUrl = String(object.jumpUrl);
                return message;
            };

            /**
             * Creates a plain object from a GetHttpCookiesRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.web.GetHttpCookiesRequest
             * @static
             * @param {kritor.web.GetHttpCookiesRequest} message GetHttpCookiesRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetHttpCookiesRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.appid = "";
                    object.daid = "";
                    object.jumpUrl = "";
                }
                if (message.appid != null && message.hasOwnProperty("appid"))
                    object.appid = message.appid;
                if (message.daid != null && message.hasOwnProperty("daid"))
                    object.daid = message.daid;
                if (message.jumpUrl != null && message.hasOwnProperty("jumpUrl"))
                    object.jumpUrl = message.jumpUrl;
                return object;
            };

            /**
             * Converts this GetHttpCookiesRequest to JSON.
             * @function toJSON
             * @memberof kritor.web.GetHttpCookiesRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetHttpCookiesRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetHttpCookiesRequest
             * @function getTypeUrl
             * @memberof kritor.web.GetHttpCookiesRequest
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetHttpCookiesRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.web.GetHttpCookiesRequest";
            };

            return GetHttpCookiesRequest;
        })();

        web.GetHttpCookiesResponse = (function() {

            /**
             * Properties of a GetHttpCookiesResponse.
             * @memberof kritor.web
             * @interface IGetHttpCookiesResponse
             * @property {string|null} [cookie] GetHttpCookiesResponse cookie
             */

            /**
             * Constructs a new GetHttpCookiesResponse.
             * @memberof kritor.web
             * @classdesc Represents a GetHttpCookiesResponse.
             * @implements IGetHttpCookiesResponse
             * @constructor
             * @param {kritor.web.IGetHttpCookiesResponse=} [properties] Properties to set
             */
            function GetHttpCookiesResponse(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetHttpCookiesResponse cookie.
             * @member {string} cookie
             * @memberof kritor.web.GetHttpCookiesResponse
             * @instance
             */
            GetHttpCookiesResponse.prototype.cookie = "";

            /**
             * Creates a new GetHttpCookiesResponse instance using the specified properties.
             * @function create
             * @memberof kritor.web.GetHttpCookiesResponse
             * @static
             * @param {kritor.web.IGetHttpCookiesResponse=} [properties] Properties to set
             * @returns {kritor.web.GetHttpCookiesResponse} GetHttpCookiesResponse instance
             */
            GetHttpCookiesResponse.create = function create(properties) {
                return new GetHttpCookiesResponse(properties);
            };

            /**
             * Encodes the specified GetHttpCookiesResponse message. Does not implicitly {@link kritor.web.GetHttpCookiesResponse.verify|verify} messages.
             * @function encode
             * @memberof kritor.web.GetHttpCookiesResponse
             * @static
             * @param {kritor.web.IGetHttpCookiesResponse} message GetHttpCookiesResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetHttpCookiesResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.cookie != null && Object.hasOwnProperty.call(message, "cookie"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.cookie);
                return writer;
            };

            /**
             * Encodes the specified GetHttpCookiesResponse message, length delimited. Does not implicitly {@link kritor.web.GetHttpCookiesResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof kritor.web.GetHttpCookiesResponse
             * @static
             * @param {kritor.web.IGetHttpCookiesResponse} message GetHttpCookiesResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetHttpCookiesResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetHttpCookiesResponse message from the specified reader or buffer.
             * @function decode
             * @memberof kritor.web.GetHttpCookiesResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {kritor.web.GetHttpCookiesResponse} GetHttpCookiesResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetHttpCookiesResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.kritor.web.GetHttpCookiesResponse();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.cookie = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetHttpCookiesResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof kritor.web.GetHttpCookiesResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {kritor.web.GetHttpCookiesResponse} GetHttpCookiesResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetHttpCookiesResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetHttpCookiesResponse message.
             * @function verify
             * @memberof kritor.web.GetHttpCookiesResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetHttpCookiesResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.cookie != null && message.hasOwnProperty("cookie"))
                    if (!$util.isString(message.cookie))
                        return "cookie: string expected";
                return null;
            };

            /**
             * Creates a GetHttpCookiesResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof kritor.web.GetHttpCookiesResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {kritor.web.GetHttpCookiesResponse} GetHttpCookiesResponse
             */
            GetHttpCookiesResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.kritor.web.GetHttpCookiesResponse)
                    return object;
                let message = new $root.kritor.web.GetHttpCookiesResponse();
                if (object.cookie != null)
                    message.cookie = String(object.cookie);
                return message;
            };

            /**
             * Creates a plain object from a GetHttpCookiesResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof kritor.web.GetHttpCookiesResponse
             * @static
             * @param {kritor.web.GetHttpCookiesResponse} message GetHttpCookiesResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetHttpCookiesResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.cookie = "";
                if (message.cookie != null && message.hasOwnProperty("cookie"))
                    object.cookie = message.cookie;
                return object;
            };

            /**
             * Converts this GetHttpCookiesResponse to JSON.
             * @function toJSON
             * @memberof kritor.web.GetHttpCookiesResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetHttpCookiesResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GetHttpCookiesResponse
             * @function getTypeUrl
             * @memberof kritor.web.GetHttpCookiesResponse
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GetHttpCookiesResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/kritor.web.GetHttpCookiesResponse";
            };

            return GetHttpCookiesResponse;
        })();

        return web;
    })();

    return kritor;
})();

export { $root as default };
